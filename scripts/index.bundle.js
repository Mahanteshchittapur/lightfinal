/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@firebolt-js/sdk/dist/firebolt.js":
/*!********************************************************!*\
  !*** ./node_modules/@firebolt-js/sdk/dist/firebolt.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Accessibility": () => (/* binding */ __webpack_exports__Accessibility),
/* harmony export */   "Account": () => (/* binding */ __webpack_exports__Account),
/* harmony export */   "Advertising": () => (/* binding */ __webpack_exports__Advertising),
/* harmony export */   "Authentication": () => (/* binding */ __webpack_exports__Authentication),
/* harmony export */   "Device": () => (/* binding */ __webpack_exports__Device),
/* harmony export */   "Discovery": () => (/* binding */ __webpack_exports__Discovery),
/* harmony export */   "Events": () => (/* binding */ __webpack_exports__Events),
/* harmony export */   "Keyboard": () => (/* binding */ __webpack_exports__Keyboard),
/* harmony export */   "Lifecycle": () => (/* binding */ __webpack_exports__Lifecycle),
/* harmony export */   "Localization": () => (/* binding */ __webpack_exports__Localization),
/* harmony export */   "Log": () => (/* binding */ __webpack_exports__Log),
/* harmony export */   "Metrics": () => (/* binding */ __webpack_exports__Metrics),
/* harmony export */   "Parameters": () => (/* binding */ __webpack_exports__Parameters),
/* harmony export */   "Platform": () => (/* binding */ __webpack_exports__Platform),
/* harmony export */   "Profile": () => (/* binding */ __webpack_exports__Profile),
/* harmony export */   "SecondScreen": () => (/* binding */ __webpack_exports__SecondScreen),
/* harmony export */   "Settings": () => (/* binding */ __webpack_exports__Settings)
/* harmony export */ });
/******/ // The require scope
/******/ var __nested_webpack_require_43__ = {};
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__nested_webpack_require_43__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__nested_webpack_require_43__.o(definition, key) && !__nested_webpack_require_43__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__nested_webpack_require_43__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};

// EXPORTS
__nested_webpack_require_43__.d(__webpack_exports__, {
  "yq": () => (/* reexport */ Accessibility),
  "mR": () => (/* reexport */ Account),
  "ZL": () => (/* reexport */ Advertising),
  "Vy": () => (/* reexport */ Authentication),
  "AS": () => (/* reexport */ Device),
  "PG": () => (/* reexport */ Discovery),
  "zW": () => (/* reexport */ Events),
  "N1": () => (/* reexport */ Keyboard),
  "Fw": () => (/* reexport */ Lifecycle),
  "WH": () => (/* reexport */ Localization),
  "Zb": () => (/* reexport */ Log),
  "C3": () => (/* reexport */ Metrics),
  "aE": () => (/* reexport */ Parameters),
  "t4": () => (/* reexport */ Platform),
  "NZ": () => (/* reexport */ Profile),
  "_F": () => (/* reexport */ SecondScreen),
  "Zr": () => (/* reexport */ Settings)
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Prop/MockProps.js


const mocks = {}

function mock(module, method, args, def) {
  const fullMethod = `${module}.${method}`
  if ((args == null) || (args.length === 0)) {
    // get
    const rv = mocks[fullMethod] && mocks[fullMethod].value ? mocks[fullMethod].value : def
    return rv
  } else {
    // set
    let mockMethod = mocks[fullMethod]
    if (mockMethod == null) {
      mockMethod = {
        subscribers: []
      }
    }
    mocks[fullMethod] = mockMethod
    mockMethod.value = args[0].value
    Transport_mock.event(module, method + 'Changed', {
      value: args[0].value
    })
    return {}
  }
}

/* harmony default export */ const MockProps = ({
  mock: mock
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Accessibility/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const defaults = ({

    closedCaptions: {
  "enabled": true,
  "styles": {
    "fontFamily": "Monospace sans-serif",
    "fontSize": 1,
    "fontColor": "#ffffff",
    "fontEdge": "none",
    "fontEdgeColor": "#7F7F7F",
    "fontOpacity": 100,
    "backgroundColor": "#000000",
    "backgroundOpacity": 100,
    "textAlign": "center",
    "textAlignVertical": "middle"
  }
},

    closedCaptionsSettings: function () { return MockProps.mock('accessibility', 'closedCaptionsSettings', arguments, {
  "enabled": true,
  "styles": {
    "fontFamily": "Monospace sans-serif",
    "fontSize": 1,
    "fontColor": "#ffffff",
    "fontEdge": "none",
    "fontEdgeColor": "#7F7F7F",
    "fontOpacity": 100,
    "backgroundColor": "#000000",
    "backgroundOpacity": 100,
    "textAlign": "center",
    "textAlignVertical": "middle"
  }
}) },

    voiceGuidance: {
  "enabled": true,
  "speed": 5
},

    voiceGuidanceSettings: function () { return MockProps.mock('accessibility', 'voiceGuidanceSettings', arguments, {
  "enabled": true,
  "speed": 5
}) }
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Account/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Account_defaults = ({

    id: function () { return MockProps.mock('account', 'id', arguments, "123") },

    uid: function () { return MockProps.mock('account', 'uid', arguments, "ee6723b8-7ab3-462c-8d93-dbf61227998e") }
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Advertising/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Advertising_defaults = ({

    config: {
  "adServerUrl": "http://demo.v.fwmrm.net/ad/p/1",
  "adServerUrlTemplate": "http://demo.v.fwmrm.net/ad/p/1?flag=+sltp+exvt+slcb+emcr+amcb+aeti&prof=12345:caf_allinone_profile &nw=12345&mode=live&vdur=123&caid=a110523018&asnw=372464&csid=gmott_ios_tablet_watch_live_ESPNU&ssnw=372464&vip=198.205.92.1&resp=vmap1&metr=1031&pvrn=12345&vprn=12345&vcid=1X0Ce7L3xRWlTeNhc7br8Q%3D%3D",
  "adNetworkId": "519178",
  "adProfileId": "12345:caf_allinone_profile",
  "adSiteSectionId": "caf_allinone_profile_section",
  "adOptOut": true,
  "privacyData": "ew0KICAicGR0IjogImdkcDp2MSIsDQogICJ1c19wcml2YWN5IjogIjEtTi0iLA0KICAibG10IjogIjEiIA0KfQ0K",
  "ifaValue": "01234567-89AB-CDEF-GH01-23456789ABCD",
  "ifa": "ewogICJ2YWx1ZSI6ICIwMTIzNDU2Ny04OUFCLUNERUYtR0gwMS0yMzQ1Njc4OUFCQ0QiLAogICJpZmFfdHlwZSI6ICJzc3BpZCIsCiAgImxtdCI6ICIwIgp9Cg==",
  "appName": "FutureToday",
  "appBundleId": "FutureToday.comcast",
  "distributorAppId": "1001",
  "deviceAdAttributes": "ewogICJib0F0dHJpYnV0ZXNGb3JSZXZTaGFyZUlkIjogIjEyMzQiCn0=",
  "coppa": 0,
  "authenticationEntity": "60f72475281cfba3852413bd53e957f6"
},

    policy: function () { return MockProps.mock('advertising', 'policy', arguments, {
  "skipRestriction": "adsUnwatched",
  "limitAdTracking": false
}) },

    advertisingId: {
  "ifa": "01234567-89AB-CDEF-GH01-23456789ABCD",
  "ifa_type": "idfa",
  "lmt": "0"
},

    deviceAttributes: {},

    appBundleId: "operator.app"
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Authentication/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Authentication_defaults = ({

    token: {
  "value": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
  "expires": "2022-04-23T18:25:43.511Z",
  "type": "platform"
}
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Device/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Device_defaults = ({

    id: function () { return MockProps.mock('device', 'id', arguments, "123") },

    distributor: function () { return MockProps.mock('device', 'distributor', arguments, "Company") },

    platform: function () { return MockProps.mock('device', 'platform', arguments, "WPE") },

    uid: function () { return MockProps.mock('device', 'uid', arguments, "ee6723b8-7ab3-462c-8d93-dbf61227998e") },

    type: function () { return MockProps.mock('device', 'type', arguments, "STB") },

    model: function () { return MockProps.mock('device', 'model', arguments, "xi6") },

    sku: function () { return MockProps.mock('device', 'sku', arguments, "AX061AEI") },

    make: function () { return MockProps.mock('device', 'make', arguments, "Arris") },

    version: function () { return MockProps.mock('device', 'version', arguments, {
  "sdk": {
    "major": 0,
    "minor": 5,
    "patch": 0,
    "readable": "Firebolt JS SDK v0.5.0"
  },
  "os": {
    "major": 0,
    "minor": 1,
    "patch": 0,
    "readable": "Firebolt OS v0.1.0"
  },
  "debug": ""
}) },

    hdcp: function () { return MockProps.mock('device', 'hdcp', arguments, {
  "hdcp1.4": true,
  "hdcp2.2": true
}) },

    hdr: function () { return MockProps.mock('device', 'hdr', arguments, {
  "hdr10": true,
  "hdr10Plus": true,
  "dolbyVision": true,
  "hlg": true
}) },

    audio: function () { return MockProps.mock('device', 'audio', arguments, {
  "stereo": true,
  "dolbyDigital5.1": true,
  "dolbyDigital5.1+": true,
  "dolbyAtmos": true
}) },

    screenResolution: function () { return MockProps.mock('device', 'screenResolution', arguments, [
  1920,
  1080
]) },

    videoResolution: function () { return MockProps.mock('device', 'videoResolution', arguments, [
  1920,
  1080
]) },

    name: function () { return MockProps.mock('device', 'name', arguments, "Living Room") },

    network: function () { return MockProps.mock('device', 'network', arguments, {
  "state": "connected",
  "type": "wifi"
}) }
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Discovery/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Discovery_defaults = ({

    policy: function () { return MockProps.mock('discovery', 'policy', arguments, {
  "enableRecommendations": true,
  "shareWatchHistory": true,
  "rememberWatchedPrograms": true
}) },

    entityInfo: true,

    purchasedContent: true,

    watched: true,

    watchNext: true,

    entitlements: true,

    launch: true,

    signIn: true,

    signOut: true
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Keyboard/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Keyboard_defaults = ({

    email: "user@domain.com",

    password: "abc123",

    standard: "Living Room"
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/global.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

let g

if (typeof self !== 'undefined') {
	g = self;
} else if (typeof window !== 'undefined') {
	g = window;
} else {
	g = Function('return this')();
} 

const global = g

/* harmony default export */ const Transport_global = (global);
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Lifecycle/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */





let inactive = {"state":"inactive","previous":"initializing"}
let foreground = {"state":"foreground","previous":"inactive"}
let background = {"state":"background","previous":"foreground"}
let suspended = {"state":"suspended","previous":"inactive"}
let unloading = {"state":"unloading","previous":"inactive"}

const emit = (value) => {
  value.previous = Lifecycle.state()
  Transport_mock.event('Lifecycle', value.state, value)
}

const automation = Transport_global && Transport_global.__firebolt ? !!Transport_global.__firebolt.automation : false

/* harmony default export */ const Lifecycle_defaults = ({
  ready: function() {
    inactive.previous = 'initializing'
    setTimeout(() => emit(inactive), automation ? 1 : 500)
    foreground.previous = 'inactive'
    setTimeout(() => emit(foreground), automation ? 2 : 1000)
  },

  close: function(params) {
    let reason = params.reason
    if (reason === Lifecycle.CloseReason.REMOTE_BUTTON) {
      setTimeout(() => emit(inactive), automation ? 1 : 500)
    }
    else if (Object.values(Lifecycle.CloseReason).includes(reason)) {
      setTimeout(() => emit(inactive), automation ? 1 : 500)
      setTimeout(() => emit(unloading), automation ? 2 : 1000)
      setTimeout(() => Lifecycle.finished(), automation ? 3: 3000)
    }
    else {
      throw "Invalid close reason"
    }
  },

  finished: function() {
    if (Transport_global.location)
      Transport_global.location.href = "about:blank"
  },
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Localization/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Localization_defaults = ({

    locality: "Philadelphia",

    postalCode: "19103",

    countryCode: "US",

    language: function () { return MockProps.mock('localization', 'language', arguments, "en") },

    locale: "en-US",

    latlon: [
  39.9549,
  75.1699
],

    additionalInfo: {}
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Metrics/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Metrics_defaults = ({

    ready: true,

    signIn: true,

    signOut: true,

    startContent: true,

    stopContent: true,

    page: true,

    action: true,

    error: true,

    mediaLoadStart: true,

    mediaPlay: true,

    mediaPlaying: true,

    mediaPause: true,

    mediaWaiting: true,

    mediaProgress: true,

    mediaSeeking: true,

    mediaSeeked: true,

    mediaRateChange: true,

    mediaRenditionChange: true,

    mediaEnded: true
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Parameters/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Parameters_defaults = ({

    initialization: {
  "lmt": 0,
  "us_privacy": "1-Y-",
  "discovery": {
    "navigateTo": {
      "action": "entity",
      "data": {
        "entityId": "abc",
        "entityType": "program",
        "programType": "movie"
      },
      "context": {
        "source": "voice"
      }
    }
  }
}
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Profile/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Profile_defaults = ({

    approveContentRating: false,

    approvePurchase: false,

    flags: {
  "userExperience": "1000"
}
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/SecondScreen/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const SecondScreen_defaults = ({

    protocols: {
  "dial1.7": true
},

    device: "device-id",

    friendlyName: function () { return MockProps.mock('secondscreen', 'friendlyName', arguments, "Living Room") }
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Platform/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */





/* harmony default export */ const Platform_defaults = ({
  localization: Localization_defaults,
  device: Device_defaults,
  accessibility: defaults,
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/mock.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */



















let listener
const setMockListener = func => { listener = func }

let mock_mock = {
  accessibility: defaults,
  account: Account_defaults,
  advertising: Advertising_defaults,
  authentication: Authentication_defaults,
  device: Device_defaults,
  discovery: Discovery_defaults,
  keyboard: Keyboard_defaults,
  lifecycle: Lifecycle_defaults,
  localization: Localization_defaults,
  metrics: Metrics_defaults,
  parameters: Parameters_defaults,
  profile: Profile_defaults,
  secondscreen: SecondScreen_defaults,
  platform: Platform_defaults,
}

let callback
let testHarness

if (Transport_global.__firebolt && Transport_global.__firebolt.testHarness) {
  testHarness = Transport_global.__firebolt.testHarness
}

function send(message) {
  let json = JSON.parse(message)
  let [module, method] = json.method.split('.')

  if (testHarness && testHarness.onSend) {
    testHarness.onSend(module, method, json.params, json.id)
  }

  // store the ID of the first listen for each event
  // TODO: what about wild cards?
  let result
  try {
    result = getResult(json.method, json.params)
  }
  catch (error) {
    setTimeout(() => callback(JSON.stringify({ 
      jsonrpc: '2.0',
      error: {
        code: -32602,
        message: "Invalid params (this is a mock error from the mock transport layer)"
      },
      id: json.id
    })))
  }

  setTimeout(() => callback(JSON.stringify({ 
    jsonrpc: '2.0',
    result: result,
    id: json.id
  })))
}

function receive(_callback) {
  callback = _callback

  if (testHarness && (typeof testHarness.initialize === 'function')) {
    testHarness.initialize({
      emit: mock_event,
      listen: function(...args) { listener(...args) },
    })
  }
}

function mock_event(module, event, value) {
  const listener = Object.entries(Transport.getEventMap()).find(([k, v]) => v.toLowerCase() === module.toLowerCase() + '.' + event.toLowerCase())
  if (listener) {
    let message = JSON.stringify({
      jsonrpc: '2.0',
      id: listener[0],
      result: value
    })
    callback(message)
  }
}

function dotGrab(obj = {}, key) {
  const keys = key.split('.')
  let ref = obj
  for (let i = 0; i < keys.length; i++) {
    ref = ref[keys[i]] || {}
  }
  return ref
}

function getResult(method, params) {
  let api = dotGrab(mock_mock, method)

  if (method.match(/^[a-zA-Z]+\.on[A-Za-z]+$/)) {
    api = {
      event: method,
      listening: true
    }
  }

  if (typeof api === 'function') {
    return params == null ? api() : api(params)
  } else return api
}

/* harmony default export */ const Transport_mock = ({
  send: send,
  receive: receive,
  event: mock_event
});


;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/queue.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

class Queue {
  constructor () {
    this._callback = null
    this._queue = []
  }

  send (json) {
    this._queue.push(json)
  }

  receive (_callback) {
    this._callback = _callback
  }

  flush (transport) {
    transport.receive(this._callback)
    this._queue.forEach(item => transport.send(item))
  }
}

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Settings/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

const settings = {}
const subscribers = {}

const initSettings = (appSettings, platformSettings) => {
  settings['app'] = appSettings
  settings['platform'] = {
    logLevel: 'WARN',
    ...platformSettings
  }
  settings['user'] = {}
}

const publish = (key, value) => {
  subscribers[key] && subscribers[key].forEach(subscriber => subscriber(value))
}

const Settings_dotGrab = (obj = {}, key) => {
  const keys = key.split('.')
  for (let i = 0; i < keys.length; i++) {
    obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {}
  }
  return typeof obj === 'object' ? (Object.keys(obj).length ? obj : undefined) : obj
}

/* harmony default export */ const Settings = ({
  get(type, key, fallback = undefined) {
    const val = Settings_dotGrab(settings[type], key)
    return val !== undefined ? val : fallback
  },
  has(type, key) {
    return !!this.get(type, key)
  },
  set(key, value) {
    settings['user'][key] = value
    publish(key, value)
  },
  subscribe(key, callback) {
    subscribers[key] = subscribers[key] || []
    subscribers[key].push(callback)
  },
  unsubscribe(key, callback) {
    if (callback) {
      const index = subscribers[key] && subscribers[key].findIndex(cb => cb === callback)
      index > -1 && subscribers[key].splice(index, 1)
    } else {
      if (key in subscribers) {
        subscribers[key] = []
      }
    }
  },
  clearSubscribers() {
    for (const key of Object.getOwnPropertyNames(subscribers)) {
      delete subscribers[key]
    }
  },
  setLogLevel (logLevel) {
    settings.platform.logLevel = logLevel
  },
  getLogLevel () {
    return settings.platform.logLevel
  }
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/LegacyTransport.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

class LegacyTransport {
  constructor (bridge) {
    this.bridge = bridge
  }

  send (msg) {
    this.bridge.JSMessageChanged(msg, () => {})
  }

  receive (callback) {
    window.$badger = window.$badger || {}
    /** Hold on to real $badger callback and event methods so they can be called for non-jsonrpc messages */
    const badgerCallback = window.$badger.callback ? window.$badger.callback.bind(window.$badger) : null
    const badgerEvent = window.$badger.event ? window.$badger.event.bind(window.$badger) : null
    window.$badger.callback = (pid, success, json) => {
      if (json.jsonrpc) {
        callback(JSON.stringify(json))
      } else if (badgerCallback) {
        badgerCallback(pid, success, json)
      }
    }
    window.$badger.event = (handlerId, json) => {
      if (json.jsonrpc) {
        callback(JSON.stringify(json))
      } else if (badgerEvent) {
        badgerEvent(handlerId, json)
      }
    }
  }

  static isLegacy (transport) {
    return LegacyTransport.isXREProxy(transport) || ((transport.send === undefined) && (transport.JSMessageChanged))
  }

  static isXREProxy (transport) {
    /** Set top boxes running XRE has a "Proxy" transport
     * native object that intercepts ALL method calls, so we
     * cannot test for transport.send existence because it will return true
     * even though it actually is not supported. Check if some obscure method
     * name like "proxyObjectTest" is defined. If it is then we know we are using a
     * Proxy object and thus is legacy transport.
     */
    return transport.proxyObjectTest !== undefined
  }
}

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/WebsocketTransport.js
const MAX_QUEUED_MESSAGES = 100

class WebsocketTransport {
  constructor (endpoint) {
    this._endpoint = endpoint
    this._ws = null
    this._connected = false
    this._queue = []
    this._callbacks = []
  }

  send (msg) {
    this._connect()

    if (this._connected) {
      this._ws.send(msg)
    } else {
      if (this._queue.length < MAX_QUEUED_MESSAGES) {
        this._queue.push(msg)
      }
    }
  }

  receive (callback) {
    if (!callback) return
    this._connect()
    this._callbacks.push(callback)
  }

  _notifyCallbacks (message) {
    for (let i = 0; i < this._callbacks.length; i++) {
      setTimeout(() => this._callbacks[i](message), 1)
    }
  }

  _connect () {
    if (this._ws) return
    this._ws = new WebSocket(this._endpoint)
    this._ws.addEventListener('message', message => {
      this._notifyCallbacks(message.data)
    })
    this._ws.addEventListener('error', message => {
    })
    this._ws.addEventListener('close', message => {
      this._ws = null
      this._connected = false
    })
    this._ws.addEventListener('open', message => {
      this._connected = true
      for (let i = 0; i < this._queue.length; i++) {
        this._ws.send(this._queue[i])
      }
      this._queue = []
    })
  }
}
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */








const LEGACY_TRANSPORT_SERVICE_NAME = 'com.comcast.BridgeObject_1'
let moduleInstance = null

const isEventSuccess = x => x && (typeof x.event === 'string') && (typeof x.listening === 'boolean')

class Transport {
  constructor () {
    this._promises = []
    this._transport = null
    this._id = 1
    this._eventEmitters = []
    this._eventMap = {}
    this._queue = new Queue()
    this._deprecated = {}
    this.isMock = false
  }

  static addEventEmitter (emitter) {
    Transport.get()._eventEmitters.push(emitter)
  }

  static registerDeprecatedMethod (module, method, alternative) {
    Transport.get()._deprecated[module.toLowerCase() + '.' + method.toLowerCase()] = {
      alternative: alternative || ''
    }
  }

  _endpoint () {
    if (Transport_global.__firebolt && Transport_global.__firebolt.endpoint) {
      return Transport_global.__firebolt.endpoint
    }
    return null
  }

  constructTransportLayer () {
    let transport
    const endpoint = this._endpoint()
    if (endpoint && (endpoint.startsWith('ws://') || endpoint.startsWith('wss://'))) {
      transport = new WebsocketTransport(endpoint)
      transport.receive(this.receiveHandler.bind(this))
    } else if (
      typeof Transport_global.ServiceManager !== 'undefined' &&
      Transport_global.ServiceManager &&
      Transport_global.ServiceManager.version
    ) {
      // Wire up the queue
      transport = this._queue
      // get the default bridge service, and flush the queue
      Transport_global.ServiceManager.getServiceForJavaScript(LEGACY_TRANSPORT_SERVICE_NAME, service => {
        if (LegacyTransport.isLegacy(service)) {
          transport = new LegacyTransport(service)
        } else {
          transport = service
        }
        this.setTransportLayer(transport)
      })
    } else {
      this.isMock = true
      transport = Transport_mock
      transport.receive(this.receiveHandler.bind(this))
    }
    return transport
  }

  setTransportLayer (tl) {
    this._transport = tl
    this._queue.flush(tl)
  }

  static send (module, method, params) {
    /** Transport singleton across all SDKs to keep single id map */
    return Transport.get()._send(module, method, params)
  }

  _send (module, method, params) {
    const p = new Promise((resolve, reject) => {
      this._promises[this._id] = {}
      this._promises[this._id].promise = this
      this._promises[this._id].resolve = resolve
      this._promises[this._id].reject = reject

      const deprecated = this._deprecated[module.toLowerCase() + '.' + method.toLowerCase()]
      if (deprecated) {
        console.warn(`WARNING: ${module}.${method}() is deprecated. ` + deprecated.alternative)
      }

      // store the ID of the first listen for each event
      // TODO: what about wild cards?
      if (method.match(/^on[A-Z]/)) {
        if (params.listen) {
          this._eventMap[this._id] = module.toLowerCase() + '.' + method[2].toLowerCase() + method.substr(3)
        } else {
          Object.keys(this._eventMap).forEach(key => {
            if (this._eventMap[key] === module.toLowerCase() + '.' + method[2].toLowerCase() + method.substr(3)) {
              delete this._eventMap[key]
            }
          })
        }
      }
    })

    const json = { jsonrpc: '2.0', method: module + '.' + method, params: params, id: this._id }
    this._id++

    const msg = JSON.stringify(json)
    if (Settings.getLogLevel() === 'DEBUG') {
      console.debug('Sending message to transport: ' + msg)
    }
    this._transport.send(msg)

    return p
  }

  static getEventMap () {
    return Transport.get()._eventMap
  }

  /**
   * If we have a global transport, use that. Otherwise, use the module-scoped transport instance.
   * @returns {Transport}
   */
  static get () {
    return Transport_global.__firebolt.transport ? Transport_global.__firebolt.transport : moduleInstance
  }

  receiveHandler (message) {
    if (Settings.getLogLevel() === 'DEBUG') {
      console.debug('Received message from transport: ' + message)
    }
    const json = JSON.parse(message)
    const p = this._promises[json.id]

    if (p) {
      if (json.error) p.reject(json.error)
      else {
        p.resolve(json.result)
      }
      delete this._promises[json.id]
    }

    // event responses need to be emitted, even after the listen call is resolved
    if (this._eventMap[json.id] && !isEventSuccess(json.result)) {
      const moduleevent = this._eventMap[json.id]
      if (moduleevent) {
        this._eventEmitters.forEach(emit => {
          emit(moduleevent.split('.')[0], moduleevent.split('.')[1], json.result)
        })
      }
    }
  }

  init () {
    initSettings({}, { log: true })
    this._queue.receive(this.receiveHandler.bind(this))
    if (Transport_global.__firebolt) {
      if (Transport_global.__firebolt.mockTransportLayer === true) {
        this.isMock = true
        this.setTransportLayer(Transport_mock)
      } else if (Transport_global.__firebolt.getTransportLayer) {
        this.setTransportLayer(Transport_global.__firebolt.getTransportLayer())
      }
    }
    if (this._transport == null) {
      this._transport = this.constructTransportLayer()
    }
  }
}

/** Set up singleton and initialize it */
Transport_global.__firebolt = Transport_global.__firebolt || {}
if ((Transport_global.__firebolt.transport == null) && (moduleInstance == null)) {
  const transport = new Transport()
  transport.init()
  if (transport.isMock) {
    /** We should use the mock transport built with the SDK, not a global */
    moduleInstance = transport
  } else {
    Transport_global.__firebolt = Transport_global.__firebolt || {}
    Transport_global.__firebolt.transport = transport
  }
  Transport_global.__firebolt.setTransportLayer = transport.setTransportLayer.bind(transport)
}

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Events/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */




let listenerId = 0

// holds a map of ${module}.${event} => listenerId, e.g. callback method id
// note that one callback can listen to multiple events, e.g. 'discovery.*'
const listeners = {}

// holds a map of ${module}.${event} => Transport.send calls (only called once per event)
// note that the keys here MUST NOT contain wild cards
const enabledEvents = {}

const oncers = []
const validEvents = {}
let transportInitialized = false

const Events_emit = (module, event, value) => {
  callCallbacks(listeners[module + '.*'], [event, value])
  callCallbacks(listeners[module + '.' + event], [value])
}

const registerEvents = (module, events) => {
  validEvents[module.toLowerCase()] = events.concat()
}

const callCallbacks = (cbs, args) => {
  cbs &&
    Object.keys(cbs).forEach(listenerId => {
      let callback = cbs[listenerId]
      if (oncers.indexOf(parseInt(listenerId)) >= 0) {
        oncers.splice(oncers.indexOf(parseInt(listenerId)), 1)
        delete cbs[listenerId]
      }
      callback.apply(null, args)
    })
}

const doListen = function(module, event, callback, once) {
  if (typeof callback !== 'function') {
    return Promise.reject('No valid callback function provided.')
  } else {
    if (module === '*') {
      return Promise.reject('No valid module name provided')
    }

    let events = (event === '*' ? validEvents[module] : [event]) // explodes wildcards into an array
    let promises = []
    const key = module + '.' + event // this might be a wildcard, e.g. 'lifecycle.*'
    listenerId++
    listeners[key] = listeners[key] || {}
    listeners[key][''+listenerId] = callback

    if (once) {
      oncers.push(listenerId)
    }

    events.forEach(event => {
      // Check each event, and only turn on events (not wildcards) that are off
      if (!enabledEvents[module + '.' + event]) {
        promises.push(
          Transport.send(module, 'on' + event[0].toUpperCase() + event.substr(1), { listen: true })
        )
        enabledEvents[module + '.' + event] = true
      }
    })

    let resolve, reject
    let p = new Promise((res, rej) => {
      resolve = res
      reject = rej
    })

    if (promises.length) {
      Promise.all(promises).then(responses => {
        resolve(listenerId)
      }).catch(error => {
        // Promise.all rejects if at least one promise rejects... we don't want that behavior here
        // TODO: Do something better than fail silently
        if (event === '*') {
          resolve(listenerId)
        }
        else {
          reject(error)
        }
      })
    }
    else {
      resolve(listenerId)
    }

    return p
  }
}

const getListenArgs = function(...args) {
  const callback = args.pop()
  const module = args[0].toLowerCase() || '*'
  const event = args[1] || '*'
  return [module, event, callback]
}

const once = function(...args) {
  const [module, event, callback] = getListenArgs(...args)
  return doListen(module, event, callback, true)
}

const listen = function(...args) {
  init()
  const [module, event, callback] = getListenArgs(...args)
  return doListen(module, event, callback, false)
}

const init = () => {
  if (!transportInitialized) {
    Transport.addEventEmitter(Events_emit)
    setMockListener(listen)
    transportInitialized = true
  }
}

/* harmony default export */ const Events = ({
  listen: listen,
  once: once,
  // TODO: clear needs to go through Transport Layer
  clear(moduleOrId = false, event = false) {
    if (typeof moduleOrId === 'number') {
      const searchId = moduleOrId.toString()
      Object.keys(listeners).every(key => {
        if (listeners[key][searchId]) {
          // delete callback
          delete listeners[key][searchId]
          // delete the whole namespace if it was the only callback
          if (Object.keys(listeners[key]).length === 0) {
            delete listeners[key]
          }
          return false
        }
        return true
      })
    } else {
      if (!moduleOrId && !event) {
        Object.keys(listeners).forEach(key => {
          delete listeners[key]
        })
      } else if (!event) {
        Object.keys(listeners).forEach(key => {
          if (key.indexOf(moduleOrId.toLowerCase()) === 0) {
            delete listeners[key]
          }
        })
      } else {
        delete listeners[moduleOrId + '.' + event]
      }
    }
  },
  broadcast(event, value) {
    Events_emit('app', event, value)
  },
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Prop/index.js



function prop(moduleName, key, args, immutable, readonly) {
  if (args.length === 0) {
    // getter
    return Transport.send(moduleName, key)
  } else if (args.length === 1 && typeof args[0] === 'function') {
    // subscribe
    if (immutable) {
      throw new Error('Cannot subscribe to an immutable property')
    }
    return Events.listen(moduleName, key + 'Changed', args[0])
  } else {
    // setter
    if (immutable) {
      throw new Error('Cannot set a value to an immutable property')
    }
    if (readonly) {
      throw new Error('Cannot set a value to a readonly property')
    }
    return Transport.send(moduleName, key, {
      value: args[0]
    })
  }
}

/* harmony default export */ const Prop = ({
  prop: prop
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Accessibility/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Accessibility', Object.values(["closedCaptionsSettingsChanged","voiceGuidanceSettingsChanged"]))

Transport.registerDeprecatedMethod('Accessibility', 'closedCaptions', 'Use Accessibility.closedCaptionsSettings() instead.')
Transport.registerDeprecatedMethod('Accessibility', 'voiceGuidance', 'Use Accessibility.voiceGuidanceSettings() instead.')


function closedCaptions() {
  return Transport.send('accessibility', 'closedCaptions', {  })
}
function closedCaptionsSettings() {
  return Prop.prop('accessibility',  'closedCaptionsSettings', arguments, false, true)
}

function voiceGuidance() {
  return Transport.send('accessibility', 'voiceGuidance', {  })
}
function voiceGuidanceSettings() {
  return Prop.prop('accessibility',  'voiceGuidanceSettings', arguments, false, true)
}

function Accessibility_listen(...args) {
  return Events.listen('accessibility', ...args)
} 

function Accessibility_once(...args) {
  return Events.once('accessibility', ...args)
}

function clear(...args) {
  return Events.clear('accessibility', ...args)
}

/* harmony default export */ const Accessibility = ({

  events: {
    closedCaptionsSettingsChanged:'closedCaptionsSettingsChanged',
    voiceGuidanceSettingsChanged:'voiceGuidanceSettingsChanged'
  },
closedCaptions,
  closedCaptionsSettings,
  voiceGuidance,
  voiceGuidanceSettings,
  listen: Accessibility_listen,
  once: Accessibility_once,
  clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Account/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function id() {
  return Prop.prop('account',  'id', arguments, true, true)
}
function uid() {
  return Prop.prop('account',  'uid', arguments, true, true)
}

/* harmony default export */ const Account = ({

id,
  uid
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Advertising/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Advertising', Object.values(["policyChanged"]))



function config(options) {
  return Transport.send('advertising', 'config', { options })
}
function policy() {
  return Prop.prop('advertising',  'policy', arguments, false, true)
}

function advertisingId() {
  return Transport.send('advertising', 'advertisingId', {  })
}

function deviceAttributes() {
  return Transport.send('advertising', 'deviceAttributes', {  })
}

function appBundleId() {
  return Transport.send('advertising', 'appBundleId', {  })
}

function Advertising_listen(...args) {
  return Events.listen('advertising', ...args)
} 

function Advertising_once(...args) {
  return Events.once('advertising', ...args)
}

function Advertising_clear(...args) {
  return Events.clear('advertising', ...args)
}

/* harmony default export */ const Advertising = ({

  events: {
    policyChanged:'policyChanged'
  },

  SkipRestriction: {
    NONE: 'none',
    ADS_UNWATCHED: 'adsUnwatched',
    ADS_ALL: 'adsAll',
    ALL: 'all'
  },

config,
  policy,
  advertisingId,
  deviceAttributes,
  appBundleId,
  listen: Advertising_listen,
  once: Advertising_once,
  clear: Advertising_clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Authentication/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function token(type, options) {
  return Transport.send('authentication', 'token', { type, options })
}

/* harmony default export */ const Authentication = ({


  TokenType: {
    PLATFORM: 'platform',
    DEVICE: 'device',
    DISTRIBUTOR: 'distributor'
  },

token
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Device/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Device', Object.values(["deviceNameChanged","hdcpChanged","hdrChanged","audioChanged","screenResolutionChanged","videoResolutionChanged","nameChanged","networkChanged"]))

Transport.registerDeprecatedMethod('Device', 'onDeviceNameChanged', 'Use Device.name() instead.')

function version() {
  return new Promise( (resolve, reject) => {
      Transport.send('device', 'version').then( v => {
          v = v || {}
          v.sdk = v.sdk || {}
          v.sdk.major = parseInt('0')
          v.sdk.minor = parseInt('6')
          v.sdk.patch = parseInt('0')
          v.sdk.readable = 'The Firebolt JS SDK'
          resolve(v)    
      }).catch(error => {
          reject(error)
      })
  })
}

function Device_id() {
  return Prop.prop('device',  'id', arguments, true, true)
}
function distributor() {
  return Prop.prop('device',  'distributor', arguments, true, true)
}
function platform() {
  return Prop.prop('device',  'platform', arguments, true, true)
}
function Device_uid() {
  return Prop.prop('device',  'uid', arguments, true, true)
}
function type() {
  return Prop.prop('device',  'type', arguments, true, true)
}
function model() {
  return Prop.prop('device',  'model', arguments, true, true)
}
function sku() {
  return Prop.prop('device',  'sku', arguments, true, true)
}
function make() {
  return Prop.prop('device',  'make', arguments, true, true)
}
function hdcp() {
  return Prop.prop('device',  'hdcp', arguments, false, true)
}
function hdr() {
  return Prop.prop('device',  'hdr', arguments, false, true)
}
function audio() {
  return Prop.prop('device',  'audio', arguments, false, true)
}
function screenResolution() {
  return Prop.prop('device',  'screenResolution', arguments, false, true)
}
function videoResolution() {
  return Prop.prop('device',  'videoResolution', arguments, false, true)
}
function Device_name() {
  return Prop.prop('device',  'name', arguments, false, true)
}
function network() {
  return Prop.prop('device',  'network', arguments, false, true)
}

function Device_listen(...args) {
  return Events.listen('device', ...args)
} 

function Device_once(...args) {
  return Events.once('device', ...args)
}

function Device_clear(...args) {
  return Events.clear('device', ...args)
}

/* harmony default export */ const Device = ({

  events: {
    deviceNameChanged:'deviceNameChanged',
    hdcpChanged:'hdcpChanged',
    hdrChanged:'hdrChanged',
    audioChanged:'audioChanged',
    screenResolutionChanged:'screenResolutionChanged',
    videoResolutionChanged:'videoResolutionChanged',
    nameChanged:'nameChanged',
    networkChanged:'networkChanged'
  },

  NetworkType: {
    WIFI: 'wifi',
    ETHERNET: 'ethernet',
    HYBRID: 'hybrid'
  },


  NetworkState: {
    CONNECTED: 'connected',
    DISCONNECTED: 'disconnected'
  },


  AudioProfile: {
    STEREO: 'stereo',
    DOLBY_DIGITAL_5_1: 'dolbyDigital5.1',
    DOLBY_DIGITAL_7_1: 'dolbyDigital7.1',
    DOLBY_DIGITAL_5_1_PLUS: 'dolbyDigital5.1+',
    DOLBY_DIGITAL_7_1_PLUS: 'dolbyDigital7.1+',
    DOLBY_ATMOS: 'dolbyAtmos'
  },


  version,
id: Device_id,
  distributor,
  platform,
  uid: Device_uid,
  type,
  model,
  sku,
  make,
  hdcp,
  hdr,
  audio,
  screenResolution,
  videoResolution,
  name: Device_name,
  network,
  listen: Device_listen,
  once: Device_once,
  clear: Device_clear
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Metrics/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function ready() {
  return Transport.send('metrics', 'ready', {})
}

function signIn() {
  return Transport.send('metrics', 'signIn', {})
}

function signOut() {
  return Transport.send('metrics', 'signOut', {})
}



function startContent(entityId) {
  return Transport.send('metrics', 'startContent', { entityId })
}

function stopContent(entityId) {
  return Transport.send('metrics', 'stopContent', { entityId })
}

function page(pageId) {
  return Transport.send('metrics', 'page', { pageId })
}

function action(category, type, parameters) {
  return Transport.send('metrics', 'action', { category, type, parameters })
}

function error(type, code, description, visible, parameters) {
  return Transport.send('metrics', 'error', { type, code, description, visible, parameters })
}

function mediaLoadStart(entityId) {
  return Transport.send('metrics', 'mediaLoadStart', { entityId })
}

function mediaPlay(entityId) {
  return Transport.send('metrics', 'mediaPlay', { entityId })
}

function mediaPlaying(entityId) {
  return Transport.send('metrics', 'mediaPlaying', { entityId })
}

function mediaPause(entityId) {
  return Transport.send('metrics', 'mediaPause', { entityId })
}

function mediaWaiting(entityId) {
  return Transport.send('metrics', 'mediaWaiting', { entityId })
}

function mediaProgress(entityId, progress) {
  return Transport.send('metrics', 'mediaProgress', { entityId, progress })
}

function mediaSeeking(entityId, target) {
  return Transport.send('metrics', 'mediaSeeking', { entityId, target })
}

function mediaSeeked(entityId, position) {
  return Transport.send('metrics', 'mediaSeeked', { entityId, position })
}

function mediaRateChange(entityId, rate) {
  return Transport.send('metrics', 'mediaRateChange', { entityId, rate })
}

function mediaRenditionChange(entityId, bitrate, width, height, profile) {
  return Transport.send('metrics', 'mediaRenditionChange', { entityId, bitrate, width, height, profile })
}

function mediaEnded(entityId) {
  return Transport.send('metrics', 'mediaEnded', { entityId })
}

/* harmony default export */ const Metrics = ({


  ErrorType: {
    NETWORK: 'network',
    MEDIA: 'media',
    RESTRICTION: 'restriction',
    ENTITLEMENT: 'entitlement',
    OTHER: 'other'
  },

startContent,
  stopContent,
  page,
  action,
  error,
  mediaLoadStart,
  mediaPlay,
  mediaPlaying,
  mediaPause,
  mediaWaiting,
  mediaProgress,
  mediaSeeking,
  mediaSeeked,
  mediaRateChange,
  mediaRenditionChange,
  mediaEnded
});


;// CONCATENATED MODULE: ./build/sdk/javascript/src/Discovery/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Discovery', Object.values(["navigateTo","policyChanged"]))


function Discovery_policy() {
  return Prop.prop('discovery',  'policy', arguments, false, true)
}

let entityInfoHasCallback = false

function entityInfo (data) {
  if (arguments.length === 1 && typeof arguments[0] === 'function') {
    if (entityInfoHasCallback) {
      return Promise.reject('Cannot register more than one entityInfo handler.')
    }

    const callback = arguments[0]
    entityInfoHasCallback = true
    return Events.listen('discovery', 'pullEntityInfo', (request) => {
      if (typeof request === 'boolean') return

      try {
        const result = callback(request.parameters).then(result => {
          const params = {
            correlationId: request.correlationId,
            result: result
          }
          Transport.send('discovery', 'entityInfo', params).catch(error => {
            const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
            InternalMetrics.sdk.error(`Failed to send entityInfo pull response through Transport Layer: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
          })
        }).catch(error => {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
          InternalMetrics.sdk.error(`App 'entityInfo' callback failed: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
        })
      }
      catch (error) {
        const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
        InternalMetrics.sdk.error(`App 'entityInfo' callback failed: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
    }
    })
  }
  else {
    return Transport.send('discovery', 'entityInfo', { data })
  }
}

let purchasedContentHasCallback = false

function purchasedContent (data) {
  if (arguments.length === 1 && typeof arguments[0] === 'function') {
    if (purchasedContentHasCallback) {
      return Promise.reject('Cannot register more than one purchasedContent handler.')
    }

    const callback = arguments[0]
    purchasedContentHasCallback = true
    return Events.listen('discovery', 'pullPurchasedContent', (request) => {
      if (typeof request === 'boolean') return

      try {
        const result = callback(request.parameters).then(result => {
          const params = {
            correlationId: request.correlationId,
            result: result
          }
          Transport.send('discovery', 'purchasedContent', params).catch(error => {
            const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
            InternalMetrics.sdk.error(`Failed to send purchasedContent pull response through Transport Layer: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
          })
        }).catch(error => {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
          InternalMetrics.sdk.error(`App 'purchasedContent' callback failed: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
        })
      }
      catch (error) {
        const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
        InternalMetrics.sdk.error(`App 'purchasedContent' callback failed: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
    }
    })
  }
  else {
    return Transport.send('discovery', 'purchasedContent', { data })
  }
}

function watched(entityId, progress, completed, watchedOn) {
  if (arguments.length === 1 && Array.isArray(arguments[0])) {
    return Transport.send('discovery', 'watched', arguments[0])
  }
  else {
    return Transport.send('discovery', 'watched', { entityId, progress, completed, watchedOn })
  }
}

function watchNext(title, identifiers, expires, images) {
  return Transport.send('discovery', 'watchNext', { title, identifiers, expires, images })
}

function entitlements(entitlements) {
  return Transport.send('discovery', 'entitlements', { entitlements })
}

function launch(appId, intent) {
  return Transport.send('discovery', 'launch', { appId, intent })
}



function Discovery_signIn(entitlements) {
    const p = Transport.send('discovery', 'signIn', { entitlements })
    
    p.then(_ => {
        setTimeout(_ => {
            signIn(entitlements)
        })    
    })

    return p
}



function Discovery_signOut() {
    const p = Transport.send('discovery', 'signOut', {  })
    
    p.then(_ => {
        setTimeout(_ => {
            signOut()
        })    
    })

    return p
}

function Discovery_listen(...args) {
  return Events.listen('discovery', ...args)
} 

function Discovery_once(...args) {
  return Events.once('discovery', ...args)
}

function Discovery_clear(...args) {
  return Events.clear('discovery', ...args)
}

/* harmony default export */ const Discovery = ({

  events: {
    navigateTo:'navigateTo',
    policyChanged:'policyChanged'
  },
policy: Discovery_policy,
  entityInfo,
  purchasedContent,
  watched,
  watchNext,
  entitlements,
  launch,
  signIn: Discovery_signIn,
  signOut: Discovery_signOut,
  listen: Discovery_listen,
  once: Discovery_once,
  clear: Discovery_clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Keyboard/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function email(type, message) {
  return Transport.send('keyboard', 'email', { type, message })
}

function Keyboard_password(message) {
  return Transport.send('keyboard', 'password', { message })
}

function standard(message) {
  return Transport.send('keyboard', 'standard', { message })
}

/* harmony default export */ const Keyboard = ({


  EmailUsage: {
    SIGN_IN: 'signIn',
    SIGN_UP: 'signUp'
  },

email,
  password: Keyboard_password,
  standard
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Lifecycle/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






registerEvents('Lifecycle', Object.values(["inactive","foreground","background","suspended","unloading"]))


const store = {
  _current: 'initializing',
  get current() {
    return this._current
  }
}

Events.listen('Lifecycle', (event, value) => {
  store._current = event
})


;

function Lifecycle_ready() {
    const p = Transport.send('lifecycle', 'ready', {  })
    
    p.then(_ => {
        setTimeout(_ => {
            ready()
        })    
    })

    return p
}

function Lifecycle_close(reason) {
  return Transport.send('lifecycle', 'close', { reason })
}

function Lifecycle_listen(...args) {
  return Events.listen('lifecycle', ...args)
} 

function Lifecycle_once(...args) {
  return Events.once('lifecycle', ...args)
}

function Lifecycle_clear(...args) {
  return Events.clear('lifecycle', ...args)
}

function state() {
  return store.current
}

function finished() {
  if (store.current === 'unloading') {
    return Transport.send('lifecycle', 'finished')
  } else {
    throw 'Cannot call finished() except when in the unloading transition'
  }
}

// public API
/* harmony default export */ const Lifecycle = ({

  events: {
    inactive:'inactive',
    foreground:'foreground',
    background:'background',
    suspended:'suspended',
    unloading:'unloading'
  },


  LifecycleState: {
    INITIALIZING: 'initializing',
    INACTIVE: 'inactive',
    BACKGROUND: 'background',
    FOREGROUND: 'foreground',
    SUSPENDED: 'suspended',
    UNLOADING: 'unloading'
  },


  CloseReason: {
    REMOTE_BUTTON: 'remoteButton',
    USER_EXIT: 'userExit',
    ERROR: 'error'
  },


  state,
  finished,

ready: Lifecycle_ready,
  close: Lifecycle_close,
  listen: Lifecycle_listen,
  once: Lifecycle_once,
  clear: Lifecycle_clear  
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Localization/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Localization', Object.values(["languageChanged"]))



function locality() {
  return Transport.send('localization', 'locality', {  })
}

function postalCode() {
  return Transport.send('localization', 'postalCode', {  })
}

function countryCode() {
  return Transport.send('localization', 'countryCode', {  })
}
function language() {
  return Prop.prop('localization',  'language', arguments, false, true)
}

function locale() {
  return Transport.send('localization', 'locale', {  })
}

function latlon() {
  return Transport.send('localization', 'latlon', {  })
}

function additionalInfo() {
  return Transport.send('localization', 'additionalInfo', {  })
}

function Localization_listen(...args) {
  return Events.listen('localization', ...args)
} 

function Localization_once(...args) {
  return Events.once('localization', ...args)
}

function Localization_clear(...args) {
  return Events.clear('localization', ...args)
}

/* harmony default export */ const Localization = ({

  events: {
    languageChanged:'languageChanged'
  },
locality,
  postalCode,
  countryCode,
  language,
  locale,
  latlon,
  additionalInfo,
  listen: Localization_listen,
  once: Localization_once,
  clear: Localization_clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Parameters/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function initialization() {
  return Transport.send('parameters', 'initialization', {  })
}

/* harmony default export */ const Parameters = ({

initialization
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Profile/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function approveContentRating() {
  return Transport.send('profile', 'approveContentRating', {  })
}

function approvePurchase() {
  return Transport.send('profile', 'approvePurchase', {  })
}

function flags() {
  return Transport.send('profile', 'flags', {  })
}

/* harmony default export */ const Profile = ({

approveContentRating,
  approvePurchase,
  flags
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/SecondScreen/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('SecondScreen', Object.values(["launchRequest","closeRequest","friendlyNameChanged"]))



function protocols() {
  return Transport.send('secondscreen', 'protocols', {  })
}

function device(type) {
  return Transport.send('secondscreen', 'device', { type })
}
function friendlyName() {
  return Prop.prop('secondscreen',  'friendlyName', arguments, false, true)
}

function SecondScreen_listen(...args) {
  return Events.listen('secondscreen', ...args)
} 

function SecondScreen_once(...args) {
  return Events.once('secondscreen', ...args)
}

function SecondScreen_clear(...args) {
  return Events.clear('secondscreen', ...args)
}

/* harmony default export */ const SecondScreen = ({

  events: {
    launchRequest:'launchRequest',
    closeRequest:'closeRequest',
    friendlyNameChanged:'friendlyNameChanged'
  },
protocols,
  device,
  friendlyName,
  listen: SecondScreen_listen,
  once: SecondScreen_once,
  clear: SecondScreen_clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Platform/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






// public API
/* harmony default export */ const Platform = ({
  Localization: Localization,
  Device: Device,
  Accessibility: Accessibility,
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Log/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */



const prepLog = (type, args) => {
  const colors = {
    Info: 'green',
    Debug: 'gray',
    Warn: 'orange',
    Error: 'red',
  }

  args = Array.from(args)
  return [
    '%c' + (args.length > 1 && typeof args[0] === 'string' ? args.shift() : type),
    'background-color: ' + colors[type] + '; color: white; padding: 2px 4px; border-radius: 2px',
    args,
  ]
}

/* harmony default export */ const Log = ({
  info() {
    Settings.get('platform', 'log') && console.log.apply(console, prepLog('Info', arguments))
  },
  debug() {
    Settings.get('platform', 'log') && console.debug.apply(console, prepLog('Debug', arguments))
  },
  error() {
    Settings.get('platform', 'log') && console.error.apply(console, prepLog('Error', arguments))
  },
  warn() {
    Settings.get('platform', 'log') && console.warn.apply(console, prepLog('Warn', arguments))
  },
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */



















var __webpack_exports__Accessibility = __webpack_exports__.yq;
var __webpack_exports__Account = __webpack_exports__.mR;
var __webpack_exports__Advertising = __webpack_exports__.ZL;
var __webpack_exports__Authentication = __webpack_exports__.Vy;
var __webpack_exports__Device = __webpack_exports__.AS;
var __webpack_exports__Discovery = __webpack_exports__.PG;
var __webpack_exports__Events = __webpack_exports__.zW;
var __webpack_exports__Keyboard = __webpack_exports__.N1;
var __webpack_exports__Lifecycle = __webpack_exports__.Fw;
var __webpack_exports__Localization = __webpack_exports__.WH;
var __webpack_exports__Log = __webpack_exports__.Zb;
var __webpack_exports__Metrics = __webpack_exports__.C3;
var __webpack_exports__Parameters = __webpack_exports__.aE;
var __webpack_exports__Platform = __webpack_exports__.t4;
var __webpack_exports__Profile = __webpack_exports__.NZ;
var __webpack_exports__SecondScreen = __webpack_exports__._F;
var __webpack_exports__Settings = __webpack_exports__.Zr;


//# sourceMappingURL=firebolt.js.map

/***/ }),

/***/ "./node_modules/@lightningjs/core/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@lightningjs/core/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_lightning_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/lightning.mjs */ "./node_modules/@lightningjs/core/src/lightning.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_src_lightning_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/index.js":
/*!************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ads": () => (/* reexport safe */ _src_Ads__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "AppData": () => (/* reexport safe */ _src_Application__WEBPACK_IMPORTED_MODULE_1__.AppData),
/* harmony export */   "Application": () => (/* reexport safe */ _src_Application__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "AudioPlayer": () => (/* reexport safe */ _src_AudioPlayer__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "Colors": () => (/* reexport safe */ _src_Colors__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "Img": () => (/* reexport safe */ _src_Img__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "Keyboard": () => (/* reexport safe */ _src_Keyboard__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "Language": () => (/* reexport safe */ _src_Language__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "Launch": () => (/* reexport safe */ _src_Launch__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "Lightning": () => (/* reexport safe */ _src_Lightning__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "Locale": () => (/* reexport safe */ _src_Locale__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "Log": () => (/* reexport safe */ _src_Log__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "MediaPlayer": () => (/* reexport safe */ _src_MediaPlayer__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "Metadata": () => (/* reexport safe */ _src_Metadata__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   "Metrics": () => (/* reexport safe */ _src_Metrics__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   "Pin": () => (/* reexport safe */ _src_Pin__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   "Profile": () => (/* reexport safe */ _src_Profile__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   "Purchase": () => (/* reexport safe */ _src_Purchase__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   "Registry": () => (/* reexport safe */ _src_Registry__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   "Router": () => (/* reexport safe */ _src_Router__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   "Settings": () => (/* reexport safe */ _src_Settings__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   "Storage": () => (/* reexport safe */ _src_Storage__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   "TV": () => (/* reexport safe */ _src_TV__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   "Utils": () => (/* reexport safe */ _src_Utils__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   "VideoPlayer": () => (/* reexport safe */ _src_VideoPlayer__WEBPACK_IMPORTED_MODULE_22__["default"])
/* harmony export */ });
/* harmony import */ var _src_Ads__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/Ads */ "./node_modules/@lightningjs/sdk/src/Ads/index.js");
/* harmony import */ var _src_Application__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/Application */ "./node_modules/@lightningjs/sdk/src/Application/index.js");
/* harmony import */ var _src_AudioPlayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/AudioPlayer */ "./node_modules/@lightningjs/sdk/src/AudioPlayer/index.js");
/* harmony import */ var _src_Colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/Colors */ "./node_modules/@lightningjs/sdk/src/Colors/index.js");
/* harmony import */ var _src_Img__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/Img */ "./node_modules/@lightningjs/sdk/src/Img/index.js");
/* harmony import */ var _src_Keyboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/Keyboard */ "./node_modules/@lightningjs/sdk/src/Keyboard/index.js");
/* harmony import */ var _src_Launch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/Launch */ "./node_modules/@lightningjs/sdk/src/Launch/index.js");
/* harmony import */ var _src_Lightning__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _src_Locale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/Locale */ "./node_modules/@lightningjs/sdk/src/Locale/index.js");
/* harmony import */ var _src_Language__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/Language */ "./node_modules/@lightningjs/sdk/src/Language/index.js");
/* harmony import */ var _src_Log__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _src_MediaPlayer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/MediaPlayer */ "./node_modules/@lightningjs/sdk/src/MediaPlayer/index.js");
/* harmony import */ var _src_Metrics__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _src_Pin__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/Pin */ "./node_modules/@lightningjs/sdk/src/Pin/index.js");
/* harmony import */ var _src_Profile__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/Profile */ "./node_modules/@lightningjs/sdk/src/Profile/index.js");
/* harmony import */ var _src_Purchase__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/Purchase */ "./node_modules/@lightningjs/sdk/src/Purchase/index.js");
/* harmony import */ var _src_Registry__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/Registry */ "./node_modules/@lightningjs/sdk/src/Registry/index.js");
/* harmony import */ var _src_Router__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/Router */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _src_Settings__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _src_Storage__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/Storage */ "./node_modules/@lightningjs/sdk/src/Storage/index.js");
/* harmony import */ var _src_TV__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/TV */ "./node_modules/@lightningjs/sdk/src/TV/index.js");
/* harmony import */ var _src_Utils__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/* harmony import */ var _src_VideoPlayer__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/VideoPlayer */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js");
/* harmony import */ var _src_Metadata__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/Metadata */ "./node_modules/@lightningjs/sdk/src/Metadata/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




























/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Ads/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Ads/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initAds": () => (/* binding */ initAds)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _VideoPlayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VideoPlayer */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let consumer

let getAds = () => {
  // todo: enable some default ads during development, maybe from the settings.json
  return Promise.resolve({
    prerolls: [],
    midrolls: [],
    postrolls: [],
  })
}

const initAds = config => {
  if (config.getAds) {
    getAds = config.getAds
  }
}

const state = {
  active: false,
}

const playSlot = (slot = []) => {
  return slot.reduce((promise, ad) => {
    return promise.then(() => {
      return playAd(ad)
    })
  }, Promise.resolve(null))
}

const playAd = ad => {
  return new Promise(resolve => {
    if (state.active === false) {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Skipping add due to inactive state')
      return resolve()
    }
    // is it safe to rely on videoplayer plugin already created the video tag?
    const videoEl = document.getElementsByTagName('video')[0]
    videoEl.style.display = 'block'
    videoEl.style.visibility = 'visible'
    videoEl.src = (0,_VideoPlayer__WEBPACK_IMPORTED_MODULE_1__.mediaUrl)(ad.url)
    videoEl.load()

    let timeEvents = null
    let timeout

    const cleanup = () => {
      // remove all listeners
      Object.keys(handlers).forEach(handler =>
        videoEl.removeEventListener(handler, handlers[handler])
      )
      resolve()
    }
    const handlers = {
      play() {
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Play ad', ad.url)
        fireOnConsumer('Play', ad)
        sendBeacon(ad.callbacks, 'defaultImpression')
      },
      ended() {
        fireOnConsumer('Ended', ad)
        sendBeacon(ad.callbacks, 'complete')
        cleanup()
      },
      timeupdate() {
        if (!timeEvents && videoEl.duration) {
          // calculate when to fire the time based events (now that duration is known)
          timeEvents = {
            firstQuartile: videoEl.duration / 4,
            midPoint: videoEl.duration / 2,
            thirdQuartile: (videoEl.duration / 4) * 3,
          }
          _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Calculated quartiles times', { timeEvents })
        }
        if (
          timeEvents &&
          timeEvents.firstQuartile &&
          videoEl.currentTime >= timeEvents.firstQuartile
        ) {
          fireOnConsumer('FirstQuartile', ad)
          delete timeEvents.firstQuartile
          sendBeacon(ad.callbacks, 'firstQuartile')
        }
        if (timeEvents && timeEvents.midPoint && videoEl.currentTime >= timeEvents.midPoint) {
          fireOnConsumer('MidPoint', ad)
          delete timeEvents.midPoint
          sendBeacon(ad.callbacks, 'midPoint')
        }
        if (
          timeEvents &&
          timeEvents.thirdQuartile &&
          videoEl.currentTime >= timeEvents.thirdQuartile
        ) {
          fireOnConsumer('ThirdQuartile', ad)
          delete timeEvents.thirdQuartile
          sendBeacon(ad.callbacks, 'thirdQuartile')
        }
      },
      stalled() {
        fireOnConsumer('Stalled', ad)
        timeout = setTimeout(() => {
          cleanup()
        }, 5000) // make timeout configurable
      },
      canplay() {
        timeout && clearTimeout(timeout)
      },
      error() {
        fireOnConsumer('Error', ad)
        cleanup()
      },
      // this doesn't work reliably on sky box, moved logic to timeUpdate event
      // loadedmetadata() {
      //   // calculate when to fire the time based events (now that duration is known)
      //   timeEvents = {
      //     firstQuartile: videoEl.duration / 4,
      //     midPoint: videoEl.duration / 2,
      //     thirdQuartile: (videoEl.duration / 4) * 3,
      //   }
      // },
      abort() {
        cleanup()
      },
      // todo: pause, resume, mute, unmute beacons
    }
    // add all listeners
    Object.keys(handlers).forEach(handler => videoEl.addEventListener(handler, handlers[handler]))

    videoEl.play()
  })
}

const sendBeacon = (callbacks, event) => {
  if (callbacks && callbacks[event]) {
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Sending beacon', event, callbacks[event])
    return callbacks[event].reduce((promise, url) => {
      return promise.then(() =>
        fetch(url)
          // always resolve, also in case of a fetch error (so we don't block firing the rest of the beacons for this event)
          // note: for fetch failed http responses don't throw an Error :)
          .then(response => {
            if (response.status === 200) {
              fireOnConsumer('Beacon' + event + 'Sent')
            } else {
              fireOnConsumer('Beacon' + event + 'Failed' + response.status)
            }
            Promise.resolve(null)
          })
          .catch(() => {
            Promise.resolve(null)
          })
      )
    }, Promise.resolve(null))
  } else {
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'No callback found for ' + event)
  }
}

const fireOnConsumer = (event, args) => {
  if (consumer) {
    consumer.fire('$ad' + event, args)
    consumer.fire('$adEvent', event, args)
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  get(config, videoPlayerConsumer) {
    if (config.enabled === false) {
      return Promise.resolve({
        prerolls() {
          return Promise.resolve()
        },
      })
    }
    consumer = videoPlayerConsumer

    return new Promise(resolve => {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Starting session')
      getAds(config).then(ads => {
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'API result', ads)
        resolve({
          prerolls() {
            if (ads.preroll) {
              state.active = true
              fireOnConsumer('PrerollSlotImpression', ads)
              sendBeacon(ads.preroll.callbacks, 'slotImpression')
              return playSlot(ads.preroll.ads).then(() => {
                fireOnConsumer('PrerollSlotEnd', ads)
                sendBeacon(ads.preroll.callbacks, 'slotEnd')
                state.active = false
              })
            }
            return Promise.resolve()
          },
          midrolls() {
            return Promise.resolve()
          },
          postrolls() {
            return Promise.resolve()
          },
        })
      })
    })
  },
  cancel() {
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Cancel Ad')
    state.active = false
  },
  stop() {
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Stop Ad')
    state.active = false
    // fixme: duplication
    const videoEl = document.getElementsByTagName('video')[0]
    videoEl.pause()
    videoEl.removeAttribute('src')
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Application/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Application/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppData": () => (/* binding */ AppData),
/* harmony export */   "AppInstance": () => (/* binding */ AppInstance),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepmerge */ "./node_modules/deepmerge/dist/cjs.js");
/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Locale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Locale */ "./node_modules/@lightningjs/sdk/src/Locale/index.js");
/* harmony import */ var _Metrics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _VersionLabel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VersionLabel */ "./node_modules/@lightningjs/sdk/src/VersionLabel/index.js");
/* harmony import */ var _FpsCounter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../FpsCounter */ "./node_modules/@lightningjs/sdk/src/FpsCounter/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _Language__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Language */ "./node_modules/@lightningjs/sdk/src/Language/index.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/* harmony import */ var _Registry__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Registry */ "./node_modules/@lightningjs/sdk/src/Registry/index.js");
/* harmony import */ var _Colors__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../Colors */ "./node_modules/@lightningjs/sdk/src/Colors/index.js");
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../package.json */ "./node_modules/@lightningjs/sdk/package.json");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















let AppInstance
let AppData

const defaultOptions = {
  stage: { w: 1920, h: 1080, clearColor: 0x00000000, canvas2d: false },
  debug: false,
  defaultFontFace: 'RobotoRegular',
  keys: {
    8: 'Back',
    13: 'Enter',
    27: 'Menu',
    37: 'Left',
    38: 'Up',
    39: 'Right',
    40: 'Down',
    174: 'ChannelDown',
    175: 'ChannelUp',
    178: 'Stop',
    250: 'PlayPause',
    191: 'Search', // Use "/" for keyboard
    409: 'Search',
  },
}

const customFontFaces = []

const fontLoader = (fonts, store) =>
  new Promise((resolve, reject) => {
    fonts
      .map(({ family, url, urls, descriptors }) => () => {
        const src = urls
          ? urls.map(url => {
              return 'url(' + url + ')'
            })
          : 'url(' + url + ')'
        const fontFace = new FontFace(family, src, descriptors || {})
        store.push(fontFace)
        _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('Loading font', family)
        document.fonts.add(fontFace)
        return fontFace.load()
      })
      .reduce((promise, method) => {
        return promise.then(() => method())
      }, Promise.resolve(null))
      .then(resolve)
      .catch(reject)
  })

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(App, appData, platformSettings) {
  const { width, height } = platformSettings

  if (width && height) {
    defaultOptions.stage['w'] = width
    defaultOptions.stage['h'] = height
    defaultOptions.stage['precision'] = width / 1920
  }

  // support for 720p browser
  if (!width && !height && window.innerHeight === 720) {
    defaultOptions.stage['w'] = 1280
    defaultOptions.stage['h'] = 720
    defaultOptions.stage['precision'] = 1280 / 1920
  }

  return class Application extends _Lightning__WEBPACK_IMPORTED_MODULE_1__["default"].Application {
    constructor(options) {
      const config = deepmerge__WEBPACK_IMPORTED_MODULE_0___default()(defaultOptions, options)
      // Deepmerge breaks HTMLCanvasElement, so restore the passed in canvas.
      if (options.stage.canvas) {
        config.stage.canvas = options.stage.canvas
      }
      super(config)
      this.config = config
    }

    static _template() {
      return {
        w: 1920,
        h: 1080,
      }
    }

    _setup() {
      Promise.all([
        this.loadFonts((App.config && App.config.fonts) || (App.getFonts && App.getFonts()) || []),
        // to be deprecated
        _Locale__WEBPACK_IMPORTED_MODULE_2__["default"].load((App.config && App.config.locale) || (App.getLocale && App.getLocale())),
        App.language && this.loadLanguage(App.language()),
        App.colors && this.loadColors(App.colors()),
      ])
        .then(() => {
          _Metrics__WEBPACK_IMPORTED_MODULE_3__["default"].app.loaded()

          AppData = appData

          AppInstance = this.stage.c({
            ref: 'App',
            type: App,
            zIndex: 1,
            forceZIndexContext: !!platformSettings.showVersion || !!platformSettings.showFps,
          })

          this.childList.a(AppInstance)

          this._refocus()

          _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('App version', this.config.version)
          _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('SDK version', _package_json__WEBPACK_IMPORTED_MODULE_12__.version)

          if (platformSettings.showVersion) {
            this.childList.a({
              ref: 'VersionLabel',
              type: _VersionLabel__WEBPACK_IMPORTED_MODULE_4__["default"],
              version: this.config.version,
              sdkVersion: _package_json__WEBPACK_IMPORTED_MODULE_12__.version,
              zIndex: 1,
            })
          }

          if (platformSettings.showFps) {
            this.childList.a({
              ref: 'FpsCounter',
              type: _FpsCounter__WEBPACK_IMPORTED_MODULE_5__["default"],
              zIndex: 1,
            })
          }

          super._setup()
        })
        .catch(console.error)
    }

    _handleBack() {
      this.closeApp()
    }

    _handleExit() {
      this.closeApp()
    }

    closeApp() {
      _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('Signaling App Close')

      if (platformSettings.onClose && typeof platformSettings.onClose === 'function') {
        platformSettings.onClose(...arguments)
      } else {
        this.close()
      }
    }

    close() {
      _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('Closing App')

      _Settings__WEBPACK_IMPORTED_MODULE_7__["default"].clearSubscribers()
      _Registry__WEBPACK_IMPORTED_MODULE_10__["default"].clear()

      this.childList.remove(this.tag('App'))
      this.cleanupFonts()
      // force texture garbage collect
      this.stage.gc()
      this.destroy()
    }

    loadFonts(fonts) {
      return platformSettings.fontLoader && typeof platformSettings.fontLoader === 'function'
        ? platformSettings.fontLoader(fonts, customFontFaces)
        : fontLoader(fonts, customFontFaces)
    }

    cleanupFonts() {
      if ('delete' in document.fonts) {
        customFontFaces.forEach(fontFace => {
          _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('Removing font', fontFace.family)
          document.fonts.delete(fontFace)
        })
      } else {
        _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('No support for removing manually-added fonts')
      }
    }

    loadLanguage(config) {
      let file = _Utils__WEBPACK_IMPORTED_MODULE_9__["default"].asset('translations.json')
      let language = config

      if (typeof language === 'object') {
        language = config.language || null
        file = config.file || file
      }

      return (0,_Language__WEBPACK_IMPORTED_MODULE_8__.initLanguage)(file, language)
    }

    loadColors(config) {
      let file = _Utils__WEBPACK_IMPORTED_MODULE_9__["default"].asset('colors.json')
      if (config && (typeof config === 'string' || typeof config === 'object')) {
        file = config
      }
      return (0,_Colors__WEBPACK_IMPORTED_MODULE_11__.initColors)(file)
    }

    set focus(v) {
      this._focussed = v
      this._refocus()
    }

    _getFocused() {
      return this._focussed || this.tag('App')
    }
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/AudioPlayer/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/AudioPlayer/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioPlayer)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class AudioPlayer {}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Colors/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Colors/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initColors": () => (/* binding */ initColors)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@lightningjs/sdk/src/Colors/utils.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let colors = {
  white: '#ffffff',
  black: '#000000',
  red: '#ff0000',
  green: '#00ff00',
  blue: '#0000ff',
  yellow: '#feff00',
  cyan: '#00feff',
  magenta: '#ff00ff',
}

const normalizedColors = {
  //store for normalized colors
}

const addColors = (colorsToAdd, value) => {
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(colorsToAdd)) {
    // clean up normalizedColors if they exist in the to be added colors
    Object.keys(colorsToAdd).forEach(color => cleanUpNormalizedColors(color))
    colors = Object.assign({}, colors, colorsToAdd)
  } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(colorsToAdd) && value) {
    cleanUpNormalizedColors(colorsToAdd)
    colors[colorsToAdd] = value
  }
}

const cleanUpNormalizedColors = color => {
  for (let c in normalizedColors) {
    if (c.indexOf(color) > -1) {
      delete normalizedColors[c]
    }
  }
}

const initColors = file => {
  return new Promise((resolve, reject) => {
    if (typeof file === 'object') {
      addColors(file)
      resolve()
    }
    fetch(file)
      .then(response => response.json())
      .then(json => {
        addColors(json)
        resolve()
      })
      .catch(() => {
        const error = 'Colors file ' + file + ' not found'
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error)
        reject(error)
      })
  })
}

const normalizeColorToARGB = color => {
  let targetColor = normalizedColors[color] || colors[color] || color
  if (!targetColor) {
    targetColor = color
  }
  const check = /^#([0-9A-F]{3}|[0-9A-F]{6})$/i
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(targetColor) && check.test(targetColor)) {
    let hex = check.exec(targetColor)[1]
    if (hex.length === 3) {
      hex = hex
        .split('')
        .map(value => {
          return value + value
        })
        .join('')
    }
    targetColor = `0xff${hex}` * 1
  }
  if (!normalizedColors[color]) {
    normalizedColors[color] = targetColor
  }
  return targetColor || 0xffffffff
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (color => {
  return Color.generate(color)
});

const Color = {
  color: null,
  generate: function(value = this.color) {
    if (normalizedColors[value]) {
      this.color = normalizedColors[value]
    } else {
      this.color = normalizeColorToARGB(value)
    }
    return this
  },
  get() {
    return this.color
  },
  alpha: function(percentage) {
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateAlpha)(this.color, Math.abs(percentage))
    return this
  },
  darker(percentage) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.l = hsl.l * (1 - percentage)
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  lighter(percentage) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.l = hsl.l + (1 - hsl.l) * percentage
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  saturation(percentage) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.s = percentage
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  lightness(percentage) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.l = percentage
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  hue(degrees) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.h = degrees
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  mix(argb, p) {
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeColors)(this.color, argb, p)
    return this
  },
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Colors/utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Colors/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "argbToHSLA": () => (/* binding */ argbToHSLA),
/* harmony export */   "argbToHsva": () => (/* binding */ argbToHsva),
/* harmony export */   "calculateAlpha": () => (/* binding */ calculateAlpha),
/* harmony export */   "getRgbaComponents": () => (/* binding */ getRgbaComponents),
/* harmony export */   "hslaToARGB": () => (/* binding */ hslaToARGB),
/* harmony export */   "hsvaToArgb": () => (/* binding */ hsvaToArgb),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "limitWithinRange": () => (/* binding */ limitWithinRange),
/* harmony export */   "mergeColorAlpha": () => (/* binding */ mergeColorAlpha),
/* harmony export */   "mergeColors": () => (/* binding */ mergeColors)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const isObject = v => {
  return typeof v === 'object' && v !== null
}

const isString = v => {
  return typeof v === 'string'
}

const getRgbaComponents = argb => {
  return {
    r: ((argb / 65536) | 0) % 256,
    g: ((argb / 256) | 0) % 256,
    b: (argb * 1) % 256,
    a: (argb / 16777216) | 0,
  }
}

const limitWithinRange = (num, min, max) => {
  return Math.min(Math.max(num, min), max)
}

const mergeColors = (c1, c2, p) => {
  let r1 = ((c1 / 65536) | 0) % 256
  let g1 = ((c1 / 256) | 0) % 256
  let b1 = c1 % 256
  let a1 = (c1 / 16777216) | 0
  let r2 = ((c2 / 65536) | 0) % 256
  let g2 = ((c2 / 256) | 0) % 256
  let b2 = c2 % 256
  let a2 = (c2 / 16777216) | 0
  let r = r1 * p + r2 * (1 - p)
  let g = g1 * p + g2 * (1 - p)
  let b = b1 * p + b2 * (1 - p)
  let a = a1 * p + a2 * (1 - p)
  return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b)
}

const calculateAlpha = (argb, p) => {
  if (p > 1) {
    p /= 100
  } else if (p < 0) {
    p = 0
  }
  let r = ((argb / 65536) | 0) % 256
  let g = ((argb / 256) | 0) % 256
  let b = argb % 256
  return (r << 16) + (g << 8) + b + ((p * 255) | 0) * 16777216
}

const mergeColorAlpha = (c, alpha) => {
  let a = (((c / 16777216) | 0) * alpha) | 0
  return (
    (((((c >> 16) & 0xff) * a) / 255) & 0xff) +
    ((((c & 0xff00) * a) / 255) & 0xff00) +
    (((((c & 0xff) << 16) * a) / 255) & 0xff0000) +
    (a << 24)
  )
}

const getArgbNumber = rgba => {
  rgba[0] = Math.max(0, Math.min(255, rgba[0]))
  rgba[1] = Math.max(0, Math.min(255, rgba[1]))
  rgba[2] = Math.max(0, Math.min(255, rgba[2]))
  rgba[3] = Math.max(0, Math.min(255, rgba[3]))
  let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0)
  if (v < 0) {
    v = 0xffffffff + v + 1
  }
  return v
}

const argbToHsva = argb => {
  const color = getRgbaComponents(argb)
  let r = color.r / 255
  let g = color.g / 255
  let b = color.b / 255
  let h = 0
  let s = 0

  const cMax = Math.max(r, g, b)
  const cMin = Math.min(r, g, b)
  const delta = cMax - cMin

  //calculate hue
  if (delta < 0.00001) {
    h = 0
  } else if (cMax !== 0 || cMin !== 0) {
    if (r === cMax) {
      h = (60 * ((g - b) / delta) + 360) % 360
    } else if (g === cMax) {
      h = (60 * ((b - r) / delta) + 120) % 360
    } else if (b === cMax) {
      h = (60 * ((r - g) / delta) + 240) % 360
    }
  }

  //calc saturation
  if (cMax > 0) {
    s = delta / cMax
  }
  return {
    h,
    s,
    v: cMax,
    a: color.a / 255,
  }
}

const hsvaToArgb = color => {
  const h = color.h
  const c = color.v * color.s
  const m = color.v - c
  const x = c * (1.0 - Math.abs(((h / 60) % 2) - 1))
  let r = 0
  let g = 0
  let b = 0

  if (0 <= h && h < 60) {
    r = c
    g = x
  } else if (60 <= h && h < 120) {
    r = x
    g = c
  } else if (120 <= h && h < 180) {
    g = c
    b = x
  } else if (180 <= h && h < 240) {
    g = x
    b = c
  } else if (240 <= h && h < 300) {
    r = x
    b = c
  } else if (300 <= h && h < 360) {
    r = c
    b = x
  }

  r = Math.round((r + m) * 255.0)
  g = Math.round((g + m) * 255.0)
  b = Math.round((b + m) * 255.0)
  return getArgbNumber([r, g, b, color.a * 255])
}

const argbToHSLA = argb => {
  const col = getRgbaComponents(argb)
  const r = col.r / 255
  const g = col.g / 255
  const b = col.b / 255

  const max = Math.max(r, g, b)
  const min = Math.min(r, g, b)

  let h = 0
  let s = 0
  const l = (min + max) * 0.5
  if (l > 0) {
    const maxMin = max - min
    if (maxMin > 0) {
      const r2 = (max - r) / maxMin
      const g2 = (max - g) / maxMin
      const b2 = (max - b) / maxMin
      if (l < 0.5) {
        s = max + min
      } else {
        s = 2 - max - min
      }

      if (r === max && g === min) {
        h = 5.0 + b2
      } else if (r === max) {
        h = 1.0 - g2
      } else if (g === max && b === min) {
        h = 1.0 + r2
      } else if (g === max) {
        h = 3.0 - b2
      } else if (b === max) {
        h = 3.0 + g2
      } else {
        h = 5.0 - r2
      }
      h = h / 6
    }
  }
  return { h: h % 1, s, l, a: col.a }
}

const hslaToARGB = hsla => {
  let r = 1
  let g = 1
  let b = 1

  let h = hsla.h
  let s = hsla.s
  let l = hsla.l

  if (h < 0) {
    h += 1
  }
  let max = 0
  if (l <= 0.5) {
    max = l * (1.0 + s)
  } else {
    max = l + s - l * s
  }

  if (max > 0) {
    h *= 6.0
    const min = l + l - max
    const minMax = (max - min) / max
    const sextant = Math.floor(h)
    const fract = h - sextant
    const minMaxFract = max * minMax * fract
    const mid1 = min + minMaxFract
    const mid2 = max - minMaxFract

    if (sextant === 0) {
      r = max
      g = mid1
      b = min
    }
    if (sextant === 1) {
      r = mid2
      g = max
      b = min
    }
    if (sextant === 2) {
      r = min
      g = max
      b = mid1
    }
    if (sextant === 3) {
      r = min
      g = mid2
      b = max
    }
    if (sextant === 4) {
      r = mid1
      g = min
      b = max
    }
    if (sextant === 5) {
      r = max
      g = min
      b = mid2
    }
  }
  return getArgbNumber([Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255), hsla.a])
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/FpsCounter/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/FpsCounter/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FpsIndicator)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class FpsIndicator extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      rect: true,
      color: 0xffffffff,
      texture: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Tools.getRoundRect(80, 80, 40),
      h: 80,
      w: 80,
      x: 100,
      y: 100,
      mount: 1,
      Background: {
        x: 3,
        y: 3,
        texture: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Tools.getRoundRect(72, 72, 36),
        color: 0xff008000,
      },
      Counter: {
        w: w => w,
        h: h => h,
        y: 10,
        text: {
          fontSize: 32,
          textAlign: 'center',
        },
      },
      Text: {
        w: w => w,
        h: h => h,
        y: 48,
        text: {
          fontSize: 15,
          textAlign: 'center',
          text: 'FPS',
        },
      },
    }
  }

  _setup() {
    this.config = {
      ...{
        log: false,
        interval: 500,
        threshold: 1,
      },
      ..._Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', 'showFps'),
    }

    this.fps = 0
    this.lastFps = this.fps - this.config.threshold

    const fpsCalculator = () => {
      this.fps = ~~(1 / this.stage.dt)
    }
    this.stage.on('frameStart', fpsCalculator)
    this.stage.off('framestart', fpsCalculator)
    this.interval = setInterval(this.showFps.bind(this), this.config.interval)
  }

  _firstActive() {
    this.showFps()
  }

  _detach() {
    clearInterval(this.interval)
  }

  showFps() {
    if (Math.abs(this.lastFps - this.fps) <= this.config.threshold) return
    this.lastFps = this.fps
    // green
    let bgColor = 0xff008000
    // orange
    if (this.fps <= 40 && this.fps > 20) bgColor = 0xffffa500
    // red
    else if (this.fps <= 20) bgColor = 0xffff0000

    this.tag('Background').setSmooth('color', bgColor)
    this.tag('Counter').text = `${this.fps}`

    this.config.log && _Log__WEBPACK_IMPORTED_MODULE_2__["default"].info('FPS', this.fps)
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Img/ScaledImageTexture.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Img/ScaledImageTexture.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ScaledImageTexture)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ScaledImageTexture extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].textures.ImageTexture {
  constructor(stage) {
    super(stage)
    this._scalingOptions = undefined
  }

  set options(options) {
    this.resizeMode = this._scalingOptions = options
  }

  _getLookupId() {
    return `${this._src}-${this._scalingOptions.type}-${this._scalingOptions.w}-${this._scalingOptions.h}`
  }

  getNonDefaults() {
    const obj = super.getNonDefaults()
    if (this._src) {
      obj.src = this._src
    }
    return obj
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Img/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Img/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _ScaledImageTexture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ScaledImageTexture */ "./node_modules/@lightningjs/sdk/src/Img/ScaledImageTexture.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((imageUrl, options) => {
  const imageServerUrl = _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', 'imageServerUrl')

  // make and return ScaledImageTexture
  const make = options => {
    // local asset, wrap it in Utils.asset()
    if (!/^(?:https?:)?\/\//i.test(imageUrl)) {
      imageUrl = _Utils__WEBPACK_IMPORTED_MODULE_0__["default"].asset(imageUrl)
    }

    // only pass to image server if imageServerUrl is configured
    // and if the asset isn't local to the app (i.e. has same origin)
    if (imageServerUrl && imageUrl.indexOf(window.location.origin) === -1) {
      imageUrl = _Utils__WEBPACK_IMPORTED_MODULE_0__["default"].ensureUrlWithProtocol(
        imageServerUrl + '?' + _Utils__WEBPACK_IMPORTED_MODULE_0__["default"].makeQueryString(imageUrl, options)
      )
    } else {
      // Lightning will handle the resizing and has only 2 flavours (cover and contain)
      if (options.type === 'crop') options.type = 'cover'
      else options.type = 'contain'
    }

    return {
      type: _ScaledImageTexture__WEBPACK_IMPORTED_MODULE_2__["default"],
      src: imageUrl,
      options: options,
    }
  }

  // merge options with default
  const setOptions = options => {
    options = {
      ...{
        type: 'contain',
        w: 0,
        h: 0,
      },
      ...options,
    }
    const imageQuality = Math.max(
      0.1,
      Math.min(1, (parseFloat(_Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', 'image.quality')) || 100) / 100)
    )

    options.w = options.w * imageQuality
    options.h = options.h * imageQuality
    return options
  }

  // if options are passed, return scaled image right away
  if (options) {
    return make(setOptions(options))
  }

  // otherwise return 'chained' functions
  return {
    // official api
    exact: (w, h) => make(setOptions({ type: 'exact', w, h })),
    landscape: w => make(setOptions({ type: 'landscape', w })),
    portrait: h => make(setOptions({ type: 'portrait', h })),
    cover: (w, h) => make(setOptions({ type: 'cover', w, h })),
    contain: (w, h) => make(setOptions({ type: 'contain', w, h })),
    original: () => make(setOptions({ type: 'contain' })),

    // todo: add positioning - i.e. top, bottom, center, left etc.
  }
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Keyboard/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Keyboard/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Language/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Language/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initLanguage": () => (/* binding */ initLanguage)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let meta = {}
let translations = {}
let language = null
let dictionary = null

const initLanguage = (file, language = null) => {
  return new Promise((resolve, reject) => {
    fetch(file)
      .then(response => response.json())
      .then(json => {
        setTranslations(json)
        // set language (directly or in a promise)
        typeof language === 'object' && 'then' in language && typeof language.then === 'function'
          ? language
              .then(lang =>
                setLanguage(lang)
                  .then(resolve)
                  .catch(reject)
              )
              .catch(e => {
                _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(e)
                reject(e)
              })
          : setLanguage(language)
              .then(resolve)
              .catch(reject)
      })
      .catch(() => {
        const error = 'Language file ' + file + ' not found'
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error)
        reject(error)
      })
  })
}

const setTranslations = obj => {
  if ('meta' in obj) {
    meta = { ...obj.meta }
    delete obj.meta
  }
  translations = obj
}

const getLanguage = () => {
  return language
}

const setLanguage = lng => {
  language = null
  dictionary = null

  return new Promise((resolve, reject) => {
    if (lng in translations) {
      language = lng
    } else {
      if ('map' in meta && lng in meta.map && meta.map[lng] in translations) {
        language = meta.map[lng]
      } else if ('default' in meta && meta.default in translations) {
        const error =
          'Translations for Language ' +
          language +
          ' not found. Using default language ' +
          meta.default
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].warn(error)
        language = meta.default
      } else {
        const error = 'Translations for Language ' + language + ' not found.'
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error)
        reject(error)
      }
    }

    if (language) {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Setting language to', language)

      const translationsObj = translations[language]
      if (typeof translationsObj === 'object') {
        dictionary = translationsObj
        resolve()
      } else if (typeof translationsObj === 'string') {
        const url = _Utils__WEBPACK_IMPORTED_MODULE_1__["default"].asset(translationsObj)

        fetch(url)
          .then(response => response.json())
          .then(json => {
            // save the translations for this language (to prevent loading twice)
            translations[language] = json
            dictionary = json
            resolve()
          })
          .catch(e => {
            const error = 'Error while fetching ' + url
            _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error, e)
            reject(error)
          })
      }
    }
  })
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  translate(key) {
    let replacements = [...arguments].slice(1)

    // no replacements so just translated string
    if (replacements.length === 0) {
      return (dictionary && dictionary[key]) || key
    } else {
      if (replacements.length === 1 && typeof replacements[0] === 'object') {
        replacements = replacements.pop()
      }

      return Object.keys(
        // maps array input to an object {0: 'item1', 1: 'item2'}
        Array.isArray(replacements) ? Object.assign({}, replacements) : replacements
      ).reduce((text, replacementKey) => {
        return text.replace(
          new RegExp('{\\s?' + replacementKey + '\\s?}', 'g'),
          replacements[replacementKey]
        )
      }, (dictionary && dictionary[key]) || key)
    }
  },

  translations(obj) {
    setTranslations(obj)
  },

  set(language) {
    return setLanguage(language)
  },

  get() {
    return getLanguage()
  },

  available() {
    const languageKeys = Object.keys(translations)
    return languageKeys.map(key => ({ code: key, name: (meta.names && meta.names[key]) || key }))
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Launch/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Launch/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApplicationInstance": () => (/* binding */ ApplicationInstance),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/* harmony import */ var _Profile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Profile */ "./node_modules/@lightningjs/sdk/src/Profile/index.js");
/* harmony import */ var _Metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _MediaPlayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MediaPlayer */ "./node_modules/@lightningjs/sdk/src/MediaPlayer/index.js");
/* harmony import */ var _VideoPlayer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VideoPlayer */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js");
/* harmony import */ var _Storage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Storage */ "./node_modules/@lightningjs/sdk/src/Storage/index.js");
/* harmony import */ var _Ads__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Ads */ "./node_modules/@lightningjs/sdk/src/Ads/index.js");
/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Router */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _TV__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../TV */ "./node_modules/@lightningjs/sdk/src/TV/index.js");
/* harmony import */ var _Purchase__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Purchase */ "./node_modules/@lightningjs/sdk/src/Purchase/index.js");
/* harmony import */ var _Pin__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../Pin */ "./node_modules/@lightningjs/sdk/src/Pin/index.js");
/* harmony import */ var _Metadata__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../Metadata */ "./node_modules/@lightningjs/sdk/src/Metadata/index.js");
/* harmony import */ var _Application__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../Application */ "./node_modules/@lightningjs/sdk/src/Application/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















let ApplicationInstance

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((App, appSettings, platformSettings, appData) => {
  ;(0,_Settings__WEBPACK_IMPORTED_MODULE_3__.initSettings)(appSettings, platformSettings)
  ;(0,_Metadata__WEBPACK_IMPORTED_MODULE_12__.initMetadata)(appSettings)

  ;(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.initUtils)(platformSettings)
  ;(0,_Storage__WEBPACK_IMPORTED_MODULE_6__.initStorage)()
  // Initialize plugins
  if (platformSettings.plugins) {
    platformSettings.plugins.profile && (0,_Profile__WEBPACK_IMPORTED_MODULE_1__.initProfile)(platformSettings.plugins.profile)
    platformSettings.plugins.metrics && (0,_Metrics__WEBPACK_IMPORTED_MODULE_2__.initMetrics)(platformSettings.plugins.metrics)
    platformSettings.plugins.mediaPlayer && (0,_MediaPlayer__WEBPACK_IMPORTED_MODULE_4__.initMediaPlayer)(platformSettings.plugins.mediaPlayer)
    platformSettings.plugins.mediaPlayer && (0,_VideoPlayer__WEBPACK_IMPORTED_MODULE_5__.initVideoPlayer)(platformSettings.plugins.mediaPlayer)
    platformSettings.plugins.ads && (0,_Ads__WEBPACK_IMPORTED_MODULE_7__.initAds)(platformSettings.plugins.ads)
    platformSettings.plugins.router && (0,_Router__WEBPACK_IMPORTED_MODULE_8__.initRouter)(platformSettings.plugins.router)
    platformSettings.plugins.tv && (0,_TV__WEBPACK_IMPORTED_MODULE_9__.initTV)(platformSettings.plugins.tv)
    platformSettings.plugins.purchase && (0,_Purchase__WEBPACK_IMPORTED_MODULE_10__.initPurchase)(platformSettings.plugins.purchase)
    platformSettings.plugins.pin && (0,_Pin__WEBPACK_IMPORTED_MODULE_11__.initPin)(platformSettings.plugins.pin)
  }

  const app = (0,_Application__WEBPACK_IMPORTED_MODULE_13__["default"])(App, appData, platformSettings)
  ApplicationInstance = new app(appSettings)
  return ApplicationInstance
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Lightning/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Lightning/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lightningjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lightningjs/core */ "./node_modules/@lightningjs/core/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lightningjs_core__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Locale/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Locale/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Simple module for localization of strings.
 *
 * How to use:
 * 1. Create localization file with following JSON format:
 * {
 *   "en" :{
 *     "how": "How do you want your egg today?",
 *     "boiledEgg": "Boiled egg",
 *     "softBoiledEgg": "Soft-boiled egg",
 *     "choice": "How to choose the egg",
 *     "buyQuestion": "I'd like to buy {0} eggs, {1} dollars each."
 *   },
 *
 *   "it": {
 *     "how": "Come vuoi il tuo uovo oggi?",
 *     "boiledEgg": "Uovo sodo",
 *     "softBoiledEgg": "Uovo alla coque",
 *     "choice": "Come scegliere l'uovo",
 *     "buyQuestion": "Mi piacerebbe comprare {0} uova, {1} dollari ciascuna."
 *   }
 * }
 *
 * 2. Use Locale's module load method, specifying path to your localization file and set chosen language, e.g.:
 *    > Locale.load('static/locale/locale.json');
 *    > Locale.setLanguage('en');
 *
 * 3. Use localization strings:
 *    > console.log(Locale.tr.how);
 *    How do you want your egg today?
 *    > console.log(Locale.tr.boiledEgg);
 *    Boiled egg
 *
 * 4. String formatting
 *    > console.log(Locale.tr.buyQuestion.format(10, 0.5));
 *    I'd like to buy 10 eggs, 0.5 dollars each.
 */



let warned = false
const deprecated = (force = false) => {
  if (force === true || warned === false) {
    console.warn(
      [
        "The 'Locale'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.",
        "Please consider using the new 'Language'-plugin instead.",
        'https://rdkcentral.github.io/Lightning-SDK/#/plugins/language',
      ].join('\n\n')
    )
  }
  warned = true
}
class Locale {
  constructor() {
    this.__enabled = false
  }

  /**
   * Loads translation object from external json file.
   *
   * @param {String} path Path to resource.
   * @return {Promise}
   */
  async load(path) {
    if (!this.__enabled) {
      return
    }

    await fetch(path)
      .then(resp => resp.json())
      .then(resp => {
        this.loadFromObject(resp)
      })
  }

  /**
   * Sets language used by module.
   *
   * @param {String} lang
   */
  setLanguage(lang) {
    deprecated()
    this.__enabled = true
    this.language = lang
  }

  /**
   * Returns reference to translation object for current language.
   *
   * @return {Object}
   */
  get tr() {
    deprecated(true)
    return this.__trObj[this.language]
  }

  /**
   * Loads translation object from existing object (binds existing object).
   *
   * @param {Object} trObj
   */
  loadFromObject(trObj) {
    deprecated()
    const fallbackLanguage = 'en'
    if (Object.keys(trObj).indexOf(this.language) === -1) {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].warn('No translations found for: ' + this.language)
      if (Object.keys(trObj).indexOf(fallbackLanguage) > -1) {
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].warn('Using fallback language: ' + fallbackLanguage)
        this.language = fallbackLanguage
      } else {
        const error = 'No translations found for fallback language: ' + fallbackLanguage
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error)
        throw Error(error)
      }
    }

    this.__trObj = trObj
    for (const lang of Object.values(this.__trObj)) {
      for (const str of Object.keys(lang)) {
        lang[str] = new LocalizedString(lang[str])
      }
    }
  }
}

/**
 * Extended string class used for localization.
 */
class LocalizedString extends String {
  /**
   * Returns formatted LocalizedString.
   * Replaces each placeholder value (e.g. {0}, {1}) with corresponding argument.
   *
   * E.g.:
   * > new LocalizedString('{0} and {1} and {0}').format('A', 'B');
   * A and B and A
   *
   * @param  {...any} args List of arguments for placeholders.
   */
  format(...args) {
    const sub = args.reduce((string, arg, index) => string.split(`{${index}}`).join(arg), this)
    return new LocalizedString(sub)
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Locale());


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Log/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Log/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const prepLog = (type, args) => {
  const colors = {
    Info: 'green',
    Debug: 'gray',
    Warn: 'orange',
    Error: 'red',
  }

  args = Array.from(args)
  return [
    '%c' + (args.length > 1 && typeof args[0] === 'string' ? args.shift() : type),
    'background-color: ' + colors[type] + '; color: white; padding: 2px 4px; border-radius: 2px',
    args,
  ]
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  info() {
    _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'log') && console.log.apply(console, prepLog('Info', arguments))
  },
  debug() {
    _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'log') && console.debug.apply(console, prepLog('Debug', arguments))
  },
  error() {
    _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'log') && console.error.apply(console, prepLog('Error', arguments))
  },
  warn() {
    _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'log') && console.warn.apply(console, prepLog('Warn', arguments))
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/MediaPlayer/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/MediaPlayer/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Mediaplayer),
/* harmony export */   "initMediaPlayer": () => (/* binding */ initMediaPlayer)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const events = [
  'timeupdate',
  'error',
  'ended',
  'loadeddata',
  'canplay',
  'play',
  'playing',
  'pause',
  'loadstart',
  'seeking',
  'seeked',
  'encrypted',
]

let mediaUrl = url => url

const initMediaPlayer = config => {
  if (config.mediaUrl) {
    mediaUrl = config.mediaUrl
  }
}

class Mediaplayer extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  _construct() {
    this._skipRenderToTexture = false
    this._metrics = null
    this._textureMode = _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].get('platform', 'textureMode') || false
    _Log__WEBPACK_IMPORTED_MODULE_3__["default"].info('Texture mode: ' + this._textureMode)
    console.warn(
      [
        "The 'MediaPlayer'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.",
        "Please consider using the new 'VideoPlayer'-plugin instead.",
        'https://rdkcentral.github.io/Lightning-SDK/#/plugins/videoplayer',
      ].join('\n\n')
    )
  }

  static _template() {
    return {
      Video: {
        VideoWrap: {
          VideoTexture: {
            visible: false,
            pivot: 0.5,
            texture: { type: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].textures.StaticTexture, options: {} },
          },
        },
      },
    }
  }

  set skipRenderToTexture(v) {
    this._skipRenderToTexture = v
  }

  get textureMode() {
    return this._textureMode
  }

  get videoView() {
    return this.tag('Video')
  }

  _init() {
    //re-use videotag if already there
    const videoEls = document.getElementsByTagName('video')
    if (videoEls && videoEls.length > 0) this.videoEl = videoEls[0]
    else {
      this.videoEl = document.createElement('video')
      this.videoEl.setAttribute('id', 'video-player')
      this.videoEl.style.position = 'absolute'
      this.videoEl.style.zIndex = '1'
      this.videoEl.style.display = 'none'
      this.videoEl.setAttribute('width', '100%')
      this.videoEl.setAttribute('height', '100%')

      this.videoEl.style.visibility = this.textureMode ? 'hidden' : 'visible'
      document.body.appendChild(this.videoEl)
    }
    if (this.textureMode && !this._skipRenderToTexture) {
      this._createVideoTexture()
    }

    this.eventHandlers = []
  }

  _registerListeners() {
    events.forEach(event => {
      const handler = e => {
        if (this._metrics && this._metrics[event] && typeof this._metrics[event] === 'function') {
          this._metrics[event]({ currentTime: this.videoEl.currentTime })
        }
        this.fire(event, { videoElement: this.videoEl, event: e })
      }
      this.eventHandlers.push(handler)
      this.videoEl.addEventListener(event, handler)
    })
  }

  _deregisterListeners() {
    _Log__WEBPACK_IMPORTED_MODULE_3__["default"].info('Deregistering event listeners MediaPlayer')
    events.forEach((event, index) => {
      this.videoEl.removeEventListener(event, this.eventHandlers[index])
    })
    this.eventHandlers = []
  }

  _attach() {
    this._registerListeners()
  }

  _detach() {
    this._deregisterListeners()
    this.close()
  }

  _createVideoTexture() {
    const stage = this.stage

    const gl = stage.gl
    const glTexture = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, glTexture)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)

    this.videoTexture.options = { source: glTexture, w: this.videoEl.width, h: this.videoEl.height }
  }

  _startUpdatingVideoTexture() {
    if (this.textureMode && !this._skipRenderToTexture) {
      const stage = this.stage
      if (!this._updateVideoTexture) {
        this._updateVideoTexture = () => {
          if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
            const gl = stage.gl

            const currentTime = new Date().getTime()

            // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
            // We'll fallback to fixed 30fps in this case.
            const frameCount = this.videoEl.webkitDecodedFrameCount

            const mustUpdate = frameCount
              ? this._lastFrame !== frameCount
              : this._lastTime < currentTime - 30

            if (mustUpdate) {
              this._lastTime = currentTime
              this._lastFrame = frameCount
              try {
                gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source)
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false)
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl)
                this._lastFrame = this.videoEl.webkitDecodedFrameCount
                this.videoTextureView.visible = true

                this.videoTexture.options.w = this.videoEl.videoWidth
                this.videoTexture.options.h = this.videoEl.videoHeight
                const expectedAspectRatio = this.videoTextureView.w / this.videoTextureView.h
                const realAspectRatio = this.videoEl.videoWidth / this.videoEl.videoHeight
                if (expectedAspectRatio > realAspectRatio) {
                  this.videoTextureView.scaleX = realAspectRatio / expectedAspectRatio
                  this.videoTextureView.scaleY = 1
                } else {
                  this.videoTextureView.scaleY = expectedAspectRatio / realAspectRatio
                  this.videoTextureView.scaleX = 1
                }
              } catch (e) {
                _Log__WEBPACK_IMPORTED_MODULE_3__["default"].error('texImage2d video', e)
                this._stopUpdatingVideoTexture()
                this.videoTextureView.visible = false
              }
              this.videoTexture.source.forceRenderUpdate()
            }
          }
        }
      }
      if (!this._updatingVideoTexture) {
        stage.on('frameStart', this._updateVideoTexture)
        this._updatingVideoTexture = true
      }
    }
  }

  _stopUpdatingVideoTexture() {
    if (this.textureMode) {
      const stage = this.stage
      stage.removeListener('frameStart', this._updateVideoTexture)
      this._updatingVideoTexture = false
      this.videoTextureView.visible = false

      if (this.videoTexture.options.source) {
        const gl = stage.gl
        gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source)
        gl.clearColor(0, 0, 0, 1)
        gl.clear(gl.COLOR_BUFFER_BIT)
      }
    }
  }

  updateSettings(settings = {}) {
    // The Component that 'consumes' the media player.
    this._consumer = settings.consumer

    if (this._consumer && this._consumer.getMediaplayerSettings) {
      // Allow consumer to add settings.
      settings = Object.assign(settings, this._consumer.getMediaplayerSettings())
    }

    if (!_Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Utils.equalValues(this._stream, settings.stream)) {
      if (settings.stream && settings.stream.keySystem) {
        navigator
          .requestMediaKeySystemAccess(
            settings.stream.keySystem.id,
            settings.stream.keySystem.config
          )
          .then(keySystemAccess => {
            return keySystemAccess.createMediaKeys()
          })
          .then(createdMediaKeys => {
            return this.videoEl.setMediaKeys(createdMediaKeys)
          })
          .then(() => {
            if (settings.stream && settings.stream.src) this.open(settings.stream.src)
          })
          .catch(() => {
            console.error('Failed to set up MediaKeys')
          })
      } else if (settings.stream && settings.stream.src) {
        // This is here to be backwards compatible, will be removed
        // in future sdk release
        if (_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].get('app', 'hls')) {
          if (!window.Hls) {
            window.Hls = class Hls {
              static isSupported() {
                console.warn('hls-light not included')
                return false
              }
            }
          }
          if (window.Hls.isSupported()) {
            if (!this._hls) this._hls = new window.Hls({ liveDurationInfinity: true })
            this._hls.loadSource(settings.stream.src)
            this._hls.attachMedia(this.videoEl)
            this.videoEl.style.display = 'block'
          }
        } else {
          this.open(settings.stream.src)
        }
      } else {
        this.close()
      }
      this._stream = settings.stream
    }

    this._setHide(settings.hide)
    this._setVideoArea(settings.videoPos)
  }

  _setHide(hide) {
    if (this.textureMode) {
      this.tag('Video').setSmooth('alpha', hide ? 0 : 1)
    } else {
      this.videoEl.style.visibility = hide ? 'hidden' : 'visible'
    }
  }

  open(url, settings = { hide: false, videoPosition: null }) {
    // prep the media url to play depending on platform (mediaPlayerplugin)
    url = mediaUrl(url)
    this._metrics = _Metrics__WEBPACK_IMPORTED_MODULE_1__["default"].media(url)
    _Log__WEBPACK_IMPORTED_MODULE_3__["default"].info('Playing stream', url)
    if (this.application.noVideo) {
      _Log__WEBPACK_IMPORTED_MODULE_3__["default"].info('noVideo option set, so ignoring: ' + url)
      return
    }
    // close the video when opening same url as current (effectively reloading)
    if (this.videoEl.getAttribute('src') === url) {
      this.close()
    }
    this.videoEl.setAttribute('src', url)

    // force hide, then force show (in next tick!)
    // (fixes comcast playback rollover issue)
    this.videoEl.style.visibility = 'hidden'
    this.videoEl.style.display = 'none'

    setTimeout(() => {
      this.videoEl.style.display = 'block'
      this.videoEl.style.visibility = 'visible'
    })

    this._setHide(settings.hide)
    this._setVideoArea(settings.videoPosition || [0, 0, 1920, 1080])
  }

  close() {
    // We need to pause first in order to stop sound.
    this.videoEl.pause()
    this.videoEl.removeAttribute('src')

    // force load to reset everything without errors
    this.videoEl.load()

    this._clearSrc()

    this.videoEl.style.display = 'none'
  }

  playPause() {
    if (this.isPlaying()) {
      this.doPause()
    } else {
      this.doPlay()
    }
  }

  get muted() {
    return this.videoEl.muted
  }

  set muted(v) {
    this.videoEl.muted = v
  }

  get loop() {
    return this.videoEl.loop
  }

  set loop(v) {
    this.videoEl.loop = v
  }

  isPlaying() {
    return this._getState() === 'Playing'
  }

  doPlay() {
    this.videoEl.play()
  }

  doPause() {
    this.videoEl.pause()
  }

  reload() {
    var url = this.videoEl.getAttribute('src')
    this.close()
    this.videoEl.src = url
  }

  getPosition() {
    return Promise.resolve(this.videoEl.currentTime)
  }

  setPosition(pos) {
    this.videoEl.currentTime = pos
  }

  getDuration() {
    return Promise.resolve(this.videoEl.duration)
  }

  seek(time, absolute = false) {
    if (absolute) {
      this.videoEl.currentTime = time
    } else {
      this.videoEl.currentTime += time
    }
  }

  get videoTextureView() {
    return this.tag('Video').tag('VideoTexture')
  }

  get videoTexture() {
    return this.videoTextureView.texture
  }

  _setVideoArea(videoPos) {
    if (_Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Utils.equalValues(this._videoPos, videoPos)) {
      return
    }

    this._videoPos = videoPos

    if (this.textureMode) {
      this.videoTextureView.patch({
        smooth: {
          x: videoPos[0],
          y: videoPos[1],
          w: videoPos[2] - videoPos[0],
          h: videoPos[3] - videoPos[1],
        },
      })
    } else {
      const precision = this.stage.getRenderPrecision()
      this.videoEl.style.left = Math.round(videoPos[0] * precision) + 'px'
      this.videoEl.style.top = Math.round(videoPos[1] * precision) + 'px'
      this.videoEl.style.width = Math.round((videoPos[2] - videoPos[0]) * precision) + 'px'
      this.videoEl.style.height = Math.round((videoPos[3] - videoPos[1]) * precision) + 'px'
    }
  }

  _fireConsumer(event, args) {
    if (this._consumer) {
      this._consumer.fire(event, args)
    }
  }

  _equalInitData(buf1, buf2) {
    if (!buf1 || !buf2) return false
    if (buf1.byteLength != buf2.byteLength) return false
    const dv1 = new Int8Array(buf1)
    const dv2 = new Int8Array(buf2)
    for (let i = 0; i != buf1.byteLength; i++) if (dv1[i] != dv2[i]) return false
    return true
  }

  error(args) {
    this._fireConsumer('$mediaplayerError', args)
    this._setState('')
    return ''
  }

  loadeddata(args) {
    this._fireConsumer('$mediaplayerLoadedData', args)
  }

  play(args) {
    this._fireConsumer('$mediaplayerPlay', args)
  }

  playing(args) {
    this._fireConsumer('$mediaplayerPlaying', args)
    this._setState('Playing')
  }

  canplay(args) {
    this.videoEl.play()
    this._fireConsumer('$mediaplayerStart', args)
  }

  loadstart(args) {
    this._fireConsumer('$mediaplayerLoad', args)
  }

  seeked() {
    this._fireConsumer('$mediaplayerSeeked', {
      currentTime: this.videoEl.currentTime,
      duration: this.videoEl.duration || 1,
    })
  }

  seeking() {
    this._fireConsumer('$mediaplayerSeeking', {
      currentTime: this.videoEl.currentTime,
      duration: this.videoEl.duration || 1,
    })
  }

  durationchange(args) {
    this._fireConsumer('$mediaplayerDurationChange', args)
  }

  encrypted(args) {
    const video = args.videoElement
    const event = args.event
    // FIXME: Double encrypted events need to be properly filtered by Gstreamer
    if (video.mediaKeys && !this._equalInitData(this._previousInitData, event.initData)) {
      this._previousInitData = event.initData
      this._fireConsumer('$mediaplayerEncrypted', args)
    }
  }

  static _states() {
    return [
      class Playing extends this {
        $enter() {
          this._startUpdatingVideoTexture()
        }
        $exit() {
          this._stopUpdatingVideoTexture()
        }
        timeupdate() {
          this._fireConsumer('$mediaplayerProgress', {
            currentTime: this.videoEl.currentTime,
            duration: this.videoEl.duration || 1,
          })
        }
        ended(args) {
          this._fireConsumer('$mediaplayerEnded', args)
          this._setState('')
        }
        pause(args) {
          this._fireConsumer('$mediaplayerPause', args)
          this._setState('Playing.Paused')
        }
        _clearSrc() {
          this._fireConsumer('$mediaplayerStop', {})
          this._setState('')
        }
        static _states() {
          return [class Paused extends this {}]
        }
      },
    ]
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Metadata/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Metadata/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initMetadata": () => (/* binding */ initMetadata)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let metadata = {}

const initMetadata = metadataObj => {
  metadata = metadataObj
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  get(key, fallback = undefined) {
    return key in metadata ? metadata[key] : fallback
  },
  appId() {
    return this.get('id')
  },
  safeAppId() {
    return this.get('id').replace(/[^0-9a-zA-Z_$]/g, '_')
  },
  appName() {
    return this.get('name')
  },
  appVersion() {
    return (this.get('version') || '').split('-').shift()
  },
  appIcon() {
    return this.get('icon')
  },
  // Version from app store (with commit hash)
  appFullVersion() {
    return this.get('version')
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Metrics/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Metrics/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initMetrics": () => (/* binding */ initMetrics)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



let sendMetric = (type, event, params) => {
  _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Sending metric', type, event, params)
}

const initMetrics = config => {
  sendMetric = config.sendMetric
}

// available metric per category
const metrics = {
  app: ['launch', 'loaded', 'ready', 'close'],
  page: ['view', 'leave'],
  user: ['click', 'input'],
  media: [
    'abort',
    'canplay',
    'ended',
    'pause',
    'play',
    // with some videos there occur almost constant suspend events ... should investigate
    // 'suspend',
    'volumechange',
    'waiting',
    'seeking',
    'seeked',
  ],
}

// error metric function (added to each category)
const errorMetric = (type, message, code, visible, params = {}) => {
  params = { params, ...{ message, code, visible } }
  sendMetric(type, 'error', params)
}

const Metric = (type, events, options = {}) => {
  return events.reduce(
    (obj, event) => {
      obj[event] = (name, params = {}) => {
        params = { ...options, ...(name ? { name } : {}), ...params }
        sendMetric(type, event, params)
      }
      return obj
    },
    {
      error(message, code, params) {
        errorMetric(type, message, code, params)
      },
      event(name, params) {
        sendMetric(type, name, params)
      },
    }
  )
}

const Metrics = types => {
  return Object.keys(types).reduce(
    (obj, type) => {
      // media metric works a bit different!
      // it's a function that accepts a url and returns an object with the available metrics
      // url is automatically passed as a param in every metric
      type === 'media'
        ? (obj[type] = url => Metric(type, types[type], { url }))
        : (obj[type] = Metric(type, types[type]))
      return obj
    },
    { error: errorMetric, event: sendMetric }
  )
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Metrics(metrics));


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Pin/dialog.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Pin/dialog.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PinDialog)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Pin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Pin */ "./node_modules/@lightningjs/sdk/src/Pin/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class PinInput extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      w: 120,
      h: 150,
      rect: true,
      color: 0xff949393,
      alpha: 0.5,
      shader: { type: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].shaders.RoundedRectangle, radius: 10 },
      Nr: {
        w: w => w,
        y: 24,
        text: {
          text: '',
          textColor: 0xff333333,
          fontSize: 80,
          textAlign: 'center',
          verticalAlign: 'middle',
        },
      },
    }
  }

  set index(v) {
    this.x = v * (120 + 24)
  }

  set nr(v) {
    this._timeout && clearTimeout(this._timeout)

    if (v) {
      this.setSmooth('alpha', 1)
    } else {
      this.setSmooth('alpha', 0.5)
    }

    this.tag('Nr').patch({
      text: {
        text: (v && v.toString()) || '',
        fontSize: v === '*' ? 120 : 80,
      },
    })

    if (v && v !== '*') {
      this._timeout = setTimeout(() => {
        this._timeout = null
        this.nr = '*'
      }, 750)
    }
  }
}

class PinDialog extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      zIndex: 1,
      w: w => w,
      h: h => h,
      rect: true,
      color: 0xdd000000,
      alpha: 0.000001,
      Dialog: {
        w: 648,
        h: 320,
        y: h => (h - 320) / 2,
        x: w => (w - 648) / 2,
        rect: true,
        color: 0xdd333333,
        shader: { type: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].shaders.RoundedRectangle, radius: 10 },
        Info: {
          y: 24,
          x: 48,
          text: { text: 'Please enter your PIN', fontSize: 32 },
        },
        Msg: {
          y: 260,
          x: 48,
          text: { text: '', fontSize: 28, textColor: 0xffffffff },
        },
        Code: {
          x: 48,
          y: 96,
        },
      },
    }
  }

  _init() {
    const children = []
    for (let i = 0; i < 4; i++) {
      children.push({
        type: PinInput,
        index: i,
      })
    }

    this.tag('Code').children = children
  }

  get pin() {
    if (!this._pin) this._pin = ''
    return this._pin
  }

  set pin(v) {
    if (v.length <= 4) {
      const maskedPin = new Array(Math.max(v.length - 1, 0)).fill('*', 0, v.length - 1)
      v.length && maskedPin.push(v.length > this._pin.length ? v.slice(-1) : '*')
      for (let i = 0; i < 4; i++) {
        this.tag('Code').children[i].nr = maskedPin[i] || ''
      }
      this._pin = v
    }
  }

  get msg() {
    if (!this._msg) this._msg = ''
    return this._msg
  }

  set msg(v) {
    this._timeout && clearTimeout(this._timeout)

    this._msg = v
    if (this._msg) {
      this.tag('Msg').text = this._msg
      this.tag('Info').setSmooth('alpha', 0.5)
      this.tag('Code').setSmooth('alpha', 0.5)
    } else {
      this.tag('Msg').text = ''
      this.tag('Info').setSmooth('alpha', 1)
      this.tag('Code').setSmooth('alpha', 1)
    }
    this._timeout = setTimeout(() => {
      this.msg = ''
    }, 2000)
  }

  _firstActive() {
    this.setSmooth('alpha', 1)
  }

  _handleKey(event) {
    if (this.msg) {
      this.msg = false
    } else {
      const val = parseInt(event.key)
      if (val > -1) {
        this.pin += val
      }
    }
  }

  _handleBack() {
    if (this.msg) {
      this.msg = false
    } else {
      if (this.pin.length) {
        this.pin = this.pin.slice(0, this.pin.length - 1)
      } else {
        _Pin__WEBPACK_IMPORTED_MODULE_1__["default"].hide()
        this.resolve(false)
      }
    }
  }

  _handleEnter() {
    if (this.msg) {
      this.msg = false
    } else {
      _Pin__WEBPACK_IMPORTED_MODULE_1__["default"].submit(this.pin)
        .then(val => {
          this.msg = 'Unlocking ...'
          setTimeout(() => {
            _Pin__WEBPACK_IMPORTED_MODULE_1__["default"].hide()
          }, 1000)
          this.resolve(val)
        })
        .catch(e => {
          this.msg = e
          this.reject(e)
        })
    }
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Pin/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Pin/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initPin": () => (/* binding */ initPin)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _dialog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dialog */ "./node_modules/@lightningjs/sdk/src/Pin/dialog.js");
/* harmony import */ var _Launch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Launch */ "./node_modules/@lightningjs/sdk/src/Launch/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../index */ "./node_modules/@lightningjs/sdk/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






// only used during local development
let unlocked = false
const contextItems = ['purchase', 'parental']

let submit = (pin, context) => {
  return new Promise((resolve, reject) => {
    if (pin.toString() === _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'pin', '0000').toString()) {
      unlocked = true
      resolve(unlocked)
    } else {
      reject('Incorrect pin')
    }
  })
}

let check = context => {
  return new Promise(resolve => {
    resolve(unlocked)
  })
}

const initPin = config => {
  if (config.submit && typeof config.submit === 'function') {
    submit = config.submit
  }
  if (config.check && typeof config.check === 'function') {
    check = config.check
  }
}

let pinDialog = null

const contextCheck = context => {
  if (context === undefined) {
    _index__WEBPACK_IMPORTED_MODULE_3__.Log.info('Please provide context explicitly')
    return contextItems[0]
  } else if (!contextItems.includes(context)) {
    _index__WEBPACK_IMPORTED_MODULE_3__.Log.warn('Incorrect context provided')
    return false
  }
  return context
}

// Public API
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  show() {
    return new Promise((resolve, reject) => {
      pinDialog = _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.stage.c({
        ref: 'PinDialog',
        type: _dialog__WEBPACK_IMPORTED_MODULE_1__["default"],
        resolve,
        reject,
      })
      _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.childList.a(pinDialog)
      _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.focus = pinDialog
    })
  },
  hide() {
    _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.focus = null
    _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.children = _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.children.map(
      child => child !== pinDialog && child
    )
    pinDialog = null
  },
  submit(pin, context) {
    return new Promise((resolve, reject) => {
      try {
        context = contextCheck(context)
        if (context) {
          submit(pin, context)
            .then(resolve)
            .catch(reject)
        } else {
          reject('Incorrect Context provided')
        }
      } catch (e) {
        reject(e)
      }
    })
  },
  unlocked(context) {
    return new Promise((resolve, reject) => {
      try {
        context = contextCheck(context)
        if (context) {
          check(context)
            .then(resolve)
            .catch(reject)
        } else {
          reject('Incorrect Context provided')
        }
      } catch (e) {
        reject(e)
      }
    })
  },
  locked(context) {
    return new Promise((resolve, reject) => {
      try {
        context = contextCheck(context)
        if (context) {
          check(context)
            .then(unlocked => resolve(!!!unlocked))
            .catch(reject)
        } else {
          reject('Incorrect Context provided')
        }
      } catch (e) {
        reject(e)
      }
    })
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Profile/defaults.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Profile/defaults.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultProfile": () => (/* binding */ defaultProfile)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Profile/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const defaultProfile = {
  ageRating: 'adult',
  city: 'New York',
  zipCode: '27505',
  countryCode: () => (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getCountryCode)('US'),
  ip: '127.0.0.1',
  household: 'b2244e9d4c04826ccd5a7b2c2a50e7d4',
  language: () => (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getLanguage)('en'),
  latlon: () => (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getLatLon)([40.7128, 74.006]),
  locale: () => (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getLocale)('en-US'),
  mac: '00:00:00:00:00:00',
  operator: 'metrological',
  platform: 'metrological',
  packages: [],
  uid: 'ee6723b8-7ab3-462c-8d93-dbf61227998e',
  stbType: 'metrological',
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Profile/helpers.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Profile/helpers.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCountryCode": () => (/* binding */ getCountryCode),
/* harmony export */   "getLanguage": () => (/* binding */ getLanguage),
/* harmony export */   "getLatLon": () => (/* binding */ getLatLon),
/* harmony export */   "getLocale": () => (/* binding */ getLocale)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const formatLocale = locale => {
  if (locale && locale.length === 2) {
    return `${locale.toLowerCase()}-${locale.toUpperCase()}`
  } else {
    return locale
  }
}

const getLocale = defaultValue => {
  if ('language' in navigator) {
    const locale = formatLocale(navigator.language)
    return Promise.resolve(locale)
  } else {
    return Promise.resolve(defaultValue)
  }
}

const getLanguage = defaultValue => {
  if ('language' in navigator) {
    const language = formatLocale(navigator.language).slice(0, 2)
    return Promise.resolve(language)
  } else {
    return Promise.resolve(defaultValue)
  }
}

const getCountryCode = defaultValue => {
  if ('language' in navigator) {
    const countryCode = formatLocale(navigator.language).slice(3, 5)
    return Promise.resolve(countryCode)
  } else {
    return Promise.resolve(defaultValue)
  }
}

const hasOrAskForGeoLocationPermission = () => {
  return new Promise(resolve => {
    // force to prompt for location permission
    if (_Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'forceBrowserGeolocation') === true) resolve(true)
    if ('permissions' in navigator && typeof navigator.permissions.query === 'function') {
      navigator.permissions.query({ name: 'geolocation' }).then(status => {
        resolve(status.state === 'granted' || status.status === 'granted')
      })
    } else {
      resolve(false)
    }
  })
}

const getLatLon = defaultValue => {
  return new Promise(resolve => {
    hasOrAskForGeoLocationPermission().then(granted => {
      if (granted === true) {
        if ('geolocation' in navigator) {
          navigator.geolocation.getCurrentPosition(
            // success
            result =>
              result && result.coords && resolve([result.coords.latitude, result.coords.longitude]),
            // error
            () => resolve(defaultValue),
            // options
            {
              enableHighAccuracy: true,
              timeout: 5000,
              maximumAge: 0,
            }
          )
        } else {
          return queryForLatLon().then(result => resolve(result || defaultValue))
        }
      } else {
        return queryForLatLon().then(result => resolve(result || defaultValue))
      }
    })
  })
}

const queryForLatLon = () => {
  return new Promise(resolve => {
    fetch('https://geolocation-db.com/json/')
      .then(response => response.json())
      .then(({ latitude, longitude }) =>
        latitude && longitude ? resolve([latitude, longitude]) : resolve(false)
      )
      .catch(() => resolve(false))
  })
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Profile/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Profile/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initProfile": () => (/* binding */ initProfile)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaults */ "./node_modules/@lightningjs/sdk/src/Profile/defaults.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let getInfo = key => {
  const profile = { ..._defaults__WEBPACK_IMPORTED_MODULE_1__.defaultProfile, ..._Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'profile') }
  return Promise.resolve(typeof profile[key] === 'function' ? profile[key]() : profile[key])
}

let setInfo = (key, params) => {
  if (key in _defaults__WEBPACK_IMPORTED_MODULE_1__.defaultProfile) _defaults__WEBPACK_IMPORTED_MODULE_1__.defaultProfile[key] = params
}

const initProfile = config => {
  getInfo = config.getInfo
  setInfo = config.setInfo
}

const getOrSet = (key, params) => (params ? setInfo(key, params) : getInfo(key))

// public API
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  ageRating(params) {
    return getOrSet('ageRating', params)
  },
  city(params) {
    return getOrSet('city', params)
  },
  zipCode(params) {
    return getOrSet('zipCode', params)
  },
  countryCode(params) {
    return getOrSet('countryCode', params)
  },
  ip(params) {
    return getOrSet('ip', params)
  },
  household(params) {
    return getOrSet('household', params)
  },
  language(params) {
    return getOrSet('language', params)
  },
  latlon(params) {
    return getOrSet('latlon', params)
  },
  locale(params) {
    return getOrSet('locale', params)
  },
  mac(params) {
    return getOrSet('mac', params)
  },
  operator(params) {
    return getOrSet('operator', params)
  },
  platform(params) {
    return getOrSet('platform', params)
  },
  packages(params) {
    return getOrSet('packages', params)
  },
  uid(params) {
    return getOrSet('uid', params)
  },
  stbType(params) {
    return getOrSet('stbType', params)
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Purchase/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Purchase/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initPurchase": () => (/* binding */ initPurchase)
/* harmony export */ });
/* harmony import */ var _Profile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Profile */ "./node_modules/@lightningjs/sdk/src/Profile/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _helpers_sequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/sequence */ "./node_modules/@lightningjs/sdk/src/helpers/sequence.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





let cspUrl = 'http://payment-csp-example.metrological.com:8080/'
let billingUrl = 'https://payment-sdk.metrological.com/'

let cspEndpoints = {
  assets: {
    uri: '/assets',
    method: 'GET',
  },
  asset: {
    uri: '/assets/:id',
    method: 'GET',
  },
  signature: {
    uri: '/assets/:id/signature',
    method: 'POST',
  },
  subscribe: {
    uri: '/assets/:id/subscribe',
    method: 'POST',
  },
  unsubscribe: {
    uri: '/assets/:id/unsubscribe',
    method: 'POST',
  },
}

const initPurchase = config => {
  if (config.billingUrl) billingUrl = config.billingUrl
}

const createUrl = (uri, baseUrl, params = {}) => {
  return new URL(
    // sprinkle in the params
    Object.keys(params)
      .reduce((res, key) => res.replace(new RegExp(':' + key, 'g'), params[key]), uri)
      // remove any leading slash from uri
      .replace(/^\//, ''),
    // make sure baseUrl always has a trailing slash
    /\/$/.test(baseUrl) ? baseUrl : baseUrl.replace(/$/, '/')
  )
}

const request = (url, method = 'GET', data, headers = {}) => {
  if (method === 'GET' && data) {
    url.search = new URLSearchParams(data)
  }

  return new Promise((resolve, reject) => {
    fetch(url, {
      headers: {
        ...{
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        ...headers,
      },
      method: method,
      body: method !== 'GET' && data ? JSON.stringify(data) : null,
    })
      .then(response => (response.ok ? resolve(response.json()) : reject(response.statusText)))
      .catch(reject)
  })
}

const cspRequest = (type, data = null, params = {}) => {
  return new Promise((resolve, reject) => {
    const endpoint = cspEndpoints[type]

    if (!endpoint) {
      reject('No endpoint found for "' + type + '" call')
    } else {
      if (endpoint.callback && typeof endpoint.callback === 'function') {
        endpoint
          .callback(data, params)
          .then(resolve)
          .catch(reject)
      } else {
        request(
          createUrl(endpoint.uri, cspUrl, params),
          endpoint.method,
          {
            ...(endpoint.data || {}),
            ...data,
          },
          endpoint.headers || {}
        )
          .then(resolve)
          .catch(reject)
      }
    }
  })
}

const billingRequest = (uri, data, method = 'POST') => {
  return new Promise((resolve, reject) => {
    request(createUrl(uri, billingUrl), method, data)
      .then(resolve)
      .catch(reject)
  })
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  setup(config) {
    if (config.cspUrl) cspUrl = config.cspUrl
    if (config.endpoints) cspEndpoints = { cspEndpoints, ...config.endpoints }
  },
  assets() {
    return new Promise((resolve, reject) => {
      _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household().then(household => {
        cspRequest('assets', { household })
          .then(resolve)
          .catch(reject)
      })
    })
  },
  asset(id) {
    return new Promise((resolve, reject) => {
      _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household().then(household => {
        cspRequest('asset', { household }, { id })
          .then(resolve)
          .catch(reject)
      })
    })
  },
  signature(id) {
    return new Promise((resolve, reject) => {
      Promise.all([_Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household()]).then(([household]) => {
        cspRequest('signature', { household }, { id })
          .then(resolve)
          .catch(reject)
      })
    })
  },
  subscribe(id, transaction) {
    return new Promise((resolve, reject) => {
      cspRequest('subscribe', { ...transaction }, { id })
        .then(resolve)
        .catch(reject)
    })
  },
  unsubscribe(id) {
    return new Promise((resolve, reject) => {
      _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household().then(household => {
        cspRequest('unsubscribe', { household }, { id })
          .then(resolve)
          .catch(reject)
      })
    })
  },
  payment(signature = {}, type = 'in-app') {
    return new Promise((resolve, reject) => {
      Promise.all([
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household(),
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].countryCode(),
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].operator(),
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].mac(),
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].uid(),
      ])
        .then(([household, country, operator, mac, uid]) => {
          billingRequest('/', {
            purchase: signature,
            identifier: _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('app', 'id'),
            name: _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('app', 'id'),
            household,
            country,
            operator,
            mac,
            uid,
            type,
          })
            .then(resolve)
            .catch(reject)
        })
        .catch(reject)
    })
  },
  confirm(transactionId) {
    return new Promise((resolve, reject) => {
      billingRequest('/confirm', {
        transactionId,
      })
        .then(resolve)
        .catch(reject)
    })
  },
  buy(assetId, type) {
    return new Promise((resolve, reject) => {
      let transactionId
      ;(0,_helpers_sequence__WEBPACK_IMPORTED_MODULE_2__["default"])([
        () => this.signature(assetId),
        signature => this.payment(signature, type),
        transaction => {
          transactionId = transaction.transactionId
          return this.subscribe(assetId, transaction)
        },
        () => this.confirm(transactionId),
      ])
        .then(resolve)
        .catch(reject)
    })
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Registry/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Registry/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const registry = {
  eventListeners: [],
  timeouts: [],
  intervals: [],
  targets: [],
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  // Timeouts
  setTimeout(cb, timeout, ...params) {
    const timeoutId = setTimeout(
      () => {
        registry.timeouts = registry.timeouts.filter(id => id !== timeoutId)
        cb.apply(null, params)
      },
      timeout,
      params
    )
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Set Timeout', 'ID: ' + timeoutId)
    registry.timeouts.push(timeoutId)
    return timeoutId
  },

  clearTimeout(timeoutId) {
    if (registry.timeouts.indexOf(timeoutId) > -1) {
      registry.timeouts = registry.timeouts.filter(id => id !== timeoutId)
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Clear Timeout', 'ID: ' + timeoutId)
      clearTimeout(timeoutId)
    } else {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error('Clear Timeout', 'ID ' + timeoutId + ' not found')
    }
  },

  clearTimeouts() {
    registry.timeouts.forEach(timeoutId => {
      this.clearTimeout(timeoutId)
    })
  },

  // Intervals
  setInterval(cb, interval, ...params) {
    const intervalId = setInterval(
      () => {
        registry.intervals.filter(id => id !== intervalId)
        cb.apply(null, params)
      },
      interval,
      params
    )
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Set Interval', 'ID: ' + intervalId)
    registry.intervals.push(intervalId)
    return intervalId
  },

  clearInterval(intervalId) {
    if (registry.intervals.indexOf(intervalId) > -1) {
      registry.intervals = registry.intervals.filter(id => id !== intervalId)
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Clear Interval', 'ID: ' + intervalId)
      clearInterval(intervalId)
    } else {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error('Clear Interval', 'ID ' + intervalId + ' not found')
    }
  },

  clearIntervals() {
    registry.intervals.forEach(intervalId => {
      this.clearInterval(intervalId)
    })
  },

  // Event listeners
  addEventListener(target, event, handler) {
    target.addEventListener(event, handler)
    const targetIndex =
      registry.targets.indexOf(target) > -1
        ? registry.targets.indexOf(target)
        : registry.targets.push(target) - 1

    registry.eventListeners[targetIndex] = registry.eventListeners[targetIndex] || {}
    registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event] || []
    registry.eventListeners[targetIndex][event].push(handler)
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info(
      'Add eventListener',
      'Target:',
      target,
      'Event: ' + event,
      'Handler:',
      handler.toString()
    )
  },

  removeEventListener(target, event, handler) {
    const targetIndex = registry.targets.indexOf(target)
    if (
      targetIndex > -1 &&
      registry.eventListeners[targetIndex] &&
      registry.eventListeners[targetIndex][event] &&
      registry.eventListeners[targetIndex][event].indexOf(handler) > -1
    ) {
      registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][
        event
      ].filter(fn => fn !== handler)
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info(
        'Remove eventListener',
        'Target:',
        target,
        'Event: ' + event,
        'Handler:',
        handler.toString()
      )
      target.removeEventListener(event, handler)
    } else {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(
        'Remove eventListener',
        'Not found',
        'Target',
        target,
        'Event: ' + event,
        'Handler',
        handler.toString()
      )
    }
  },

  // if `event` is omitted, removes all registered event listeners for target
  // if `target` is also omitted, removes all registered event listeners
  removeEventListeners(target, event) {
    if (target && event) {
      const targetIndex = registry.targets.indexOf(target)
      if (targetIndex > -1) {
        registry.eventListeners[targetIndex][event].forEach(handler => {
          this.removeEventListener(target, event, handler)
        })
      }
    } else if (target) {
      const targetIndex = registry.targets.indexOf(target)
      if (targetIndex > -1) {
        Object.keys(registry.eventListeners[targetIndex]).forEach(_event => {
          this.removeEventListeners(target, _event)
        })
      }
    } else {
      Object.keys(registry.eventListeners).forEach(targetIndex => {
        this.removeEventListeners(registry.targets[targetIndex])
      })
    }
  },

  // Clear everything (to be called upon app close for proper cleanup)
  clear() {
    this.clearTimeouts()
    this.clearIntervals()
    this.removeEventListeners()
    registry.eventListeners = []
    registry.timeouts = []
    registry.intervals = []
    registry.targets = []
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/base.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RoutedApp": () => (/* binding */ RoutedApp)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _utils_router_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/router.js */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class RoutedApp extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      Pages: {
        forceZIndexContext: true,
      },
      /**
       * This is a default Loading page that will be made visible
       * during data-provider on() you CAN override in child-class
       */
      Loading: {
        rect: true,
        w: 1920,
        h: 1080,
        color: 0xff000000,
        visible: false,
        zIndex: 99,
        Label: {
          mount: 0.5,
          x: 960,
          y: 540,
          text: {
            text: 'Loading..',
          },
        },
      },
    }
  }

  static _states() {
    return [
      class Loading extends this {
        $enter() {
          this.tag('Loading').visible = true
        }

        $exit() {
          this.tag('Loading').visible = false
        }
      },
      class Widgets extends this {
        $enter(args, widget) {
          // store widget reference
          this._widget = widget

          // since it's possible that this behaviour
          // is non-remote driven we force a recalculation
          // of the focuspath
          this._refocus()
        }

        _getFocused() {
          // we delegate focus to selected widget
          // so it can consume remotecontrol presses
          return this._widget
        }

        // if we want to widget to widget focus delegation
        reload(widget) {
          this._widget = widget
          this._refocus()
        }

        _handleKey() {
          const restoreFocus = _utils_router_js__WEBPACK_IMPORTED_MODULE_2__.routerConfig.get('autoRestoreRemote')
          /**
           * The Router used to delegate focus back to the page instance on
           * every unhandled key. This is barely usefull in any situation
           * so for now we offer the option to explicity turn that behaviour off
           * so we don't don't introduce a breaking change.
           */
          if (!(0,_utils_helpers__WEBPACK_IMPORTED_MODULE_3__.isBoolean)(restoreFocus) || restoreFocus === true) {
            _index__WEBPACK_IMPORTED_MODULE_1__["default"].focusPage()
          }
        }
      },
    ]
  }

  /**
   * Return location where pages need to be stored
   */
  get pages() {
    return this.tag('Pages')
  }

  /**
   * Tell router where widgets are stored
   */
  get widgets() {
    return this.tag('Widgets')
  }

  /**
   * we MUST register _handleBack method so the Router
   * can override it
   * @private
   */
  _handleBack() {}

  /**
   * We MUST return Router.activePage() so the new Page
   * can listen to the remote-control.
   */
  _getFocused() {
    return _index__WEBPACK_IMPORTED_MODULE_1__["default"].getActivePage()
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getResumeHash": () => (/* binding */ getResumeHash),
/* harmony export */   "initRouter": () => (/* binding */ initRouter),
/* harmony export */   "navigate": () => (/* binding */ navigate),
/* harmony export */   "navigateQueue": () => (/* binding */ navigateQueue),
/* harmony export */   "step": () => (/* binding */ step)
/* harmony export */ });
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _utils_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _utils_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/widgets */ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js");
/* harmony import */ var _utils_history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/history */ "./node_modules/@lightningjs/sdk/src/Router/utils/history.js");
/* harmony import */ var _utils_route__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _utils_loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/loader */ "./node_modules/@lightningjs/sdk/src/Router/utils/loader.js");
/* harmony import */ var _utils_regex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/regex */ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base */ "./node_modules/@lightningjs/sdk/src/Router/base.js");
/* harmony import */ var _Registry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Registry */ "./node_modules/@lightningjs/sdk/src/Registry/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













/*
rouThor ==[x]
 */
let navigateQueue = new Map()
let forcedHash = ''
let resumeHash = ''

/**
 * Start routing the app
 * @param config - route config object
 * @param instance - instance of the app
 */
const startRouter = (config, instance) => {
  ;(0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.bootRouter)(config, instance)
  registerListener()
  start()
}

// start translating url
const start = () => {
  let hash = (getHash() || '').replace(/^#/, '')
  const bootKey = '$'
  const params = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.getQueryStringParams)(hash)
  const bootRequest = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getBootRequest)()
  const rootHash = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getRootHash)()
  const isDirectLoad = hash.indexOf(bootKey) !== -1

  // prevent direct reload of wildcard routes
  // expect bootComponent
  if (_utils_regex__WEBPACK_IMPORTED_MODULE_6__.isWildcard.test(hash) && hash !== bootKey) {
    hash = ''
  }

  // store resume point for manual resume
  resumeHash = isDirectLoad ? rootHash : hash || rootHash

  const ready = () => {
    if (!hash && rootHash) {
      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isString)(rootHash)) {
        navigate(rootHash)
      } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(rootHash)) {
        rootHash().then(res => {
          if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
            navigate(res.path, res.params)
          } else {
            navigate(res)
          }
        })
      }
    } else {
      queue(hash)
      handleHashChange()
        .then(() => {
          _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
        })
        .catch(e => {
          console.error(e)
        })
    }
  }

  if ((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)(bootKey)) {
    if (hash && !isDirectLoad) {
      if (!(0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getRouteByHash)(hash)) {
        navigate('*', { failedHash: hash })
        return
      }
    }
    navigate(
      bootKey,
      {
        resume: resumeHash,
        reload: bootKey === hash,
      },
      false
    )
  } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(bootRequest)) {
    bootRequest(params)
      .then(() => {
        ready()
      })
      .catch(e => {
        handleBootError(e)
      })
  } else {
    ready()
  }
}

const handleBootError = e => {
  if ((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)('!')) {
    navigate('!', { request: { error: e } })
  } else {
    console.error(e)
  }
}

/**
 * start a new request
 * @param url
 * @param args
 * @param store
 */
const navigate = (url, args = {}, store) => {
  if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(url)) {
    url = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getHashByName)(url)
    if (!url) {
      return
    }
  }

  let hash = getHash()
  if (!(0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.mustUpdateLocationHash)() && forcedHash) {
    hash = forcedHash
  }
  if (hash.replace(/^#/, '') !== url) {
    // push request in the queue
    queue(url, args, store)

    setHash(url)
    if (!(0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.mustUpdateLocationHash)()) {
      forcedHash = url
      handleHashChange(url)
        .then(() => {
          _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
        })
        .catch(e => {
          console.error(e)
        })
    }
  } else if (args.reload) {
    // push request in the queue
    queue(url, args, store)

    handleHashChange(url)
      .then(() => {
        _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
      })
      .catch(e => {
        console.error(e)
      })
  }
}

const queue = (hash, args = {}, store) => {
  hash = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.cleanHash)(hash)
  if (!navigateQueue.has(hash)) {
    for (let request of navigateQueue.values()) {
      request.cancel()
    }
    const request = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.createRequest)(hash, args, store)
    navigateQueue.set(decodeURIComponent(hash), request)

    return request
  }
  return false
}

/**
 * Handle change of hash
 * @param override
 * @returns {Promise<void>}
 */
const handleHashChange = async override => {
  const hash = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.cleanHash)(override || getHash())
  const queueId = decodeURIComponent(hash)
  let request = navigateQueue.get(queueId)

  // handle hash updated manually
  if (!request && !navigateQueue.size) {
    request = queue(hash)
  }

  const route = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getRouteByHash)(hash)

  if (!route) {
    if ((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)('*')) {
      navigate('*', { failedHash: hash })
    } else {
      console.error(`Unable to navigate to: ${hash}`)
    }
    return
  }

  // update current processed request
  request.hash = hash
  request.route = route

  let result = await (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.beforeEachRoute)((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveHash)(), request)

  // test if a local hook is configured for the route
  if (route.beforeNavigate) {
    result = await route.beforeNavigate((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveHash)(), request)
  }

  if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(result)) {
    // only if resolve value is explicitly true
    // we continue the current route request
    if (result) {
      return resolveHashChange(request)
    }
  } else {
    // if navigation guard didn't return true
    // we cancel the current request
    request.cancel()
    navigateQueue.delete(queueId)

    if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isString)(result)) {
      navigate(result)
    } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(result)) {
      let store = true
      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(result.store)) {
        store = result.store
      }
      navigate(result.path, result.params, store)
    }
  }
}

/**
 * Continue processing the hash change if not blocked
 * by global or local hook
 * @param request - {}
 */
const resolveHashChange = request => {
  const hash = request.hash
  const route = request.route
  const queueId = decodeURIComponent(hash)
  // store last requested hash so we can
  // prevent a route that resolved later
  // from displaying itself
  ;(0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.setLastHash)(hash)

  if (route.path) {
    const component = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getComponent)(route.path)
    // if a hook is provided for the current route
    if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(route.hook)) {
      const urlParams = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getValuesFromHash)(hash, route.path)
      const params = {}
      for (const key of urlParams.keys()) {
        params[key] = urlParams.get(key)
      }
      route.hook(_utils_router__WEBPACK_IMPORTED_MODULE_1__.app, { ...params })
    }
    // if there is a component attached to the route
    if (component) {
      // force page to root state to prevent shared state issues
      const activePage = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActivePage)()
      if (activePage) {
        const keepAlive = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.keepActivePageAlive)((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveRoute)(), request)
        if (activePage && route.path === (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveRoute)() && !keepAlive) {
          activePage._setState('')
        }
      }

      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isPage)(component, _utils_router__WEBPACK_IMPORTED_MODULE_1__.stage)) {
        (0,_utils_loader__WEBPACK_IMPORTED_MODULE_5__.load)(request).then(() => {
          _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
          navigateQueue.delete(queueId)
        })
      } else {
        // of the component is not a constructor
        // or a Component instance we can assume
        // that it's a dynamic import
        component()
          .then(contents => {
            return contents.default
          })
          .then(module => {
            (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.storeComponent)(route.path, module)
            return (0,_utils_loader__WEBPACK_IMPORTED_MODULE_5__.load)(request)
          })
          .then(() => {
            _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
            navigateQueue.delete(queueId)
          })
      }
    } else {
      navigateQueue.delete(queueId)
    }
  }
}

/**
 * Directional step in history
 * @param direction
 */
const step = (level = 0) => {
  if (!level || isNaN(level)) {
    return false
  }
  const history = (0,_utils_history__WEBPACK_IMPORTED_MODULE_3__.getHistory)()
  // for now we only support negative numbers
  level = Math.abs(level)

  // we can't step back past the amount
  // of history entries
  if (level > history.length) {
    if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(_utils_router__WEBPACK_IMPORTED_MODULE_1__.app._handleAppClose)) {
      return _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._handleAppClose()
    }
    return false
  } else if (history.length) {
    // for now we only support history back
    const route = history.splice(history.length - level, level)[0]
    // store changed history
    ;(0,_utils_history__WEBPACK_IMPORTED_MODULE_3__.setHistory)(history)
    return navigate(
      route.hash,
      {
        [_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.backtrack]: true,
        [_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.historyState]: route.state,
      },
      false
    )
  } else if (_utils_router__WEBPACK_IMPORTED_MODULE_1__.routerConfig.get('backtrack')) {
    const hashLastPart = /(\/:?[\w%\s-]+)$/
    let hash = (0,_utils_regex__WEBPACK_IMPORTED_MODULE_6__.stripRegex)(getHash())
    let floor = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getFloor)(hash)

    // test if we got deep-linked
    if (floor > 1) {
      while (floor--) {
        // strip of last part
        hash = hash.replace(hashLastPart, '')
        // if we have a configured route
        // we navigate to it
        if ((0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getRouteByHash)(hash)) {
          return navigate(hash, { [_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.backtrack]: true }, false)
        }
      }
    }
  }
  return false
}

/**
 * Resume Router's page loading process after
 * the BootComponent became visible;
 */
const resume = () => {
  if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isString)(resumeHash)) {
    navigate(resumeHash, false)
    resumeHash = ''
  } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(resumeHash)) {
    resumeHash().then(res => {
      resumeHash = ''
      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
        navigate(res.path, res.params)
      } else {
        navigate(res)
      }
    })
  } else {
    console.warn('[Router]: resume() called but no hash found')
  }
}

/**
 * Force reload active hash
 */
const reload = () => {
  if (!isNavigating()) {
    const hash = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveHash)()
    navigate(hash, { reload: true }, false)
  }
}

/**
 * Query if the Router is still processing a Request
 * @returns {boolean}
 */
const isNavigating = () => {
  if (navigateQueue.size) {
    let isProcessing = false
    for (let request of navigateQueue.values()) {
      if (!request.isCancelled) {
        isProcessing = true
      }
    }
    return isProcessing
  }
  return false
}

const getResumeHash = () => {
  return resumeHash
}

/**
 * By default we return the location hash
 * @returns {string}
 */
let getHash = () => {
  return document.location.hash
}

/**
 * Update location hash
 * @param url
 */
let setHash = url => {
  document.location.hash = url
}

/**
 * This can be called from the platform / bootstrapper to override
 * the default getting and setting of the hash
 * @param config
 */
const initRouter = config => {
  if (config.getHash) {
    getHash = config.getHash
  }
  if (config.setHash) {
    setHash = config.setHash
  }
}

/**
 * On hash change we start processing
 */
const registerListener = () => {
  _Registry__WEBPACK_IMPORTED_MODULE_8__["default"].addEventListener(window, 'hashchange', async () => {
    if ((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.mustUpdateLocationHash)()) {
      try {
        await handleHashChange()
      } catch (e) {
        console.error(e)
      }
    }
  })
}

/**
 * Navigate to root hash
 */
const root = () => {
  const rootHash = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getRootHash)()
  if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isString)(rootHash)) {
    navigate(rootHash)
  } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(rootHash)) {
    rootHash().then(res => {
      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
        navigate(res.path, res.params)
      } else {
        navigate(res)
      }
    })
  }
}

// export API
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  startRouter,
  navigate,
  resume,
  step,
  go: step,
  back: step.bind(null, -1),
  activePage: _utils_router__WEBPACK_IMPORTED_MODULE_1__.getActivePage,
  getActivePage() {
    // warning
    return (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActivePage)()
  },
  getActiveRoute: _utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveRoute,
  getActiveHash: _utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveHash,
  focusWidget: _utils_widgets__WEBPACK_IMPORTED_MODULE_2__.focusWidget,
  getActiveWidget: _utils_widgets__WEBPACK_IMPORTED_MODULE_2__.getActiveWidget,
  restoreFocus: _utils_widgets__WEBPACK_IMPORTED_MODULE_2__.restoreFocus,
  isNavigating,
  getHistory: _utils_history__WEBPACK_IMPORTED_MODULE_3__.getHistory,
  setHistory: _utils_history__WEBPACK_IMPORTED_MODULE_3__.setHistory,
  getHistoryState: _utils_history__WEBPACK_IMPORTED_MODULE_3__.getHistoryState,
  replaceHistoryState: _utils_history__WEBPACK_IMPORTED_MODULE_3__.replaceHistoryState,
  getQueryStringParams: _utils_helpers__WEBPACK_IMPORTED_MODULE_0__.getQueryStringParams,
  reload,
  symbols: _utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols,
  App: _base__WEBPACK_IMPORTED_MODULE_7__.RoutedApp,
  // keep backwards compatible
  focusPage: _utils_widgets__WEBPACK_IMPORTED_MODULE_2__.restoreFocus,
  root: root,
  /**
   * Deprecated api methods
   */
  setupRoutes() {
    console.warn('Router: setupRoutes is deprecated, consolidate your configuration')
    console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration')
  },
  on() {
    console.warn('Router.on() is deprecated, consolidate your configuration')
    console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration')
  },
  before() {
    console.warn('Router.before() is deprecated, consolidate your configuration')
    console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration')
  },
  after() {
    console.warn('Router.after() is deprecated, consolidate your configuration')
    console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration')
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/model/Request.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/model/Request.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Request)
/* harmony export */ });
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _utils_register__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/register */ "./node_modules/@lightningjs/sdk/src/Router/utils/register.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class Request {
  constructor(hash = '', navArgs, storeCaller) {
    /**
     * Hash we navigate to
     * @type {string}
     * @private
     */
    this._hash = hash

    /**
     * Do we store previous hash in history
     * @type {boolean}
     * @private
     */
    this._storeCaller = storeCaller

    /**
     * Request and navigate data
     * @type {Map}
     * @private
     */
    this._register = new Map()

    /**
     * Flag if the instance is created due to
     * this request
     * @type {boolean}
     * @private
     */
    this._isCreated = false

    /**
     * Flag if the instance is shared between
     * previous and current request
     * @type {boolean}
     * @private
     */
    this._isSharedInstance = false

    /**
     * Flag if the request has been cancelled
     * @type {boolean}
     * @private
     */
    this._cancelled = false

    /**
     * if instance is shared between requests we copy state object
     * from instance before the new request overrides state
     * @type {null}
     * @private
     */
    this._copiedHistoryState = null

    // if there are arguments attached to navigate()
    // we store them in new request
    if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(navArgs)) {
      this._register = (0,_utils_register__WEBPACK_IMPORTED_MODULE_1__.createRegister)(navArgs)
    } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(navArgs)) {
      // if second navigate() argument is explicitly
      // set to false we prevent the calling page
      // from ending up in history
      this._storeCaller = navArgs
    }
    // @todo: remove because we can simply check
    // ._storeCaller property
    this._register.set(_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.store, this._storeCaller)
  }

  cancel() {
    _Log__WEBPACK_IMPORTED_MODULE_2__["default"].debug('[router]:', `cancelled ${this._hash}`)
    this._cancelled = true
  }

  get url() {
    return this._hash
  }

  get register() {
    return this._register
  }

  get hash() {
    return this._hash
  }

  set hash(args) {
    this._hash = args
  }

  get route() {
    return this._route
  }

  set route(args) {
    this._route = args
  }

  get provider() {
    return this._provider
  }

  set provider(args) {
    this._provider = args
  }

  get providerType() {
    return this._providerType
  }

  set providerType(args) {
    this._providerType = args
  }

  set page(args) {
    this._page = args
  }

  get page() {
    return this._page
  }

  set isCreated(args) {
    this._isCreated = args
  }

  get isCreated() {
    return this._isCreated
  }

  get isSharedInstance() {
    return this._isSharedInstance
  }

  set isSharedInstance(args) {
    this._isSharedInstance = args
  }

  get isCancelled() {
    return this._cancelled
  }

  set copiedHistoryState(v) {
    this._copiedHistoryState = v
  }

  get copiedHistoryState() {
    return this._copiedHistoryState
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/model/Route.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/model/Route.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Route)
/* harmony export */ });
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class Route {
  constructor(config = {}) {
    // keep backwards compatible
    let type = ['on', 'before', 'after'].reduce((acc, type) => {
      return (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(config[type]) ? type : acc
    }, undefined)

    this._cfg = config
    if (type) {
      this._provider = {
        type,
        request: config[type],
      }
    }
  }

  get path() {
    return this._cfg.path
  }

  get component() {
    return this._cfg.component
  }

  get options() {
    return this._cfg.options
  }

  get widgets() {
    return this._cfg.widgets
  }

  get cache() {
    return this._cfg.cache
  }

  get hook() {
    return this._cfg.hook
  }

  get beforeNavigate() {
    return this._cfg.beforeNavigate
  }

  get provider() {
    return this._provider
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/transitions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/transitions.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const fade = (i, o) => {
  return new Promise(resolve => {
    i.patch({
      alpha: 0,
      visible: true,
      smooth: {
        alpha: [1, { duration: 0.5, delay: 0.1 }],
      },
    })
    // resolve on y finish
    i.transition('alpha').on('finish', () => {
      if (o) {
        o.visible = false
      }
      resolve()
    })
  })
}

const crossFade = (i, o) => {
  return new Promise(resolve => {
    i.patch({
      alpha: 0,
      visible: true,
      smooth: {
        alpha: [1, { duration: 0.5, delay: 0.1 }],
      },
    })
    if (o) {
      o.patch({
        smooth: {
          alpha: [0, { duration: 0.5, delay: 0.3 }],
        },
      })
    }
    // resolve on y finish
    i.transition('alpha').on('finish', () => {
      resolve()
    })
  })
}

const moveOnAxes = (axis, direction, i, o) => {
  const bounds = axis === 'x' ? 1920 : 1080
  return new Promise(resolve => {
    i.patch({
      [`${axis}`]: direction ? bounds * -1 : bounds,
      visible: true,
      smooth: {
        [`${axis}`]: [0, { duration: 0.4, delay: 0.2 }],
      },
    })
    // out is optional
    if (o) {
      o.patch({
        [`${axis}`]: 0,
        smooth: {
          [`${axis}`]: [direction ? bounds : bounds * -1, { duration: 0.4, delay: 0.2 }],
        },
      })
    }
    // resolve on y finish
    i.transition(axis).on('finish', () => {
      resolve()
    })
  })
}

const up = (i, o) => {
  return moveOnAxes('y', 0, i, o)
}

const down = (i, o) => {
  return moveOnAxes('y', 1, i, o)
}

const left = (i, o) => {
  return moveOnAxes('x', 0, i, o)
}

const right = (i, o) => {
  return moveOnAxes('x', 1, i, o)
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  fade,
  crossFade,
  up,
  down,
  left,
  right,
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/components.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/components.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createComponent": () => (/* binding */ createComponent)
/* harmony export */ });
/* harmony import */ var _widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./widgets */ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const createComponent = (stage, type) => {
  return stage.c({
    type,
    visible: false,
    widgets: (0,_widgets__WEBPACK_IMPORTED_MODULE_0__.getReferences)(),
  })
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/emit.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((page, events = [], params = {}) => {
  if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isArray)(events)) {
    events = [events]
  }
  events.forEach(e => {
    const event = `_on${(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.ucfirst)(e)}`
    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(page[event])) {
      page[event](params)
    }
  })
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cleanHash": () => (/* binding */ cleanHash),
/* harmony export */   "getConfigMap": () => (/* binding */ getConfigMap),
/* harmony export */   "getQueryStringParams": () => (/* binding */ getQueryStringParams),
/* harmony export */   "incorrectParams": () => (/* binding */ incorrectParams),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBoolean": () => (/* binding */ isBoolean),
/* harmony export */   "isComponentConstructor": () => (/* binding */ isComponentConstructor),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isPage": () => (/* binding */ isPage),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "objectToQueryString": () => (/* binding */ objectToQueryString),
/* harmony export */   "symbols": () => (/* binding */ symbols),
/* harmony export */   "ucfirst": () => (/* binding */ ucfirst)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../index */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const isFunction = v => {
  return typeof v === 'function'
}

const isObject = v => {
  return typeof v === 'object' && v !== null
}

const isBoolean = v => {
  return typeof v === 'boolean'
}

const isPage = v => {
  if (v instanceof _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Element || isComponentConstructor(v)) {
    return true
  }
  return false
}

const isComponentConstructor = type => {
  return type.prototype && 'isComponent' in type.prototype
}

const isArray = v => {
  return Array.isArray(v)
}

const ucfirst = v => {
  return `${v.charAt(0).toUpperCase()}${v.slice(1)}`
}

const isString = v => {
  return typeof v === 'string'
}

const isPromise = method => {
  let result
  if (isFunction(method)) {
    try {
      result = method.apply(null)
    } catch (e) {
      result = e
    }
  } else {
    result = method
  }
  return isObject(result) && isFunction(result.then)
}

const cleanHash = (hash = '') => {
  return hash.replace(/^#/, '').replace(/\/+$/, '')
}

const getConfigMap = () => {
  const routerSettings = _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', 'router')
  const isObj = isObject(routerSettings)
  return [
    'backtrack',
    'gcOnUnload',
    'destroyOnHistoryBack',
    'lazyCreate',
    'lazyDestroy',
    'reuseInstance',
    'autoRestoreRemote',
    'numberNavigation',
    'updateHash',
    'storeSameHash',
  ].reduce((config, key) => {
    config.set(key, isObj ? routerSettings[key] : _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', key))
    return config
  }, new Map())
}

const incorrectParams = (cb, route) => {
  const isIncorrect = /^\w*?\s?\(\s?\{.*?\}\s?\)/i
  if (isIncorrect.test(cb.toString())) {
    console.warn(
      [
        `DEPRECATION: The data-provider for route: ${route} is not correct.`,
        '"page" is no longer a property of the params object but is now the first function parameter: ',
        'https://github.com/rdkcentral/Lightning-SDK/blob/feature/router/docs/plugins/router/dataproviding.md#data-providing',
        "It's supported for now but will be removed in a future release.",
      ].join('\n')
    )
    return true
  }
  return false
}

const getQueryStringParams = (hash = (0,_router__WEBPACK_IMPORTED_MODULE_2__.getActiveHash)()) => {
  const resumeHash = (0,_index__WEBPACK_IMPORTED_MODULE_3__.getResumeHash)()
  if ((hash === '$' || !hash) && resumeHash) {
    if (isString(resumeHash)) {
      hash = resumeHash
    }
  }

  let parse = ''
  const getQuery = /([?&].*)/
  const matches = getQuery.exec(hash)
  const params = {}

  if (document.location && document.location.search) {
    parse = document.location.search
  }

  if (matches && matches.length) {
    let hashParams = matches[1]
    if (parse) {
      // if location.search is not empty we
      // remove the leading ? to create a
      // valid string
      hashParams = hashParams.replace(/^\?/, '')
      // we parse hash params last so they we can always
      // override search params with hash params
      parse = `${parse}&${hashParams}`
    } else {
      parse = hashParams
    }
  }

  if (parse) {
    const urlParams = new URLSearchParams(parse)
    for (const [key, value] of urlParams.entries()) {
      params[key] = value
    }
    return params
  } else {
    return false
  }
}

const objectToQueryString = obj => {
  if (!isObject(obj)) {
    return ''
  }
  return (
    '?' +
    Object.keys(obj)
      .map(key => {
        return `${key}=${obj[key]}`
      })
      .join('&')
  )
}

const symbols = {
  route: Symbol('route'),
  hash: Symbol('hash'),
  store: Symbol('store'),
  fromHistory: Symbol('fromHistory'),
  expires: Symbol('expires'),
  resume: Symbol('resume'),
  backtrack: Symbol('backtrack'),
  historyState: Symbol('historyState'),
  queryParams: Symbol('queryParams'),
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/history.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/history.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getHistory": () => (/* binding */ getHistory),
/* harmony export */   "getHistoryState": () => (/* binding */ getHistoryState),
/* harmony export */   "replaceHistoryState": () => (/* binding */ replaceHistoryState),
/* harmony export */   "setHistory": () => (/* binding */ setHistory),
/* harmony export */   "updateHistory": () => (/* binding */ updateHistory)
/* harmony export */ });
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _route__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Simple flat array that holds the visited hashes + state Object
 * so the router can navigate back to them
 * @type {Array}
 */
let history = []

const updateHistory = request => {
  const hash = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getActiveHash)()
  if (!hash) {
    return
  }

  // navigate storage flag
  const register = request.register
  const forceNavigateStore = register.get(_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.store)

  // test preventStorage on route configuration
  const activeRoute = (0,_route__WEBPACK_IMPORTED_MODULE_1__.getRouteByHash)(hash)
  const preventStorage = (0,_route__WEBPACK_IMPORTED_MODULE_1__.getOption)(activeRoute.options, 'preventStorage')

  // we give prio to navigate storage flag
  let store = (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(forceNavigateStore) ? forceNavigateStore : !preventStorage

  if (store) {
    const toStore = hash.replace(/^\//, '')
    const location = locationInHistory(toStore)
    const stateObject = getStateObject((0,_router__WEBPACK_IMPORTED_MODULE_0__.getActivePage)(), request)
    const routerConfig = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getRouterConfig)()

    // store hash if it's not a part of history or flag for
    // storage of same hash is true
    if (location === -1 || routerConfig.get('storeSameHash')) {
      history.push({ hash: toStore, state: stateObject })
    } else {
      // if we visit the same route we want to sync history
      const prev = history.splice(location, 1)[0]
      history.push({ hash: prev.hash, state: stateObject })
    }
  }
}

const locationInHistory = hash => {
  for (let i = 0; i < history.length; i++) {
    if (history[i].hash === hash) {
      return i
    }
  }
  return -1
}

const getHistoryState = hash => {
  let state = null
  if (history.length) {
    // if no hash is provided we get the last
    // pushed history record
    if (!hash) {
      const record = history[history.length - 1]
      // could be null
      state = record.state
    } else {
      if (locationInHistory(hash) !== -1) {
        const record = history[locationInHistory(hash)]
        state = record.state
      }
    }
  }
  return state
}

const replaceHistoryState = (state = null, hash) => {
  if (!history.length) {
    return
  }
  const location = hash ? locationInHistory(hash) : history.length - 1
  if (location !== -1 && (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isObject)(state)) {
    history[location].state = state
  }
}

const getStateObject = (page, request) => {
  // if the new request shared instance with the
  // previous request we used the copied state object
  if (request.isSharedInstance) {
    if (request.copiedHistoryState) {
      return request.copiedHistoryState
    }
  } else if (page && (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isFunction)(page.historyState)) {
    return page.historyState()
  }
  return null
}

const getHistory = () => {
  return history.slice(0)
}

const setHistory = (arr = []) => {
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isArray)(arr)) {
    history = arr
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/loader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/loader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "load": () => (/* binding */ load),
/* harmony export */   "mustReuse": () => (/* binding */ mustReuse)
/* harmony export */ });
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./provider */ "./node_modules/@lightningjs/sdk/src/Router/utils/provider.js");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components */ "./node_modules/@lightningjs/sdk/src/Router/utils/components.js");
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transition */ "./node_modules/@lightningjs/sdk/src/Router/utils/transition.js");
/* harmony import */ var _widgets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./widgets */ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js");
/* harmony import */ var _emit__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./emit */ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js");
/* harmony import */ var _route__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../index */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./history */ "./node_modules/@lightningjs/sdk/src/Router/utils/history.js");
/* harmony import */ var _regex__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./regex */ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */















/**
 * The actual loading of the component
 * */
const load = async request => {
  let expired = false
  try {
    request = await loader(request)
    if (request && !request.isCancelled) {
      // in case of on() providing we need to reset
      // app state;
      if (_router__WEBPACK_IMPORTED_MODULE_0__.app.state === 'Loading') {
        if ((0,_router__WEBPACK_IMPORTED_MODULE_0__.getPreviousState)() === 'Widgets') {
          _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('Widgets', [(0,_widgets__WEBPACK_IMPORTED_MODULE_6__.getActiveWidget)()])
        } else {
          _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('')
        }
      }
      // Do page transition if instance
      // is not shared between the routes
      if (!request.isSharedInstance && !request.isCancelled) {
        await (0,_transition__WEBPACK_IMPORTED_MODULE_5__.executeTransition)(request.page, (0,_router__WEBPACK_IMPORTED_MODULE_0__.getActivePage)())
      }
    } else {
      expired = true
    }
    // on expired we only cleanup
    if (expired || request.isCancelled) {
      _Log__WEBPACK_IMPORTED_MODULE_1__["default"].debug('[router]:', `Rejected ${request.hash} because route to ${(0,_router__WEBPACK_IMPORTED_MODULE_0__.getLastHash)()} started`)
      if (request.isCreated && !request.isSharedInstance) {
        // remove from render-tree
        _router__WEBPACK_IMPORTED_MODULE_0__.pagesHost.remove(request.page)
      }
    } else {
      (0,_router__WEBPACK_IMPORTED_MODULE_0__.onRequestResolved)(request)
      // resolve promise
      return request.page
    }
  } catch (request) {
    if (!request.route) {
      console.error(request)
    } else if (!expired) {
      // @todo: revisit
      const { route } = request
      // clean up history if modifier is set
      if ((0,_route__WEBPACK_IMPORTED_MODULE_8__.getOption)(route.options, 'clearHistory')) {
        (0,_history__WEBPACK_IMPORTED_MODULE_10__.setHistory)([])
      } else if (!_regex__WEBPACK_IMPORTED_MODULE_11__.isWildcard.test(route.path)) {
        (0,_history__WEBPACK_IMPORTED_MODULE_10__.updateHistory)(request)
      }

      if (request.isCreated && !request.isSharedInstance) {
        // remove from render-tree
        _router__WEBPACK_IMPORTED_MODULE_0__.pagesHost.remove(request.page)
      }
      handleError(request)
    }
  }
}

const loader = async request => {
  const route = request.route
  const hash = request.hash
  const register = request.register

  // todo: grab from Route instance
  let type = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getComponent)(route.path)
  let isConstruct = (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isComponentConstructor)(type)
  let provide = false

  // if it's an instance bt we're not coming back from
  // history we test if we can re-use this instance
  if (!isConstruct && !register.get(_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.backtrack)) {
    if (!mustReuse(route)) {
      type = type.constructor
      isConstruct = true
    }
  }

  // If page is Lightning Component instance
  if (!isConstruct) {
    request.page = type
    // if we have have a data route for current page
    if ((0,_provider__WEBPACK_IMPORTED_MODULE_3__.hasProvider)(route.path)) {
      if ((0,_provider__WEBPACK_IMPORTED_MODULE_3__.isPageExpired)(type) || type[_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.hash] !== hash) {
        provide = true
      }
    }
    let currentRoute = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getActivePage)() && (0,_router__WEBPACK_IMPORTED_MODULE_0__.getActivePage)()[_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.route]
    // if the new route is equal to the current route it means that both
    // route share the Component instance and stack location / since this case
    // is conflicting with the way before() and after() loading works we flag it,
    // and check platform settings in we want to re-use instance
    if (route.path === currentRoute) {
      request.isSharedInstance = true
      // since we're re-using the instance we must attach
      // historyState to the request to prevent it from
      // being overridden.
      if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isFunction)(request.page.historyState)) {
        request.copiedHistoryState = request.page.historyState()
      }
    }
  } else {
    request.page = (0,_components__WEBPACK_IMPORTED_MODULE_4__.createComponent)(_router__WEBPACK_IMPORTED_MODULE_0__.stage, type)
    _router__WEBPACK_IMPORTED_MODULE_0__.pagesHost.a(request.page)
    // test if need to request data provider
    if ((0,_provider__WEBPACK_IMPORTED_MODULE_3__.hasProvider)(route.path)) {
      provide = true
    }
    request.isCreated = true
  }

  // we store hash and route as properties on the page instance
  // that way we can easily calculate new behaviour on page reload
  request.page[_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.hash] = hash
  request.page[_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.route] = route.path

  try {
    if (provide) {
      // extract attached data-provider for route
      // we're processing
      const { type: loadType, provider } = (0,_provider__WEBPACK_IMPORTED_MODULE_3__.getProvider)(route)

      // update running request
      request.provider = provider
      request.providerType = loadType

      await _provider__WEBPACK_IMPORTED_MODULE_3__.dataHooks[loadType](request)

      // we early exit if the current request is expired
      if (hash !== (0,_router__WEBPACK_IMPORTED_MODULE_0__.getLastHash)()) {
        return false
      } else {
        if (request.providerType !== 'after') {
          (0,_emit__WEBPACK_IMPORTED_MODULE_7__["default"])(request.page, 'dataProvided')
        }
        // resolve promise
        return request
      }
    } else {
      (0,_provider__WEBPACK_IMPORTED_MODULE_3__.addPersistData)(request)
      return request
    }
  } catch (e) {
    request.error = e
    return Promise.reject(request)
  }
}

const handleError = request => {
  if (request && request.error) {
    console.error(request.error)
  } else if (request) {
    _Log__WEBPACK_IMPORTED_MODULE_1__["default"].error(request)
  }

  if (request.page && (0,_router__WEBPACK_IMPORTED_MODULE_0__.routeExists)('!')) {
    (0,_index__WEBPACK_IMPORTED_MODULE_9__.navigate)('!', { request }, false)
  }
}

const mustReuse = route => {
  const opt = (0,_route__WEBPACK_IMPORTED_MODULE_8__.getOption)(route.options, 'reuseInstance')
  const config = _router__WEBPACK_IMPORTED_MODULE_0__.routerConfig.get('reuseInstance')

  // route always has final decision
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(opt)) {
    return opt
  }
  return !((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(config) && config === false)
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/provider.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/provider.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addPersistData": () => (/* binding */ addPersistData),
/* harmony export */   "dataHooks": () => (/* binding */ dataHooks),
/* harmony export */   "getProvider": () => (/* binding */ getProvider),
/* harmony export */   "hasProvider": () => (/* binding */ hasProvider),
/* harmony export */   "isPageExpired": () => (/* binding */ isPageExpired),
/* harmony export */   "previousState": () => (/* binding */ previousState)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _route__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _emit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./emit */ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






let previousState

const dataHooks = {
  on: request => {
    previousState = _router__WEBPACK_IMPORTED_MODULE_1__.app.state || ''
    _router__WEBPACK_IMPORTED_MODULE_1__.app._setState('Loading')
    return execProvider(request)
  },
  before: request => {
    return execProvider(request)
  },
  after: request => {
    try {
      execProvider(request, true)
    } catch (e) {
      // for now we fail silently
    }
    return Promise.resolve()
  },
}

const execProvider = (request, emitProvided) => {
  const route = request.route
  const provider = route.provider
  const expires = route.cache ? route.cache * 1000 : 0
  const params = addPersistData(request)
  return provider.request(request.page, { ...params }).then(() => {
    request.page[_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.expires] = Date.now() + expires
    if (emitProvided) {
      (0,_emit__WEBPACK_IMPORTED_MODULE_3__["default"])(request.page, 'dataProvided')
    }
  })
}

const addPersistData = ({ page, route, hash, register = new Map() }) => {
  const urlValues = (0,_route__WEBPACK_IMPORTED_MODULE_2__.getValuesFromHash)(hash, route.path)
  const queryParams = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getQueryStringParams)(hash)
  const pageData = new Map([...urlValues, ...register])
  const params = {}

  // make dynamic url data available to the page
  // as instance properties
  for (let [name, value] of pageData) {
    params[name] = value
  }

  if (queryParams) {
    params[_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.queryParams] = queryParams
  }

  // check navigation register for persistent data
  if (register.size) {
    const obj = {}
    for (let [k, v] of register) {
      obj[k] = v
    }
    page.persist = obj
  }

  // make url data and persist data available
  // via params property
  page.params = params
  ;(0,_emit__WEBPACK_IMPORTED_MODULE_3__["default"])(page, ['urlParams'], params)

  return params
}

/**
 * Test if page passed cache-time
 * @param page
 * @returns {boolean}
 */
const isPageExpired = page => {
  if (!page[_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.expires]) {
    return false
  }

  const expires = page[_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.expires]
  const now = Date.now()

  return now >= expires
}

const hasProvider = path => {
  if ((0,_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)(path)) {
    const record = _router__WEBPACK_IMPORTED_MODULE_1__.routes.get(path)
    return !!record.provider
  }
  return false
}

const getProvider = route => {
  // @todo: fix, route already is passed in
  if ((0,_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)(route.path)) {
    const { provider } = _router__WEBPACK_IMPORTED_MODULE_1__.routes.get(route.path)
    return {
      type: provider.type,
      provider: provider.request,
    }
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/regex.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasLookupId": () => (/* binding */ hasLookupId),
/* harmony export */   "hasRegex": () => (/* binding */ hasRegex),
/* harmony export */   "isNamedGroup": () => (/* binding */ isNamedGroup),
/* harmony export */   "isWildcard": () => (/* binding */ isWildcard),
/* harmony export */   "stripRegex": () => (/* binding */ stripRegex)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const hasRegex = /\{\/(.*?)\/([igm]{0,3})\}/g
const isWildcard = /^[!*$]$/
const hasLookupId = /\/:\w+?@@([0-9]+?)@@/
const isNamedGroup = /^\/:/

/**
 * Test if a route is part regular expressed
 * and replace it for a simple character
 * @param route
 * @returns {*}
 */
const stripRegex = (route, char = 'R') => {
  // if route is part regular expressed we replace
  // the regular expression for a character to
  // simplify floor calculation and backtracking
  if (hasRegex.test(route)) {
    route = route.replace(hasRegex, char)
  }
  return route
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/register.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/register.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRegister": () => (/* binding */ createRegister)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Create a local request register
 * @param flags
 * @returns {Map<any, any>}
 */
const createRegister = flags => {
  const reg = new Map()
  // store user defined and router
  // defined flags in register
  ;[...Object.keys(flags), ...Object.getOwnPropertySymbols(flags)].forEach(key => {
    reg.set(key, flags[key])
  })
  return reg
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/route.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRequest": () => (/* binding */ createRequest),
/* harmony export */   "createRoute": () => (/* binding */ createRoute),
/* harmony export */   "getFloor": () => (/* binding */ getFloor),
/* harmony export */   "getHashByName": () => (/* binding */ getHashByName),
/* harmony export */   "getOption": () => (/* binding */ getOption),
/* harmony export */   "getRouteByHash": () => (/* binding */ getRouteByHash),
/* harmony export */   "getValuesFromHash": () => (/* binding */ getValuesFromHash),
/* harmony export */   "keepActivePageAlive": () => (/* binding */ keepActivePageAlive)
/* harmony export */ });
/* harmony import */ var _regex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex */ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _model_Request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/Request */ "./node_modules/@lightningjs/sdk/src/Router/model/Request.js");
/* harmony import */ var _model_Route__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/Route */ "./node_modules/@lightningjs/sdk/src/Router/model/Route.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Simple route length calculation
 * @param route {string}
 * @returns {number} - floor
 */
const getFloor = route => {
  return (0,_regex__WEBPACK_IMPORTED_MODULE_0__.stripRegex)(route).split('/').length
}

/**
 * return all stored routes that live on the same floor
 * @param floor
 * @returns {Array}
 */
const getRoutesByFloor = floor => {
  const matches = []
  // simple filter of level candidates
  for (let [route] of _router__WEBPACK_IMPORTED_MODULE_1__.routes.entries()) {
    if (getFloor(route) === floor) {
      matches.push(route)
    }
  }
  return matches
}

/**
 * return a matching route by provided hash
 * hash: home/browse/12 will match:
 * route: home/browse/:categoryId
 * @param hash {string}
 * @returns {boolean|{}} - route
 */
const getRouteByHash = hash => {
  // @todo: clean up on handleHash
  hash = hash.replace(/^#/, '')

  const getUrlParts = /(\/?:?[^/]+)/g
  // grab possible candidates from stored routes
  const candidates = getRoutesByFloor(getFloor(hash))
  // break hash down in chunks
  const hashParts = hash.match(getUrlParts) || []

  // to simplify the route matching and prevent look around
  // in our getUrlParts regex we get the regex part from
  // route candidate and store them so that we can reference
  // them when we perform the actual regex against hash
  let regexStore = []

  let matches = candidates.filter(route => {
    let isMatching = true
    // replace regex in route with lookup id => @@{storeId}@@
    if (_regex__WEBPACK_IMPORTED_MODULE_0__.hasRegex.test(route)) {
      const regMatches = route.match(_regex__WEBPACK_IMPORTED_MODULE_0__.hasRegex)
      if (regMatches && regMatches.length) {
        route = regMatches.reduce((fullRoute, regex) => {
          const lookupId = regexStore.length
          fullRoute = fullRoute.replace(regex, `@@${lookupId}@@`)
          regexStore.push(regex.substring(1, regex.length - 1))
          return fullRoute
        }, route)
      }
    }

    const routeParts = route.match(getUrlParts) || []

    for (let i = 0, j = routeParts.length; i < j; i++) {
      const routePart = routeParts[i]
      const hashPart = hashParts[i]

      // Since we support catch-all and regex driven name groups
      // we first test for regex lookup id and see if the regex
      // matches the value from the hash
      if (_regex__WEBPACK_IMPORTED_MODULE_0__.hasLookupId.test(routePart)) {
        const routeMatches = _regex__WEBPACK_IMPORTED_MODULE_0__.hasLookupId.exec(routePart)
        const storeId = routeMatches[1]
        const routeRegex = regexStore[storeId]

        // split regex and modifiers so we can use both
        // to create a new RegExp
        // eslint-disable-next-line
                const regMatches = /\/([^\/]+)\/([igm]{0,3})/.exec(routeRegex)

        if (regMatches && regMatches.length) {
          const expression = regMatches[1]
          const modifiers = regMatches[2]

          const regex = new RegExp(`^/${expression}$`, modifiers)

          if (!regex.test(hashPart)) {
            isMatching = false
          }
        }
      } else if (_regex__WEBPACK_IMPORTED_MODULE_0__.isNamedGroup.test(routePart)) {
        // we kindly skip namedGroups because this is dynamic
        // we only need to the static and regex drive parts
        continue
      } else if (hashPart && routePart.toLowerCase() !== hashPart.toLowerCase()) {
        isMatching = false
      }
    }
    return isMatching
  })

  if (matches.length) {
    if (matches.indexOf(hash) !== -1) {
      const match = matches[matches.indexOf(hash)]
      return _router__WEBPACK_IMPORTED_MODULE_1__.routes.get(match)
    } else {
      // we give prio to static routes over dynamic
      matches = matches.sort(a => {
        return _regex__WEBPACK_IMPORTED_MODULE_0__.isNamedGroup.test(a) ? -1 : 1
      })
      // would be strange if this fails
      // but still we test
      if ((0,_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)(matches[0])) {
        return _router__WEBPACK_IMPORTED_MODULE_1__.routes.get(matches[0])
      }
    }
  }
  return false
}

const getValuesFromHash = (hash = '', path) => {
  // replace the regex definition from the route because
  // we already did the matching part
  path = (0,_regex__WEBPACK_IMPORTED_MODULE_0__.stripRegex)(path, '')

  const getUrlParts = /(\/?:?[\w%\s:.-]+)/g
  const hashParts = hash.match(getUrlParts) || []
  const routeParts = path.match(getUrlParts) || []
  const getNamedGroup = /^\/:([\w-]+)\/?/

  return routeParts.reduce((storage, value, index) => {
    const match = getNamedGroup.exec(value)
    if (match && match.length) {
      storage.set(match[1], decodeURIComponent(hashParts[index].replace(/^\//, '')))
    }
    return storage
  }, new Map())
}

const getOption = (stack, prop) => {
  // eslint-disable-next-line
    if(stack && stack.hasOwnProperty(prop)){
    return stack[prop]
  }
  // we explicitly return undefined since we're testing
  // for explicit test values
}

/**
 * create and return new Route instance
 * @param config
 */
const createRoute = config => {
  // we need to provide a bit of additional logic
  // for the bootComponent
  if (config.path === '$') {
    let options = {
      preventStorage: true,
    }
    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_4__.isObject)(config.options)) {
      options = {
        ...config.options,
        ...options,
      }
    }
    config.options = options
    // if configured add reference to bootRequest
    // as router after provider
    if (_router__WEBPACK_IMPORTED_MODULE_1__.bootRequest) {
      config.after = _router__WEBPACK_IMPORTED_MODULE_1__.bootRequest
    }
  }
  return new _model_Route__WEBPACK_IMPORTED_MODULE_3__["default"](config)
}

/**
 * Create a new Router request object
 * @param url
 * @param args
 * @param store
 * @returns {*}
 */
const createRequest = (url, args, store) => {
  return new _model_Request__WEBPACK_IMPORTED_MODULE_2__["default"](url, args, store)
}

const getHashByName = obj => {
  if (!obj.to && !obj.name) {
    return false
  }
  const route = getRouteByName(obj.to || obj.name)
  const hasDynamicGroup = /\/:([\w-]+)\/?/
  let hash = route

  // if route contains dynamic group
  // we replace them with the provided params
  if (hasDynamicGroup.test(route)) {
    if (obj.params) {
      const keys = Object.keys(obj.params)
      hash = keys.reduce((acc, key) => {
        return acc.replace(`:${key}`, obj.params[key])
      }, route)
    }
    if (obj.query) {
      return `${hash}${(0,_helpers__WEBPACK_IMPORTED_MODULE_4__.objectToQueryString)(obj.query)}`
    }
  }
  return hash
}

const getRouteByName = name => {
  for (let [path, route] of _router__WEBPACK_IMPORTED_MODULE_1__.routes.entries()) {
    if (route.name === name) {
      return path
    }
  }
  return false
}

const keepActivePageAlive = (route, request) => {
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_4__.isString)(route)) {
    const routes = (0,_router__WEBPACK_IMPORTED_MODULE_1__.getRoutes)()
    if (routes.has(route)) {
      route = routes.get(route)
    } else {
      return false
    }
  }

  const register = request.register
  const routeOptions = route.options

  if (register.has('keepAlive')) {
    return register.get('keepAlive')
  } else if (routeOptions && routeOptions.keepAlive) {
    return routeOptions.keepAlive
  }

  return false
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/router.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "afterEachRoute": () => (/* binding */ afterEachRoute),
/* harmony export */   "app": () => (/* binding */ app),
/* harmony export */   "application": () => (/* binding */ application),
/* harmony export */   "beforeEachRoute": () => (/* binding */ beforeEachRoute),
/* harmony export */   "bootRequest": () => (/* binding */ bootRequest),
/* harmony export */   "bootRouter": () => (/* binding */ bootRouter),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "getActiveHash": () => (/* binding */ getActiveHash),
/* harmony export */   "getActivePage": () => (/* binding */ getActivePage),
/* harmony export */   "getActiveRoute": () => (/* binding */ getActiveRoute),
/* harmony export */   "getBootRequest": () => (/* binding */ getBootRequest),
/* harmony export */   "getComponent": () => (/* binding */ getComponent),
/* harmony export */   "getLastHash": () => (/* binding */ getLastHash),
/* harmony export */   "getPreviousState": () => (/* binding */ getPreviousState),
/* harmony export */   "getRootHash": () => (/* binding */ getRootHash),
/* harmony export */   "getRouterConfig": () => (/* binding */ getRouterConfig),
/* harmony export */   "getRoutes": () => (/* binding */ getRoutes),
/* harmony export */   "mustUpdateLocationHash": () => (/* binding */ mustUpdateLocationHash),
/* harmony export */   "onRequestResolved": () => (/* binding */ onRequestResolved),
/* harmony export */   "pagesHost": () => (/* binding */ pagesHost),
/* harmony export */   "routeExists": () => (/* binding */ routeExists),
/* harmony export */   "routerConfig": () => (/* binding */ routerConfig),
/* harmony export */   "routes": () => (/* binding */ routes),
/* harmony export */   "setActiveHash": () => (/* binding */ setActiveHash),
/* harmony export */   "setActivePage": () => (/* binding */ setActivePage),
/* harmony export */   "setLastHash": () => (/* binding */ setLastHash),
/* harmony export */   "setPreviousState": () => (/* binding */ setPreviousState),
/* harmony export */   "stage": () => (/* binding */ stage),
/* harmony export */   "storeComponent": () => (/* binding */ storeComponent),
/* harmony export */   "updateHash": () => (/* binding */ updateHash),
/* harmony export */   "widgetsHost": () => (/* binding */ widgetsHost)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _route__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components */ "./node_modules/@lightningjs/sdk/src/Router/utils/components.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _regex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./regex */ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js");
/* harmony import */ var _emit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./emit */ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js");
/* harmony import */ var _widgets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./widgets */ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./history */ "./node_modules/@lightningjs/sdk/src/Router/utils/history.js");
/* harmony import */ var _Application__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../Application */ "./node_modules/@lightningjs/sdk/src/Application/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












/**
 * @type {Lightning.Application}
 */
let application

/**
 * Actual instance of the app
 * @type {Lightning.Component}
 */
let app

/**
 * Component that hosts all routed pages
 * @type {Lightning.Component}
 */
let pagesHost

/**
 * @type {Lightning.Stage}
 */
let stage

/**
 * Platform driven Router configuration
 * @type {Map<string>}
 */
let routerConfig

/**
 * Component that hosts all attached widgets
 * @type {Lightning.Component}
 */
let widgetsHost

/**
 * Hash we point the browser to when we boot the app
 * and there is no deep-link provided
 * @type {string|Function}
 */
let rootHash

/**
 * Boot request will fire before app start
 * can be used to execute some global logic
 * and can be configured
 */
let bootRequest

/**
 * Flag if we need to update the browser location hash.
 * Router can work without.
 * @type {boolean}
 */
let updateHash = true

/**
 * Will be called before a route starts, can be overridden
 * via routes config
 * @param from - route we came from
 * @param to - route we navigate to
 * @returns {Promise<*>}
 */
// eslint-disable-next-line
let beforeEachRoute = async (from, to)=>{
  return true
}

/**
 *  * Will be called after a navigate successfully resolved,
 * can be overridden via routes config
 */
let afterEachRoute = () => {}

/**
 * All configured routes
 * @type {Map<string, object>}
 */
let routes = new Map()

/**
 * Store all page components per route
 * @type {Map<string, object>}
 */
let components = new Map()

/**
 * Flag if router has been initialised
 * @type {boolean}
 */
let initialised = false

/**
 * Current page being rendered on screen
 * @type {null}
 */
let activePage = null
let activeHash
let activeRoute

/**
 *  During the process of a navigation request a new
 *  request can start, to prevent unwanted behaviour
 *  the navigate()-method stores the last accepted hash
 *  so we can invalidate any prior requests
 */
let lastAcceptedHash

/**
 * With on()-data providing behaviour the Router forced the App
 * in a Loading state. When the data-provider resolves we want to
 * change the state back to where we came from
 */
let previousState

const mixin = app => {
  // by default the Router Baseclass provides the component
  // reference in which we store our pages
  if (app.pages) {
    pagesHost = app.pages.childList
  }
  // if the app is using widgets we grab refs
  // and hide all the widgets
  if (app.widgets && app.widgets.children) {
    widgetsHost = app.widgets.childList
    // hide all widgets on boot
    widgetsHost.forEach(w => (w.visible = false))
  }
  app._handleBack = e => {
    (0,_index__WEBPACK_IMPORTED_MODULE_1__.step)(-1)
    e.preventDefault()
  }
}

const bootRouter = (config, instance) => {
  let { appInstance, routes } = config

  // if instance is provided and it's and Lightning Component instance
  if (instance && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isPage)(instance)) {
    app = instance
  }
  if (!app) {
    app = appInstance || _Application__WEBPACK_IMPORTED_MODULE_9__.AppInstance
  }

  application = app.application
  pagesHost = application.childList
  stage = app.stage
  routerConfig = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getConfigMap)()

  mixin(app)

  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isArray)(routes)) {
    setup(config)
  } else if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(routes)) {
    console.warn('[Router]: Calling Router.route() directly is deprecated.')
    console.warn(
      'Use object config: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration'
    )
  }
}

const setup = config => {
  if (!initialised) {
    init(config)
  }
  config.routes.forEach(r => {
    const path = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.cleanHash)(r.path)
    if (!routeExists(path)) {
      const route = (0,_route__WEBPACK_IMPORTED_MODULE_2__.createRoute)(r)
      routes.set(path, route)
      // if route has a configured component property
      // we store it in a different map to simplify
      // the creating and destroying per route
      if (route.component) {
        let type = route.component
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isComponentConstructor)(type)) {
          if (!routerConfig.get('lazyCreate')) {
            type = (0,_components__WEBPACK_IMPORTED_MODULE_3__.createComponent)(stage, type)
            pagesHost.a(type)
          }
        }
        components.set(path, type)
      }
    } else {
      console.error(`${path} already exists in routes configuration`)
    }
  })
}

const init = config => {
  rootHash = config.root
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(config.boot)) {
    bootRequest = config.boot
  }
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(config.updateHash)) {
    updateHash = config.updateHash
  }
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(config.beforeEachRoute)) {
    beforeEachRoute = config.beforeEachRoute
  }
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(config.afterEachRoute)) {
    afterEachRoute = config.afterEachRoute
  }
  if (config.bootComponent) {
    console.warn(
      '[Router]: Boot Component is now available as a special router: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration?id=special-routes'
    )
    console.warn(
      '[Router]: setting { bootComponent } property will be deprecated in a future release'
    )
    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isPage)(config.bootComponent)) {
      config.routes.push({
        path: '$',
        component: config.bootComponent,
        // we try to assign the bootRequest as after data-provider
        // so it will behave as any other component
        after: bootRequest || null,
        options: {
          preventStorage: true,
        },
      })
    } else {
      console.error(`[Router]: ${config.bootComponent} is not a valid boot component`)
    }
  }
  initialised = true
}

const storeComponent = (route, type) => {
  if (components.has(route)) {
    components.set(route, type)
  }
}

const getComponent = route => {
  if (components.has(route)) {
    return components.get(route)
  }
  return null
}
/**
 * Test if router needs to update browser location hash
 * @returns {boolean}
 */
const mustUpdateLocationHash = () => {
  if (!routerConfig || !routerConfig.size) {
    return false
  }
  // we need support to either turn change hash off
  // per platform or per app
  const updateConfig = routerConfig.get('updateHash')
  return !(((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(updateConfig) && !updateConfig) || ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(updateHash) && !updateHash))
}

/**
 * Will be called when a new navigate() request has completed
 * and has not been expired due to it's async nature
 * @param request
 */
const onRequestResolved = request => {
  const hash = request.hash
  const route = request.route
  const register = request.register
  const page = request.page

  // clean up history if modifier is set
  if ((0,_route__WEBPACK_IMPORTED_MODULE_2__.getOption)(route.options, 'clearHistory')) {
    (0,_history__WEBPACK_IMPORTED_MODULE_8__.setHistory)([])
  } else if (hash && !_regex__WEBPACK_IMPORTED_MODULE_5__.isWildcard.test(route.path)) {
    (0,_history__WEBPACK_IMPORTED_MODULE_8__.updateHistory)(request)
  }

  // we only update the stackLocation if a route
  // is not expired before it resolves
  storeComponent(route.path, page)

  if (request.isSharedInstance || !request.isCreated) {
    (0,_emit__WEBPACK_IMPORTED_MODULE_6__["default"])(page, 'changed')
  } else if (request.isCreated) {
    (0,_emit__WEBPACK_IMPORTED_MODULE_6__["default"])(page, 'mounted')
  }

  // only update widgets if we have a host
  if (widgetsHost) {
    (0,_widgets__WEBPACK_IMPORTED_MODULE_7__.updateWidgets)(route.widgets, page)
  }

  // we want to clean up if there is an
  // active page that is not being shared
  // between current and previous route
  if (getActivePage() && !request.isSharedInstance) {
    cleanUp(activePage, request)
  }

  // provide history object to active page
  if (register.get(_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.historyState) && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(page.historyState)) {
    page.historyState(register.get(_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.historyState))
  }

  setActivePage(page)

  activeHash = request.hash
  activeRoute = route.path

  // cleanup all cancelled requests
  for (let request of _index__WEBPACK_IMPORTED_MODULE_1__.navigateQueue.values()) {
    if (request.isCancelled && request.hash) {
      _index__WEBPACK_IMPORTED_MODULE_1__.navigateQueue["delete"](request.hash)
    }
  }

  afterEachRoute(request)

  _Log__WEBPACK_IMPORTED_MODULE_4__["default"].info('[route]:', route.path)
  _Log__WEBPACK_IMPORTED_MODULE_4__["default"].info('[hash]:', hash)
}

const cleanUp = (page, request) => {
  const route = activeRoute
  const register = request.register
  const lazyDestroy = routerConfig.get('lazyDestroy')
  const destroyOnBack = routerConfig.get('destroyOnHistoryBack')
  const keepAlive = register.get('keepAlive')
  const isFromHistory = register.get(_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.backtrack)

  let doCleanup = false

  // if this request is executed due to a step back in history
  // and we have configured to destroy active page when we go back
  // in history or lazyDestory is enabled
  if (isFromHistory && (destroyOnBack || lazyDestroy)) {
    doCleanup = true
  }

  // clean up if lazyDestroy is enabled and the keepAlive flag
  // in navigation register is false
  if (lazyDestroy && !keepAlive) {
    doCleanup = true
  }

  // if the current and new request share the same route blueprint
  if (activeRoute === request.route.path) {
    doCleanup = true
  }

  if (doCleanup) {
    // grab original class constructor if
    // statemachine routed else store constructor
    storeComponent(route, page._routedType || page.constructor)

    // actual remove of page from memory
    pagesHost.remove(page)

    // force texture gc() if configured
    // so we can cleanup textures in the same tick
    if (routerConfig.get('gcOnUnload')) {
      stage.gc()
    }
  } else {
    // If we're not removing the page we need to
    // reset it's properties
    page.patch({
      x: 0,
      y: 0,
      scale: 1,
      alpha: 1,
      visible: false,
    })
  }
}

const getActiveHash = () => {
  return activeHash
}

const setActiveHash = hash => {
  activeHash = hash
}

const setActivePage = page => {
  activePage = page
}

const getActivePage = () => {
  return activePage
}

const getActiveRoute = () => {
  return activeRoute
}

const getLastHash = () => {
  return lastAcceptedHash
}

const setLastHash = hash => {
  lastAcceptedHash = hash
}

const setPreviousState = state => {
  previousState = state
}

const getPreviousState = () => {
  return previousState
}

const routeExists = key => {
  return routes.has(key)
}

const getRootHash = () => {
  return rootHash
}

const getBootRequest = () => {
  return bootRequest
}

const getRouterConfig = () => {
  return routerConfig
}

const getRoutes = () => {
  return routes
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/transition.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/transition.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "executeTransition": () => (/* binding */ executeTransition)
/* harmony export */ });
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transitions */ "./node_modules/@lightningjs/sdk/src/Router/transitions.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * execute transition between new / old page and
 * toggle the defined widgets
 * @todo: platform override default transition
 * @param pageIn
 * @param pageOut
 */
const executeTransition = (pageIn, pageOut = null) => {
  const transition = pageIn.pageTransition || pageIn.easing
  const hasCustomTransitions = !!(pageIn.smoothIn || pageIn.smoothInOut || transition)
  const transitionsDisabled = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getRouterConfig)().get('disableTransitions')

  if (pageIn.easing) {
    console.warn('easing() method is deprecated and will be removed. Use pageTransition()')
  }

  // default behaviour is a visibility toggle
  if (!hasCustomTransitions || transitionsDisabled) {
    pageIn.visible = true
    if (pageOut) {
      pageOut.visible = false
    }
    return Promise.resolve()
  }

  if (transition) {
    let type
    try {
      type = transition.call(pageIn, pageIn, pageOut)
    } catch (e) {
      type = 'crossFade'
    }

    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.isPromise)(type)) {
      return type
    }

    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.isString)(type)) {
      const fn = _transitions__WEBPACK_IMPORTED_MODULE_2__["default"][type]
      if (fn) {
        return fn(pageIn, pageOut)
      }
    }

    // keep backwards compatible for now
    if (pageIn.smoothIn) {
      // provide a smooth function that resolves itself
      // on transition finish
      const smooth = (p, v, args = {}) => {
        return new Promise(resolve => {
          pageIn.visible = true
          pageIn.setSmooth(p, v, args)
          pageIn.transition(p).on('finish', () => {
            resolve()
          })
        })
      }
      return pageIn.smoothIn({ pageIn, smooth })
    }
  }
  return _transitions__WEBPACK_IMPORTED_MODULE_2__["default"].crossFade(pageIn, pageOut)
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "focusWidget": () => (/* binding */ focusWidget),
/* harmony export */   "getActiveWidget": () => (/* binding */ getActiveWidget),
/* harmony export */   "getReferences": () => (/* binding */ getReferences),
/* harmony export */   "handleRemote": () => (/* binding */ handleRemote),
/* harmony export */   "restoreFocus": () => (/* binding */ restoreFocus),
/* harmony export */   "setActiveWidget": () => (/* binding */ setActiveWidget),
/* harmony export */   "updateWidgets": () => (/* binding */ updateWidgets)
/* harmony export */ });
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _emit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./emit */ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





let activeWidget = null

const getReferences = () => {
  if (!_router__WEBPACK_IMPORTED_MODULE_0__.widgetsHost) {
    return
  }
  return _router__WEBPACK_IMPORTED_MODULE_0__.widgetsHost.get().reduce((storage, widget) => {
    const key = widget.ref.toLowerCase()
    storage[key] = widget
    return storage
  }, {})
}

/**
 * update the visibility of the available widgets
 * for the current page / route
 * @param page
 */
const updateWidgets = (widgets, page) => {
  // force lowercase lookup
  const configured = (widgets || []).map(ref => ref.toLowerCase())

  _router__WEBPACK_IMPORTED_MODULE_0__.widgetsHost.forEach(widget => {
    widget.visible = configured.indexOf(widget.ref.toLowerCase()) !== -1
    if (widget.visible) {
      (0,_emit__WEBPACK_IMPORTED_MODULE_2__["default"])(widget, ['activated'], page)
    }
  })
  if (_router__WEBPACK_IMPORTED_MODULE_0__.app.state === 'Widgets' && activeWidget && !activeWidget.visible) {
    _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('')
  }
}

const getWidgetByName = name => {
  name = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.ucfirst)(name)
  return _router__WEBPACK_IMPORTED_MODULE_0__.widgetsHost.getByRef(name) || false
}

/**
 * delegate app focus to a on-screen widget
 * @param name - {string}
 */
const focusWidget = name => {
  const widget = getWidgetByName(name)
  if (widget) {
    setActiveWidget(widget)

    // if app is already in 'Widgets' state we can assume that
    // focus has been delegated from one widget to another so
    // we need to set the new widget reference and trigger a
    // new focus calculation of Lightning's focuspath
    if (_router__WEBPACK_IMPORTED_MODULE_0__.app.state === 'Widgets') {
      _router__WEBPACK_IMPORTED_MODULE_0__.app.reload(activeWidget)
    } else {
      _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('Widgets', [activeWidget])
    }
  }
}

const handleRemote = (type, name) => {
  if (type === 'widget') {
    focusWidget(name)
  } else if (type === 'page') {
    restoreFocus()
  }
}

const restoreFocus = () => {
  activeWidget = null
  _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('')
}

const getActiveWidget = () => {
  return activeWidget
}

const setActiveWidget = instance => {
  activeWidget = instance
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Settings/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Settings/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initSettings": () => (/* binding */ initSettings)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const settings = {}
const subscribers = {}

const initSettings = (appSettings, platformSettings) => {
  settings['app'] = appSettings
  settings['platform'] = platformSettings
  settings['user'] = {}
}

const publish = (key, value) => {
  subscribers[key] && subscribers[key].forEach(subscriber => subscriber(value))
}

const dotGrab = (obj = {}, key) => {
  if (obj === null) return undefined
  const keys = key.split('.')
  for (let i = 0; i < keys.length; i++) {
    obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {}
  }
  return typeof obj === 'object' && obj !== null ? (Object.keys(obj).length ? obj : undefined) : obj
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  get(type, key, fallback = undefined) {
    const val = dotGrab(settings[type], key)
    return val !== undefined ? val : fallback
  },
  has(type, key) {
    return !!this.get(type, key)
  },
  set(key, value) {
    settings['user'][key] = value
    publish(key, value)
  },
  subscribe(key, callback) {
    subscribers[key] = subscribers[key] || []
    subscribers[key].push(callback)
  },
  unsubscribe(key, callback) {
    if (callback) {
      const index = subscribers[key] && subscribers[key].findIndex(cb => cb === callback)
      index > -1 && subscribers[key].splice(index, 1)
    } else {
      if (key in subscribers) {
        subscribers[key] = []
      }
    }
  },
  clearSubscribers() {
    for (const key of Object.getOwnPropertyNames(subscribers)) {
      delete subscribers[key]
    }
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Storage/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Storage/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initStorage": () => (/* binding */ initStorage)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var localCookie_module_localCookie_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! localCookie/module/localCookie.js */ "./node_modules/localCookie/module/localCookie.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let namespace
let lc

const initStorage = () => {
  namespace = _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'id')
  // todo: pass options (for example to force the use of cookies)
  lc = new localCookie_module_localCookie_js__WEBPACK_IMPORTED_MODULE_1__["default"]()
}

const namespacedKey = key => (namespace ? [namespace, key].join('.') : key)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  get(key) {
    try {
      return JSON.parse(lc.getItem(namespacedKey(key)))
    } catch (e) {
      return null
    }
  },
  set(key, value) {
    try {
      lc.setItem(namespacedKey(key), JSON.stringify(value))
      return true
    } catch (e) {
      return false
    }
  },
  remove(key) {
    lc.removeItem(namespacedKey(key))
  },
  clear() {
    if (namespace) {
      lc.keys().forEach(key => {
        // remove the item if in the namespace
        key.indexOf(namespace + '.') === 0 ? lc.removeItem(key) : null
      })
    } else {
      lc.clear()
    }
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/TV/defaults.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/TV/defaults.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "channels": () => (/* binding */ channels),
/* harmony export */   "randomChannel": () => (/* binding */ randomChannel)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const defaultChannels = [
  {
    number: 1,
    name: 'Metro News 1',
    description: 'New York Cable News Channel',
    entitled: true,
    program: {
      title: 'The Morning Show',
      description: "New York's best morning show",
      startTime: new Date(new Date() - 60 * 5 * 1000).toUTCString(), // started 5 minutes ago
      duration: 60 * 30, // 30 minutes
      ageRating: 0,
    },
  },
  {
    number: 2,
    name: 'MTV',
    description: 'Music Television',
    entitled: true,
    program: {
      title: 'Beavis and Butthead',
      description: 'American adult animated sitcom created by Mike Judge',
      startTime: new Date(new Date() - 60 * 20 * 1000).toUTCString(), // started 20 minutes ago
      duration: 60 * 45, // 45 minutes
      ageRating: 18,
    },
  },
  {
    number: 3,
    name: 'NBC',
    description: 'NBC TV Network',
    entitled: false,
    program: {
      title: 'The Tonight Show Starring Jimmy Fallon',
      description: 'Late-night talk show hosted by Jimmy Fallon on NBC',
      startTime: new Date(new Date() - 60 * 10 * 1000).toUTCString(), // started 10 minutes ago
      duration: 60 * 60, // 1 hour
      ageRating: 10,
    },
  },
]

const channels = () => _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'tv', defaultChannels)

const randomChannel = () => channels()[~~(channels.length * Math.random())]


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/TV/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/TV/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initTV": () => (/* binding */ initTV)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaults */ "./node_modules/@lightningjs/sdk/src/TV/defaults.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





let currentChannel
const callbacks = {}

const emit = (event, ...args) => {
  callbacks[event] &&
    callbacks[event].forEach(cb => {
      cb.apply(null, args)
    })
}

// local mock methods
let methods = {
  getChannel() {
    if (!currentChannel) currentChannel = (0,_defaults__WEBPACK_IMPORTED_MODULE_1__.randomChannel)()
    return new Promise((resolve, reject) => {
      if (currentChannel) {
        const channel = { ...currentChannel }
        delete channel.program
        resolve(channel)
      } else {
        reject('No channel found')
      }
    })
  },
  getProgram() {
    if (!currentChannel) currentChannel = (0,_defaults__WEBPACK_IMPORTED_MODULE_1__.randomChannel)()
    return new Promise((resolve, reject) => {
      currentChannel.program ? resolve(currentChannel.program) : reject('No program found')
    })
  },
  setChannel(number) {
    return new Promise((resolve, reject) => {
      if (number) {
        const newChannel = (0,_defaults__WEBPACK_IMPORTED_MODULE_1__.channels)().find(c => c.number === number)
        if (newChannel) {
          currentChannel = newChannel
          const channel = { ...currentChannel }
          delete channel.program
          emit('channelChange', channel)
          resolve(channel)
        } else {
          reject('Channel not found')
        }
      } else {
        reject('No channel number supplied')
      }
    })
  },
}

const initTV = config => {
  methods = {}
  if (config.getChannel && typeof config.getChannel === 'function') {
    methods.getChannel = config.getChannel
  }
  if (config.getProgram && typeof config.getProgram === 'function') {
    methods.getProgram = config.getProgram
  }
  if (config.setChannel && typeof config.setChannel === 'function') {
    methods.setChannel = config.setChannel
  }
  if (config.emit && typeof config.emit === 'function') {
    config.emit(emit)
  }
}

// public API
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  channel(number = null) {
    return new Promise((resolve, reject) => {
      try {
        // call setChannel when number argument is passed, otherwise getChannel
        methods[number ? 'setChannel' : 'getChannel'](number)
          .then(channel => {
            // to do: ensure consistent formatting of channel info here?
            resolve(channel)
          })
          .catch(reject)
      } catch (e) {
        reject(e)
      }
    })
  },
  program() {
    return new Promise((resolve, reject) => {
      try {
        methods
          .getProgram()
          .then(program => {
            // to do: ensure consistent formatting of program info here?
            resolve(program)
          })
          .catch(reject)
      } catch (e) {
        reject(e)
      }
    })
  },
  entitled() {
    return new Promise((resolve, reject) => {
      try {
        methods
          .getChannel()
          .then(channel => {
            'entitled' in channel ? resolve(!!channel.entitled) : reject()
          })
          .catch(reject)
      } catch (e) {
        reject(e)
      }
    })
  },
  addEventListener(event, cb) {
    if (typeof cb === 'function') {
      callbacks[event] = callbacks[event] || []
      callbacks[event].push(cb)
    } else {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error('Please provide a function as a callback')
    }
  },
  removeEventListener(event, cb = false) {
    if (callbacks[event] && callbacks[event].length) {
      callbacks[event] = cb ? callbacks[event].filter(_cb => _cb === cb) : []
    }
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Utils/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Utils/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cleanUpPathName": () => (/* binding */ cleanUpPathName),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "ensureUrlWithProtocol": () => (/* binding */ ensureUrlWithProtocol),
/* harmony export */   "initUtils": () => (/* binding */ initUtils),
/* harmony export */   "makeFullStaticPath": () => (/* binding */ makeFullStaticPath)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let basePath
let proxyUrl

const initUtils = config => {
  basePath = ensureUrlWithProtocol(makeFullStaticPath(window.location.pathname, config.path || '/'))

  if (config.proxyUrl) {
    proxyUrl = ensureUrlWithProtocol(config.proxyUrl)
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  asset(relPath) {
    return basePath + relPath
  },
  proxyUrl(url, options = {}) {
    return proxyUrl ? proxyUrl + '?' + makeQueryString(url, options) : url
  },
  makeQueryString() {
    return makeQueryString(...arguments)
  },
  // since imageworkers don't work without protocol
  ensureUrlWithProtocol() {
    return ensureUrlWithProtocol(...arguments)
  },
});

const ensureUrlWithProtocol = url => {
  if (/^\/\//.test(url)) {
    return window.location.protocol + url
  }
  if (!/^(?:https?:)/i.test(url)) {
    return window.location.origin + url
  }
  return url
}

const makeFullStaticPath = (pathname = '/', path) => {
  // ensure path has traling slash
  path = path.charAt(path.length - 1) !== '/' ? path + '/' : path

  // if path is URL, we assume it's already the full static path, so we just return it
  if (/^(?:https?:)?(?:\/\/)/.test(path)) {
    return path
  }

  if (path.charAt(0) === '/') {
    return path
  } else {
    // cleanup the pathname (i.e. remove possible index.html)
    pathname = cleanUpPathName(pathname)

    // remove possible leading dot from path
    path = path.charAt(0) === '.' ? path.substr(1) : path
    // ensure path has leading slash
    path = path.charAt(0) !== '/' ? '/' + path : path
    return pathname + path
  }
}

const cleanUpPathName = pathname => {
  if (pathname.slice(-1) === '/') return pathname.slice(0, -1)
  const parts = pathname.split('/')
  if (parts[parts.length - 1].indexOf('.') > -1) parts.pop()
  return parts.join('/')
}

const makeQueryString = (url, options = {}, type = 'url') => {
  // add operator as an option
  options.operator = 'metrological' // Todo: make this configurable (via url?)
  // add type (= url or qr) as an option, with url as the value
  options[type] = url

  return Object.keys(options)
    .map(key => {
      return encodeURIComponent(key) + '=' + encodeURIComponent('' + options[key])
    })
    .join('&')
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/VersionLabel/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/VersionLabel/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VersionLabel)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class VersionLabel extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      rect: true,
      color: 0xbb0078ac,
      h: 40,
      w: 100,
      x: w => w - 50,
      y: h => h - 50,
      mount: 1,
      Text: {
        w: w => w,
        h: h => h,
        y: 5,
        x: 20,
        text: {
          fontSize: 22,
          lineHeight: 26,
        },
      },
    }
  }

  _firstActive() {
    this.tag('Text').text = `APP - v${this.version}\nSDK - v${this.sdkVersion}`
    this.tag('Text').loadTexture()
    this.w = this.tag('Text').renderWidth + 40
    this.h = this.tag('Text').renderHeight + 5
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/VideoPlayer/VideoTexture.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/VideoPlayer/VideoTexture.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoTexture)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class VideoTexture extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      Video: {
        alpha: 1,
        visible: false,
        pivot: 0.5,
        texture: { type: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].textures.StaticTexture, options: {} },
      },
    }
  }

  set videoEl(v) {
    this._videoEl = v
  }

  get videoEl() {
    return this._videoEl
  }

  get videoView() {
    return this.tag('Video')
  }

  get videoTexture() {
    return this.videoView.texture
  }

  get isVisible() {
    return this.videoView.alpha === 1 && this.videoView.visible === true
  }

  _init() {
    this._createVideoTexture()
  }

  _createVideoTexture() {
    const stage = this.stage

    const gl = stage.gl
    const glTexture = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, glTexture)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
    this.videoTexture.options = { source: glTexture, w: this.videoEl.width, h: this.videoEl.height }

    this.videoView.w = this.videoEl.width / this.stage.getRenderPrecision()
    this.videoView.h = this.videoEl.height / this.stage.getRenderPrecision()
  }

  start() {
    const stage = this.stage
    this._lastTime = 0
    if (!this._updateVideoTexture) {
      this._updateVideoTexture = () => {
        if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
          const gl = stage.gl

          const currentTime = new Date().getTime()
          const getVideoPlaybackQuality = this.videoEl.getVideoPlaybackQuality()

          // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
          // We'll fallback to fixed 30fps in this case.
          // As 'webkitDecodedFrameCount' is about to deprecate, check for the 'totalVideoFrames'
          const frameCount = getVideoPlaybackQuality
            ? getVideoPlaybackQuality.totalVideoFrames
            : this.videoEl.webkitDecodedFrameCount

          const mustUpdate = frameCount
            ? this._lastFrame !== frameCount
            : this._lastTime < currentTime - 30

          if (mustUpdate) {
            this._lastTime = currentTime
            this._lastFrame = frameCount
            try {
              gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source)
              gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false)
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl)
              this._lastFrame = this.videoEl.webkitDecodedFrameCount
              this.videoView.visible = true

              this.videoTexture.options.w = this.videoEl.width
              this.videoTexture.options.h = this.videoEl.height
              const expectedAspectRatio = this.videoView.w / this.videoView.h
              const realAspectRatio = this.videoEl.width / this.videoEl.height

              if (expectedAspectRatio > realAspectRatio) {
                this.videoView.scaleX = realAspectRatio / expectedAspectRatio
                this.videoView.scaleY = 1
              } else {
                this.videoView.scaleY = expectedAspectRatio / realAspectRatio
                this.videoView.scaleX = 1
              }
            } catch (e) {
              _Log__WEBPACK_IMPORTED_MODULE_1__["default"].error('texImage2d video', e)
              this.stop()
            }
            this.videoTexture.source.forceRenderUpdate()
          }
        }
      }
    }
    if (!this._updatingVideoTexture) {
      stage.on('frameStart', this._updateVideoTexture)
      this._updatingVideoTexture = true
    }
  }

  stop() {
    const stage = this.stage
    stage.removeListener('frameStart', this._updateVideoTexture)
    this._updatingVideoTexture = false
    this.videoView.visible = false

    if (this.videoTexture.options.source) {
      const gl = stage.gl
      gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source)
      gl.clearColor(0, 0, 0, 1)
      gl.clear(gl.COLOR_BUFFER_BIT)
    }
  }

  position(top, left) {
    this.videoView.patch({
      smooth: {
        x: left,
        y: top,
      },
    })
  }

  size(width, height) {
    this.videoView.patch({
      smooth: {
        w: width,
        h: height,
      },
    })
  }

  show() {
    this.videoView.setSmooth('alpha', 1)
  }

  hide() {
    this.videoView.setSmooth('alpha', 0)
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/VideoPlayer/events.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/VideoPlayer/events.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  abort: 'Abort',
  canplay: 'CanPlay',
  canplaythrough: 'CanPlayThrough',
  durationchange: 'DurationChange',
  emptied: 'Emptied',
  encrypted: 'Encrypted',
  ended: 'Ended',
  error: 'Error',
  interruptbegin: 'InterruptBegin',
  interruptend: 'InterruptEnd',
  loadeddata: 'LoadedData',
  loadedmetadata: 'LoadedMetadata',
  loadstart: 'LoadStart',
  pause: 'Pause',
  play: 'Play',
  playing: 'Playing',
  progress: 'Progress',
  ratechange: 'Ratechange',
  seeked: 'Seeked',
  seeking: 'Seeking',
  stalled: 'Stalled',
  // suspend: 'Suspend', // this one is called a looooot for some videos
  timeupdate: 'TimeUpdate',
  volumechange: 'VolumeChange',
  waiting: 'Waiting',
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initVideoPlayer": () => (/* binding */ initVideoPlayer),
/* harmony export */   "mediaUrl": () => (/* binding */ mediaUrl),
/* harmony export */   "setUpVideoTexture": () => (/* binding */ setUpVideoTexture),
/* harmony export */   "setupVideoTag": () => (/* binding */ setupVideoTag)
/* harmony export */ });
/* harmony import */ var _michieljs_execute_as_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @michieljs/execute-as-promise */ "./node_modules/@michieljs/execute-as-promise/src/execute-as-promise.js");
/* harmony import */ var _Metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _Ads__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Ads */ "./node_modules/@lightningjs/sdk/src/Ads/index.js");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/events.js");
/* harmony import */ var _helpers_autoSetupMixin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/autoSetupMixin */ "./node_modules/@lightningjs/sdk/src/helpers/autoSetupMixin.js");
/* harmony import */ var _helpers_easeExecution__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/easeExecution */ "./node_modules/@lightningjs/sdk/src/helpers/easeExecution.js");
/* harmony import */ var _Launch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Launch */ "./node_modules/@lightningjs/sdk/src/Launch/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _VideoTexture__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./VideoTexture */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/VideoTexture.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */














let mediaUrl = url => url
let videoEl
let videoTexture
let metrics
let consumer
let precision = 1
let textureMode = false

const initVideoPlayer = config => {
  if (config.mediaUrl) {
    mediaUrl = config.mediaUrl
  }
}

// todo: add this in a 'Registry' plugin
// to be able to always clean this up on app close
let eventHandlers = {}

const state = {
  adsEnabled: false,
  playing: false,
  _playingAds: false,
  get playingAds() {
    return this._playingAds
  },
  set playingAds(val) {
    if (this._playingAds !== val) {
      this._playingAds = val
      fireOnConsumer(val === true ? 'AdStart' : 'AdEnd')
    }
  },
  skipTime: false,
  playAfterSeek: null,
}

const hooks = {
  play() {
    state.playing = true
  },
  pause() {
    state.playing = false
  },
  seeked() {
    state.playAfterSeek === true && videoPlayerPlugin.play()
    state.playAfterSeek = null
  },
  abort() {
    deregisterEventListeners()
  },
}

const withPrecision = val => Math.round(precision * val) + 'px'

const fireOnConsumer = (event, args) => {
  if (consumer) {
    consumer.fire('$videoPlayer' + event, args, videoEl.currentTime)
    consumer.fire('$videoPlayerEvent', event, args, videoEl.currentTime)
  }
}

const fireHook = (event, args) => {
  hooks[event] && typeof hooks[event] === 'function' && hooks[event].call(null, event, args)
}

let customLoader = null
let customUnloader = null

const loader = (url, videoEl, config) => {
  return customLoader && typeof customLoader === 'function'
    ? customLoader(url, videoEl, config)
    : new Promise(resolve => {
        url = mediaUrl(url)
        videoEl.setAttribute('src', url)
        videoEl.load()
        resolve()
      })
}

const unloader = videoEl => {
  return customUnloader && typeof customUnloader === 'function'
    ? customUnloader(videoEl)
    : new Promise(resolve => {
        videoEl.removeAttribute('src')
        videoEl.load()
        resolve()
      })
}

const setupVideoTag = () => {
  const videoEls = document.getElementsByTagName('video')
  if (videoEls && videoEls.length) {
    return videoEls[0]
  } else {
    const videoEl = document.createElement('video')
    const platformSettingsWidth = _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'width')
      ? _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'width')
      : 1920
    const platformSettingsHeight = _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'height')
      ? _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'height')
      : 1080
    videoEl.setAttribute('id', 'video-player')
    videoEl.setAttribute('width', withPrecision(platformSettingsWidth))
    videoEl.setAttribute('height', withPrecision(platformSettingsHeight))
    videoEl.style.position = 'absolute'
    videoEl.style.zIndex = '1'
    videoEl.style.display = 'none'
    videoEl.style.visibility = 'hidden'
    videoEl.style.top = withPrecision(0)
    videoEl.style.left = withPrecision(0)
    videoEl.style.width = withPrecision(platformSettingsWidth)
    videoEl.style.height = withPrecision(platformSettingsHeight)
    document.body.appendChild(videoEl)
    return videoEl
  }
}

const setUpVideoTexture = () => {
  if (!_Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.tag('VideoTexture')) {
    const el = _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.stage.c({
      type: _VideoTexture__WEBPACK_IMPORTED_MODULE_9__["default"],
      ref: 'VideoTexture',
      zIndex: 0,
      videoEl,
    })
    _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.childList.addAt(el, 0)
  }
  return _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.tag('VideoTexture')
}

const registerEventListeners = () => {
  _Log__WEBPACK_IMPORTED_MODULE_2__["default"].info('VideoPlayer', 'Registering event listeners')
  Object.keys(_events__WEBPACK_IMPORTED_MODULE_4__["default"]).forEach(event => {
    const handler = e => {
      // Fire a metric for each event (if it exists on the metrics object)
      if (metrics && metrics[event] && typeof metrics[event] === 'function') {
        metrics[event]({ currentTime: videoEl.currentTime })
      }
      // fire an internal hook
      fireHook(event, { videoElement: videoEl, event: e })

      // fire the event (with human friendly event name) to the consumer of the VideoPlayer
      fireOnConsumer(_events__WEBPACK_IMPORTED_MODULE_4__["default"][event], { videoElement: videoEl, event: e })
    }

    eventHandlers[event] = handler
    videoEl.addEventListener(event, handler)
  })
}

const deregisterEventListeners = () => {
  _Log__WEBPACK_IMPORTED_MODULE_2__["default"].info('VideoPlayer', 'Deregistering event listeners')
  Object.keys(eventHandlers).forEach(event => {
    videoEl.removeEventListener(event, eventHandlers[event])
  })
  eventHandlers = {}
}

const videoPlayerPlugin = {
  consumer(component) {
    consumer = component
  },

  loader(loaderFn) {
    customLoader = loaderFn
  },

  unloader(unloaderFn) {
    customUnloader = unloaderFn
  },

  position(top = 0, left = 0) {
    videoEl.style.left = withPrecision(left)
    videoEl.style.top = withPrecision(top)
    if (textureMode === true) {
      videoTexture.position(top, left)
    }
  },

  size(width = 1920, height = 1080) {
    videoEl.style.width = withPrecision(width)
    videoEl.style.height = withPrecision(height)
    videoEl.width = parseFloat(videoEl.style.width)
    videoEl.height = parseFloat(videoEl.style.height)
    if (textureMode === true) {
      videoTexture.size(width, height)
    }
  },

  area(top = 0, right = 1920, bottom = 1080, left = 0) {
    this.position(top, left)
    this.size(right - left, bottom - top)
  },

  open(url, config = {}) {
    if (!this.canInteract) return
    metrics = _Metrics__WEBPACK_IMPORTED_MODULE_1__["default"].media(url)

    this.hide()
    deregisterEventListeners()

    if (this.src == url) {
      this.clear().then(this.open(url, config))
    } else {
      const adConfig = { enabled: state.adsEnabled, duration: 300 }
      if (config.videoId) {
        adConfig.caid = config.videoId
      }
      _Ads__WEBPACK_IMPORTED_MODULE_3__["default"].get(adConfig, consumer).then(ads => {
        state.playingAds = true
        ads.prerolls().then(() => {
          state.playingAds = false
          loader(url, videoEl, config)
            .then(() => {
              registerEventListeners()
              this.show()
              this.play()
            })
            .catch(e => {
              fireOnConsumer('error', { videoElement: videoEl, event: e })
            })
        })
      })
    }
  },

  reload() {
    if (!this.canInteract) return
    const url = videoEl.getAttribute('src')
    this.close()
    this.open(url)
  },

  close() {
    _Ads__WEBPACK_IMPORTED_MODULE_3__["default"].cancel()
    if (state.playingAds) {
      state.playingAds = false
      _Ads__WEBPACK_IMPORTED_MODULE_3__["default"].stop()
      // call self in next tick
      setTimeout(() => {
        this.close()
      })
    }
    if (!this.canInteract) return
    this.clear()
    this.hide()
    deregisterEventListeners()
  },

  clear() {
    if (!this.canInteract) return
    // pause the video first to disable sound
    this.pause()
    if (textureMode === true) videoTexture.stop()
    return unloader(videoEl).then(() => {
      fireOnConsumer('Clear', { videoElement: videoEl })
    })
  },

  play() {
    if (!this.canInteract) return
    if (textureMode === true) videoTexture.start()
    ;(0,_michieljs_execute_as_promise__WEBPACK_IMPORTED_MODULE_0__["default"])(videoEl.play, null, videoEl).catch(e => {
      fireOnConsumer('error', { videoElement: videoEl, event: e })
    })
  },

  pause() {
    if (!this.canInteract) return
    videoEl.pause()
  },

  playPause() {
    if (!this.canInteract) return
    this.playing === true ? this.pause() : this.play()
  },

  mute(muted = true) {
    if (!this.canInteract) return
    videoEl.muted = muted
  },

  loop(looped = true) {
    videoEl.loop = looped
  },

  seek(time) {
    if (!this.canInteract) return
    if (!this.src) return
    // define whether should continue to play after seek is complete (in seeked hook)
    if (state.playAfterSeek === null) {
      state.playAfterSeek = !!state.playing
    }
    // pause before actually seeking
    this.pause()
    // currentTime always between 0 and the duration of the video (minus 0.1s to not set to the final frame and stall the video)
    videoEl.currentTime = Math.max(0, Math.min(time, this.duration - 0.1))
  },

  skip(seconds) {
    if (!this.canInteract) return
    if (!this.src) return

    state.skipTime = (state.skipTime || videoEl.currentTime) + seconds
    ;(0,_helpers_easeExecution__WEBPACK_IMPORTED_MODULE_6__["default"])(() => {
      this.seek(state.skipTime)
      state.skipTime = false
    }, 300)
  },

  show() {
    if (!this.canInteract) return
    if (textureMode === true) {
      videoTexture.show()
    } else {
      videoEl.style.display = 'block'
      videoEl.style.visibility = 'visible'
    }
  },

  hide() {
    if (!this.canInteract) return
    if (textureMode === true) {
      videoTexture.hide()
    } else {
      videoEl.style.display = 'none'
      videoEl.style.visibility = 'hidden'
    }
  },

  enableAds(enabled = true) {
    state.adsEnabled = enabled
  },

  /* Public getters */
  get duration() {
    return videoEl && (isNaN(videoEl.duration) ? Infinity : videoEl.duration)
  },

  get currentTime() {
    return videoEl && videoEl.currentTime
  },

  get muted() {
    return videoEl && videoEl.muted
  },

  get looped() {
    return videoEl && videoEl.loop
  },

  get src() {
    return videoEl && videoEl.getAttribute('src')
  },

  get playing() {
    return state.playing
  },

  get playingAds() {
    return state.playingAds
  },

  get canInteract() {
    // todo: perhaps add an extra flag wether we allow interactions (i.e. pauze, mute, etc.) during ad playback
    return state.playingAds === false
  },

  get top() {
    return videoEl && parseFloat(videoEl.style.top)
  },

  get left() {
    return videoEl && parseFloat(videoEl.style.left)
  },

  get bottom() {
    return videoEl && parseFloat(videoEl.style.top - videoEl.style.height)
  },

  get right() {
    return videoEl && parseFloat(videoEl.style.left - videoEl.style.width)
  },

  get width() {
    return videoEl && parseFloat(videoEl.style.width)
  },

  get height() {
    return videoEl && parseFloat(videoEl.style.height)
  },

  get visible() {
    if (textureMode === true) {
      return videoTexture.isVisible
    } else {
      return videoEl && videoEl.style.display === 'block'
    }
  },

  get adsEnabled() {
    return state.adsEnabled
  },

  // prefixed with underscore to indicate 'semi-private'
  // because it's not recommended to interact directly with the video element
  get _videoEl() {
    return videoEl
  },

  get _consumer() {
    return consumer
  },
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_helpers_autoSetupMixin__WEBPACK_IMPORTED_MODULE_5__["default"])(videoPlayerPlugin, () => {
  precision =
    (_Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance &&
      _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.stage &&
      _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.stage.getRenderPrecision()) ||
    precision

  videoEl = setupVideoTag()

  textureMode = _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'textureMode', false)
  if (textureMode === true) {
    videoEl.setAttribute('crossorigin', 'anonymous')
    videoTexture = setUpVideoTexture()
  }
}));


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/helpers/autoSetupMixin.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/helpers/autoSetupMixin.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((sourceObject, setup = () => {}) => {
  let ready = false

  const doSetup = () => {
    if (ready === false) {
      setup()
      ready = true
    }
  }

  return Object.keys(sourceObject).reduce((obj, key) => {
    if (typeof sourceObject[key] === 'function') {
      obj[key] = function() {
        doSetup()
        return sourceObject[key].apply(sourceObject, arguments)
      }
    } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).get === 'function') {
      obj.__defineGetter__(key, function() {
        doSetup()
        return Object.getOwnPropertyDescriptor(sourceObject, key).get.apply(sourceObject)
      })
    } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).set === 'function') {
      obj.__defineSetter__(key, function() {
        doSetup()
        return Object.getOwnPropertyDescriptor(sourceObject, key).set.sourceObject[key].apply(
          sourceObject,
          arguments
        )
      })
    } else {
      obj[key] = sourceObject[key]
    }
    return obj
  }, {})
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/helpers/easeExecution.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/helpers/easeExecution.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let timeout = null

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((cb, delay) => {
  clearTimeout(timeout)
  timeout = setTimeout(() => {
    cb()
  }, delay)
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/helpers/sequence.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/helpers/sequence.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (steps => {
  return steps.reduce((promise, method) => {
    return promise
      .then(function() {
        return method(...arguments)
      })
      .catch(e => Promise.reject(e))
  }, Promise.resolve(null))
});


/***/ }),

/***/ "./node_modules/@michieljs/execute-as-promise/src/execute-as-promise.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@michieljs/execute-as-promise/src/execute-as-promise.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((method, args = null, context = null) => {
  let result
  if (method && typeof method === 'function') {
    try {
      result = method.apply(context, args)
    } catch (e) {
      result = e
    }
  } else {
    result = method
  }

  // if it looks like a duck .. ehm ... promise and talks like a promise, let's assume it's a promise
  if (
    result !== null &&
    typeof result === 'object' &&
    result.then &&
    typeof result.then === 'function'
  ) {
    return result
  }
  // otherwise make it into a promise
  else {
    return new Promise((resolve, reject) => {
      if (result instanceof Error) {
        reject(result)
      } else {
        resolve(result)
      }
    })
  }
});


/***/ }),

/***/ "./node_modules/deepmerge/dist/cjs.js":
/*!********************************************!*\
  !*** ./node_modules/deepmerge/dist/cjs.js ***!
  \********************************************/
/***/ ((module) => {



var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return target.propertyIsEnumerable(symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

module.exports = deepmerge_1;


/***/ }),

/***/ "./node_modules/localCookie/module/localCookie.js":
/*!********************************************************!*\
  !*** ./node_modules/localCookie/module/localCookie.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class localCookie{constructor(e){return e=e||{},this.forceCookies=e.forceCookies||!1,!0===this._checkIfLocalStorageWorks()&&!0!==e.forceCookies?{getItem:this._getItemLocalStorage,setItem:this._setItemLocalStorage,removeItem:this._removeItemLocalStorage,clear:this._clearLocalStorage}:{getItem:this._getItemCookie,setItem:this._setItemCookie,removeItem:this._removeItemCookie,clear:this._clearCookies}}_checkIfLocalStorageWorks(){if("undefined"==typeof localStorage)return!1;try{return localStorage.setItem("feature_test","yes"),"yes"===localStorage.getItem("feature_test")&&(localStorage.removeItem("feature_test"),!0)}catch(e){return!1}}_getItemLocalStorage(e){return window.localStorage.getItem(e)}_setItemLocalStorage(e,t){return window.localStorage.setItem(e,t)}_removeItemLocalStorage(e){return window.localStorage.removeItem(e)}_clearLocalStorage(){return window.localStorage.clear()}_getItemCookie(e){var t=document.cookie.match(RegExp("(?:^|;\\s*)"+function(e){return e.replace(/([.*+?\^${}()|\[\]\/\\])/g,"\\$1")}(e)+"=([^;]*)"));return t&&""===t[1]&&(t[1]=null),t?t[1]:null}_setItemCookie(e,t){var o=new Date,r=new Date(o.getTime()+15768e7);document.cookie=`${e}=${t}; expires=${r.toUTCString()};`}_removeItemCookie(e){document.cookie=`${e}=;Max-Age=-99999999;`}_clearCookies(){document.cookie.split(";").forEach(e=>{document.cookie=e.replace(/^ +/,"").replace(/=.*/,"=;expires=Max-Age=-99999999")})}}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localCookie);


/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "App": () => (/* binding */ App)
/* harmony export */ });
/* harmony import */ var _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lightningjs/sdk */ "./node_modules/@lightningjs/sdk/index.js");
/* harmony import */ var _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebolt-js/sdk */ "./node_modules/@firebolt-js/sdk/dist/firebolt.js");
/* harmony import */ var _MyButton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MyButton */ "./src/MyButton.js");
/* harmony import */ var _BlackAdam__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BlackAdam */ "./src/BlackAdam.js");


//import { Wifi } from '@firebolt-js/manage-sdk';
//import {Button} from './button.js';



// const LifecycleColors = {
//   // BLUE
//   BOOT: "0xff0000ff",
//   // RED
//   INACTIVE: "0xffff0000",
//   // ORANGE
//   BACKGROUND: "0xffE69738",
//   // GREEN
//   FOREGROUND: "0xff00aa00",
// };

class App extends _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.Component {
  static getFonts() {
    return [
      { family: "Regular", url: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("fonts/Roboto-Regular.ttf") },
    ];
  }

  static _template() {
    return {
      

      HelloWorld: {
        w: 1920,
        h: 1080,
        y: 0,
        rect: true,
        color: 0xffffffff,
        FireboltStatus: {
          // Lifecycle: {
          //   mountX: 0.5,
          //   x: 960,
          //   y: 100,
          //   text: {
          //     text: "Lifecycle not Ready!",
          //     fontFace: "Regular",
          //     fontSize: 50,
          //   },
          // },
          Rdklogo: {
            x: 30,
            y: 40,
            w: 300,
            h: 80,
            shadowColor: 0xffff00ff,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/rdklogo.png"),
          },
          Alexalogo: {
            x: 1200,
            y: 5,
            w: 150,
            h: 150,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/alexa.png"),
          },
          Settlogo: {
            x: 0,
            y: 170,
            w: 1920,
            h: 700,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/big.jpg"),
          },
          Belllogo: {
            x: 1400,
            y: 20,
            w: 100,
            h: 100,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/setting.png"),
          },
          Notifilogo: {
            x: 1600,
            y: 20,
            w: 100,
            h: 100,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/noti.png"),
          },
          Device: {
            mountX: 0.5,
            x: 960,
            y: 900,
            text: {
              text: "Device not Ready!",

              fontFace: "Regular",
              fontSize: 35,
              textColor: 0xff000000,
            },
          },
          Localization: {
            mountX: 0.5,
            x: 960,
            y: 950,
            text: {
              text: "loaclization API ==> ",
              fontFace: "Regular",
              fontSize: 35,
              textColor: 0xff000000,
          }
        },
        Metrics:{
          mountX: 0.5,
          x: 960,
          y: 1000,
          text: {
            text: "Metrics API ==> ",
            fontFace: "Regular",
            fontSize: 35,
            textColor: 0xff000000,

        },
        },
      },
        Playbutton: {
          type: _MyButton__WEBPACK_IMPORTED_MODULE_2__.MyButton,
          x: 1500,
          y: 770,
          signals: {
            onClick: "handleButtonEnter",
          },
        },
        // Complete: {
        // 	visible:true, mountX:0.5, x: 960, y: 50,
        // 	text: { text: 'Firebolt >> Hello World', fontFace: 'Regular', fontSize: 90 },
        // },
        //Button: {mount: 0.5, x: 960, y:15, type: Button, label: 'Button'},
      },
      VideoSection: {
        alpha: 1,
        x: 0,
        y: 0,
        w: 1920,
        h: 1080,
        color: "0xff000000",
        rect: true,
        visible: false,
        HelpMsg: {
          x: 80,
          y: 50,
          w: 1920,
          text: {
            text: "Play the Video using AAMP Player",
            fontSize: 40,
            fontFace: "Regular",
            textAlign: "center",
            lineHeight: 50,
          },
          color: "0xffffffff",
          alpha: 1,
        },
        Video: {
          x: 0,
          y: 0,
          w: 1920, // Set to your desired width
          h: 1080, // Set to your desired height
          type: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.components.VideoItem, // Use the appropriate Lightning video
        },
      },
      Slider: {

        w: 800,

        h: 350,

        x: 480,

        y: 350,

        mount: 0.5,

        Wrapper: {

 

        },

      },

      Logo: {

        mount: 0.5,

        w: 120,

        h: 60,

        x: 130,

        y: 50,

       

      },

      BlackAdam: {

        mount: 0.5,

        x: 150,

        y: 130,

        text: {

          text: "Explore",

          fontFace: 'Regular',

          fontSize: 25,

          textColor: 0xffffffff,

        },
      },
    }
  }
  _getFocused() {
    return this.tag("Playbutton");
    

  }

  _init() {
    this.index = 0;

    this.dataLength = 3;

    const buttons = [];

 

    for (let i = 0; i < this.dataLength; i++) {

      buttons.push(

        { type: _BlackAdam__WEBPACK_IMPORTED_MODULE_3__.BlackAdam, x: i * (300 + 30), item: { label: `Train`, src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset(`images/black.jpg`) } },

      );

    }

 

    this.tag('Wrapper').children = buttons;
  }


  repositionWrapper() {

    const wrapper = this.tag('Wrapper');

    const sliderW = this.tag('Slider').w;

    const currentWrapperX = wrapper.transition('x').targetvalue || wrapper.x;

    const currentFocus = wrapper.children[this.index];

    const currentFocusX = currentFocus.x + currentWrapperX;

    const currentFocusOuterWidth = currentFocus.x + currentFocus.w;

 

    if (currentFocusX < 0) {

      wrapper.setSmooth('x', - currentFocus.x);

    }

    else if (currentFocusOuterWidth > sliderW) {

      wrapper.setSmooth('x', sliderW - (currentFocusOuterWidth));

    }

  }

 

  _handleLeft() {

    if (this.index === 0) {

      this.index = this.dataLength - 1;

    }

    else {

      this.index -= 1;

    }

    this.repositionWrapper();

  }

 

  _handleRight() {

    if (this.index === this.dataLength - 1) {

      this.index = 0;

    }

    else {

      this.index += 1;

    }

    this.repositionWrapper();

  }

 

  _getFocused() {

    return this.tag('Slider.Wrapper').children[this.index]

  }





  initiatePlayer() {
    const url =
      "https://amssamples.streaming.mediaservices.windows.net/683f7e47-bd83-4427-b0a3-26a6c4547782/BigBuckBunny.ism/manifest(format=mpd-time-csf)";
    this._player = new AAMPMediaPlayer();
    this._player.load(url);
  }

  static _states() {
    return [
      class LaunchView extends this {
        _getFocused() {
          return this.tag("Playbutton");
        }
        handleButtonEnter() {
          this.initiatePlayer();
          this._setState("VideoPlay");
        }
      },
      class VideoPlay extends this {
        _getFocused() {
          //return this.tag("VideoSection");
        }
        $enter() {
          this.tag("VideoSection").visible = true;
          this.tag("HelloWorld").visible = false;
        }
        _handleBack() {
          console.log("back to launchView");
          this.tag("VideoSection").visible = false;
          this.tag("HelloWorld").visible = true;
          this._setState("LaunchView");
        }
      },
    ];
  }

  _active() {
    console.log("active set state to launchView");
    this._setState("LaunchView");

    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Device.audio().then((supportedAudioProfiles) => {
      const newAudio = "audio profile **" + supportedAudioProfiles.stereo;
      //Log.info(supportedAudioProfiles.stereo);
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info("Device", newAudio);
      //this.tag('Device').text.text = newAudio + ' :: ';
      this.tag("Device").text.text = supportedAudioProfiles + " :: ";
      //console.log("Is stereo supported",supportedAudioProfiles.stereo);
      console.log("Is stereo supported", supportedAudioProfiles.stereo);
    });

    // Device.audio()
    // .then(supportedAudioProfiles => {
    //     console.log(supportedAudioProfiles);
    //     const newAudioProfile = supportedAudioProfiles.stereo;
    //     Log.info("Device", newAudioProfile);
    //     this.tag("Device").text.text = newAudioProfile +"::";
    //     console.log(newAudioProfile);
    // })

    // Device.name()
    //         .then(value => {
    // 		console.log(value)
    // 		Log.info("listenerId**", value);
    // 		this.tag('Device').text.text = value + ' :: ';
    // 	  }).then(listenerId => {
    // 		Log.info("listenerId**",value);
    // 		console.log(listenerId)
    // 	  });

    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Device.distributor().then((distributor) => {
      const deviceDistributor = "distributor:" + distributor;
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info(deviceDistributor);
      this.tag("Device").text.text = deviceDistributor + " :: ";
    });

    // Device.model()
    // 	.then(model => {
    // 		const deviceModel = 'model:' + model;
    // 		Log.info(deviceModel);
    // 		this.tag('Device').text.text += deviceModel + ' :: ';
    // 		console.log(JSON.stringify(deviceModel, null, 3));
    // 	});

    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Device.platform().then((platform) => {
      const devicePlatform = "platform:" + platform;
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info(devicePlatform);
      this.tag("Device").text.text += devicePlatform + " :: ";
    });

    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Device.version().then((version) => {
      const deviceVersion =
        "version:" +
        version.sdk.readable +
        " : v" +
        version.sdk.major +
        "." +
        version.sdk.minor +
        "." +
        version.sdk.patch;
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info(deviceVersion);
      this.tag("Device").text.text += deviceVersion;
    });
    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Localization.language().then(lang => {
      const langu = "language:" + lang;
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info(langu);
      this.tag("Localization").text.text += langu + " ::";
       
    })
    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Localization.countryCode().then(code => {
      const C_Code = " Country_Code:" + code;
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info(C_Code);
      this.tag("Localization").text.text += C_Code + " ";
        console.log(code)
    })

    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Metrics.action("user", "The user did foo", null).then(success => {
      const met_act = " action : " + success;
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info(met_act);
      this.tag("Metrics").text.text += met_act + " ";
       
    })

    // this._registerLifecycleCallbacks();
    // Lifecycle.ready();
    // Log.info("Lifecycle ready!");
  }

  // _registerLifecycleCallbacks() {
  //   Lifecycle.listen((event, value) => {
  //     Log.info("Lifecycle.listen:", event, value);

  //     if (value.state) {
  //       Log.warn("Lifecycle: >> : previous state :" + value.previous, value);
  //       Log.warn("Lifecycle: >> : current state :" + value.state, value);
  //     }

  //     if (value.state == "foreground") {
  //       Log.info("Lifecycle : Foreground State", null);
  //       this.tag("HelloWorld").color = LifecycleColors.FOREGROUND;
  //       this.tag("Lifecycle").text.text = "Lifecycle : Foreground State";
  //       this.tag("Complete").visible = true;
  //     }
  //     if (value.state == "inactive") {
  //       Log.info("Lifecycle : Inactive State", null);
  //       this.tag("HelloWorld").color = LifecycleColors.INACTIVE;
  //       this.tag("Lifecycle").text.text = "Lifecycle : Inactive State";
  //     }
  //     if (value.state == "background") {
  //       Log.info("Lifecycle : Background State", null);
  //       this.tag("HelloWorld").color = LifecycleColors.BACKGROUND;
  //       this.tag("Lifecycle").text.text = "Lifecycle : Background State";
  //     }
  //   });
  // }
}


/***/ }),

/***/ "./src/BlackAdam.js":
/*!**************************!*\
  !*** ./src/BlackAdam.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlackAdam": () => (/* binding */ BlackAdam)
/* harmony export */ });
/* harmony import */ var _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lightningjs/sdk */ "./node_modules/@lightningjs/sdk/index.js");


class BlackAdam extends _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.Component {

    static _template() {
  
      return {
  
        w: 300,
  
        h: 450,
  
        Image: {
  
          w: w => w, h: h => h - 50,
  
        },
  
      }
  
    }
  
   
  
    set item(obj) {
  
      const { label, src } = obj;
  
      this.patch({
  
        Image: { src },
  
      })
  
    }
  
   
  
    _focus() {
  
      this.patch({
  
        smooth: { color: 0xff005500, scale: 1.1 },
  
        shader: { type: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.shaders.Outline, stroke: 1.1, color: 0xff09f676 },
  
      });
  
    }
  
   
  
    _unfocus() {
  
      this.patch({
  
        smooth: { color: 0xffffffff, scale: 1.0 },
  
        shader: { type: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.shaders.Outline, stroke: 0, color: 0x0000000 },
  
      });
  
    }
  
  }

/***/ }),

/***/ "./src/MyButton.js":
/*!*************************!*\
  !*** ./src/MyButton.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MyButton": () => (/* binding */ MyButton)
/* harmony export */ });
/* harmony import */ var _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lightningjs/sdk */ "./node_modules/@lightningjs/sdk/index.js");


class MyButton extends _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.Component {
  static _template() {
    return {
      // Add a colored rectangle as the background of the button
      Background: {
        w: 250,
        h: 100,
        rect: true,
        radius: 10,
        color: 0xffc0c0c0, //0xff007aff, // Blue color
      },

      Label: {
        x: 80,
        y: 20,
        text: {
          text: "Play",
          fontSize: 28,
          textColor: 0xff000000, //0xffffffff, // White color
        },
      },
    };
  }
  _handleEnter() {
    this.signal("onClick");
  }

  _focus() {
    /* this.patch({
      Label: {
        text: {
          fontSize: 50,
        },
      },
    }); */
    console.log("button focus");
    this.patch({
      smooth: { color: 0xff007aff },
      Label: {
        smooth: { color: 0xffffffff },
        text: { fontSize: 50 },
      },
    });
  }

  _unfocus() {
    /* this.patch({
      Label: {
        text: {
          fontSize: 40,
        },
      },
    }); */
    this.patch({
      smooth: { color: 0xffffffff },
      Label: {
        smooth: { color: 0xff000000 },
        text: { fontSize: 35 },
      },
    });
  }
}

/***/ }),

/***/ "./src/settings.js":
/*!*************************!*\
  !*** ./src/settings.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "appData": () => (/* binding */ appData),
/* harmony export */   "appSettings": () => (/* binding */ appSettings),
/* harmony export */   "platformSettings": () => (/* binding */ platformSettings)
/* harmony export */ });
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../package.json */ "./package.json");
/*
* Copyright 2021 Comcast Cable Communications Management, LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* SPDX-License-Identifier: Apache-2.0
*/



const isDevelopment = "development" === 'development';

const appData = {};

const appSettings = {
  version: _package_json__WEBPACK_IMPORTED_MODULE_0__.version,
  stage: {
    clearColor: '0x000000',
  },
  debug: false,
};

const platformSettings = {
  log: true,
  path: "./static",
  showVersion: false
};


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/EventEmitter.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/EventEmitter.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EventEmitter)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This is a partial (and more efficient) implementation of the event emitter.
 * It attempts to maintain a one-to-one mapping between events and listeners, skipping an array lookup.
 * Only if there are multiple listeners, they are combined in an array.
 */
class EventEmitter {

    constructor() {
        // This is set (and kept) to true when events are used at all.
        this._hasEventListeners = false;
    }

    on(name, listener) {
        if (!this._hasEventListeners) {
            this._eventFunction = {}
            this._eventListeners = {}
            this._hasEventListeners = true;
        }

        const current = this._eventFunction[name];
        if (!current) {
            this._eventFunction[name] = listener;
        } else {
            if (this._eventFunction[name] !== EventEmitter.combiner) {
                this._eventListeners[name] = [this._eventFunction[name], listener];
                this._eventFunction[name] = EventEmitter.combiner;
            } else {
                this._eventListeners[name].push(listener);
            }
        }
    }

    once(name, listener) {
        const wrapper = (arg1, arg2, arg3) => {
            listener(arg1, arg2, arg3);
            this.off(name, wrapper);
        }
        wrapper.__originalFunc = listener;
        this.on(name, wrapper);
    }

    has(name, listener) {
        if (this._hasEventListeners) {
            const current = this._eventFunction[name];
            if (current) {
                if (current === EventEmitter.combiner) {
                    const listeners = this._eventListeners[name];
                    for (const l of listeners) {
                        if (l === listener || l.__originalFunc == listener) {
                            return true;
                        }
                    }
                } else if (this._eventFunction[name] === listener || this._eventFunction[name].__originalFunc === listener) {
                    return true;
                }
            }
        }
        return false;
    }

    off(name, listener) {
        if (this._hasEventListeners) {
            const current = this._eventFunction[name];
            if (current) {
                if (current === EventEmitter.combiner) {
                    const listeners = this._eventListeners[name];
                    let index = listeners.indexOf(listener);
                    if (index >= 0) {
                        listeners.splice(index, 1);
                    }
                    index = listeners.map((l) => l.__originalFunc).indexOf(listener);
                    if (index >= 0) {
                        listeners.splice(index, 1);
                    }
                    if (listeners.length === 1) {
                        this._eventFunction[name] = listeners[0];
                        this._eventListeners[name] = undefined;
                    }
                } else if (this._eventFunction[name] === listener || this._eventFunction[name].__originalFunc === listener) {
                    this._eventFunction[name] = undefined;
                }
            }
        }
    }

    removeListener(name, listener) {
        this.off(name, listener);
    }

    emit(name, arg1, arg2, arg3) {
        if (this._hasEventListeners) {
            const func = this._eventFunction[name];
            if (func) {
                if (func === EventEmitter.combiner) {
                    func(this, name, arg1, arg2, arg3);
                } else {
                    func(arg1, arg2, arg3);
                }
            }
        }
    }

    listenerCount(name) {
        if (this._hasEventListeners) {
            const func = this._eventFunction[name];
            if (func) {
                if (func === EventEmitter.combiner) {
                    return this._eventListeners[name].length;
                } else {
                    return 1;
                }
            }
        }
        return 0;
    }

    removeAllListeners(name) {
        if (this._hasEventListeners) {
            delete this._eventFunction[name];
            delete this._eventListeners[name];
        }
    }

}

EventEmitter.combiner = function(object, name, arg1, arg2, arg3) {
    const listeners = object._eventListeners[name];
    if (listeners) {
        /* Because listener may detach itself while being invoked and therefore invalidate the iterator,
           we need to create a copy to loop over it */
        for (const listener of [...listeners]) {
            listener(arg1, arg2, arg3);
        }
    }
}

EventEmitter.addAsMixin = function(cls) {
    cls.prototype.on = EventEmitter.prototype.on;
    cls.prototype.once = EventEmitter.prototype.once;
    cls.prototype.has = EventEmitter.prototype.has;
    cls.prototype.off = EventEmitter.prototype.off;
    cls.prototype.removeListener = EventEmitter.prototype.removeListener;
    cls.prototype.emit = EventEmitter.prototype.emit;
    cls.prototype.listenerCount = EventEmitter.prototype.listenerCount;
    cls.prototype.removeAllListeners = EventEmitter.prototype.removeAllListeners;
}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/Animation.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/Animation.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Animation)
/* harmony export */ });
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/* harmony import */ var _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimationSettings.mjs */ "./node_modules/@lightningjs/core/src/animation/AnimationSettings.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class Animation extends _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(manager, settings, element) {
        super();

        this.manager = manager;

        this._settings = settings;

        this._element = element;

        this._state = Animation.STATES.IDLE;

        this._p = 0;
        this._delayLeft = 0;
        this._repeatsLeft = 0;

        this._stopDelayLeft = 0;
        this._stopP = 0;
    }

    start() {
        if (this._element && this._element.attached) {
            this._p = 0;
            this._delayLeft = this.settings.delay;
            this._repeatsLeft = this.settings.repeat;
            this._state = Animation.STATES.PLAYING;
            this.emit('start');
            this.checkActive();
        } else {
            console.warn("[Lightning] Element must be attached before starting animation");
        }
    }

    play() {
        if (this._state === Animation.STATES.PAUSED) {
            // Continue.;
            this._state = Animation.STATES.PLAYING;
            this.checkActive();
            this.emit('resume');
        } else if (this._state == Animation.STATES.STOPPING && this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.REVERSE) {
            // Continue.;
            this._state = Animation.STATES.PLAYING;
            this.emit('stopContinue');
        } else if (this._state != Animation.STATES.PLAYING && this._state != Animation.STATES.FINISHED) {
            // Restart.;
            this.start();
        }
    }

    pause() {
        if (this._state === Animation.STATES.PLAYING) {
            this._state = Animation.STATES.PAUSED;
            this.emit('pause');
        }
    }

    replay() {
        if (this._state == Animation.STATES.FINISHED) {
            this.start();
        } else {
            this.play();
        }
    }

    skipDelay() {
        this._delayLeft = 0;
        this._stopDelayLeft = 0;
    }

    finish() {
        if (this._state === Animation.STATES.PLAYING) {
            this._delayLeft = 0;
            this._p = 1;
        } else if (this._state === Animation.STATES.STOPPING) {
            this._stopDelayLeft = 0;
            this._p = 0;
        }
    }

    stop() {
        if (this._state === Animation.STATES.STOPPED || this._state === Animation.STATES.IDLE) return;

        this._stopDelayLeft = this.settings.stopDelay || 0;

        if (((this.settings.stopMethod === _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.IMMEDIATE) && !this._stopDelayLeft) || this._delayLeft > 0) {
            // Stop upon next progress.;
            this._state = Animation.STATES.STOPPING;
            this.emit('stop');
        } else {
            if (this.settings.stopMethod === _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FADE) {
                this._stopP = 0;
            }

            this._state = Animation.STATES.STOPPING;
            this.emit('stop');
        }

        this.checkActive();
    }

    stopNow() {
        if (this._state !== Animation.STATES.STOPPED || this._state !== Animation.STATES.IDLE) {
            this._state = Animation.STATES.STOPPING;
            this._p = 0;
            this.emit('stop');
            this.reset();
            this._state = Animation.STATES.STOPPED;
            this.emit('stopFinish');
        }
    }

    isPaused() {
        return this._state === Animation.STATES.PAUSED;
    }

    isPlaying() {
        return this._state === Animation.STATES.PLAYING;
    }

    isStopping() {
        return this._state === Animation.STATES.STOPPING;
    }

    isFinished() {
        return this._state === Animation.STATES.FINISHED;
    }

    checkActive() {
        if (this.isActive()) {
            this.manager.addActive(this);
        }
    }

    isActive() {
        return (this._state == Animation.STATES.PLAYING || this._state == Animation.STATES.STOPPING) && this._element && this._element.attached;
    }

    progress(dt) {
        if (!this._element) return;
        this._progress(dt);
        this.apply();
    }

    _progress(dt) {
        if (this._state == Animation.STATES.STOPPING) {
            this._stopProgress(dt);
            return;
        }

        if (this._state != Animation.STATES.PLAYING) {
            return;
        }

        if (this._delayLeft > 0) {
            this._delayLeft -= dt;

            if (this._delayLeft < 0) {
                dt = -this._delayLeft;
                this._delayLeft = 0;

                this.emit('delayEnd');
            } else {
                return;
            }
        }

        if (this.settings.duration === 0) {
            this._p = 1;
        } else if (this.settings.duration > 0) {
            this._p += dt / this.settings.duration;
        }
        if (this._p >= 1) {
            // Finished!;
            if (this.settings.repeat == -1 || this._repeatsLeft > 0) {
                if (this._repeatsLeft > 0) {
                    this._repeatsLeft--;
                }
                this._p = this.settings.repeatOffset;
                this.emit('progress', this._p);
                
                if (this.settings.repeatDelay) {
                    this._delayLeft = this.settings.repeatDelay;
                }

                this.emit('repeat', this._repeatsLeft);
            } else {
                this._p = 1;
                this.emit('progress', this._p);
                
                this._state = Animation.STATES.FINISHED;
                this.emit('finish');
                if (this.settings.autostop) {
                    this.stop();
                }
            }
        } else {
            this.emit('progress', this._p);
        }
    }
    
    _stopProgress(dt) {
        let duration = this._getStopDuration();

        if (this._stopDelayLeft > 0) {
            this._stopDelayLeft -= dt;

            if (this._stopDelayLeft < 0) {
                dt = -this._stopDelayLeft;
                this._stopDelayLeft = 0;

                this.emit('stopDelayEnd');
            } else {
                return;
            }
        }
        if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.IMMEDIATE) {
            this._state = Animation.STATES.STOPPED;
            this.emit('stopFinish');
        } else if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.REVERSE) {
            if (duration === 0) {
                this._p = 0;
            } else if (duration > 0) {
                this._p -= dt / duration;
            }

            if (this._p <= 0) {
                this._p = 0;
                this._state = Animation.STATES.STOPPED;
                this.emit('stopFinish');
            }
        } else if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FADE) {
            this._progressStopTransition(dt);
            if (this._stopP >= 1) {
                this._p = 0;
                this._state = Animation.STATES.STOPPED;
                this.emit('stopFinish');
            }
        } else if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.ONETOTWO) {
            if (this._p < 2) {
                if (duration === 0) {
                    this._p = 2;
                } else if (duration > 0) {
                    if (this._p < 1) {
                        this._p += dt / this.settings.duration;
                    } else {
                        this._p += dt / duration;
                    }
                }
                if (this._p >= 2) {
                    this._p = 2;
                    this._state = Animation.STATES.STOPPED;
                    this.emit('stopFinish');
                } else {
                    this.emit('progress', this._p);
                }
            }
        } else if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FORWARD) {
            if (this._p < 1) {
                if (this.settings.duration == 0) {
                    this._p = 1;
                } else {
                    this._p += dt / this.settings.duration;
                }
                if (this._p >= 1) {
                    if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FORWARD) {
                        this._p = 1;
                        this._state = Animation.STATES.STOPPED;
                        this.emit('stopFinish');
                    } else {
                        if (this._repeatsLeft > 0) {
                            this._repeatsLeft--;
                            this._p = 0;
                            this.emit('repeat', this._repeatsLeft);
                        } else {
                            this._p = 1;
                            this._state = Animation.STATES.STOPPED;
                            this.emit('stopFinish');
                        }
                    }
                } else {
                    this.emit('progress', this._p);
                }
            }
        }
        
    }
    
    _progressStopTransition(dt) {
        if (this._stopP < 1) {
            if (this._stopDelayLeft > 0) {
                this._stopDelayLeft -= dt;

                if (this._stopDelayLeft < 0) {
                    dt = -this._stopDelayLeft;
                    this._stopDelayLeft = 0;

                    this.emit('delayEnd');
                } else {
                    return;
                }
            }
            
            const duration = this._getStopDuration();

            if (duration == 0) {
                this._stopP = 1;
            } else {
                this._stopP += dt / duration;
            }
            if (this._stopP >= 1) {
                // Finished!;
                this._stopP = 1;
            }
        }
    }

    _getStopDuration() {
        return this.settings.stopDuration || this.settings.duration;
    }

    apply() {
        if (this._state === Animation.STATES.STOPPED) {
            this.reset();
        } else {
            let factor = 1;
            if (this._state === Animation.STATES.STOPPING && this.settings.stopMethod === _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FADE) {
                factor = (1 - this.settings.stopTimingFunctionImpl(this._stopP));
            }
            this._settings.apply(this._element, this._p, factor);
        }
    }

    reset() {
        this._settings.reset(this._element);
    }

    get state() {
        return this._state;
    }

    get p() {
        return this._p;
    }

    get delayLeft() {
        return this._delayLeft;
    }

    get element() {
        return this._element;
    }

    get frame() {
        return Math.round(this._p * this._settings.duration * 60);
    }

    get settings() {
        return this._settings;
    }

}

Animation.STATES = {
    IDLE: 0,
    PLAYING: 1,
    STOPPING: 2,
    STOPPED: 3,
    FINISHED: 4,
    PAUSED: 5
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/AnimationActionSettings.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/AnimationActionSettings.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnimationActionSettings)
/* harmony export */ });
/* harmony import */ var _tools_MultiSpline_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/MultiSpline.mjs */ "./node_modules/@lightningjs/core/src/tools/MultiSpline.mjs");
/* harmony import */ var _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tree/Element.mjs */ "./node_modules/@lightningjs/core/src/tree/Element.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class AnimationActionSettings {

    constructor(animationSettings) {

        this.animationSettings = animationSettings;

        /**
         * The selector that selects the elements.
         * @type {string}
         */
        this._selector = "";

        /**
         * The value items, ordered by progress offset.
         * @type {MultiSpline}
         * @private;
         */
        this._items = new _tools_MultiSpline_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]();

        /**
         * The affected properties (paths).
         * @private;
         */
        this._props = [];

        /**
         * Property setters, indexed according to props.
         * @private;
         */
        this._propSetters = [];

        this._resetValue = undefined;
        this._hasResetValue = false;

        this._hasColorProperty = undefined;
    }

    getResetValue() {
        if (this._hasResetValue) {
            return this._resetValue;
        } else {
            return this._items.getValue(0);
        }
    }

    apply(element, p, factor) {
        const elements = this.getAnimatedElements(element);

        let v = this._items.getValue(p);

        if (v === undefined || !elements.length) {
            return;
        }

        if (factor !== 1) {
            // Stop factor.;
            let sv = this.getResetValue();

            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(v) && _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(sv)) {
                if (this.hasColorProperty()) {
                    v = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].mergeColors(v, sv, factor);
                } else {
                    v = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].mergeNumbers(v, sv, factor);
                }
            }
        }

        // Apply transformation to all components.;
        const n = this._propSetters.length;

        const m = elements.length;
        for (let j = 0; j < m; j++) {
            for (let i = 0; i < n; i++) {
                this._propSetters[i](elements[j], v);
            }
        }
    }
    
    getAnimatedElements(element) {
        return element.select(this._selector);
    }

    reset(element) {
        const elements = this.getAnimatedElements(element);

        let v = this.getResetValue();

        if (v === undefined || !elements.length) {
            return;
        }

        // Apply transformation to all components.
        const n = this._propSetters.length;

        const m = elements.length;
        for (let j = 0; j < m; j++) {
            for (let i = 0; i < n; i++) {
                this._propSetters[i](elements[j], v);
            }
        }
    }
    
    set selector(v) {
        this._selector = v;
    }

    set t(v) {
        this.selector = v;
    }

    get resetValue() {
        return this._resetValue;
    }
    
    set resetValue(v) {
        this._resetValue = v;
        this._hasResetValue = (v !== undefined);
    }

    set rv(v) {
        this.resetValue = v;
    }

    set value(v) {
        this._items.parse(this.hasColorProperty(), v);
    }

    set v(v) {
        this.value = v;
    }

    set properties(v) {
        if (!Array.isArray(v)) {
            v = [v];
        }

        this._props = [];

        v.forEach((prop) => {
            this._props.push(prop);
            this._propSetters.push(_tree_Element_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].getSetter(prop));
        });
    }

    set property(v) {
        this._hasColorProperty = undefined;
        this.properties = v;
    }

    set p(v) {
        this.properties = v;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].patchObject(this, settings);
    }

    hasColorProperty() {
        if (this._hasColorProperty === undefined) {
            this._hasColorProperty = this._props.length ? _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isColorProperty(this._props[0]) : false;
        }
        return this._hasColorProperty;
    }
}

AnimationActionSettings.prototype.isAnimationActionSettings = true;








/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/AnimationManager.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/AnimationManager.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnimationManager)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnimationSettings.mjs */ "./node_modules/@lightningjs/core/src/animation/AnimationSettings.mjs");
/* harmony import */ var _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animation.mjs */ "./node_modules/@lightningjs/core/src/animation/Animation.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class AnimationManager {

    constructor(stage) {
        this.stage = stage;

        this.stage.on('frameStart', () => this.progress());

        /**
         * All running animations on attached subjects.
         * @type {Set<Animation>}
         */
        this.active = new Set();
    }

    progress() {
        if (this.active.size) {
            let dt = this.stage.dt;

            let filter = false;
            this.active.forEach(function(a) {
                if (a.isActive()) {
                    a.progress(dt);
                } else {
                    filter = true;
                }
            });

            if (filter) {
                this.active = new Set([...this.active].filter(t => t.isActive()));
            }
        }
    }

    createAnimation(element, settings) {
        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(settings)) {
            // Convert plain object to proper settings object.
            settings = this.createSettings(settings);
        }

        return new _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](
            this,
            settings,
            element
        );
    }

    createSettings(settings) {
        const animationSettings = new _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]();
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].patchObject(animationSettings, settings);
        return animationSettings;
    }

    addActive(transition) {
        this.active.add(transition);
    }
}







/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/AnimationSettings.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/AnimationSettings.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnimationSettings)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _AnimationActionSettings_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimationActionSettings.mjs */ "./node_modules/@lightningjs/core/src/animation/AnimationActionSettings.mjs");
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class AnimationSettings {
    constructor() {
        /**
         * @type {AnimationActionSettings[]}
         */
        this._actions = [];

        this.delay = 0;
        this.duration = 1;

        this.repeat = 0;
        this.repeatOffset = 0;
        this.repeatDelay = 0;

        this.autostop = false;

        this.stopMethod = AnimationSettings.STOP_METHODS.FADE;
        this._stopTimingFunction = 'ease';
        this._stopTimingFunctionImpl = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getTimingFunction(this._stopTimingFunction);
        this.stopDuration = 0;
        this.stopDelay = 0;
    }

    get actions() {
        return this._actions;
    }

    set actions(v) {
        this._actions = [];
        for (let i = 0, n = v.length; i < n; i++) {
            const e = v[i];
            if (!e.isAnimationActionSettings) {
                const aas = new _AnimationActionSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);
                aas.patch(e);
                this._actions.push(aas);
            } else {
                this._actions.push(e);
            }
        }
    }

    /**
     * Applies the animation to the specified element, for the specified progress between 0 and 1.
     * @param {Element} element;
     * @param {number} p;
     * @param {number} factor;
     */
    apply(element, p, factor = 1) {
        this._actions.forEach(function(action) {
            action.apply(element, p, factor);
        });
    }

    /**
     * Resets the animation to the reset values.
     * @param {Element} element;
     */
    reset(element) {
        this._actions.forEach(function(action) {
            action.reset(element);
        });
    }

    get stopTimingFunction() {
        return this._stopTimingFunction;
    }

    set stopTimingFunction(v) {
        this._stopTimingFunction = v;
        this._stopTimingFunctionImpl = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getTimingFunction(v);
    }

    get stopTimingFunctionImpl() {
        return this._stopTimingFunctionImpl;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].patchObject(this, settings);
    }

}

AnimationSettings.STOP_METHODS = {
    FADE: 'fade',
    REVERSE: 'reverse',
    FORWARD: 'forward',
    IMMEDIATE: 'immediate',
    ONETOTWO: 'onetotwo'
};



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/Transition.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/Transition.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Transition)
/* harmony export */ });
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class Transition extends _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(manager, settings, element, property) {
        super();

        this.manager = manager;

        this._settings = settings;

        this._element = element;

        this._getter = element.constructor.getGetter(property);
        this._setter = element.constructor.getSetter(property);

        this._merger = settings.merger;

        if (!this._merger) {
            this._merger = element.constructor.getMerger(property);
        }

        this._startValue = this._getter(this._element);
        this._targetValue = this._startValue;

        this._p = 1;
        this._delayLeft = 0;
    }

    start(targetValue) {
        this._startValue = this._getter(this._element);

        if (!this.isAttached()) {
            // We don't support transitions on non-attached elements. Just set value without invoking listeners.
            this._targetValue = targetValue;
            this._p = 1;
            this._updateDrawValue();
        } else {
            if (targetValue === this._startValue) {
                this.reset(targetValue, 1);
            } else {
                this._targetValue = targetValue;
                this._p = 0;
                this._delayLeft = this._settings.delay;
                this.emit('start');
                this.add();
            }
        }
    }

    finish() {
        if (this._p < 1) {
            // Value setting and will must be invoked (async) upon next transition cycle.
            this._p = 1;
        }
    }

    stop() {
        // Just stop where the transition is at.
        this.emit('stop');
        this.manager.removeActive(this);
    }

    pause() {
        this.stop();
    }

    play() {
        this.manager.addActive(this);
    }

    reset(targetValue, p) {
        if (!this.isAttached()) {
            // We don't support transitions on non-attached elements. Just set value without invoking listeners.
            this._startValue = this._getter(this._element);
            this._targetValue = targetValue;
            this._p = 1;
            this._updateDrawValue();
        } else {
            this._startValue = this._getter(this._element);
            this._targetValue = targetValue;
            this._p = p;
            this.add();
        }
    }

    _updateDrawValue() {
        this._setter(this._element, this.getDrawValue());
    }

    add() {
        this.manager.addActive(this);
    }

    isAttached() {
        return this._element.attached;
    }

    isRunning() {
        return (this._p < 1.0);
    }

    progress(dt) {
        if (!this.isAttached()) {
            // Skip to end of transition so that it is removed.
            this._p = 1;
        }

        if (this.p < 1) {
            if (this.delayLeft > 0) {
                this._delayLeft -= dt;

                if (this.delayLeft < 0) {
                    dt = -this.delayLeft;
                    this._delayLeft = 0;

                    this.emit('delayEnd');
                } else {
                    return;
                }
            }

            if (this._settings.duration == 0) {
                this._p = 1;
            } else {
                this._p += dt / this._settings.duration;
            }
            if (this._p >= 1) {
                // Finished!;
                this._p = 1;
            }
        }

        this._updateDrawValue();

        this.invokeListeners();
    }

    invokeListeners() {
        this.emit('progress', this.p);
        if (this.p === 1) {
            this.emit('finish');
        }
    }

    updateTargetValue(targetValue) {
        let t = this._settings.timingFunctionImpl(this.p);
        if (t === 1) {
            this._targetValue = targetValue;
        } else if (t === 0) {
            this._startValue = this._targetValue;
            this._targetValue = targetValue;
        } else {
            this._startValue = targetValue - ((targetValue - this._targetValue) / (1 - t));
            this._targetValue = targetValue;
        }
    }

    getDrawValue() {
        if (this.p >= 1) {
            return this.targetValue;
        } else {
            let v = this._settings._timingFunctionImpl(this.p);
            return this._merger(this.targetValue, this.startValue, v);
        }
    }

    skipDelay() {
        this._delayLeft = 0;
    }

    get startValue() {
        return this._startValue;
    }

    get targetValue() {
        return this._targetValue;
    }

    get p() {
        return this._p;
    }

    get delayLeft() {
        return this._delayLeft;
    }

    get element() {
        return this._element;
    }

    get settings() {
        return this._settings;
    }

    set settings(v) {
        this._settings = v;
    }

}

Transition.prototype.isTransition = true;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/TransitionManager.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/TransitionManager.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TransitionManager)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _TransitionSettings_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransitionSettings.mjs */ "./node_modules/@lightningjs/core/src/animation/TransitionSettings.mjs");
/* harmony import */ var _Transition_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transition.mjs */ "./node_modules/@lightningjs/core/src/animation/Transition.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class TransitionManager {

    constructor(stage) {
        this.stage = stage;

        this.stage.on('frameStart', () => this.progress());

        /**
         * All transitions that are running and attached.
         * (we don't support transitions on un-attached elements to prevent memory leaks)
         * @type {Set<Transition>}
         */
        this.active = new Set();

        this.defaultTransitionSettings = new _TransitionSettings_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this.stage);
    }

    progress() {
        if (this.active.size) {
            let dt = this.stage.dt;

            let filter = false;
            this.active.forEach(function(a) {
                a.progress(dt);
                if (!a.isRunning()) {
                    filter = true;
                }
            });

            if (filter) {
                this.active = new Set([...this.active].filter(t => (t.isRunning())));
            }
        }
    }

    createSettings(settings) {
        const transitionSettings = new _TransitionSettings_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]();
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].patchObject(transitionSettings, settings);
        return transitionSettings;
    }

    addActive(transition) {
        this.active.add(transition);
    }

    removeActive(transition) {
        this.active.delete(transition);
    }
}






/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/TransitionSettings.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/TransitionSettings.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TransitionSettings)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class TransitionSettings {
    constructor(stage) {
        this.stage = stage;
        this._timingFunction = 'ease';
        this._timingFunctionImpl = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getTimingFunction(this._timingFunction);
        this.delay = 0;
        this.duration = 0.2;
        this.merger = null;
    }

    get timingFunction() {
        return this._timingFunction;
    }

    set timingFunction(v) {
        this._timingFunction = v;
        this._timingFunctionImpl = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getTimingFunction(v);
    }

    get timingFunctionImpl() {
        return this._timingFunctionImpl;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].patchObject(this, settings);
    }
}

TransitionSettings.prototype.isTransitionSettings = true;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/application/Application.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/application/Application.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Application)
/* harmony export */ });
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_Stage_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tree/Stage.mjs */ "./node_modules/@lightningjs/core/src/tree/Stage.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class Application extends _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(options = {}, properties) {
        // Save options temporarily to avoid having to pass it through the constructor.
        Application._temp_options = options;

        // Booting flag is used to postpone updateFocusSettings;
        Application.booting = true;
        const stage = new _tree_Stage_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](options.stage);
        super(stage, properties);
        Application.booting = false;

        this.__updateFocusCounter = 0;
        this.__keypressTimers = new Map();
        this.__hoveredChild = null;

        // We must construct while the application is not yet attached.
        // That's why we 'init' the stage later (which actually emits the attach event).
        this.stage.init();

        // Initially, the focus settings are updated after both the stage and application are constructed.
        this.updateFocusSettings();

        this.__keymap = this.getOption('keys');

        if (this.__keymap) {
            this.stage.platform.registerKeydownHandler((e) => {
                this._receiveKeydown(e);
            });

            this.stage.platform.registerKeyupHandler((e) => {
                this._receiveKeyup(e);
            });
        }

        if (this.getOption("enablePointer")) {
            this.stage.platform.registerClickHandler((e) => {
                this._receiveClick(e);
            });

            this.stage.platform.registerHoverHandler((e) => {
                this._receiveHover(e);
            });

            this.stage.platform.registerScrollWheelHandler((e) => {
                this._recieveScrollWheel(e);
            });

            this.cursor = 'default';
        }
    }

    getOption(name) {
        return this.__options[name];
    }

    _setOptions(o) {
        this.__options = {};

        let opt = (name, def) => {
            let value = o[name];

            if (value === undefined) {
                this.__options[name] = def;
            } else {
                this.__options[name] = value;
            }
        }

        opt('debug', false);
        opt('keys', {
            38: "Up",
            40: "Down",
            37: "Left",
            39: "Right",
            13: "Enter",
            8: "Back",
            27: "Exit"
        });
        opt('enablePointer', false);
    }

    __construct() {
        this.stage.setApplication(this);

        this._setOptions(Application._temp_options);
        delete Application._temp_options;

        super.__construct();
    }

    __init() {
        super.__init();
        this.__updateFocus();
    }

    updateFocusPath() {
        this.__updateFocus();
    }

    __updateFocus() {
        const notOverridden = this.__updateFocusRec();

        if (!Application.booting && notOverridden) {
            this.updateFocusSettings();
        }
    }

    __updateFocusRec() {
        const updateFocusId = ++this.__updateFocusCounter;
        this.__updateFocusId = updateFocusId;

        const newFocusPath = this.__getFocusPath();
        const newFocusedComponent = newFocusPath[newFocusPath.length - 1];
        const prevFocusedComponent = this._focusPath ? this._focusPath[this._focusPath.length - 1] : undefined;

        if (!prevFocusedComponent) {
            // Focus events.
            this._focusPath = [];
            for (let i = 0, n = newFocusPath.length; i < n; i++) {
                this._focusPath.push(newFocusPath[i]);
                this._focusPath[i]._focus(newFocusedComponent, undefined);
                const focusOverridden = (this.__updateFocusId !== updateFocusId);
                if (focusOverridden) {
                    return false;
                }
            }
            return true;
        } else {
            let m = Math.min(this._focusPath.length, newFocusPath.length);
            let index;
            for (index = 0; index < m; index++) {
                if (this._focusPath[index] !== newFocusPath[index]) {
                    break;
                }
            }

            if (this._focusPath.length !== newFocusPath.length || index !== newFocusPath.length) {

                if (this.getOption('debug')) {
                    console.log('[Lightning] Focus changed: ' + newFocusedComponent.getLocationString());
                }

                // Unfocus events.
                for (let i = this._focusPath.length - 1; i >= index; i--) {
                    const unfocusedElement = this._focusPath.pop();
                    unfocusedElement._unfocus(newFocusedComponent, prevFocusedComponent);
                    const focusOverridden = (this.__updateFocusId !== updateFocusId);
                    if (focusOverridden) {
                        return false;
                    }
                }

                // Focus events.
                for (let i = index, n = newFocusPath.length; i < n; i++) {
                    this._focusPath.push(newFocusPath[i]);
                    this._focusPath[i]._focus(newFocusedComponent, prevFocusedComponent);
                    const focusOverridden = (this.__updateFocusId !== updateFocusId);
                    if (focusOverridden) {
                        return false;
                    }
                }

                // Focus changed events.
                for (let i = 0; i < index; i++) {
                    this._focusPath[i]._focusChange(newFocusedComponent, prevFocusedComponent);
                }
            }
        }

        return true;
    }

    updateFocusSettings() {
        const focusedComponent = this._focusPath[this._focusPath.length - 1];

        // Get focus settings. These can be used for dynamic application-wide settings that depend on the
        // focus directly (such as the application background).
        const focusSettings = {};
        const defaultSetFocusSettings = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].prototype._setFocusSettings;
        for (let i = 0, n = this._focusPath.length; i < n; i++) {
            if (this._focusPath[i]._setFocusSettings !== defaultSetFocusSettings) {
                this._focusPath[i]._setFocusSettings(focusSettings);
            }
        }

        const defaultHandleFocusSettings = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].prototype._handleFocusSettings;
        for (let i = 0, n = this._focusPath.length; i < n; i++) {
            if (this._focusPath[i]._handleFocusSettings !== defaultHandleFocusSettings) {
                this._focusPath[i]._handleFocusSettings(focusSettings, this.__prevFocusSettings, focusedComponent);
            }
        }

        this.__prevFocusSettings = focusSettings;
    }

    _handleFocusSettings(settings, prevSettings, focused, prevFocused) {
        // Override to handle focus-based settings.
    }

    __getFocusPath() {
        const path = [this];
        let current = this;
        do {
            const nextFocus = current._getFocused();
            if (!nextFocus || (nextFocus === current)) {
                // Found!;
                break;
            }


            let ptr = nextFocus.cparent;
            if (ptr === current) {
                path.push(nextFocus);
            } else {
                // Not an immediate child: include full path to descendant.
                const newParts = [nextFocus];
                do {
                    if (!ptr) {
                        current._throwError("Return value for _getFocused must be an attached descendant component but its '" + nextFocus.getLocationString() + "'");
                    }
                    newParts.push(ptr);
                    ptr = ptr.cparent;
                } while (ptr !== current);

                // Add them reversed.
                for (let i = 0, n = newParts.length; i < n; i++) {
                    path.push(newParts[n - i - 1]);
                }
            }

            current = nextFocus;
        } while(true);

        return path;
    }

    get focusPath() {
        return this._focusPath;
    }

    /**
     * Injects an event in the state machines, top-down from application to focused component.
     */
    focusTopDownEvent(events, ...args) {
        const path = this.focusPath;
        const n = path.length;

        // Multiple events.
        for (let i = 0; i < n; i++) {
            const event = path[i]._getMostSpecificHandledMember(events);
            if (event !== undefined) {
                const returnValue = path[i][event](...args);
                if (returnValue !== false) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Injects an event in the state machines, bottom-up from focused component to application.
     */
    focusBottomUpEvent(events, ...args) {
        const path = this.focusPath;
        const n = path.length;

        // Multiple events.
        for (let i = n - 1; i >= 0; i--) {
            const event = path[i]._getMostSpecificHandledMember(events);
            if (event !== undefined) {
                const returnValue = path[i][event](...args);
                if (returnValue !== false) {
                    return true;
                }
            }
        }

        return false;
    }

    _receiveKeydown(e) {
        const obj = e;
        const key = this.__keymap[e.keyCode];
        const path = this.focusPath;

        let keys;
        if (key) {
            keys = Array.isArray(key) ? key : [key];
        }

        if (keys) {
            for (let i = 0, n = keys.length; i < n; i++) {
                const hasTimer = this.__keypressTimers.has(keys[i]);
                // prevent event from getting fired when the timeout is still active
                if (path[path.length - 1].longpress && hasTimer) {
                    return;
                }

                if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}`, "_captureKey"], obj)) {
                    this.stage.application.focusBottomUpEvent([`_handle${keys[i]}`, "_handleKey"], obj);
                }
            }
        } else {
            if (!this.stage.application.focusTopDownEvent(["_captureKey"], obj)) {
                this.stage.application.focusBottomUpEvent(["_handleKey"], obj);
            }
        }

        this.updateFocusPath();

        const consumer = path[path.length - 1];

        if (keys && consumer.longpress) {
            for (let i = 0, n = keys.length; i < n; i++) {
                this._startLongpressTimer(keys[i], consumer);
            }
        }
    }

    /**
     * Keyup listener
     * To take away some confusion we add `Release` to the event to prevent ending up with method names like:
     *  _handleLeftUp / _handleUpUp / _handleEnterUp etc
     *
     * @param e
     * @private
     */
    _receiveKeyup(e) {
        const obj = e;
        const key = this.__keymap[e.keyCode];

        let keys;
        if (key) {
            keys = Array.isArray(key) ? key : [key];
        }

        if (keys) {
            for (let i = 0, n = keys.length; i < n; i++) {
                if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}Release`, "_captureKeyRelease"], obj)) {
                    this.stage.application.focusBottomUpEvent([`_handle${keys[i]}Release`, "_handleKeyRelease"], obj);
                }
            }
        } else {
            if (!this.stage.application.focusTopDownEvent(["_captureKeyRelease"], obj)) {
                this.stage.application.focusBottomUpEvent(["_handleKeyRelease"], obj);
            }
        }

        this.updateFocusPath();

        if (keys) {
            for (let i = 0, n = keys.length; i < n; i++) {
                if (this.__keypressTimers.has(keys[i])) {
                    // keyup has fired before end of timeout so we clear it
                    clearTimeout(this.__keypressTimers.get(keys[i]));
                    // delete so we can register it again
                    this.__keypressTimers.delete(keys[i]);
                }
            }
        }
    }

    /**
     * Registers and starts a timer for the pressed key. Timer will be cleared when the key is released
     * before the timer goes off.
     *
     * If key is not release (keyup) the longpress handler will be fired.
     * Configuration can be via the Components template:
     *
     * static _template() {
     *     return {
     *         w:100, h:100,
     *         longpress:{up:700, down:500}
     *     }
     * }     *
     * // this will get called when up has been pressed for 700ms
     * _handleUpLong() {
     *
     * }
     *
     * @param key
     * @param element
     * @private
     */
    _startLongpressTimer(key, element) {
        const config = element.longpress;
        const lookup = key.toLowerCase();

        if (config[lookup]) {
            const timeout = config[lookup];
            if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(timeout)) {
                element._throwError("config value for longpress must be a number");
            } else {
                this.__keypressTimers.set(key, setTimeout(() => {
                    if (!this.stage.application.focusTopDownEvent([`_capture${key}Long`, "_captureKey"], {})) {
                        this.stage.application.focusBottomUpEvent([`_handle${key}Long`, "_handleKey"], {});
                    }

                    this.__keypressTimers.delete(key);
                }, timeout || 500 /* prevent 0ms */));
            }
        }
        return;
    }

    _recieveScrollWheel(e) {
        const obj = e;
        const {clientX, clientY} = obj;

        if (clientX <= this.stage.w && clientY <= this.stage.h) {
            if (!this.fireTopDownScrollWheelHandler("_captureScroll", obj)) {
                this.fireBottomUpScrollWheelHandler("_handleScroll", obj);
            }
        }
    }

    fireTopDownScrollWheelHandler(event, obj) {
        let children = this.stage.application.children;
        let affected = this._findChildren([], children).reverse();
        let n = affected.length;

        while(n--) {
            const child = affected[n];
            if (child && child[event]) {
                child._captureScroll(obj);
                return true; 
            }
        }
        return false;
    }

    fireBottomUpScrollWheelHandler(event, obj) {
        const {clientX, clientY} = obj;
        const target = this._getTargetChild(clientX, clientY);
        let child = target;

        // Search tree bottom up for a handler
        while (child !== null) {
            if (child && child[event]) {
                child._handleScroll(obj);
                return true;
            }
            child = child.parent;
        }
        return false;
    }

    _receiveClick(e) {
        const obj = e;
        const {clientX, clientY} = obj;

        if (clientX <= this.stage.w && clientY <= this.stage.h) {
            this.stage.application.fireBottomUpClickHandler(obj);
        }
    }

    fireBottomUpClickHandler(obj) {
        const {clientX, clientY} = obj;
        const target = this._getTargetChild(clientX, clientY);
        let child = target;

        // Search tree bottom up for a handler
        while (child !== null) {
            if (child && child["_handleClick"]) {
                child._handleClick(target);
                break;
            }
            child = child.parent;
        }
    }

    _receiveHover(e) {
        const obj = e;
        const {clientX, clientY} = obj;

        if (clientX <= this.stage.w && clientY <= this.stage.h) {
            this.stage.application.fireBottomUpHoverHandler(obj);
        }
    }

    fireBottomUpHoverHandler(obj) {
        const {clientX, clientY} = obj;
        const target = this._getTargetChild(clientX, clientY);

        // Only fire handlers when pointer target changes
        if (target !== this.__hoveredChild) {

            let hoveredBranch = new Set();
            let newHoveredBranch = new Set();

            if (target) {
                newHoveredBranch = new Set(target.getAncestors());
            }

            if (this.__hoveredChild) {
                hoveredBranch = new Set(this.__hoveredChild.getAncestors());
                for (const elem of [...hoveredBranch].filter((e) => !newHoveredBranch.has(e))) {
                    const c = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(elem);
                    if (c["_handleUnhover"]) {
                        c._handleUnhover(elem);
                    }
                    if (elem.parent && elem.parent.cursor) {
                        this.stage.getCanvas().style.cursor = elem.parent.cursor;
                    }
                }
            }

            this.__hoveredChild = target;

            const diffBranch = [...newHoveredBranch].filter((e) => !hoveredBranch.has(e))
            for (const elem of diffBranch) {
                const c = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(elem);
                if (c["_handleHover"]) {
                    c._handleHover(elem);
                }
            }

            // New element hover cursor
            const lastElement = diffBranch[0];
            if (lastElement && lastElement.cursor) {
                this.stage.getCanvas().style.cursor = lastElement.cursor;
            }

            // Rerun _handleHover for target element in case it's been hovered
            // back from its child
            if (diffBranch.length === 0 && target) {
                const c = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(target);
                if (c["_handleHover"]) {
                    c._handleHover(target);
                }
            }
        }
    }

    _getTargetChild(clientX, clientY) {
        let children = this.stage.application.children;
        let affected = this._findChildren([], children);
        let hoverableChildren = this._withinClickableRange(affected, clientX, clientY);

        hoverableChildren.sort((a,b) => {
            // Sort by zIndex and then id
            if (a.zIndex > b.zIndex) {
                return 1;
            } else if (a.zIndex < b.zIndex) {
                return -1;
            } else {
                return a.id > b.id ? 1: -1;
            }
        });

        if (hoverableChildren.length) {
            // Assume target has highest zIndex (id when zIndex equal)
            return hoverableChildren.slice(-1)[0];
        } else {
            return null;
        }
    }

    _findChildren(bucket, children) {
        let n = children.length;
        while (n--) {
            const child = children[n];
            // only add active children
            if (child.__active && child.collision) {
                if (child.collision === true) {
                    bucket.push(child);
                }
                if (child.hasChildren()) {
                    this._findChildren(bucket, child.children);
                }
            }
        }
        return bucket;
    }

    _withinClickableRange(affectedChildren, cursorX, cursorY) {
        let n = affectedChildren.length;
        const candidates = [];

        // loop through affected children
        // and perform collision detection
        while (n--) {
            const child = affectedChildren[n];
            const precision = this.stage.getRenderPrecision();
            const ctx = child.core._worldContext;

            const cx = ctx.px * precision;
            const cy = ctx.py * precision;
            const cw = child.finalW * ctx.ta * precision;
            const ch = child.finalH * ctx.td * precision;

            if (cx > this.stage.w || cy > this.stage.h) {
                continue;
            }

            if (child.parent.core._scissor) {
                const scissor = child.parent.core._scissor.map((v) => v * precision);
                if (!this._testCollision(cursorX, cursorY, ...scissor))
                    continue
            }

            if (this._testCollision(cursorX, cursorY, cx, cy, cw, ch)) {
                candidates.push(child);
            }
        }
        return candidates;
    }

    _testCollision(px, py, cx, cy, cw, ch) {
        if (px >= cx &&
            px <= cx + cw &&
            py >= cy &&
            py <= cy + ch) {
            return true;
        }
        return false;
    }

    destroy() {
        if (!this._destroyed) {
            this._destroy();
            this.stage.destroy();
            this._destroyed = true;
        }
    }

    _destroy() {
        // This forces the _detach, _disabled and _active events to be called.
        this.stage.setApplication(undefined);
        this._updateAttachedFlag();
        this._updateEnabledFlag();

        if (this.__keypressTimers.size) {
            for (const timer of this.__keypressTimers.values()) {
                clearTimeout(timer);
            }

            this.__keypressTimers.clear();
        }
    }

    getCanvas() {
        return this.stage.getCanvas();
    }

}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/application/Component.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/application/Component.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Element.mjs */ "./node_modules/@lightningjs/core/src/tree/Element.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _StateMachine_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StateMachine.mjs */ "./node_modules/@lightningjs/core/src/application/StateMachine.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @extends StateMachine
 */
class Component extends _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage, properties) {
        super(stage);

        // Encapsulate tags to prevent leaking.
        this.tagRoot = true;

        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(properties)) {
            Object.assign(this, properties);
        }

        this.__initialized = false;
        this.__firstActive = false;
        this.__firstEnable = false;

        this.__signals = undefined;

        this.__passSignals = undefined;

        this.__construct();

        // Quick-apply template.
        const func = this.constructor.getTemplateFunc(this);
        func.f(this, func.a);

        this._build();
    }

    __start() {
        _StateMachine_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].setupStateMachine(this);
        this._onStateChange = Component.prototype.__onStateChange;
    }

    get state() {
        return this._getState();
    }

    __onStateChange() {
        /* FIXME: Workaround for case, where application was shut but component still lives */
        if (this.application) {
            this.application.updateFocusPath();
        }
    }

    _refocus() {
        /* FIXME: Workaround for case, where application was shut but component still lives */
        if (this.application) {
            this.application.updateFocusPath();
        }
    }

    static bindProp(name, func = null) {
        return {__propertyBinding: true, __name: name, __func: func};
    }

    __bindProperty(propObj, targetObj, targetProp) {
        // 1. find binding position: find object and property name to be bound
        const obj = targetObj;
        const prop = targetProp;
        const propDependencies = Array.isArray(propObj.__name) ? propObj.__name : [propObj.__name];

        // 2. create setters for every given dependency
        for (let i = 0; i < propDependencies.length; i++) {
            const propName = propDependencies[i];
            const func = propObj.__func ? propObj.__func : (context) => context[propName];

            if (!this.hasOwnProperty(propName)) {
                this[`__prop_bindings_${propName}`] = [{__obj: obj, __prop: prop, __func: func}];
                Object.defineProperty(this, propName, {
                    set: (value) => {
                        this[`__prop_${propName}`] = value;
                        for (const {__obj, __prop, __func} of this[`__prop_bindings_${propName}`]) {
                            __obj[__prop] = __func(this);
                        }
                    },
                    get: () => this[`__prop_${propName}`]
                });
            } else {
                this[`__prop_bindings_${propName}`].push({__obj: obj, __prop: prop, __func: func});
            }
        }
    }

    /**
     * Returns a high-performance template patcher.
     */
    static getTemplateFunc(ctx) {
        // We need a different template function per patch id.
        const name = "_templateFunc";

        // Be careful with class-based static inheritance.
        const hasName = '__has' + name;
        if (this[hasName] !== this) {
            this[hasName] = this;
            this[name] = this.parseTemplate(this._template(ctx));
        }
        return this[name];
    }

    static parseTemplate(obj) {
        const context = {
            loc: [],
            store: [],
            rid: 0
        };

        this.parseTemplateRec(obj, context, "element");

        const code = context.loc.join(";\n");
        const f = new Function("element", "store", code);
        return {f: f, a: context.store};
    }

    static parseTemplateRec(obj, context, cursor) {
        const store = context.store;
        const loc = context.loc;
        const keys = Object.keys(obj);
        keys.forEach(key => {
            let value = obj[key];
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isUcChar(key.charCodeAt(0))) {
                // Value must be expanded as well.
                if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value)) {
                    // Ref.
                    const childCursor = `r${key.replace(/[^a-z0-9]/gi, "") + context.rid}`;
                    let type = value.type ? value.type : _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_0__["default"];
                    if (type === _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]) {
                        loc.push(`var ${childCursor} = element.stage.createElement()`);
                    } else {
                        store.push(type);
                        loc.push(`var ${childCursor} = new store[${store.length - 1}](${cursor}.stage)`);
                    }
                    loc.push(`${childCursor}.ref = "${key}"`);
                    context.rid++;

                    // Enter sub.
                    this.parseTemplateRec(value, context, childCursor);

                    loc.push(`${cursor}.childList.add(${childCursor})`);
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(value)) {
                    // Dynamic assignment.
                    store.push(value);
                    loc.push(`${cursor}.childList.add(store[${store.length - 1}])`);
                }
            } else {
                if (key === "text") {
                    const propKey = cursor + "__text";
                    loc.push(`var ${propKey} = ${cursor}.enableTextTexture()`);
                    if (value.__propertyBinding === true) {
                        // Allow binding entire objects to text property
                        store.push(value);
                        loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                    } else {
                        this.parseTemplatePropRec(value, context, propKey);
                    }
                } else if (key === "shader" && _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value)) {
                    const shaderCursor = `${cursor}["shader"]`
                    store.push(value);
                    loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                    this.parsePropertyBindings(value, context, shaderCursor);
                } else if (key === "texture" && _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value)) {
                    const propKey = cursor + "__texture";
                    const type = value.type;
                    if (type) {
                        store.push(type);
                        loc.push(`var ${propKey} = new store[${store.length - 1}](${cursor}.stage)`);
                        this.parseTemplatePropRec(value, context, propKey);
                        loc.push(`${cursor}["${key}"] = ${propKey}`);
                    } else {
                        loc.push(`${propKey} = ${cursor}.texture`);
                        this.parseTemplatePropRec(value, context, propKey);
                    }
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value) && value.__propertyBinding === true) {
                    store.push(value);
                    loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                } else {
                    // Property;
                    if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(value)) {
                        loc.push(`${cursor}["${key}"] = ${value}`);
                    } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isBoolean(value)) {
                        loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
                    } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(value) || Array.isArray(value)) {
                        // Dynamic assignment.
                        // Because literal objects may contain dynamics, we store the full object.
                        store.push(value);
                        loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                    } else {
                        // String etc.
                        loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
                    }
                }
            }
        });
    }

    static parseTemplatePropRec(obj, context, cursor) {
        const store = context.store;
        const loc = context.loc;
        const keys = Object.keys(obj);
        keys.forEach(key => {
            if (key !== "type") {
                const value = obj[key];
                if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(value)) {
                    loc.push(`${cursor}["${key}"] = ${value}`);
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isBoolean(value)) {
                    loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(value) && value.__propertyBinding === true) {
                    store.push(value);
                    loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(value) || Array.isArray(value)) {
                    // Dynamic assignment.
                    // Because literal objects may contain dynamics, we store the full object.
                    store.push(value);
                    loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                } else {
                    // String etc.
                    loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
                }
            }
        });
    }

    static parsePropertyBindings(obj, context, cursor) {
        const store = context.store;
        const loc = context.loc;
        const keys = Object.keys(obj);
        keys.forEach(key => {
            if (key !== "type") {
                const value = obj[key];
                if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value) && value.__propertyBinding === true) {
                    store.push(value);
                    loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                }
            }
        });
    }

    _onSetup() {
        if (!this.__initialized) {
            this._setup();
        }
    }

    _setup() {
    }

    _onAttach() {
        if (!this.__initialized) {
            this.__init();
            this.__initialized = true;
        }

        this._attach();
    }

    _attach() {
    }

    _onDetach() {
        this._detach();
    }

    _detach() {
    }

    _onEnabled() {
        if (!this.__firstEnable) {
            this._firstEnable();
            this.__firstEnable = true;
        }

        this._enable();
    }

    _firstEnable() {
    }

    _enable() {
    }

    _onDisabled() {
        this._disable();
    }

    _disable() {
    }

    _onActive() {
        if (!this.__firstActive) {
            this._firstActive();
            this.__firstActive = true;
        }

        this._active();
    }

    _firstActive() {
    }

    _active() {
    }

    _onInactive() {
        this._inactive();
    }

    _inactive() {
    }

    get application() {
        return this.stage.application;
    }

    __construct() {
        this._construct();
    }

    _construct() {
    }

    _build() {
    }

    __init() {
        this._init();
    }

    _init() {
    }

    _focus(newTarget, prevTarget) {
    }

    _unfocus(newTarget) {
    }

    _focusChange(target, newTarget) {
    }

    _getFocused() {
        // Override to delegate focus to child components.
        return this;
    }

    _setFocusSettings(settings) {
        // Override to add custom settings. See Application._handleFocusSettings().
    }

    _handleFocusSettings(settings) {
        // Override to react on custom settings. See Application._handleFocusSettings().
    }

    static _template() {
        return {};
    }

    hasFinalFocus() {
        let path = this.application._focusPath;
        return path && path.length && path[path.length - 1] === this;
    }

    hasFocus() {
        let path = this.application._focusPath;
        return path && (path.indexOf(this) >= 0);
    }

    get cparent() {
        return Component.getParent(this);
    }

    seekAncestorByType(type) {
        let c = this.cparent;
        while (c) {
            if (c.constructor === type) {
                return c;
            }
            c = c.cparent;
        }
    }

    getSharedAncestorComponent(element) {
        let ancestor = this.getSharedAncestor(element);
        while (ancestor && !ancestor.isComponent) {
            ancestor = ancestor.parent;
        }
        return ancestor;
    }

    get signals() {
        return this.__signals;
    }

    set signals(v) {
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(v)) {
            this._throwError("Signals: specify an object with signal-to-fire mappings");
        }
        this.__signals = v;
    }

    set alterSignals(v) {
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(v)) {
            this._throwError("Signals: specify an object with signal-to-fire mappings");
        }
        if (!this.__signals) {
            this.__signals = {};
        }
        for (let key in v) {
            const d = v[key];
            if (d === undefined) {
                delete this.__signals[key];
            } else {
                this.__signals[key] = v;
            }
        }
    }

    get passSignals() {
        return this.__passSignals || {};
    }

    set passSignals(v) {
        this.__passSignals = Object.assign(this.__passSignals || {}, v);
    }

    set alterPassSignals(v) {
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(v)) {
            this._throwError("Signals: specify an object with signal-to-fire mappings");
        }
        if (!this.__passSignals) {
            this.__passSignals = {};
        }
        for (let key in v) {
            const d = v[key];
            if (d === undefined) {
                delete this.__passSignals[key];
            } else {
                this.__passSignals[key] = v;
            }
        }
    }

    /**
     * Signals the parent of the specified event.
     * A parent/ancestor that wishes to handle the signal should set the 'signals' property on this component.
     * @param {string} event
     * @param {...*} args
     */
    signal(event, ...args) {
        return this._signal(event, args);
    }

    _signal(event, args) {
        const signalParent = this._getParentSignalHandler();
        if (signalParent) {
            if (this.__signals) {
                let fireEvent = this.__signals[event];
                if (fireEvent === false) {
                    // Ignore event.
                    return;
                }
                if (fireEvent) {
                    if (fireEvent === true) {
                        fireEvent = event;
                    }
 
                    if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(fireEvent)) {
                        return fireEvent(...args);
                    }

                    if (signalParent._hasMethod(fireEvent)) {
                        return signalParent[fireEvent](...args);
                    }
                }
            }

            let passSignal = (this.__passSignals && this.__passSignals[event]);
            if (passSignal) {
                // Bubble up.
                if (passSignal && passSignal !== true) {
                    // Replace signal name.
                    event = passSignal;
                }

                return signalParent._signal(event, args);
            }
        }
    }

    _getParentSignalHandler() {
        return this.cparent ? this.cparent._getSignalHandler() : null;
    }

    _getSignalHandler() {
        if (this._signalProxy) {
            return this.cparent ? this.cparent._getSignalHandler() : null;
        }
        return this;
    }

    get _signalProxy() {
        return false;
    }

    fireAncestors(name, ...args) {
        if (!name.startsWith('$')) {
            throw new Error("Ancestor event name must be prefixed by dollar sign.");
        }

        const parent = this._getParentSignalHandler();
        if (parent) {
            return parent._doFireAncestors(name, args);
        }
    }

    _doFireAncestors(name, args) {
        if (this._hasMethod(name)) {
            return this.fire(name, ...args);
        } else {
            const signalParent = this._getParentSignalHandler();
            if (signalParent) {
                return signalParent._doFireAncestors(name, args);
            }
        }
    }

    static collectSubComponents(subs, element) {
        if (element.hasChildren()) {
            const childList = element.__childList;
            for (let i = 0, n = childList.length; i < n; i++) {
                const child = childList.getAt(i);
                if (child.isComponent) {
                    subs.push(child);
                } else {
                    Component.collectSubComponents(subs, child);
                }
            }
        }
    }

    static getComponent(element) {
        let parent = element;
        while (parent && !parent.isComponent) {
            parent = parent.parent;
        }
        return parent;
    }

    static getParent(element) {
        return Component.getComponent(element.parent);
    }
}

Component.prototype.isComponent = true;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/application/StateMachine.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/application/StateMachine.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StateMachine)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class StateMachine {

    constructor() {
        StateMachine.setupStateMachine(this);
    }

    static setupStateMachine(target) {
        const targetConstructor = target.constructor;
        const router = StateMachine.create(targetConstructor);
        Object.setPrototypeOf(target, router.prototype);
        target.constructor = targetConstructor;
        target._initStateMachine();
    }

    /**
     * Creates a state machine implementation.
     * It extends the original type and should be used when creating new instances.
     * The original type is available as static property 'original', and it must be used when subclassing as follows:
     * const type = StateMachine.create(class YourNewStateMachineClass extends YourBaseStateMachineClass.original {  })
     * @param {Class} type
     * @returns {StateMachine}
     */
    static create(type) {
        if (!type.hasOwnProperty('_sm')) {
            // Only need to run once.
            const stateMachineType = new StateMachineType(type);
            type._sm = stateMachineType;
        }

        return type._sm.router;
    }

    /**
     * Calls the specified method if it exists.
     * @param {string} event
     * @param {*...} args
     */
    fire(event, ...args) {
        if (this._hasMethod(event)) {
            return this[event](...args);
        }
    }

    /**
     * Returns the current state path (for example "Initialized.Loading").
     * @returns {string}
     * @protected
     */
    _getState() {
        return this._state.__path;
    }

    /**
     * Returns true iff statePath is (an ancestor of) currentStatePath.
     * @param {string} statePath
     * @param {string} currentStatePath
     * @returns {Boolean}
     * @protected
     */
    _inState(statePath, currentStatePath = this._state.__path) {
        const state = this._sm.getStateByPath(statePath);
        const currentState = this._sm.getStateByPath(currentStatePath);
        const level = state.__level;
        const stateAtLevel = StateMachine._getStateAtLevel(currentState, level);
        return (stateAtLevel === state);
    }

    /**
     * Returns true if the specified class member is defined for the currently set state.
     * @param {string} name
     * @returns {boolean}
     * @protected
     */
    _hasMember(name) {
        return !!this.constructor.prototype[name];
    }

    /**
     * Returns true if the specified class member is a method for the currently set state.
     * @param {string} name
     * @returns {boolean}
     * @protected
     */
    _hasMethod(name) {
        const member = this.constructor.prototype[name];
        return !!member && (typeof member === "function")
    }

    /**
     * Switches to the specified state.
     * @param {string} statePath
     *   Substates are seperated by a underscores (for example "Initialized.Loading").
     * @param {*[]} [args]
     *   Args that are supplied in $enter and $exit events.
     * @protected
     */
    _setState(statePath, args) {
        const setStateId = ++this._setStateCounter;
        this._setStateId = setStateId;

        if (this._state.__path !== statePath) {
            // Performance optimization.
            let newState = this._sm._stateMap[statePath];
            if (!newState) {
                // Check for super state.
                newState = this._sm.getStateByPath(statePath);
            }

            const prevState = this._state;

            const hasDifferentEnterMethod = (newState.prototype.$enter !== this._state.prototype.$enter);
            const hasDifferentExitMethod = (newState.prototype.$exit !== this._state.prototype.$exit);
            if (hasDifferentEnterMethod || hasDifferentExitMethod) {
                const sharedState = StateMachine._getSharedState(this._state, newState);
                const context = {
                    newState: newState.__path,
                    prevState: prevState.__path,
                    sharedState: sharedState.__path
                };
                const sharedLevel = sharedState.__level;

                if (hasDifferentExitMethod) {
                    const exitStates = StateMachine._getStatesUntilLevel(this._state, sharedLevel);
                    for (let i = 0, n = exitStates.length; i < n; i++) {
                        this.__setState(exitStates[i]);
                        this._callExit(this._state, args, context);
                        const stateChangeOverridden = (this._setStateId !== setStateId);
                        if (stateChangeOverridden) {
                            return;
                        }
                    }
                }

                if (hasDifferentEnterMethod) {
                    const enterStates = StateMachine._getStatesUntilLevel(newState, sharedLevel).reverse();
                    for (let i = 0, n = enterStates.length; i < n; i++) {
                        this.__setState(enterStates[i]);
                        this._callEnter(this._state, args, context);
                        const stateChangeOverridden = (this._setStateId !== setStateId);
                        if (stateChangeOverridden) {
                            return;
                        }
                    }
                }

            }

            this.__setState(newState);

            if (this._changedState) {
                const context = {
                    newState: newState.__path,
                    prevState: prevState.__path
                };

                if (args) {
                    this._changedState(context, ...args);
                } else {
                    this._changedState(context);
                }
            }

            if (this._onStateChange) {
                const context = {
                    newState: newState.__path,
                    prevState: prevState.__path
                };
                this._onStateChange(context);
            }

        }
    }

    _callEnter(state, args = [], context) {
        const hasParent = !!state.__parent;
        if (state.prototype.$enter) {
            if (!hasParent || (state.__parent.prototype.$enter !== state.prototype.$enter)) {
                state.prototype.$enter.apply(this, [context, ...args]);
            }
        }
    }

    _callExit(state, args = [], context) {
        const hasParent = !!state.__parent;
        if (state.prototype.$exit) {
            if (!hasParent || (state.__parent.prototype.$exit !== state.prototype.$exit)) {
                state.prototype.$exit.apply(this, [context, ...args]);
            }
        }
    }

    __setState(state) {
        this._state = state;
        this._stateIndex = state.__index;
        this.constructor = state;
    }

    _initStateMachine() {
        this._state = null;
        this._stateIndex = 0;
        this._setStateCounter = 0;
        this._sm = this._routedType._sm;
        this.__setState(this._sm.getStateByPath(""));
        const context = {newState: "", prevState: undefined, sharedState: undefined};
        this._callEnter(this._state, [], context);
        this._onStateChange = undefined;
    }

    /**
     * Between multiple member names, select the one specified in the deepest state.
     * If multiple member names are specified in the same deepest state, the first one in the array is returned.
     * @param {string[]} memberNames
     * @returns {string|undefined}
     * @protected
     */
    _getMostSpecificHandledMember(memberNames) {
        let cur = this._state;
        do {
            for (let i = 0, n = memberNames.length; i < n; i++) {
                const memberName = memberNames[i];
                if (!cur.__parent) {
                    if (cur.prototype[memberName]) {
                        return memberName;
                    }
                } else {
                    const alias = StateMachineType.getStateMemberAlias(cur.__path, memberName);
                    if (this[alias]) {
                        return memberName;
                    }
                }
            }
            cur = cur.__parent;
        } while (cur);
    }

    static _getStatesUntilLevel(state, level) {
        const states = [];
        while (state.__level > level) {
            states.push(state);
            state = state.__parent;
        }
        return states;
    }

    static _getSharedState(state1, state2) {
        const state1Array = StateMachine._getAncestorStates(state1);
        const state2Array = StateMachine._getAncestorStates(state2);
        const n = Math.min(state1Array.length, state2Array.length);
        for (let i = 0; i < n; i++) {
            if (state1Array[i] !== state2Array[i]) {
                return state1Array[i - 1];
            }
        }
        return state1Array[n - 1];
    }

    static _getAncestorStates(state) {
        const result = [];
        do {
            result.push(state);
        } while(state = state.__parent);
        return result.reverse();
    }

    static _getStateAtLevel(state, level) {
        if (level > state.__level) {
            return undefined;
        }

        while(level < state.__level) {
            state = state.__parent;
        }
        return state;
    }
}

class StateMachineType {

    constructor(type) {
        this._type = type;
        this._router = null;

        this.init();
    }

    get router() {
        return this._router;
    }

    init() {
        this._router = this._createRouter();

        this._stateMap = this._getStateMap();

        this._addStateMemberDelegatorsToRouter();

    }

    _createRouter() {
        const type = this._type;

        const router = class StateMachineRouter extends type {
            constructor() {
                super(...arguments);
                if (!this.constructor.hasOwnProperty('_isRouter')) {
                    throw new Error(`You need to extend ${type.name}.original instead of ${type.name}.`);
                }
            }
        };
        router._isRouter = true;
        router.prototype._routedType = type;
        router.original = type;

        this._mixinStateMachineMethods(router);

        return router;
    }

    _mixinStateMachineMethods(router) {
        // Mixin the state machine methods, so that we reuse the methods instead of re-creating them.
        const names = Object.getOwnPropertyNames(StateMachine.prototype);
        for (let i = 0, n = names.length; i < n; i++) {
            const name = names[i];
            if (name !== "constructor") {
                const descriptor = Object.getOwnPropertyDescriptor(StateMachine.prototype, name);
                Object.defineProperty(router.prototype, name, descriptor);
            }
        }
    }

    _addStateMemberDelegatorsToRouter() {
        const members = this._getAllMemberNames();

        members.forEach(member => {
            this._addMemberRouter(member);
        });
    }

    /**
     * @note We are generating code because it yields much better performance.
     */
    _addMemberRouter(member) {
        const statePaths = Object.keys(this._stateMap);
        const descriptors = [];
        const aliases = [];
        statePaths.forEach((statePath, index) => {
            const state = this._stateMap[statePath];
            const descriptor = this._getDescriptor(state, member);
            if (descriptor) {
                descriptors[index] = descriptor;

                // Add to prototype.
                const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                aliases[index] = alias;

                if (!this._router.prototype.hasOwnProperty(alias)) {
                    Object.defineProperty(this._router.prototype, alias, descriptor);
                }
            } else {
                descriptors[index] = null;
                aliases[index] = null;
            }
        });

        let type = undefined;
        descriptors.forEach(descriptor => {
            if (descriptor) {
                const descType = this._getDescriptorType(descriptor);
                if (type && (type !== descType)) {
                    console.warn(`[Lightning] Member ${member} in ${this._type.name} has inconsistent types.`);
                    return;
                }
                type = descType;
            }
        });

        switch(type) {
            case "method":
                this._addMethodRouter(member, descriptors, aliases);
                break;
            case "getter":
                this._addGetterSetterRouters(member);
                break;
            case "property":
                console.warn("[Lightning] Fixed properties are not supported; please use a getter instead!")
                break;
        }
    }

    _getDescriptor(state, member, isValid = () => true) {
        let type = state;
        let curState = state;

        do {
            const descriptor = Object.getOwnPropertyDescriptor(type.prototype, member);
            if (descriptor) {
                if (isValid(descriptor)) {
                    descriptor._source = curState;
                    return descriptor;
                }
            }
            type = Object.getPrototypeOf(type);
            if (type && type.hasOwnProperty('__state')) {
                curState = type;
            }
        } while(type && type.prototype);
        return undefined;
    }

    _getDescriptorType(descriptor) {
        if (descriptor.get || descriptor.set) {
            return 'getter';
        } else {
            if (typeof descriptor.value === "function") {
                return 'method';
            } else {
                return 'property';
            }
        }
    }

    static _supportsSpread() {
        if (this.__supportsSpread === undefined) {
            this.__supportsSpread = false;
            try {
                const func = new Function("return [].concat(...arguments);");
                func();
                this.__supportsSpread = true;
            } catch(e) {}
        }
        return this.__supportsSpread;
    }

    _addMethodRouter(member, descriptors, aliases) {
        const code = [
            // The line ensures that, while debugging, your IDE won't open many tabs.
            "//@ sourceURL=StateMachineRouter.js",
            "var i = this._stateIndex;"
        ];
        let cur = aliases[0];
        const supportsSpread = StateMachineType._supportsSpread();
        for (let i = 1, n = aliases.length; i < n; i++) {
            const alias = aliases[i];
            if (alias !== cur) {
                if (cur) {
                    if (supportsSpread) {
                        code.push(`if (i < ${i}) return this["${cur}"](...arguments); else`);
                    } else {
                        code.push(`if (i < ${i}) return this["${cur}"].apply(this, arguments); else`);
                    }
                } else {
                    code.push(`if (i < ${i}) return ; else`);
                }
            }
            cur = alias;
        }
        if (cur) {
            if (supportsSpread) {
                code.push(`return this["${cur}"](...arguments);`);
            } else {
                code.push(`return this["${cur}"].apply(this, arguments);`);
            }
        } else {
            code.push(`;`);
        }
        const functionBody = code.join("\n");
        const router = new Function([], functionBody);

        const descriptor = {value: router};
        Object.defineProperty(this._router.prototype, member, descriptor);
    }

    _addGetterSetterRouters(member) {
        const getter = this._getGetterRouter(member);
        const setter = this._getSetterRouter(member);
        const descriptor = {
            get: getter,
            set: setter
        };
        Object.defineProperty(this._router.prototype, member, descriptor);
    }

    _getGetterRouter(member) {
        const statePaths = Object.keys(this._stateMap);
        const descriptors = [];
        const aliases = [];
        statePaths.forEach((statePath, index) => {
            const state = this._stateMap[statePath];
            const descriptor = this._getDescriptor(state, member, (descriptor => descriptor.get));
            if (descriptor) {
                descriptors[index] = descriptor;

                // Add to prototype.
                const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                aliases[index] = alias;

                if (!this._router.prototype.hasOwnProperty(alias)) {
                    Object.defineProperty(this._router.prototype, alias, descriptor);
                }
            } else {
                descriptors[index] = null;
                aliases[index] = null;
            }
        });

        const code = [
            // The line ensures that, while debugging, your IDE won't open many tabs.
            "//@ sourceURL=StateMachineRouter.js",
            "var i = this._stateIndex;"
        ];
        let cur = aliases[0];
        for (let i = 1, n = aliases.length; i < n; i++) {
            const alias = aliases[i];
            if (alias !== cur) {
                if (cur) {
                    code.push(`if (i < ${i}) return this["${cur}"]; else`);
                } else {
                    code.push(`if (i < ${i}) return ; else`);
                }
            }
            cur = alias;
        }
        if (cur) {
            code.push(`return this["${cur}"];`);
        } else {
            code.push(`;`);
        }
        const functionBody = code.join("\n");
        const router = new Function([], functionBody);
        return router;
    }

    _getSetterRouter(member) {
        const statePaths = Object.keys(this._stateMap);
        const descriptors = [];
        const aliases = [];
        statePaths.forEach((statePath, index) => {
            const state = this._stateMap[statePath];
            const descriptor = this._getDescriptor(state, member, (descriptor => descriptor.set));
            if (descriptor) {
                descriptors[index] = descriptor;

                // Add to prototype.
                const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                aliases[index] = alias;

                if (!this._router.prototype.hasOwnProperty(alias)) {
                    Object.defineProperty(this._router.prototype, alias, descriptor);
                }
            } else {
                descriptors[index] = null;
                aliases[index] = null;
            }
        });

        const code = [
            // The line ensures that, while debugging, your IDE won't open many tabs.
            "//@ sourceURL=StateMachineRouter.js",
            "var i = this._stateIndex;"
        ];
        let cur = aliases[0];
        for (let i = 1, n = aliases.length; i < n; i++) {
            const alias = aliases[i];
            if (alias !== cur) {
                if (cur) {
                    code.push(`if (i < ${i}) this["${cur}"] = arg; else`);
                } else {
                    code.push(`if (i < ${i}) ; else`);
                }
            }
            cur = alias;
        }
        if (cur) {
            code.push(`this["${cur}"] = arg;`);
        } else {
            code.push(`;`);
        }
        const functionBody = code.join("\n");
        const router = new Function(["arg"], functionBody);
        return router;
    }

    static getStateMemberAlias(path, member) {
        return "$" + (path ? path + "." : "") + member;
    }

    _getAllMemberNames() {
        const stateMap = this._stateMap;
        const map = Object.keys(stateMap);
        let members = new Set();
        map.forEach(statePath => {
            if (statePath === "") {
                // Root state can be skipped: if the method only occurs in the root state, we don't need to re-delegate it based on state.
                return;
            }
            const state = stateMap[statePath];
            const names = this._getStateMemberNames(state);
            names.forEach(name => {
                members.add(name);
            })
        });
        return [...members];
    }

    _getStateMemberNames(state) {
        let type = state;
        let members = new Set();
        const isRoot = this._type === state;
        do {
            const names = this._getStateMemberNamesForType(type);
            names.forEach(name => {
                members.add(name)
            });

            type = Object.getPrototypeOf(type);
        } while(type && type.prototype && (!type.hasOwnProperty("__state") || isRoot));

        return members;
    }

    _getStateMemberNamesForType(type) {
        const memberNames = Object.getOwnPropertyNames(type.prototype);
        return memberNames.filter(memberName => {
            return (memberName !== "constructor") && !StateMachineType._isStateLocalMember(memberName);
        });
    }

    static _isStateLocalMember(memberName) {
        return (memberName === "$enter") || (memberName === "$exit");
    }

    getStateByPath(statePath) {
        if (this._stateMap[statePath]) {
            return this._stateMap[statePath];
        }

        // Search for closest match.
        const parts = statePath.split(".");
        while(parts.pop()) {
            const statePath = parts.join(".");
            if (this._stateMap[statePath]) {
                return this._stateMap[statePath];
            }
        }
    }

    _getStateMap() {
        if (!this._stateMap) {
            this._stateMap = this._createStateMap();
        }
        return this._stateMap;
    }

    _createStateMap() {
        const stateMap = {};
        this._addState(this._type, null, "", stateMap);
        return stateMap;
    }

    _addState(state, parentState, name, stateMap) {
        state.__state = true;
        state.__name = name;

        this._addStaticStateProperty(state, parentState);

        const parentPath = (parentState ? parentState.__path : "");
        let path = (parentPath ? parentPath + "." : "") + name;
        state.__path = path;
        state.__level = parentState ? parentState.__level + 1 : 0;
        state.__parent = parentState;
        state.__index = Object.keys(stateMap).length;
        stateMap[path] = state;

        const states = state._states;
        if (states) {
            const isInheritedFromParent = (parentState && parentState._states === states);
            if (!isInheritedFromParent) {
                const subStates = state._states();
                subStates.forEach(subState => {
                    const stateName = StateMachineType._getStateName(subState);
                    this._addState(subState, state, stateName, stateMap);
                });
            }
        }
    }

    static _getStateName(state) {
        const name = state.name;

        const index = name.indexOf('$');
        if (index > 0) {
            // Strip off rollup name suffix.
            return name.substr(0, index);
        }

        return name;
    }

    _addStaticStateProperty(state, parentState) {
        if (parentState) {
            const isClassStateLevel = parentState && !parentState.__parent;
            if (isClassStateLevel) {
                this._router[state.__name] = state;
            } else {
                parentState[state.__name] = state;
            }
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/BloomComponent.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/BloomComponent.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BloomComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/webgl/shaders/LinearBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/webgl/shaders/BoxBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/webgl/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class BloomComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        const onUpdate = function(element, elementCore) {
            if ((elementCore._recalc & (2 + 128))) {
                const w = elementCore.w;
                const h = elementCore.h;
                let cur = elementCore;
                do {
                    cur = cur._children[0];
                    cur._element.w = w;
                    cur._element.h = h;
                } while(cur._children);
            }
        };

        return {
            Textwrap: {rtt: true, forceZIndexContext: true, renderOffscreen: true,
                BloomBase: {shader: {type: BloomBaseShader},
                    Content: {}
                }
            },
            Layers: {
                L0: {rtt: true, onUpdate: onUpdate, scale: 2, pivot: 0, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L1: {rtt: true, onUpdate: onUpdate, scale: 4, pivot: 0, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L2: {rtt: true, onUpdate: onUpdate, scale: 8, pivot: 0, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L3: {rtt: true, onUpdate: onUpdate, scale: 16, pivot: 0, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}}
            }
        }
    }

    get _signalProxy() {
        return true;
    }

    constructor(stage) {
        super(stage);
        this._textwrap = this.sel("Textwrap");
        this._wrapper = this.sel("Textwrap.Content");
        this._layers = this.sel("Layers");

        this._amount = 0;
        this._paddingX = 0;
        this._paddingY = 0;
    }

    _build() {
        const filterShaderSettings = [{x:1,y:0,kernelRadius:3},{x:0,y:1,kernelRadius:3},{x:1.5,y:0,kernelRadius:3},{x:0,y:1.5,kernelRadius:3}];
        const filterShaders = filterShaderSettings.map(s => {
            const shader = this.stage.createShader(Object.assign({type: _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]}, s));
            return shader;
        });

        this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
        this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);

        // Notice that 1.5 filters should be applied before 1.0 filters.
        this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
        this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
    }

    _setLayerTexture(element, texture, steps) {
        if (!steps.length) {
            element.texture = texture;
        } else {
            const step = steps.pop();
            const child = element.stage.c({rtt: true, shader: step});

            // Recurse.
            this._setLayerTexture(child, texture, steps);

            element.childList.add(child);
        }
        return element;
    }

    get content() {
        return this.sel('Textwrap.Content');
    }

    set content(v) {
        this.sel('Textwrap.Content').patch(v);
    }

    set padding(v) {
        this._paddingX = v;
        this._paddingY = v;
        this._updateBlurSize();
    }

    set paddingX(v) {
        this._paddingX = v;
        this._updateBlurSize();
    }

    set paddingY(v) {
        this._paddingY = v;
        this._updateBlurSize();
    }

    getLayer(i) {
        return this._layers.sel("L" + i);
    }

    getLayerContents(i) {
        return this.getLayer(i).sel("Content");
    }

    _onResize() {
        this._updateBlurSize();
    }

    _updateBlurSize() {
        let w = this.renderWidth;
        let h = this.renderHeight;

        let paddingX = this._paddingX;
        let paddingY = this._paddingY;

        let fw = w + paddingX * 2;
        let fh = h + paddingY * 2;
        this._textwrap.w = fw;
        this._wrapper.x = paddingX;
        this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
        this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
        this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
        this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
        this._textwrap.x = -paddingX;

        this._textwrap.h = fh;
        this._wrapper.y = paddingY;
        this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
        this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
        this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
        this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
        this._textwrap.y = -paddingY;

        this.w = w;
        this.h = h;
    }

    /**
     * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
     * Best results for non-fractional values.
     * @param v;
     */
    set amount(v) {
        this._amount = v;
        this._update();
    }

    get amount() {
        return this._amount;
    }

    _update() {
        let v = Math.min(4, Math.max(0, this._amount));
        if (v > 0) {
            this.getLayer(0).visible = (v > 0);
            this.getLayer(1).visible = (v > 1);
            this.getLayer(2).visible = (v > 2);
            this.getLayer(3).visible = (v > 3);
        }
    }

    set shader(s) {
        super.shader = s;
        if (!this.renderToTexture) {
            console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
        }
    }

    _firstActive() {
        this._build();
    }

}

class BloomBaseShader extends _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
}

BloomBaseShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float m = max(max(color.r, color.g), color.b);
        float c = max(0.0, (m - 0.80)) * 5.0;
        color = color * c;
        gl_FragColor = color;
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/BorderComponent.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/BorderComponent.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BorderComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class BorderComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        return {
            Content: {},
            Borders: {
                Top: {rect: true, visible: false, mountY: 1},
                Right: {rect: true, visible: false},
                Bottom: {rect: true, visible: false},
                Left: {rect: true, visible: false, mountX: 1}
            }
        };
    }

    get _signalProxy() {
        return true;
    }

    constructor(stage) {
        super(stage);

        this._borderTop = this.tag("Top");
        this._borderRight = this.tag("Right");
        this._borderBottom = this.tag("Bottom");
        this._borderLeft = this.tag("Left");

        this.onAfterUpdate = function (element) {
            const content = element.childList.first;
            let w = element.core.w || content.renderWidth;
            let h = element.core.h || content.renderHeight;
            element._borderTop.w = w;
            element._borderBottom.y = h;
            element._borderBottom.w = w;
            element._borderLeft.h = h + element._borderTop.h + element._borderBottom.h;
            element._borderLeft.y = -element._borderTop.h;
            element._borderRight.x = w;
            element._borderRight.h = h + element._borderTop.h + element._borderBottom.h;
            element._borderRight.y = -element._borderTop.h;
        };

        this.borderWidth = 1;
    }

    get content() {
        return this.sel('Content');
    }

    set content(v) {
        this.sel('Content').patch(v, true);
    }

    get borderWidth() {
        return this.borderWidthTop;
    }

    get borderWidthTop() {
        return this._borderTop.h;
    }

    get borderWidthRight() {
        return this._borderRight.w;
    }

    get borderWidthBottom() {
        return this._borderBottom.h;
    }

    get borderWidthLeft() {
        return this._borderLeft.w;
    }

    set borderWidth(v) {
        this.borderWidthTop = v;
        this.borderWidthRight = v;
        this.borderWidthBottom = v;
        this.borderWidthLeft = v;
    }

    set borderWidthTop(v) {
        this._borderTop.h = v;
        this._borderTop.visible = (v > 0);
    }

    set borderWidthRight(v) {
        this._borderRight.w = v;
        this._borderRight.visible = (v > 0);
    }

    set borderWidthBottom(v) {
        this._borderBottom.h = v;
        this._borderBottom.visible = (v > 0);
    }

    set borderWidthLeft(v) {
        this._borderLeft.w = v;
        this._borderLeft.visible = (v > 0);
    }

    get colorBorder() {
        return this.colorBorderTop;
    }

    get colorBorderTop() {
        return this._borderTop.color;
    }

    get colorBorderRight() {
        return this._borderRight.color;
    }

    get colorBorderBottom() {
        return this._borderBottom.color;
    }

    get colorBorderLeft() {
        return this._borderLeft.color;
    }

    set colorBorder(v) {
        this.colorBorderTop = v;
        this.colorBorderRight = v;
        this.colorBorderBottom = v;
        this.colorBorderLeft = v;
    }

    set colorBorderTop(v) {
        this._borderTop.color = v;
    }

    set colorBorderRight(v) {
        this._borderRight.color = v;
    }

    set colorBorderBottom(v) {
        this._borderBottom.color = v;
    }

    set colorBorderLeft(v) {
        this._borderLeft.color = v;
    }

    get borderTop() {
        return this._borderTop;
    }

    set borderTop(settings) {
        this.borderTop.patch(settings);
    }

    get borderRight() {
        return this._borderRight;
    }

    set borderRight(settings) {
        this.borderRight.patch(settings);
    }

    get borderBottom() {
        return this._borderBottom;
    }

    set borderBottom(settings) {
        this.borderBottom.patch(settings);
    }

    get borderLeft() {
        return this._borderLeft;
    }

    set borderLeft(settings) {
        this.borderLeft.patch(settings);
    }

    set borders(settings) {
        this.borderTop = settings;
        this.borderLeft = settings;
        this.borderBottom = settings;
        this.borderRight = settings;
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/FastBlurComponent.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/FastBlurComponent.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FastBlurComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/webgl/shaders/LinearBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/webgl/shaders/BoxBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/webgl/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _renderer_c2d_shaders_BlurShader_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/c2d/shaders/BlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/BlurShader.mjs");
/* harmony import */ var _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tree/Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/* harmony import */ var _tools_MultiSpline_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tools/MultiSpline.mjs */ "./node_modules/@lightningjs/core/src/tools/MultiSpline.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









class FastBlurComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static _template() {
        return {}
    }

    get wrap() {
        return this.tag("Wrap");
    }

    set content(v) {
        return this.wrap.content = v;
    }

    get content() {
        return this.wrap.content;
    }

    set padding(v) {
        this.wrap._paddingX = v;
        this.wrap._paddingY = v;
        this.wrap._updateBlurSize();
    }

    set paddingX(v) {
        this.wrap._paddingX = v;
        this.wrap._updateBlurSize();
    }

    set paddingY(v) {
        this.wrap._paddingY = v;
        this.wrap._updateBlurSize();
    }

    set amount(v) {
        return this.wrap.amount = v;
    }

    get amount() {
        return this.wrap.amount;
    }

    _onResize() {
        this.wrap.w = this.renderWidth;
        this.wrap.h = this.renderHeight;
    }

    get _signalProxy() {
        return true;
    }

    _build() {
        this.patch({
            Wrap: {type: this.stage.gl ? WebGLFastBlurComponent : C2dFastBlurComponent}
        });
    }

}


class C2dFastBlurComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        return {
            forceZIndexContext: true,
            rtt: true,
            Textwrap: {shader: {type: _renderer_c2d_shaders_BlurShader_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]}, Content: {}}
        }
    }

    constructor(stage) {
        super(stage);
        this._textwrap = this.sel("Textwrap");
        this._wrapper = this.sel("Textwrap>Content");

        this._amount = 0;
        this._paddingX = 0;
        this._paddingY = 0;

    }

    static getSpline() {
        if (!this._multiSpline) {
            this._multiSpline = new _tools_MultiSpline_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]();
            this._multiSpline.parse(false, {0: 0, 0.25: 1.5, 0.5: 5.5, 0.75: 18, 1: 39});
        }
        return this._multiSpline;
    }

    get content() {
        return this.sel('Textwrap>Content');
    }

    set content(v) {
        this.sel('Textwrap>Content').patch(v, true);
    }

    set padding(v) {
        this._paddingX = v;
        this._paddingY = v;
        this._updateBlurSize();
    }

    set paddingX(v) {
        this._paddingX = v;
        this._updateBlurSize();
    }

    set paddingY(v) {
        this._paddingY = v;
        this._updateBlurSize();
    }

    _updateBlurSize() {
        let w = this.renderWidth;
        let h = this.renderHeight;

        let paddingX = this._paddingX;
        let paddingY = this._paddingY;

        this._wrapper.x = paddingX;
        this._textwrap.x = -paddingX;

        this._wrapper.y = paddingY;
        this._textwrap.y = -paddingY;

        this._textwrap.w = w + paddingX * 2;
        this._textwrap.h = h + paddingY * 2;
    }

    get amount() {
        return this._amount;
    }

    /**
     * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
     * Best results for non-fractional values.
     * @param v;
     */
    set amount(v) {
        this._amount = v;
        this._textwrap.shader.kernelRadius = C2dFastBlurComponent._amountToKernelRadius(v);
    }

    static _amountToKernelRadius(v) {
        return C2dFastBlurComponent.getSpline().getValue(Math.min(1, v * 0.25));
    }

    get _signalProxy() {
        return true;
    }

}

class WebGLFastBlurComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        const onUpdate = function(element, elementCore) {
            if ((elementCore._recalc & (2 + 128))) {
                const w = elementCore.w;
                const h = elementCore.h;
                let cur = elementCore;
                do {
                    cur = cur._children[0];
                    cur._element.w = w;
                    cur._element.h = h;
                } while(cur._children);
            }
        };

        return {
            Textwrap: {rtt: true, forceZIndexContext: true, renderOffscreen: true, Content: {}},
            Layers: {
                L0: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L1: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L2: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L3: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}}
            },
            Result: {shader: {type: FastBlurOutputShader}, visible: false}
        }
    }

    get _signalProxy() {
        return true;
    }

    constructor(stage) {
        super(stage);
        this._textwrap = this.sel("Textwrap");
        this._wrapper = this.sel("Textwrap>Content");
        this._layers = this.sel("Layers");
        this._output = this.sel("Result");

        this._amount = 0;
        this._paddingX = 0;
        this._paddingY = 0;
    }

    _buildLayers() {
        const filterShaderSettings = [{x:1,y:0,kernelRadius:1},{x:0,y:1,kernelRadius:1},{x:1.5,y:0,kernelRadius:1},{x:0,y:1.5,kernelRadius:1}];
        const filterShaders = filterShaderSettings.map(s => {
            const shader = _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].create(this.stage, Object.assign({type: _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]}, s));
            return shader;
        });

        this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
        this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);

        // Notice that 1.5 filters should be applied before 1.0 filters.
        this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
        this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
    }

    _setLayerTexture(element, texture, steps) {
        if (!steps.length) {
            element.texture = texture;
        } else {
            const step = steps.pop();
            const child = element.stage.c({rtt: true, shader: step});

            // Recurse.
            this._setLayerTexture(child, texture, steps);

            element.childList.add(child);
        }
        return element;
    }

    get content() {
        return this.sel('Textwrap>Content');
    }

    set content(v) {
        this.sel('Textwrap>Content').patch(v, true);
    }

    set padding(v) {
        this._paddingX = v;
        this._paddingY = v;
        this._updateBlurSize();
    }

    set paddingX(v) {
        this._paddingX = v;
        this._updateBlurSize();
    }

    set paddingY(v) {
        this._paddingY = v;
        this._updateBlurSize();
    }

    getLayer(i) {
        return this._layers.sel("L" + i);
    }

    getLayerContents(i) {
        return this.getLayer(i).sel("Content");
    }

    _onResize() {
        this._updateBlurSize();
    }

    _updateBlurSize() {
        let w = this.renderWidth;
        let h = this.renderHeight;

        let paddingX = this._paddingX;
        let paddingY = this._paddingY;

        let fw = w + paddingX * 2;
        let fh = h + paddingY * 2;
        this._textwrap.w = fw;
        this._wrapper.x = paddingX;
        this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
        this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
        this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
        this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
        this._output.x = -paddingX;
        this._textwrap.x = -paddingX;
        this._output.w = fw;

        this._textwrap.h = fh;
        this._wrapper.y = paddingY;
        this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
        this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
        this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
        this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
        this._output.y = -paddingY;
        this._textwrap.y = -paddingY;
        this._output.h = fh;

        this.w = w;
        this.h = h;
    }

    /**
     * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
     * Best results for non-fractional values.
     * @param v;
     */
    set amount(v) {
        this._amount = v;
        this._update();
    }

    get amount() {
        return this._amount;
    }

    _update() {
        let v = Math.min(4, Math.max(0, this._amount));
        if (v === 0) {
            this._textwrap.renderToTexture = false;
            this._output.shader.otherTextureSource = null;
            this._output.visible = false;
        } else {
            this._textwrap.renderToTexture = true;
            this._output.visible = true;

            this.getLayer(0).visible = (v > 0);
            this.getLayer(1).visible = (v > 1);
            this.getLayer(2).visible = (v > 2);
            this.getLayer(3).visible = (v > 3);

            if (v <= 1) {
                this._output.texture = this._textwrap.getTexture();
                this._output.shader.otherTextureSource = this.getLayer(0).getTexture();
                this._output.shader.a = v;
            } else if (v <= 2) {
                this._output.texture = this.getLayer(0).getTexture();
                this._output.shader.otherTextureSource = this.getLayer(1).getTexture();
                this._output.shader.a = v - 1;
            } else if (v <= 3) {
                this._output.texture = this.getLayer(1).getTexture();
                this._output.shader.otherTextureSource = this.getLayer(2).getTexture();
                this._output.shader.a = v - 2;
            } else if (v <= 4) {
                this._output.texture = this.getLayer(2).getTexture();
                this._output.shader.otherTextureSource = this.getLayer(3).getTexture();
                this._output.shader.a = v - 3;
            }
        }
    }

    set shader(s) {
        super.shader = s;
        if (!this.renderToTexture) {
            console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
        }
    }

    _firstActive() {
        this._buildLayers();
    }

}

/**
 * Shader that combines two textures into one output.
 */
class FastBlurOutputShader extends _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {

    constructor(ctx) {
        super(ctx);

        this._a = 0;
        this._otherTextureSource = null;
    }

    get a() {
        return this._a;
    }

    set a(v) {
        this._a = v;
        this.redraw();
    }

    set otherTextureSource(v) {
        this._otherTextureSource = v;
        this.redraw();
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("a", this._a, this.gl.uniform1f);
        this._setUniform("uSampler2", 1, this.gl.uniform1i);
    }

    beforeDraw(operation) {
        let glTexture = this._otherTextureSource ? this._otherTextureSource.nativeTexture : null;

        let gl = this.gl;
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.activeTexture(gl.TEXTURE0);
    }
}

FastBlurOutputShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uSampler2;
    uniform float a;
    void main(void){
        if (a == 1.0) {
            gl_FragColor = texture2D(uSampler2, vTextureCoord) * vColor;
        } else {
            gl_FragColor = ((1.0 - a) * texture2D(uSampler, vTextureCoord) + (a * texture2D(uSampler2, vTextureCoord))) * vColor;
        }
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/ListComponent.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/ListComponent.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ListComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _tools_ObjectListWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/ObjectListWrapper.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjectListWrapper.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ListComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);

        this._wrapper = super._children.a({});

        this._reloadVisibleElements = false;

        this._visibleItems = new Set();

        this._index = 0;

        this._started = false;

        /**
         * The transition definition that is being used when scrolling the items.
         * @type TransitionSettings
         */
        this._scrollTransitionSettings = this.stage.transitions.createSettings({});

        /**
         * The scroll area size in pixels per item.
         */
        this._itemSize = 100;

        this._viewportScrollOffset = 0;

        this._itemScrollOffset = 0;

        /**
         * Should the list jump when scrolling between end to start, or should it be continuous, like a carrousel?
         */
        this._roll = false;

        /**
         * Allows restricting the start scroll position.
         */
        this._rollMin = 0;

        /**
         * Allows restricting the end scroll position.
         */
        this._rollMax = 0;

        /**
         * Definition for a custom animation that is applied when an item is (partially) selected.
         * @type AnimationSettings
         */
        this._progressAnimation = null;

        /**
         * Inverts the scrolling direction.
         * @type {boolean}
         * @private
         */
        this._invertDirection = false;

        /**
         * Layout the items horizontally or vertically?
         * @type {boolean}
         * @private
         */
        this._horizontal = true;

        this.itemList = new ListItems(this);
    }

    _allowChildrenAccess() {
        return false;
    }

    get items() {
        return this.itemList.get();
    }

    set items(children) {
        this.itemList.patch(children);
    }

    start() {
        this._wrapper.transition(this.property, this._scrollTransitionSettings);
        this._scrollTransition = this._wrapper.transition(this.property);
        this._scrollTransition.on('progress', p => this.update());

        this.setIndex(0, true, true);

        this._started = true;

        this.update();
    }

    setIndex(index, immediate = false, closest = false) {
        let nElements = this.length;
        if (!nElements) return;

        this.emit('unfocus', this.getElement(this.realIndex), this._index, this.realIndex);

        if (closest) {
            // Scroll to same offset closest to the index.
            let offset = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(index, nElements);
            let o = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(this.index, nElements);
            let diff = offset - o;
            if (diff > 0.5 * nElements) {
                diff -= nElements;
            } else if (diff < -0.5 * nElements) {
                diff += nElements;
            }
            this._index += diff;
        } else {
            this._index = index;
        }

        if (this._roll || (this.viewportSize > this._itemSize * nElements)) {
            this._index = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(this._index, nElements);
        }

        let direction = (this._horizontal ^ this._invertDirection ? -1 : 1);
        let value = direction * this._index * this._itemSize;

        if (this._roll) {
            let min, max, scrollDelta;
            if (direction == 1) {
                max = (nElements - 1) * this._itemSize;
                scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;

                max -= scrollDelta;

                min = this.viewportSize - (this._itemSize + scrollDelta);

                if (this._rollMin) min -= this._rollMin;
                if (this._rollMax) max += this._rollMax;

                value = Math.max(Math.min(value, max), min);
            } else {
                max = (nElements * this._itemSize - this.viewportSize);
                scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;

                max += scrollDelta;

                let min = scrollDelta;

                if (this._rollMin) min -= this._rollMin;
                if (this._rollMax) max += this._rollMax;

                value = Math.min(Math.max(-max, value), -min);
            }
        }

        this._scrollTransition.start(value);

        if (immediate) {
            this._scrollTransition.finish();
        }

        this.emit('focus', this.getElement(this.realIndex), this._index, this.realIndex);
    }

    getAxisPosition() {
        let target = -this._scrollTransition._targetValue;

        let direction = (this._horizontal ^ this._invertDirection ? -1 : 1);
        let value = -direction * this._index * this._itemSize;

        return this._viewportScrollOffset * this.viewportSize + (value - target);
    }

    update() {
        if (!this._started) return;

        let nElements = this.length;
        if (!nElements) return;

        let direction = (this._horizontal ^ this._invertDirection ? -1 : 1);

        // Map position to index value.
        let v = (this._horizontal ? this._wrapper.x : this._wrapper.y);

        let viewportSize = this.viewportSize;
        let scrollDelta = this._viewportScrollOffset * viewportSize - this._itemScrollOffset * this._itemSize;
        v += scrollDelta;

        let s, e, ps, pe;
        if (direction == -1) {
            s = Math.floor(-v / this._itemSize);
            ps = 1 - ((-v / this._itemSize) - s);
            e = Math.floor((viewportSize - v) / this._itemSize);
            pe = (((viewportSize - v) / this._itemSize) - e);
        } else {
            s = Math.ceil(v / this._itemSize);
            ps = 1 + (v / this._itemSize) - s;
            e = Math.ceil((v - viewportSize) / this._itemSize);
            pe = e - ((v - viewportSize) / this._itemSize);
        }
        if (this._roll || (viewportSize > this._itemSize * nElements)) {
            // Don't show additional items.
            if (e >= nElements) {
                e = nElements - 1;
                pe = 1;
            }
            if (s >= nElements) {
                s = nElements - 1;
                ps = 1;
            }
            if (e <= -1) {
                e = 0;
                pe = 1;
            }
            if (s <= -1) {
                s = 0;
                ps = 1;
            }
        }

        let offset = -direction * s * this._itemSize;

        let item;
        for (let index = s; (direction == -1 ? index <= e : index >= e); (direction == -1 ? index++ : index--)) {
            let realIndex = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(index, nElements);

            let element = this.getElement(realIndex);
            item = element.parent;
            this._visibleItems.delete(item);
            if (this._horizontal) {
                item.x = offset + scrollDelta;
            } else {
                item.y = offset + scrollDelta;
            }

            let wasVisible = item.visible;
            item.visible = true;

            if (!wasVisible || this._reloadVisibleElements) {
                // Turned visible.
                this.emit('visible', index, realIndex);
            }



            if (this._progressAnimation) {
                let p = 1;
                if (index == s) {
                    p = ps;
                } else if (index == e) {
                    p = pe;
                }

                // Use animation to progress.
                this._progressAnimation.apply(element, p);
            }

            offset += this._itemSize;
        }

        // Handle item visibility.
        let self = this;
        this._visibleItems.forEach(function(invisibleItem) {
            invisibleItem.visible = false;
            self._visibleItems.delete(invisibleItem);
        });

        for (let index = s; (direction == -1 ? index <= e : index >= e); (direction == -1 ? index++ : index--)) {
            let realIndex = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(index, nElements);
            this._visibleItems.add(this.getWrapper(realIndex));
        }

        this._reloadVisibleElements = false;
    }

    setPrevious() {
        this.setIndex(this._index - 1);
    }

    setNext() {
        this.setIndex(this._index + 1);
    }

    getWrapper(index) {
        return this._wrapper.children[index];
    }

    getElement(index) {
        let e = this._wrapper.children[index];
        return e ? e.children[0] : null;
    }

    reload() {
        this._reloadVisibleElements = true;
        this.update();
    }

    get element() {
        let e = this._wrapper.children[this.realIndex];
        return e ? e.children[0] : null;
    }

    get length() {
        return this._wrapper.children.length;
    }

    get property() {
        return this._horizontal ? 'x' : 'y';
    }

    get viewportSize() {
        return this._horizontal ? this.w : this.h;
    }

    get index() {
        return this._index;
    }

    get realIndex() {
        return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(this._index, this.length);
    }

    get itemSize() {
        return this._itemSize;
    }

    set itemSize(v) {
        this._itemSize = v;
        this.update();
    }

    get viewportScrollOffset() {
        return this._viewportScrollOffset;
    }

    set viewportScrollOffset(v) {
        this._viewportScrollOffset = v;
        this.update();
    }

    get itemScrollOffset() {
        return this._itemScrollOffset;
    }

    set itemScrollOffset(v) {
        this._itemScrollOffset = v;
        this.update();
    }

    get scrollTransitionSettings() {
        return this._scrollTransitionSettings;
    }

    set scrollTransitionSettings(v) {
        this._scrollTransitionSettings.patch(v);
    }

    set scrollTransition(v) {
        this._scrollTransitionSettings.patch(v);
    }

    get scrollTransition() {
        return this._scrollTransition;
    }

    get progressAnimation() {
        return this._progressAnimation;
    }

    set progressAnimation(v) {
        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(v)) {
            this._progressAnimation = this.stage.animations.createSettings(v);
        } else {
            this._progressAnimation = v;
        }
        this.update();
    }

    get roll() {
        return this._roll;
    }

    set roll(v) {
        this._roll = v;
        this.update();
    }

    get rollMin() {
        return this._rollMin;
    }

    set rollMin(v) {
        this._rollMin = v;
        this.update();
    }

    get rollMax() {
        return this._rollMax;
    }

    set rollMax(v) {
        this._rollMax = v;
        this.update();
    }

    get invertDirection() {
        return this._invertDirection;
    }

    set invertDirection(v) {
        if (!this._started) {
            this._invertDirection = v;
        }
    }

    get horizontal() {
        return this._horizontal;
    }

    set horizontal(v) {
        if (v !== this._horizontal) {
            if (!this._started) {
                this._horizontal = v;
            }
        }
    }

}


class ListItems extends _tools_ObjectListWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(list) {
        let wrap = (item => {
            let parent = item.stage.createElement();
            parent.add(item);
            parent.visible = false;
            return parent;
        })

        super(list._wrapper._children, wrap);
        this.list = list;
    }

    onAdd(item, index) {
        super.onAdd(item, index);
        this.checkStarted(index);
    }

    checkStarted(index) {
        this.list._reloadVisibleElements = true;
        if (!this.list._started) {
            this.list.start();
        } else {
            if (this.list.length === 1) {
                this.list.setIndex(0, true, true);
            } else {
                if (this.list._index >= this.list.length) {
                    this.list.setIndex(0);
                }
            }
            this.list.update();
        }
    }

    onRemove(item, index) {
        super.onRemove(item, index);
        let ri = this.list.realIndex;
        if (ri === index) {
            if (ri === this.list.length) {
                ri--;
            }
            if (ri >= 0) {
                this.list.setIndex(ri);
            }
        } else if (ri > index) {
            this.list.setIndex(ri - 1);
        }

        this.list._reloadVisibleElements = true;
    }

    onSet(item, index) {
        super.onSet(item, index);
        this.checkStarted(index);
    }

    onSync(removed, added, order) {
        super.onSync(removed, added, order);
        this.checkStarted(0);
    }

    get _signalProxy() {
        return true;
    }

}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/SmoothScaleComponent.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/SmoothScaleComponent.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SmoothScaleComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class SmoothScaleComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        return {
            ContentWrap: {renderOffscreen: true, forceZIndexContext: true, onAfterUpdate: SmoothScaleComponent._updateDimensions,
                Content: {}
            },
            Scale: {visible: false}
        }
    }

    constructor(stage) {
        super(stage);

        this._smoothScale = 1;
        this._iterations = 0;
    }

    get content() {
        return this.tag('Content');
    }

    set content(v) {
        this.tag('Content').patch(v, true);
    }

    get smoothScale() {
        return this._smoothScale;
    }

    set smoothScale(v) {
        if (this._smoothScale !== v) {
            let its = 0;
            while(v < 0.5 && its < 12) {
                its++;
                v = v * 2;
            }

            this.scale = v;
            this._setIterations(its);

            this._smoothScale = v;
        }
    }

    _setIterations(its) {
        if (this._iterations !== its) {
            const scalers = this.sel("Scale").childList;
            const content = this.sel("ContentWrap");
            while (scalers.length < its) {
                const first = scalers.length === 0;
                const texture = (first ? content.getTexture() : scalers.last.getTexture());
                scalers.a({rtt: true, renderOffscreen: true, texture: texture});
            }

            SmoothScaleComponent._updateDimensions(this.tag("ContentWrap"), true);

            const useScalers = (its > 0);
            this.patch({
                ContentWrap: {renderToTexture: useScalers},
                Scale: {visible: useScalers}
            });

            for (let i = 0, n = scalers.length; i < n; i++) {
                scalers.getAt(i).patch({
                    visible: i < its,
                    renderOffscreen: i !== its - 1
                });
            }
            this._iterations = its;
        }
    }

    static _updateDimensions(contentWrap, force) {
        const content = contentWrap.children[0];
        let w = content.renderWidth;
        let h = content.renderHeight;
        if (w !== contentWrap.w || h !== contentWrap.h || force) {
            contentWrap.w = w;
            contentWrap.h = h;

            const scalers = contentWrap.parent.tag("Scale").children;
            for (let i = 0, n = scalers.length; i < n; i++) {
                w = w * 0.5;
                h = h * 0.5;
                scalers[i].w = w;
                scalers[i].h = h;
            }
        }
    }

    get _signalProxy() {
        return true;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/FlexContainer.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/FlexContainer.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexContainer)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _layout_FlexLayout_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layout/FlexLayout.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/FlexLayout.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class FlexContainer {


    constructor(item) {
        this._item = item;

        this._layout = new _layout_FlexLayout_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);
        this._horizontal = true;
        this._reverse = false;
        this._wrap = false;
        this._alignItems = 'stretch';
        this._justifyContent = 'flex-start';
        this._alignContent = 'flex-start';

        this._paddingLeft = 0;
        this._paddingTop = 0;
        this._paddingRight = 0;
        this._paddingBottom = 0;
    }

    get item() {
        return this._item;
    }

    _changedDimensions() {
        this._item.changedDimensions();
    }

    _changedContents() {
        this._item.changedContents();
    }

    get direction() {
        return (this._horizontal ? "row" : "column") + (this._reverse ? "-reverse" : "");
    }

    set direction(f) {
        if (this.direction === f) return;

        this._horizontal = (f === 'row' || f === 'row-reverse');
        this._reverse = (f === 'row-reverse' || f === 'column-reverse');

        this._changedContents();
    }

    set wrap(v) {
        this._wrap = v;
        this._changedContents();
    }

    get wrap() {
        return this._wrap;
    }

    get alignItems() {
        return this._alignItems;
    }

    set alignItems(v) {
        if (this._alignItems === v) return;
        if (FlexContainer.ALIGN_ITEMS.indexOf(v) === -1) {
            throw new Error("Unknown alignItems, options: " + FlexContainer.ALIGN_ITEMS.join(","));
        }
        this._alignItems = v;

        this._changedContents();
    }

    get alignContent() {
        return this._alignContent;
    }

    set alignContent(v) {
        if (this._alignContent === v) return;
        if (FlexContainer.ALIGN_CONTENT.indexOf(v) === -1) {
            throw new Error("Unknown alignContent, options: " + FlexContainer.ALIGN_CONTENT.join(","));
        }
        this._alignContent = v;

        this._changedContents();
    }

    get justifyContent() {
        return this._justifyContent;
    }

    set justifyContent(v) {
        if (this._justifyContent === v) return;

        if (FlexContainer.JUSTIFY_CONTENT.indexOf(v) === -1) {
            throw new Error("Unknown justifyContent, options: " + FlexContainer.JUSTIFY_CONTENT.join(","));
        }
        this._justifyContent = v;

        this._changedContents();
    }

    set padding(v) {
        this.paddingLeft = v;
        this.paddingTop = v;
        this.paddingRight = v;
        this.paddingBottom = v;
    }

    get padding() {
        return this.paddingLeft;
    }
    
    set paddingLeft(v) {
        this._paddingLeft = v;
        this._changedDimensions();
    }
    
    get paddingLeft() {
        return this._paddingLeft;
    }

    set paddingTop(v) {
        this._paddingTop = v;
        this._changedDimensions();
    }

    get paddingTop() {
        return this._paddingTop;
    }

    set paddingRight(v) {
        this._paddingRight = v;
        this._changedDimensions();
    }

    get paddingRight() {
        return this._paddingRight;
    }

    set paddingBottom(v) {
        this._paddingBottom = v;
        this._changedDimensions();
    }

    get paddingBottom() {
        return this._paddingBottom;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].patchObject(this, settings);
    }

}

FlexContainer.ALIGN_ITEMS = ["flex-start", "flex-end", "center", "stretch"];
FlexContainer.ALIGN_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly", "stretch"];
FlexContainer.JUSTIFY_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly"];


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/FlexItem.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/FlexItem.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexItem)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FlexUtils.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs");
/* harmony import */ var _FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FlexContainer.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexContainer.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class FlexItem {

    constructor(item) {
        this._ctr = null;
        this._item = item;
        this._grow = 0;
        this._shrink = FlexItem.SHRINK_AUTO;
        this._alignSelf = undefined;
        this._minWidth = 0;
        this._minHeight = 0;
        this._maxWidth = 0;
        this._maxHeight = 0;

        this._marginLeft = 0;
        this._marginTop = 0;
        this._marginRight = 0;
        this._marginBottom = 0;
    }

    get item() {
        return this._item;
    }

    get grow() {
        return this._grow;
    }

    set grow(v) {
        if (this._grow === v) return;

        this._grow = parseInt(v) || 0;

        this._changed();
    }

    get shrink() {
        if (this._shrink === FlexItem.SHRINK_AUTO) {
            return this._getDefaultShrink();
        }
        return this._shrink;
    }

    _getDefaultShrink() {
        if (this.item.isFlexEnabled()) {
            return 1;
        } else {
            // All non-flex containers are absolutely positioned items with fixed dimensions, and by default not shrinkable.
            return 0;
        }
    }

    set shrink(v) {
        if (this._shrink === v) return;

        this._shrink = parseInt(v) || 0;

        this._changed();
    }

    get alignSelf() {
        return this._alignSelf;
    }

    set alignSelf(v) {
        if (this._alignSelf === v) return;

        if (v === undefined) {
            this._alignSelf = undefined;
        } else {
            if (_FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ALIGN_ITEMS.indexOf(v) === -1) {
                throw new Error("Unknown alignSelf, options: " + _FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ALIGN_ITEMS.join(","));
            }
            this._alignSelf = v;
        }

        this._changed();
    }

    get minWidth() {
        return this._minWidth;
    }

    set minWidth(v) {
        this._minWidth = Math.max(0, v);
        this._item.changedDimensions(true, false);
    }

    get minHeight() {
        return this._minHeight;
    }

    set minHeight(v) {
        this._minHeight = Math.max(0, v);
        this._item.changedDimensions(false, true);
    }

    get maxWidth() {
        return this._maxWidth;
    }

    set maxWidth(v) {
        this._maxWidth = Math.max(0, v);
        this._item.changedDimensions(true, false);
    }

    get maxHeight() {
        return this._maxHeight;
    }

    set maxHeight(v) {
        this._maxHeight = Math.max(0, v);
        this._item.changedDimensions(false, true);
    }

    /**
     * @note margins behave slightly different than in HTML with regard to shrinking.
     * In HTML, (outer) margins can be removed when shrinking. In this engine, they will not shrink at all.
     */
    set margin(v) {
        this.marginLeft = v;
        this.marginTop = v;
        this.marginRight = v;
        this.marginBottom = v;
    }

    get margin() {
        return this.marginLeft;
    }

    set marginLeft(v) {
        this._marginLeft = v;
        this._changed();
    }

    get marginLeft() {
        return this._marginLeft;
    }

    set marginTop(v) {
        this._marginTop = v;
        this._changed();
    }

    get marginTop() {
        return this._marginTop;
    }

    set marginRight(v) {
        this._marginRight = v;
        this._changed();
    }

    get marginRight() {
        return this._marginRight;
    }

    set marginBottom(v) {
        this._marginBottom = v;
        this._changed();
    }

    get marginBottom() {
        return this._marginBottom;
    }
    
    _changed() {
        if (this.ctr) this.ctr._changedContents();
    }

    set ctr(v) {
        this._ctr = v;
    }

    get ctr() {
        return this._ctr;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].patchObject(this, settings);
    }

    _resetLayoutSize() {
        this._resetHorizontalAxisLayoutSize();
        this._resetVerticalAxisLayoutSize();
    }

    _resetCrossAxisLayoutSize() {
        if (this.ctr._horizontal) {
            this._resetVerticalAxisLayoutSize();
        } else {
            this._resetHorizontalAxisLayoutSize();
        }
    }

    _resetHorizontalAxisLayoutSize() {
        let w = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRelAxisSize(this.item, true);
        if (this._minWidth) {
            w = Math.max(this._minWidth, w);
        }
        if (this._maxWidth) {
            w = Math.min(this._maxWidth, w);
        }
        _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutSize(this.item, true, w);
    }

    _resetVerticalAxisLayoutSize() {
        let h = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRelAxisSize(this.item, false);
        if (this._minHeight) {
            h = Math.max(this._minHeight, h);
        }
        if (this._maxHeight) {
            h = Math.min(this._maxHeight, h);
        }
        _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutSize(this.item, false, h);
    }

    _getCrossAxisMinSizeSetting() {
        return this._getMinSizeSetting(!this.ctr._horizontal);
    }

    _getCrossAxisMaxSizeSetting() {
        return this._getMaxSizeSetting(!this.ctr._horizontal);
    }

    _getMainAxisMaxSizeSetting() {
        return this._getMaxSizeSetting(this.ctr._horizontal);
    }

    _getMinSizeSetting(horizontal) {
        if (horizontal) {
            return this._minWidth;
        } else {
            return this._minHeight;
        }
    }

    _getMaxSizeSetting(horizontal) {
        if (horizontal) {
            return this._maxWidth;
        } else {
            return this._maxHeight;
        }
    }

    _getMainAxisMinSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisMinSize(this.item, this.ctr._horizontal);
    }

    _getCrossAxisMinSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisMinSize(this.item, !this.ctr._horizontal);
    }

    _getMainAxisLayoutSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutSize(this.item, this.ctr._horizontal);
    }

    _getMainAxisLayoutPos() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutPos(this.item, this.ctr._horizontal);
    }

    _setMainAxisLayoutPos(pos) {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutPos(this.item, this.ctr._horizontal, pos);
    }

    _setCrossAxisLayoutPos(pos) {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutPos(this.item, !this.ctr._horizontal, pos);
    }

    _getCrossAxisLayoutSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutSize(this.item, !this.ctr._horizontal);
    }

    _resizeCrossAxis(size) {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resizeAxis(this.item, !this.ctr._horizontal, size);
    }

    _resizeMainAxis(size) {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resizeAxis(this.item, this.ctr._horizontal, size);
    }

    _getMainAxisPadding() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalPadding(this.item, this.ctr._horizontal);
    }

    _getCrossAxisPadding() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalPadding(this.item, !this.ctr._horizontal);
    }

    _getMainAxisMargin() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalMargin(this.item, this.ctr._horizontal);
    }

    _getCrossAxisMargin() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalMargin(this.item, !this.ctr._horizontal);
    }

    _getHorizontalMarginOffset() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getMarginOffset(this.item, true);
    }

    _getVerticalMarginOffset() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getMarginOffset(this.item, false);
    }

    _getMainAxisMinSizeWithPaddingAndMargin() {
        return this._getMainAxisMinSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
    }

    _getCrossAxisMinSizeWithPaddingAndMargin() {
        return this._getCrossAxisMinSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
    }

    _getMainAxisLayoutSizeWithPaddingAndMargin() {
        return this._getMainAxisLayoutSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
    }

    _getCrossAxisLayoutSizeWithPaddingAndMargin() {
        return this._getCrossAxisLayoutSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
    }

    _hasFixedCrossAxisSize() {
        return !_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isZeroAxisSize(this.item, !this.ctr._horizontal);
    }

    _hasRelCrossAxisSize() {
        return !!(this.ctr._horizontal ? this.item.funcH : this.item.funcW);
    }

}


FlexItem.SHRINK_AUTO = -1;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/FlexTarget.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/FlexTarget.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexTarget)
/* harmony export */ });
/* harmony import */ var _FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FlexContainer.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexContainer.mjs");
/* harmony import */ var _FlexItem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FlexItem.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexItem.mjs");
/* harmony import */ var _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FlexUtils.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * This is the connection between the render tree with the layout tree of this flex container/item.
 */
class FlexTarget {

    constructor(target) {
        this._target = target;

        /**
         * Possible values (only in case of container):
         * bit 0: has changed or contains items with changes
         * bit 1: width changed
         * bit 2: height changed
         */
        this._recalc = 0;
        
        this._enabled = false;

        this.x = 0;
        this.y = 0;
        this.w = 0;
        this.h = 0;

        this._originalX = 0;
        this._originalY = 0;
        this._originalWidth = 0;
        this._originalHeight = 0;

        this._flex = null;
        this._flexItem = null;
        this._flexItemDisabled = false;

        this._items = null;
    }

    get flexLayout() {
        return this.flex ? this.flex._layout : null;
    }

    layoutFlexTree() {
        if (this.isFlexEnabled() && this.isChanged()) {
            this.flexLayout.layoutTree();
        }
    }

    get target() {
        return this._target;
    }

    get flex() {
        return this._flex;
    }

    set flex(v) {
        if (!v) {
            if (this.isFlexEnabled()) {
                this._disableFlex();
            }
        } else {
            if (!this.isFlexEnabled()) {
                this._enableFlex();
            }
            this._flex.patch(v);
        }
    }

    get flexItem() {
        if (this._flexItemDisabled) {
            return false;
        }
        this._ensureFlexItem();
        return this._flexItem;
    }

    set flexItem(v) {
        if (v === false) {
            if (!this._flexItemDisabled) {
                const parent = this.flexParent;
                this._flexItemDisabled = true;
                this._checkEnabled();
                if (parent) {
                    parent._clearFlexItemsCache();
                    parent.changedContents();
                }
            }
        } else {
            this._ensureFlexItem();

            this._flexItem.patch(v);

            if (this._flexItemDisabled) {
                this._flexItemDisabled = false;
                this._checkEnabled();
                const parent = this.flexParent;
                if (parent) {
                    parent._clearFlexItemsCache();
                    parent.changedContents();
                }
            }
        }
    }

    _enableFlex() {
        this._flex = new _FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this);
        this._checkEnabled();
        this.changedDimensions();
        this._enableChildrenAsFlexItems();
    }

    _disableFlex() {
        this.changedDimensions();
        this._flex = null;
        this._checkEnabled();
        this._disableChildrenAsFlexItems();
    }

    _enableChildrenAsFlexItems() {
        const children = this._target._children;
        if (children) {
            for (let i = 0, n = children.length; i < n; i++) {
                const child = children[i];
                child.layout._enableFlexItem();
            }
        }
    }

    _disableChildrenAsFlexItems() {
        const children = this._target._children;
        if (children) {
            for (let i = 0, n = children.length; i < n; i++) {
                const child = children[i];
                child.layout._disableFlexItem();
            }
        }
    }

    _enableFlexItem() {
        this._ensureFlexItem();
        const flexParent = this._target._parent._layout;
        this._flexItem.ctr = flexParent._flex;
        flexParent.changedContents();
        this._checkEnabled();
    }

    _disableFlexItem() {
        if (this._flexItem) {
            this._flexItem.ctr = null;
        }

        // We keep the flexItem object because it may contain custom settings.
        this._checkEnabled();

        // Offsets have been changed. We can't recover them, so we'll just clear them instead.
        this._resetOffsets();
    }

    _resetOffsets() {
        this.x = 0;
        this.y = 0;
    }

    _ensureFlexItem() {
        if (!this._flexItem) {
            this._flexItem = new _FlexItem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);
        }
    }

    _checkEnabled() {
        const enabled = this.isEnabled();
        if (this._enabled !== enabled) {
            if (enabled) {
                this._enable();
            } else {
                this._disable();
            }
            this._enabled = enabled;
        }
    }
    
    _enable() {
        this._setupTargetForFlex();
        this._target.enableFlexLayout();
    }

    _disable() {
        this._restoreTargetToNonFlex();
        this._target.disableFlexLayout();
    }

    isEnabled() {
        return this.isFlexEnabled() || this.isFlexItemEnabled();
    }

    isFlexEnabled() {
        return this._flex !== null;
    }

    isFlexItemEnabled() {
        return this.flexParent !== null;
    }

    _restoreTargetToNonFlex() {
        const target = this._target;
        target.x = this._originalX;
        target.y = this._originalY;
        target.setDimensions(this._originalWidth, this._originalHeight);
    }

    _setupTargetForFlex() {
        const target = this._target;
        this._originalX = target._x;
        this._originalY = target._y;
        this._originalWidth = target._w;
        this._originalHeight = target._h;
    }
    
    setParent(from, to) {
        if (from && from.isFlexContainer()) {
            from._layout._changedChildren();
        }

        if (to && to.isFlexContainer()) {
            this._enableFlexItem();
            to._layout._changedChildren();
        }
        this._checkEnabled();
    }

    get flexParent() {
        if (this._flexItemDisabled) {
            return null;
        }

        const parent = this._target._parent;
        if (parent && parent.isFlexContainer()) {
            return parent._layout;
        }
        return null;
    }

    setVisible(v) {
        const parent = this.flexParent;
        if (parent) {
            parent._changedChildren();
        }
    }

    get items() {
        if (!this._items) {
            this._items = this._getFlexItems();
        }
        return this._items;
    }

    _getFlexItems() {
        const items = [];
        const children = this._target._children;
        if (children) {
            for (let i = 0, n = children.length; i < n; i++) {
                const item = children[i];
                if (item.visible) {
                    if (item.isFlexItem()) {
                        items.push(item.layout);
                    }
                }
            }
        }
        return items;
    }

    _changedChildren() {
        this._clearFlexItemsCache();
        this.changedContents();
    }

    _clearFlexItemsCache() {
        this._items = null;
    }

    setLayout(x, y, w, h) {
        let originalX = this._originalX;
        let originalY = this._originalY;
        if (this.funcX) {
            originalX = this.funcX(_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParentAxisSizeWithPadding(this, true));
        }
        if (this.funcY) {
            originalY = this.funcY(_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParentAxisSizeWithPadding(this, false));
        }

        if (this.isFlexItemEnabled()) {
            this.target.setLayout(x + originalX, y + originalY, w, h);
        } else {
            // Reuse the x,y 'settings'.
            this.target.setLayout(originalX, originalY, w, h);
        }
    }

    changedDimensions(changeWidth = true, changeHeight = true) {
        this._updateRecalc(changeWidth, changeHeight);
    }

    changedContents() {
        this._updateRecalc();
    }

    forceLayout() {
        this._updateRecalc();
    }

    isChanged() {
        return this._recalc > 0;
    }

    _updateRecalc(changeExternalWidth = false, changeExternalHeight = false) {
        if (this.isFlexEnabled()) {
            const layout = this._flex._layout;

            // When something internal changes, it can have effect on the external dimensions.
            changeExternalWidth = changeExternalWidth || layout.isAxisFitToContents(true);
            changeExternalHeight = changeExternalHeight || layout.isAxisFitToContents(false);
        }

        const recalc = 1 + (changeExternalWidth ? 2 : 0) + (changeExternalHeight ? 4 : 0);
        const newRecalcFlags = this.getNewRecalcFlags(recalc);
        this._recalc |= recalc;
        if (newRecalcFlags > 1) {
            if (this.flexParent) {
                this.flexParent._updateRecalcBottomUp(recalc);
            } else {
                this._target.triggerLayout();
            }
        } else {
            this._target.triggerLayout();
        }
    }

    getNewRecalcFlags(flags) {
        return (7 - this._recalc) & flags;
    }

    _updateRecalcBottomUp(childRecalc) {
        const newRecalc = this._getRecalcFromChangedChildRecalc(childRecalc);
        const newRecalcFlags = this.getNewRecalcFlags(newRecalc);
        this._recalc |= newRecalc;
        if (newRecalcFlags > 1) {
            const flexParent = this.flexParent;
            if (flexParent) {
                flexParent._updateRecalcBottomUp(newRecalc);
            } else {
                this._target.triggerLayout();
            }
        } else {
            this._target.triggerLayout();
        }
    }

    _getRecalcFromChangedChildRecalc(childRecalc) {
        const layout = this._flex._layout;

        const mainAxisRecalcFlag = layout._horizontal ? 1 : 2;
        const crossAxisRecalcFlag = layout._horizontal ? 2 : 1;

        const crossAxisDimensionsChangedInChild = (childRecalc & crossAxisRecalcFlag);
        if (!crossAxisDimensionsChangedInChild) {
            const mainAxisDimensionsChangedInChild = (childRecalc & mainAxisRecalcFlag);
            if (mainAxisDimensionsChangedInChild) {
                const mainAxisIsWrapping = layout.isWrapping();
                if (mainAxisIsWrapping) {
                    const crossAxisIsFitToContents = layout.isCrossAxisFitToContents();
                    if (crossAxisIsFitToContents) {
                        // Special case: due to wrapping, the cross axis size may be changed.
                        childRecalc += crossAxisRecalcFlag;
                    }
                }
            }
        }

        let isWidthDynamic = layout.isAxisFitToContents(true);
        let isHeightDynamic = layout.isAxisFitToContents(false);

        if (layout.shrunk) {
            // If during previous layout this container was 'shrunk', any changes may change the 'min axis size' of the
            // contents, leading to a different axis size on this container even when it was not 'fit to contents'.
            if (layout._horizontal) {
                isWidthDynamic = true;
            } else {
                isHeightDynamic = true;
            }
        }

        const localRecalc = 1 + (isWidthDynamic ? 2 : 0) + (isHeightDynamic ? 4 : 0);

        const combinedRecalc = childRecalc & localRecalc;
        return combinedRecalc;
    }

    get recalc() {
        return this._recalc;
    }

    clearRecalcFlag() {
        this._recalc = 0;
    }

    enableLocalRecalcFlag() {
        this._recalc = 1;
    }

    get originalX() {
        return this._originalX;
    }

    setOriginalXWithoutUpdatingLayout(v) {
        this._originalX = v;
    }

    get originalY() {
        return this._originalY;
    }

    setOriginalYWithoutUpdatingLayout(v) {
        this._originalY = v;
    }

    get originalWidth() {
        return this._originalWidth;
    }

    set originalWidth(v) {
        if (this._originalWidth !== v) {
            this._originalWidth = v;
            this.changedDimensions(true, false);
        }
    }

    get originalHeight() {
        return this._originalHeight;
    }

    set originalHeight(v) {
        if (this._originalHeight !== v) {
            this._originalHeight = v;
            this.changedDimensions(false, true);
        }
    }

    get funcX() {
        return this._target.funcX;
    }

    get funcY() {
        return this._target.funcY;
    }

    get funcW() {
        return this._target.funcW;
    }

    get funcH() {
        return this._target.funcH;
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexUtils)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class FlexUtils {

    static getParentAxisSizeWithPadding(item, horizontal) {
        const target = item.target;
        const parent = target.getParent();
        if (!parent) {
            return 0;
        } else {
            const flexParent = item.flexParent;
            if (flexParent) {
                // Use pending layout size.
                return this.getAxisLayoutSize(flexParent, horizontal) + this.getTotalPadding(flexParent, horizontal);
            } else {
                // Use 'absolute' size.
                return horizontal ? parent.w : parent.h;
            }
        }
    }

    static getRelAxisSize(item, horizontal) {
        if (horizontal) {
            if (item.funcW) {
                if (this._allowRelAxisSizeFunction(item, true)) {
                    return item.funcW(this.getParentAxisSizeWithPadding(item, true));
                } else {
                    return 0;
                }
            } else {
                return item.originalWidth;
            }
        } else {
            if (item.funcH) {
                if (this._allowRelAxisSizeFunction(item, false)) {
                    return item.funcH(this.getParentAxisSizeWithPadding(item, false));
                } else {
                    return 0;
                }
            } else {
                return item.originalHeight;
            }
        }
    }

    static _allowRelAxisSizeFunction(item, horizontal) {
        const flexParent = item.flexParent;
        if (flexParent && flexParent._flex._layout.isAxisFitToContents(horizontal)) {
            // We don't allow relative width on fit-to-contents because it leads to conflicts.
            return false;
        }
        return true;
    }

    static isZeroAxisSize(item, horizontal) {
        if (horizontal) {
            return !item.originalWidth && !item.funcW;
        } else {
            return !item.originalHeight && !item.funcH;
        }
    }

    static getAxisLayoutPos(item, horizontal) {
        return horizontal ? item.x : item.y;
    }

    static getAxisLayoutSize(item, horizontal) {
        return horizontal ? item.w : item.h;
    }

    static setAxisLayoutPos(item, horizontal, pos) {
        if (horizontal) {
            item.x = pos;
        } else {
            item.y = pos;
        }
    }

    static setAxisLayoutSize(item, horizontal, size) {
        if (horizontal) {
            item.w = size;
        } else {
            item.h = size;
        }
    }

    static getAxisMinSize(item, horizontal) {
        let minSize = this.getPlainAxisMinSize(item, horizontal);

        let flexItemMinSize = 0;
        if (item.isFlexItemEnabled()) {
            flexItemMinSize = item._flexItem._getMinSizeSetting(horizontal);
        }

        const hasLimitedMinSize = (flexItemMinSize > 0);
        if (hasLimitedMinSize) {
            minSize = Math.max(minSize, flexItemMinSize);
        }
        return minSize;
    }

    static getPlainAxisMinSize(item, horizontal) {
        if (item.isFlexEnabled()) {
            return item._flex._layout.getAxisMinSize(horizontal);
        } else {
            const isShrinkable = (item.flexItem.shrink !== 0);
            if (isShrinkable) {
                return 0;
            } else {
                return this.getRelAxisSize(item, horizontal);
            }
        }
    }

    static resizeAxis(item, horizontal, size) {
        if (item.isFlexEnabled()) {
            const isMainAxis = (item._flex._horizontal === horizontal);
            if (isMainAxis) {
                item._flex._layout.resizeMainAxis(size);
            } else {
                item._flex._layout.resizeCrossAxis(size);
            }
        } else {
            this.setAxisLayoutSize(item, horizontal, size);
        }
    }


    static getPaddingOffset(item, horizontal) {
        if (item.isFlexEnabled()) {
            const flex = item._flex;
            if (horizontal) {
                return flex.paddingLeft;
            } else {
                return flex.paddingTop;
            }
        } else {
            return 0;
        }
    }

    static getTotalPadding(item, horizontal) {
        if (item.isFlexEnabled()) {
            const flex = item._flex;
            if (horizontal) {
                return flex.paddingRight + flex.paddingLeft;
            } else {
                return flex.paddingTop + flex.paddingBottom;
            }
        } else {
            return 0;
        }
    }

    static getMarginOffset(item, horizontal) {
        const flexItem = item.flexItem;
        if (flexItem) {
            if (horizontal) {
                return flexItem.marginLeft;
            } else {
                return flexItem.marginTop;
            }
        } else {
            return 0;
        }
    }

    static getTotalMargin(item, horizontal) {
        const flexItem = item.flexItem;
        if (flexItem) {
            if (horizontal) {
                return flexItem.marginRight + flexItem.marginLeft;
            } else {
                return flexItem.marginTop + flexItem.marginBottom;
            }
        } else {
            return 0;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/ContentAligner.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/ContentAligner.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ContentAligner)
/* harmony export */ });
/* harmony import */ var _SpacingCalculator_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SpacingCalculator.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/SpacingCalculator.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ContentAligner {

    constructor(layout) {
        this._layout = layout;
        this._totalCrossAxisSize = 0;
    }

    get _lines() {
        return this._layout._lines;
    }

    init() {
        this._totalCrossAxisSize = this._getTotalCrossAxisSize();
    }

    align() {
        const crossAxisSize = this._layout.crossAxisSize;
        const remainingSpace = crossAxisSize - this._totalCrossAxisSize;

        const {spacingBefore, spacingBetween} = this._getSpacing(remainingSpace);

        const lines = this._lines;

        const mode = this._layout._flexContainer.alignContent;
        let growSize = 0;
        if (mode === "stretch" && lines.length && (remainingSpace > 0)) {
            growSize = remainingSpace / lines.length;
        }

        let currentPos = spacingBefore;
        for (let i = 0, n = lines.length; i < n; i++) {
            const crossAxisLayoutOffset = currentPos;
            const aligner = lines[i].createItemAligner();

            let finalCrossAxisLayoutSize = lines[i].crossAxisLayoutSize + growSize;

            aligner.setCrossAxisLayoutSize(finalCrossAxisLayoutSize);
            aligner.setCrossAxisLayoutOffset(crossAxisLayoutOffset);

            aligner.align();

            if (aligner.recursiveResizeOccured) {
                lines[i].setItemPositions();
            }

            currentPos += finalCrossAxisLayoutSize;
            currentPos += spacingBetween;
        }
    }

    get totalCrossAxisSize() {
        return this._totalCrossAxisSize;
    }

    _getTotalCrossAxisSize() {
        const lines = this._lines;
        let total = 0;
        for (let i = 0, n = lines.length; i < n; i++) {
            const line = lines[i];
            total += line.crossAxisLayoutSize;
        }
        return total;
    }

    _getSpacing(remainingSpace) {
        const mode = this._layout._flexContainer.alignContent;
        const numberOfItems = this._lines.length;
        return _SpacingCalculator_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getSpacing(mode, numberOfItems, remainingSpace);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/FlexLayout.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/FlexLayout.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexLayout)
/* harmony export */ });
/* harmony import */ var _ContentAligner_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContentAligner.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/ContentAligner.mjs");
/* harmony import */ var _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../FlexUtils.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs");
/* harmony import */ var _LineLayouter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LineLayouter.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/LineLayouter.mjs");
/* harmony import */ var _ItemCoordinatesUpdater_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ItemCoordinatesUpdater.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/ItemCoordinatesUpdater.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Layouts a flex container (and descendants).
 */
class FlexLayout {

    constructor(flexContainer) {
        this._flexContainer = flexContainer;

        this._lineLayouter = new _LineLayouter_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this);

        this._resizingMainAxis = false;
        this._resizingCrossAxis = false;

        this._cachedMainAxisSizeAfterLayout = 0;
        this._cachedCrossAxisSizeAfterLayout = 0;

        this._shrunk = false;
    }

    get shrunk() {
        return this._shrunk;
    }

    get recalc() {
        return this.item.recalc;
    }

    layoutTree() {
        const isSubTree = (this.item.flexParent !== null);
        if (isSubTree) {
            // Use the dimensions set by the parent flex tree.
            this._updateSubTreeLayout();
        } else {
            this.updateTreeLayout();
        }
        this.updateItemCoords();
    }

    updateTreeLayout() {
        if (this.recalc) {
            this._performUpdateLayoutTree();
        } else {
            this._performUpdateLayoutTreeFromCache();
        }
    }

    _performUpdateLayoutTree() {
        this._setInitialAxisSizes();
        this._layoutAxes();
        this._refreshLayoutCache();
    }

    _refreshLayoutCache() {
        this._cachedMainAxisSizeAfterLayout = this.mainAxisSize;
        this._cachedCrossAxisSizeAfterLayout = this.crossAxisSize;
    }

    _performUpdateLayoutTreeFromCache() {
        const sizeMightHaveChanged = (this.item.funcW || this.item.funcH);
        if (sizeMightHaveChanged) {
            // Update after all.
            this.item.enableLocalRecalcFlag();
            this._performUpdateLayoutTree();
        } else {
            this.mainAxisSize = this._cachedMainAxisSizeAfterLayout;
            this.crossAxisSize = this._cachedCrossAxisSizeAfterLayout;
        }
    }

    updateItemCoords() {
        const updater = new _ItemCoordinatesUpdater_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](this);
        updater.finalize();
    }

    _updateSubTreeLayout() {
        // The dimensions of this container are guaranteed not to have changed.
        // That's why we can safely 'reuse' those and re-layout the contents.
        const crossAxisSize = this.crossAxisSize;
        this._layoutMainAxis();
        this.performResizeCrossAxis(crossAxisSize);
    }

    _setInitialAxisSizes() {
        if (this.item.isFlexItemEnabled()) {
            this.item.flexItem._resetLayoutSize();
        } else {
            this.mainAxisSize = this._getMainAxisBasis();
            this.crossAxisSize = this._getCrossAxisBasis();
        }
        this._resizingMainAxis = false;
        this._resizingCrossAxis = false;
        this._shrunk = false;
    }

    _layoutAxes() {
        this._layoutMainAxis();
        this._layoutCrossAxis();
    }

    /**
     * @pre mainAxisSize should exclude padding.
     */
    _layoutMainAxis() {
        this._layoutLines();
        this._fitMainAxisSizeToContents();
    }

    _layoutLines() {
        this._lineLayouter.layoutLines();
    }

    get _lines() {
        return this._lineLayouter.lines;
    }

    _fitMainAxisSizeToContents() {
        if (!this._resizingMainAxis) {
            if (this.isMainAxisFitToContents()) {
                this.mainAxisSize = this._lineLayouter.mainAxisContentSize;
            }
        }
    }

    /**
     * @pre crossAxisSize should exclude padding.
     */
    _layoutCrossAxis() {
        const aligner = new _ContentAligner_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this);
        aligner.init();
        this._totalCrossAxisSize = aligner.totalCrossAxisSize;
        this._fitCrossAxisSizeToContents();
        aligner.align();
    }

    _fitCrossAxisSizeToContents() {
        if (!this._resizingCrossAxis) {
            if (this.isCrossAxisFitToContents()) {
                this.crossAxisSize = this._totalCrossAxisSize;
            }
        }
    }

    isWrapping() {
        return this._flexContainer.wrap;
    }

    isAxisFitToContents(horizontal) {
        if (this._horizontal === horizontal) {
            return this.isMainAxisFitToContents();
        } else {
            return this.isCrossAxisFitToContents();
        }
    }

    isMainAxisFitToContents() {
        return !this.isWrapping() && !this._hasFixedMainAxisBasis();
    }

    isCrossAxisFitToContents() {
        return !this._hasFixedCrossAxisBasis();
    }

    _hasFixedMainAxisBasis() {
        return !_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isZeroAxisSize(this.item, this._horizontal);
    }

    _hasFixedCrossAxisBasis() {
        return !_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isZeroAxisSize(this.item, !this._horizontal);
    }

    getAxisMinSize(horizontal) {
        if (this._horizontal === horizontal) {
            return this._getMainAxisMinSize();
        } else {
            return this._getCrossAxisMinSize();
        }
    }

    _getMainAxisMinSize() {
        return this._lineLayouter.mainAxisMinSize;
    }

    _getCrossAxisMinSize() {
        return this._lineLayouter.crossAxisMinSize;
    }

    resizeMainAxis(size) {
        if (this.mainAxisSize !== size) {
            if (this.recalc > 0) {
                this.performResizeMainAxis(size);
            } else {
                if (this._checkValidCacheMainAxisResize()) {
                    this.mainAxisSize = size;
                    this._fitCrossAxisSizeToContents();
                } else {
                    // Cache miss.
                    this.item.enableLocalRecalcFlag();
                    this.performResizeMainAxis(size);
                }
            }
        }
    }

    _checkValidCacheMainAxisResize(size) {
        const isFinalMainAxisSize = (size === this.targetMainAxisSize);
        if (isFinalMainAxisSize) {
            return true;
        }
        const canIgnoreCacheMiss = !this.isCrossAxisFitToContents();
        if (canIgnoreCacheMiss) {
            // Allow other main axis resizes and check if final resize matches the target main axis size
            //  (ItemCoordinatesUpdater).
            return true;
        }
        return false;
    }

    performResizeMainAxis(size) {
        const isShrinking = (size < this.mainAxisSize);
        this._shrunk = isShrinking;

        this.mainAxisSize = size;

        this._resizingMainAxis = true;
        this._layoutAxes();
        this._resizingMainAxis = false;
    }

    resizeCrossAxis(size) {
        if (this.crossAxisSize !== size) {
            if (this.recalc > 0) {
                this.performResizeCrossAxis(size);
            } else {
                this.crossAxisSize = size;
            }
        }
    }

    performResizeCrossAxis(size) {
        this.crossAxisSize = size;

        this._resizingCrossAxis = true;
        this._layoutCrossAxis();
        this._resizingCrossAxis = false;
    }

    get targetMainAxisSize() {
        return this._horizontal ? this.item.target.w : this.item.target.h;
    }

    get targetCrossAxisSize() {
        return this._horizontal ? this.item.target.h : this.item.target.w;
    }

    getParentFlexContainer() {
        return this.item.isFlexItemEnabled() ? this.item.flexItem.ctr : null;
    }

    _getHorizontalPadding() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalPadding(this.item, true);
    }

    _getVerticalPadding() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalPadding(this.item, false);
    }

    _getHorizontalPaddingOffset() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getPaddingOffset(this.item, true);
    }

    _getVerticalPaddingOffset() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getPaddingOffset(this.item, false);
    }

    _getMainAxisBasis() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRelAxisSize(this.item, this._horizontal);
    }

    _getCrossAxisBasis() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRelAxisSize(this.item, !this._horizontal);
    }

    get _horizontal() {
        return this._flexContainer._horizontal;
    }

    get _reverse() {
        return this._flexContainer._reverse;
    }

    get item() {
        return this._flexContainer.item;
    }

    get items() {
        return this.item.items;
    }

    get resizingMainAxis() {
        return this._resizingMainAxis;
    }

    get resizingCrossAxis() {
        return this._resizingCrossAxis;
    }

    get numberOfItems() {
        return this.items.length;
    }

    get mainAxisSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutSize(this.item, this._horizontal);
    }

    get crossAxisSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutSize(this.item, !this._horizontal);
    }

    set mainAxisSize(v) {
        _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutSize(this.item, this._horizontal, v);
    }

    set crossAxisSize(v) {
        _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutSize(this.item, !this._horizontal, v);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/ItemCoordinatesUpdater.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/ItemCoordinatesUpdater.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ItemCoordinatesUpdater)
/* harmony export */ });
/* harmony import */ var _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../FlexUtils.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ItemCoordinatesUpdater {

    constructor(layout) {
        this._layout = layout;
        this._isReverse = this._flexContainer._reverse;
        this._horizontalPaddingOffset = this._layout._getHorizontalPaddingOffset();
        this._verticalPaddingOffset = this._layout._getVerticalPaddingOffset();
    }

    get _flexContainer() {
        return this._layout._flexContainer;
    }

    finalize() {
        const parentFlex = this._layout.getParentFlexContainer();
        if (parentFlex) {
            // We must update it from the parent to set padding offsets and reverse position.
            const updater = new ItemCoordinatesUpdater(parentFlex._layout);
            updater._finalizeItemAndChildren(this._flexContainer.item);
        } else {
            this._finalizeRoot();
            this._finalizeItems();
        }
    }

    _finalizeRoot() {
        const item = this._flexContainer.item;
        let x = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutPos(item, true);
        let y = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutPos(item, false);
        let w = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutSize(item, true);
        let h = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutSize(item, false);

        w += this._layout._getHorizontalPadding();
        h += this._layout._getVerticalPadding();

        item.clearRecalcFlag();

        item.setLayout(x, y, w, h);
    }

    _finalizeItems() {
        const items = this._layout.items;
        for (let i = 0, n = items.length; i < n; i++) {
            const item = items[i];
            const validCache = this._validateItemCache(item);

            // Notice that we must also finalize a cached items, as it's coordinates may have changed.
            this._finalizeItem(item);

            if (!validCache) {
                this._finalizeItemChildren(item);
            }
        }
    }

    _validateItemCache(item) {
        if (item.recalc === 0) {
            if (item.isFlexEnabled()) {
                const layout = item._flex._layout;

                const dimensionsMatchPreviousResult = (item.w === item.target.w && item.h === item.target.h);
                if (dimensionsMatchPreviousResult) {
                    // Cache is valid.
                    return true;
                } else {
                    const crossAxisSize = layout.crossAxisSize;
                    layout.performResizeMainAxis(layout.mainAxisSize);
                    layout.performResizeCrossAxis(crossAxisSize);
                }
            }
        }
        return false;
    }

    _finalizeItemAndChildren(item) {
        this._finalizeItem(item);
        this._finalizeItemChildren(item);
    }

    _finalizeItem(item) {
        if (this._isReverse) {
            this._reverseMainAxisLayoutPos(item);
        }

        let x = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutPos(item, true);
        let y = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutPos(item, false);
        let w = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutSize(item, true);
        let h = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutSize(item, false);

        x += this._horizontalPaddingOffset;
        y += this._verticalPaddingOffset;

        const flex = item.flex;
        if (flex) {
            w += item._flex._layout._getHorizontalPadding();
            h += item._flex._layout._getVerticalPadding();
        }

        const flexItem = item.flexItem;
        if (flexItem) {
            x += flexItem._getHorizontalMarginOffset();
            y += flexItem._getVerticalMarginOffset();
        }

        item.clearRecalcFlag();
        item.setLayout(x, y, w, h);
    }

    _finalizeItemChildren(item) {
        const flex = item._flex;
        if (flex) {
            const updater = new ItemCoordinatesUpdater(flex._layout);
            updater._finalizeItems();
        }
    }

    _reverseMainAxisLayoutPos(item) {
        const endPos = (item.flexItem._getMainAxisLayoutPos() + item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin());
        const reversedPos = this._layout.mainAxisSize - endPos;
        item.flexItem._setMainAxisLayoutPos(reversedPos);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/LineLayouter.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/LineLayouter.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LineLayouter)
/* harmony export */ });
/* harmony import */ var _line_LineLayout_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line/LineLayout.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/LineLayout.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Distributes items over layout lines.
 */
class LineLayouter {

    constructor(layout) {
        this._layout = layout;
        this._mainAxisMinSize = -1;
        this._crossAxisMinSize = -1;
        this._mainAxisContentSize = 0;
    }

    get lines() {
        return this._lines;
    }

    get mainAxisMinSize() {
        if (this._mainAxisMinSize === -1) {
            this._mainAxisMinSize = this._getMainAxisMinSize();
        }
        return this._mainAxisMinSize;
    }

    get crossAxisMinSize() {
        if (this._crossAxisMinSize === -1) {
            this._crossAxisMinSize = this._getCrossAxisMinSize();
        }
        return this._crossAxisMinSize;
    }

    get mainAxisContentSize() {
        return this._mainAxisContentSize;
    }

    layoutLines() {
        this._setup();
        const items = this._layout.items;
        const wrap = this._layout.isWrapping();

        let startIndex = 0;
        let i;
        const n = items.length;
        for (i = 0; i < n; i++) {
            const item = items[i];

            this._layoutFlexItem(item);

            // Get predicted main axis size.
            const itemMainAxisSize = item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();

            if (wrap && (i > startIndex)) {
                const isOverflowing = (this._curMainAxisPos + itemMainAxisSize > this._mainAxisSize);
                if (isOverflowing) {
                    this._layoutLine(startIndex, i - 1);
                    this._curMainAxisPos = 0;
                    startIndex = i;
                }
            }

            this._addToMainAxisPos(itemMainAxisSize);
        }

        if (startIndex < i) {
            this._layoutLine(startIndex, i - 1);
        }
    }

    _layoutFlexItem(item) {
        if (item.isFlexEnabled()) {
            item.flexLayout.updateTreeLayout();
        } else {
            item.flexItem._resetLayoutSize();
        }
    }

    _setup() {
        this._mainAxisSize = this._layout.mainAxisSize;
        this._curMainAxisPos = 0;
        this._maxMainAxisPos = 0;
        this._lines = [];

        this._mainAxisMinSize = -1;
        this._crossAxisMinSize = -1;
        this._mainAxisContentSize = 0;
    }

    _addToMainAxisPos(itemMainAxisSize) {
        this._curMainAxisPos += itemMainAxisSize;
        if (this._curMainAxisPos > this._maxMainAxisPos) {
            this._maxMainAxisPos = this._curMainAxisPos;
        }
    }

    _layoutLine(startIndex, endIndex) {
        const availableSpace = this._getAvailableMainAxisLayoutSpace();
        const line = new _line_LineLayout_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this._layout, startIndex, endIndex, availableSpace);
        line.performLayout();
        this._lines.push(line);

        if (this._mainAxisContentSize === 0 || (this._curMainAxisPos > this._mainAxisContentSize)) {
            this._mainAxisContentSize = this._curMainAxisPos;
        }
    }

    _getAvailableMainAxisLayoutSpace() {
        if (!this._layout.resizingMainAxis && this._layout.isMainAxisFitToContents()) {
            return 0;
        } else {
            return this._mainAxisSize - this._curMainAxisPos;
        }
    }

    _getCrossAxisMinSize() {
        let crossAxisMinSize = 0;
        const items = this._layout.items;
        for (let i = 0, n = items.length; i < n; i++) {
            const item = items[i];
            const itemCrossAxisMinSize = item.flexItem._getCrossAxisMinSizeWithPaddingAndMargin();
            crossAxisMinSize = Math.max(crossAxisMinSize, itemCrossAxisMinSize);
        }
        return crossAxisMinSize;
    }

    _getMainAxisMinSize() {
        if (this._lines.length === 1) {
            return this._lines[0].getMainAxisMinSize();
        } else {
            // Wrapping lines: specified width is used as min width (in accordance to W3C flexbox).
            return this._layout.mainAxisSize;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/SpacingCalculator.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/SpacingCalculator.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpacingCalculator)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class SpacingCalculator {

    static getSpacing(mode, numberOfItems, remainingSpace) {
        const itemGaps = (numberOfItems - 1);
        let spacePerGap;

        let spacingBefore, spacingBetween;

        switch(mode) {
            case "flex-start":
                spacingBefore = 0;
                spacingBetween = 0;
                break;
            case "flex-end":
                spacingBefore = remainingSpace;
                spacingBetween = 0;
                break;
            case "center":
                spacingBefore = remainingSpace / 2;
                spacingBetween = 0;
                break;
            case "space-between":
                spacingBefore = 0;
                spacingBetween = Math.max(0, remainingSpace) / itemGaps;
                break;
            case "space-around":
                if (remainingSpace < 0) {
                    return this.getSpacing("center", numberOfItems, remainingSpace);
                } else {
                    spacePerGap = remainingSpace / (itemGaps + 1);
                    spacingBefore = 0.5 * spacePerGap;
                    spacingBetween = spacePerGap;
                }
                break;
            case "space-evenly":
                if (remainingSpace < 0) {
                    return this.getSpacing("center", numberOfItems, remainingSpace);
                } else {
                    spacePerGap = remainingSpace / (itemGaps + 2);
                    spacingBefore = spacePerGap;
                    spacingBetween = spacePerGap;
                }
                break;
            case "stretch":
                spacingBefore = 0;
                spacingBetween = 0;
                break;
            default:
                throw new Error("Unknown mode: " + mode);
        }

        return {spacingBefore, spacingBetween}
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/ItemAligner.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/ItemAligner.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ItemAligner)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ItemAligner {

    constructor(line) {
        this._line = line;
        this._crossAxisLayoutSize = 0;
        this._crossAxisLayoutOffset = 0;
        this._alignItemsSetting = null;
        this._recursiveResizeOccured = false;
        this._isCrossAxisFitToContents = false;
    }

    get _layout() {
        return this._line._layout;
    }

    get _flexContainer() {
        return this._layout._flexContainer;
    }

    setCrossAxisLayoutSize(size) {
        this._crossAxisLayoutSize = size;
    }

    setCrossAxisLayoutOffset(offset) {
        this._crossAxisLayoutOffset = offset;
    }

    align() {
        this._alignItemsSetting = this._flexContainer.alignItems;

        this._isCrossAxisFitToContents = this._layout.isAxisFitToContents(!this._flexContainer._horizontal);

        this._recursiveResizeOccured = false;
        const items = this._line.items;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];
            this._alignItem(item);
        }
    }

    get recursiveResizeOccured() {
        return this._recursiveResizeOccured;
    }

    _alignItem(item) {
        const flexItem = item.flexItem;
        let align = flexItem.alignSelf || this._alignItemsSetting;

        if (align === "stretch" && this._preventStretch(flexItem)) {
            align = "flex-start";
        }

        if (align !== "stretch" && !this._isCrossAxisFitToContents) {
            if (flexItem._hasRelCrossAxisSize()) {
                // As cross axis size might have changed, we need to recalc the relative flex item's size.
                flexItem._resetCrossAxisLayoutSize();
            }
        }

        switch(align) {
            case "flex-start":
                this._alignItemFlexStart(flexItem);
                break;
            case "flex-end":
                this._alignItemFlexEnd(flexItem);
                break;
            case "center":
                this._alignItemFlexCenter(flexItem);
                break;
            case "stretch":
                this._alignItemStretch(flexItem);
                break;
        }
    }

    _alignItemFlexStart(flexItem) {
        flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);
    }

    _alignItemFlexEnd(flexItem) {
        const itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
        flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + (this._crossAxisLayoutSize - itemCrossAxisSize));
    }

    _alignItemFlexCenter(flexItem) {
        const itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
        const center = (this._crossAxisLayoutSize - itemCrossAxisSize) / 2;
        flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + center);
    }

    _alignItemStretch(flexItem) {
        flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);

        const mainAxisLayoutSizeBeforeResize = flexItem._getMainAxisLayoutSize();
        let size = this._crossAxisLayoutSize - flexItem._getCrossAxisMargin() - flexItem._getCrossAxisPadding();

        const crossAxisMinSizeSetting = flexItem._getCrossAxisMinSizeSetting();
        if (crossAxisMinSizeSetting > 0) {
            size = Math.max(size, crossAxisMinSizeSetting);
        }

        const crossAxisMaxSizeSetting = flexItem._getCrossAxisMaxSizeSetting();
        const crossAxisMaxSizeSettingEnabled = (crossAxisMaxSizeSetting > 0);
        if (crossAxisMaxSizeSettingEnabled) {
            size = Math.min(size, crossAxisMaxSizeSetting);
        }

        flexItem._resizeCrossAxis(size);
        const mainAxisLayoutSizeAfterResize = flexItem._getMainAxisLayoutSize();

        const recursiveResize = (mainAxisLayoutSizeAfterResize !== mainAxisLayoutSizeBeforeResize);
        if (recursiveResize) {
            // Recursive resize can happen when this flex item has the opposite direction than the container
            // and is wrapping and auto-sizing. Due to item/content stretching the main axis size of the flex
            // item may decrease. If it does so, we must re-justify-content the complete line.
            // Notice that we don't account for changes to the (if autosized) main axis size caused by recursive
            // resize, which may cause the container's main axis to not shrink to the contents properly.
            // This is by design, because if we had re-run the main axis layout, we could run into issues such
            // as slow layout or endless loops.
            this._recursiveResizeOccured = true;
        }
    }

    _preventStretch(flexItem) {
        const hasFixedCrossAxisSize = flexItem._hasFixedCrossAxisSize();
        const forceStretch = (flexItem.alignSelf === "stretch");
        return hasFixedCrossAxisSize && !forceStretch;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/ItemPositioner.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/ItemPositioner.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ItemPositioner)
/* harmony export */ });
/* harmony import */ var _SpacingCalculator_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../SpacingCalculator.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/SpacingCalculator.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ItemPositioner {

    constructor(lineLayout) {
        this._line = lineLayout;
    }

    get _layout() {
        return this._line._layout;
    }

    position() {
        const {spacingBefore, spacingBetween} = this._getSpacing();

        let currentPos = spacingBefore;

        const items = this._line.items;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];

            item.flexItem._setMainAxisLayoutPos(currentPos);
            currentPos += item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
            currentPos += spacingBetween;
        }
    }

    _getSpacing() {
        const remainingSpace = this._line._availableSpace;
        let mode = this._layout._flexContainer.justifyContent;
        const numberOfItems = this._line.numberOfItems;

        return _SpacingCalculator_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getSpacing(mode, numberOfItems, remainingSpace);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/LineLayout.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/LineLayout.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LineLayout)
/* harmony export */ });
/* harmony import */ var _SizeShrinker_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SizeShrinker.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/SizeShrinker.mjs");
/* harmony import */ var _SizeGrower_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SizeGrower.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/SizeGrower.mjs");
/* harmony import */ var _ItemPositioner_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ItemPositioner.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/ItemPositioner.mjs");
/* harmony import */ var _ItemAligner_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ItemAligner.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/ItemAligner.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class LineLayout {

    constructor(layout, startIndex, endIndex, availableSpace) {
        this._layout = layout;
        this.items = layout.items;
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this._availableSpace = availableSpace;
    }

    performLayout() {
        this._setItemSizes();
        this.setItemPositions();
        this._calcLayoutInfo();
    }

    _setItemSizes() {
        if (this._availableSpace > 0) {
            this._growItemSizes(this._availableSpace);
        } else if (this._availableSpace < 0) {
            this._shrinkItemSizes(-this._availableSpace);
        }
    }

    _growItemSizes(amount) {
        const grower = new _SizeGrower_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);
        grower.grow(amount);
        this._availableSpace -= grower.getGrownSize();
    }

    _shrinkItemSizes(amount) {
        const shrinker = new _SizeShrinker_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this);
        shrinker.shrink(amount);
        this._availableSpace += shrinker.getShrunkSize();
    }

    setItemPositions() {
        const positioner = new _ItemPositioner_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this);
        positioner.position();
    }

    createItemAligner() {
        return new _ItemAligner_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](this);
    }

    _calcLayoutInfo() {
        this._calcCrossAxisMaxLayoutSize();
    }

    getMainAxisMinSize() {
        let mainAxisMinSize = 0;
        for (let i = this.startIndex; i <= this.endIndex; i++) {
            const item = this.items[i];
            mainAxisMinSize += item.flexItem._getMainAxisMinSizeWithPaddingAndMargin();
        }
        return mainAxisMinSize;
    }
    
    get numberOfItems() {
        return this.endIndex - this.startIndex + 1;
    }

    get crossAxisLayoutSize() {
        const noSpecifiedCrossAxisSize = (this._layout.isCrossAxisFitToContents() && !this._layout.resizingCrossAxis);
        const shouldFitToContents = (this._layout.isWrapping() || noSpecifiedCrossAxisSize);
        if (shouldFitToContents) {
            return this._crossAxisMaxLayoutSize;
        } else {
            return this._layout.crossAxisSize;
        }
    }

    _calcCrossAxisMaxLayoutSize() {
        this._crossAxisMaxLayoutSize = this._getCrossAxisMaxLayoutSize();
    }

    _getCrossAxisMaxLayoutSize() {
        let crossAxisMaxSize = 0;
        for (let i = this.startIndex; i <= this.endIndex; i++) {
            const item = this.items[i];
            crossAxisMaxSize = Math.max(crossAxisMaxSize, item.flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin());
        }
        return crossAxisMaxSize;
    }


}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/SizeGrower.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/SizeGrower.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SizeGrower)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class SizeGrower {

    constructor(line) {
        this._line = line;
        this._amountRemaining = 0;
        this._grownSize = 0;
    }

    grow(amount) {
        this._grownSize = 0;

        this._amountRemaining = amount;
        let totalGrowAmount = this._getTotalGrowAmount();
        if (totalGrowAmount) {
            const items = this._line.items;
            do {
                let amountPerGrow = this._amountRemaining / totalGrowAmount;
                for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
                    const item = items[i];
                    const flexItem = item.flexItem;
                    const growAmount = flexItem.grow;
                    const isGrowableItem = (growAmount > 0);
                    if (isGrowableItem) {
                        let grow = growAmount * amountPerGrow;
                        const maxSize = flexItem._getMainAxisMaxSizeSetting();
                        const size = flexItem._getMainAxisLayoutSize();
                        if (maxSize > 0) {
                            if (size >= maxSize) {
                                // Already fully grown.
                                grow = 0;
                            } else {
                                const maxGrow = maxSize - size;
                                const isFullyGrown = (grow >= maxGrow);
                                if (isFullyGrown) {
                                    grow = maxGrow;

                                    // Destribute remaining amount over the other flex items.
                                    totalGrowAmount -= growAmount;
                                }
                            }
                        }

                        if (grow > 0) {
                            const finalSize = size + grow;
                            flexItem._resizeMainAxis(finalSize);

                            this._grownSize += grow;
                            this._amountRemaining -= grow;

                            if (Math.abs(this._amountRemaining) < 10e-6) {
                                return;
                            }
                        }
                    }
                }
            } while(totalGrowAmount && (Math.abs(this._amountRemaining) > 10e-6));
        }
    }

    _getTotalGrowAmount() {
        let total = 0;
        const items = this._line.items;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];
            const flexItem = item.flexItem;

            if (flexItem.grow) {
                const maxSize = flexItem._getMainAxisMaxSizeSetting();
                const size = flexItem._getMainAxisLayoutSize();

                // Exclude those already fully grown.
                if (maxSize === 0 || size < maxSize) {
                    total += flexItem.grow;
                }
            }
        }
        return total;
    }

    getGrownSize() {
        return this._grownSize;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/SizeShrinker.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/SizeShrinker.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SizeShrinker)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class SizeShrinker {

    constructor(line) {
        this._line = line;
        this._amountRemaining = 0;
        this._shrunkSize = 0;
    }

    shrink(amount) {
        this._shrunkSize = 0;

        this._amountRemaining = amount;
        let totalShrinkAmount = this._getTotalShrinkAmount();
        if (totalShrinkAmount) {
            const items = this._line.items;
            do {
                let amountPerShrink = this._amountRemaining / totalShrinkAmount;
                for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
                    const item = items[i];
                    const flexItem = item.flexItem;
                    const shrinkAmount = flexItem.shrink;
                    const isShrinkableItem = (shrinkAmount > 0);
                    if (isShrinkableItem) {
                        let shrink = shrinkAmount * amountPerShrink;
                        const minSize = flexItem._getMainAxisMinSize();
                        const size = flexItem._getMainAxisLayoutSize();
                        if (size > minSize) {
                            const maxShrink = size - minSize;
                            const isFullyShrunk = (shrink >= maxShrink);
                            if (isFullyShrunk) {
                                shrink = maxShrink;

                                // Destribute remaining amount over the other flex items.
                                totalShrinkAmount -= shrinkAmount;
                            }

                            const finalSize = size - shrink;
                            flexItem._resizeMainAxis(finalSize);

                            this._shrunkSize += shrink;
                            this._amountRemaining -= shrink;

                            if (Math.abs(this._amountRemaining) < 10e-6) {
                                return;
                            }
                        }
                    }
                }
            } while(totalShrinkAmount && (Math.abs(this._amountRemaining) > 10e-6));
        }
    }

    _getTotalShrinkAmount() {
        let total = 0;
        const items = this._line.items;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];
            const flexItem = item.flexItem;

            if (flexItem.shrink) {
                const minSize = flexItem._getMainAxisMinSize();
                const size = flexItem._getMainAxisLayoutSize();

                // Exclude those already fully shrunk.
                if (size > minSize) {
                    total += flexItem.shrink;
                }
            }
        }
        return total;
    }

    getShrunkSize() {
        return this._shrunkSize;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/lightning.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/lightning.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _application_Application_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./application/Application.mjs */ "./node_modules/@lightningjs/core/src/application/Application.mjs");
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tree/Element.mjs */ "./node_modules/@lightningjs/core/src/tree/Element.mjs");
/* harmony import */ var _tree_core_ElementCore_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tree/core/ElementCore.mjs */ "./node_modules/@lightningjs/core/src/tree/core/ElementCore.mjs");
/* harmony import */ var _tree_core_ElementTexturizer_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tree/core/ElementTexturizer.mjs */ "./node_modules/@lightningjs/core/src/tree/core/ElementTexturizer.mjs");
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/* harmony import */ var _tools_Tools_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tools/Tools.mjs */ "./node_modules/@lightningjs/core/src/tools/Tools.mjs");
/* harmony import */ var _tools_ObjMerger_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tools/ObjMerger.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjMerger.mjs");
/* harmony import */ var _tools_ObjectListProxy_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tools/ObjectListProxy.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjectListProxy.mjs");
/* harmony import */ var _tools_ObjectListWrapper_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tools/ObjectListWrapper.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjectListWrapper.mjs");
/* harmony import */ var _textures_RectangleTexture_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./textures/RectangleTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/RectangleTexture.mjs");
/* harmony import */ var _textures_NoiseTexture_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./textures/NoiseTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/NoiseTexture.mjs");
/* harmony import */ var _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./textures/TextTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/TextTexture.mjs");
/* harmony import */ var _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./textures/ImageTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/ImageTexture.mjs");
/* harmony import */ var _textures_HtmlTexture_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./textures/HtmlTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/HtmlTexture.mjs");
/* harmony import */ var _textures_StaticTexture_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./textures/StaticTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/StaticTexture.mjs");
/* harmony import */ var _textures_StaticCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./textures/StaticCanvasTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/StaticCanvasTexture.mjs");
/* harmony import */ var _textures_SourceTexture_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./textures/SourceTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/SourceTexture.mjs");
/* harmony import */ var _components_ListComponent_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/ListComponent.mjs */ "./node_modules/@lightningjs/core/src/components/ListComponent.mjs");
/* harmony import */ var _components_FastBlurComponent_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/FastBlurComponent.mjs */ "./node_modules/@lightningjs/core/src/components/FastBlurComponent.mjs");
/* harmony import */ var _components_BloomComponent_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/BloomComponent.mjs */ "./node_modules/@lightningjs/core/src/components/BloomComponent.mjs");
/* harmony import */ var _components_SmoothScaleComponent_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./components/SmoothScaleComponent.mjs */ "./node_modules/@lightningjs/core/src/components/SmoothScaleComponent.mjs");
/* harmony import */ var _components_BorderComponent_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./components/BorderComponent.mjs */ "./node_modules/@lightningjs/core/src/components/BorderComponent.mjs");
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/* harmony import */ var _renderer_webgl_WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./renderer/webgl/WebGLShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./renderer/webgl/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _renderer_common_shaders_GrayscaleShader_mjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./renderer/common/shaders/GrayscaleShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/common/shaders/GrayscaleShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./renderer/webgl/shaders/BoxBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_DitheringShader_mjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./renderer/webgl/shaders/DitheringShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DitheringShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_CircularPushShader_mjs__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./renderer/webgl/shaders/CircularPushShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/CircularPushShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_InversionShader_mjs__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./renderer/webgl/shaders/InversionShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/InversionShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./renderer/webgl/shaders/LinearBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_OutlineShader_mjs__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./renderer/webgl/shaders/OutlineShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/OutlineShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_PixelateShader_mjs__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./renderer/webgl/shaders/PixelateShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PixelateShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_RadialFilterShader_mjs__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./renderer/webgl/shaders/RadialFilterShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialFilterShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_RoundedRectangleShader_mjs__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./renderer/webgl/shaders/RoundedRectangleShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RoundedRectangleShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_FadeOutShader_mjs__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./renderer/webgl/shaders/FadeOutShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/FadeOutShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_VignetteShader_mjs__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./renderer/webgl/shaders/VignetteShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/VignetteShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_SpinnerShader_mjs__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./renderer/webgl/shaders/SpinnerShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_HoleShader_mjs__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./renderer/webgl/shaders/HoleShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/HoleShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_RadialGradientShader_mjs__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./renderer/webgl/shaders/RadialGradientShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialGradientShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_Light3dShader_mjs__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./renderer/webgl/shaders/Light3dShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/Light3dShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_PerspectiveShader_mjs__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./renderer/webgl/shaders/PerspectiveShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PerspectiveShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_MagnifierShader_mjs__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./renderer/webgl/shaders/MagnifierShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/MagnifierShader.mjs");
/* harmony import */ var _renderer_c2d_C2dShader_mjs__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./renderer/c2d/C2dShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs");
/* harmony import */ var _renderer_c2d_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./renderer/c2d/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs");
/* harmony import */ var _renderer_c2d_shaders_BlurShader_mjs__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./renderer/c2d/shaders/BlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/BlurShader.mjs");
/* harmony import */ var _tree_Stage_mjs__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./tree/Stage.mjs */ "./node_modules/@lightningjs/core/src/tree/Stage.mjs");
/* harmony import */ var _renderer_webgl_shaders_SpinnerShader2_mjs__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./renderer/webgl/shaders/SpinnerShader2.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader2.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





























































const lightning = {
    Application: _application_Application_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    Component: _application_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
    Base: _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
    Utils: _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
    StageUtils: _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
    Element: _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
    Tools: _tools_Tools_mjs__WEBPACK_IMPORTED_MODULE_9__["default"],
    Stage: _tree_Stage_mjs__WEBPACK_IMPORTED_MODULE_50__["default"],
    ElementCore: _tree_core_ElementCore_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
    ElementTexturizer: _tree_core_ElementTexturizer_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
    Texture: _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_8__["default"],
    EventEmitter: _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_26__["default"],
    shaders: {
        Grayscale: _renderer_common_shaders_GrayscaleShader_mjs__WEBPACK_IMPORTED_MODULE_29__.WebGLGrayscaleShader,
        BoxBlur: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_30__["default"],
        Dithering: _renderer_webgl_shaders_DitheringShader_mjs__WEBPACK_IMPORTED_MODULE_31__["default"],
        CircularPush: _renderer_webgl_shaders_CircularPushShader_mjs__WEBPACK_IMPORTED_MODULE_32__["default"],
        Inversion: _renderer_webgl_shaders_InversionShader_mjs__WEBPACK_IMPORTED_MODULE_33__["default"],
        LinearBlur: _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_34__["default"],
        Outline: _renderer_webgl_shaders_OutlineShader_mjs__WEBPACK_IMPORTED_MODULE_35__["default"],
        Pixelate: _renderer_webgl_shaders_PixelateShader_mjs__WEBPACK_IMPORTED_MODULE_36__["default"],
        RadialFilter: _renderer_webgl_shaders_RadialFilterShader_mjs__WEBPACK_IMPORTED_MODULE_37__["default"],
        RoundedRectangle: _renderer_webgl_shaders_RoundedRectangleShader_mjs__WEBPACK_IMPORTED_MODULE_38__["default"],
        Spinner2: _renderer_webgl_shaders_SpinnerShader2_mjs__WEBPACK_IMPORTED_MODULE_51__["default"],
        FadeOut: _renderer_webgl_shaders_FadeOutShader_mjs__WEBPACK_IMPORTED_MODULE_39__["default"],
        Hole: _renderer_webgl_shaders_HoleShader_mjs__WEBPACK_IMPORTED_MODULE_42__["default"],
        Vignette: _renderer_webgl_shaders_VignetteShader_mjs__WEBPACK_IMPORTED_MODULE_40__["default"],
        Spinner: _renderer_webgl_shaders_SpinnerShader_mjs__WEBPACK_IMPORTED_MODULE_41__["default"],
        RadialGradient: _renderer_webgl_shaders_RadialGradientShader_mjs__WEBPACK_IMPORTED_MODULE_43__["default"],
        Light3d: _renderer_webgl_shaders_Light3dShader_mjs__WEBPACK_IMPORTED_MODULE_44__["default"],
        Perspective: _renderer_webgl_shaders_PerspectiveShader_mjs__WEBPACK_IMPORTED_MODULE_45__["default"],
        Magnifier: _renderer_webgl_shaders_MagnifierShader_mjs__WEBPACK_IMPORTED_MODULE_46__["default"],
        WebGLShader: _renderer_webgl_WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_27__["default"],
        WebGLDefaultShader: _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_28__["default"],
        C2dShader: _renderer_c2d_C2dShader_mjs__WEBPACK_IMPORTED_MODULE_47__["default"],
        C2dDefaultShader: _renderer_c2d_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_48__["default"],
        c2d: {
            Grayscale: _renderer_common_shaders_GrayscaleShader_mjs__WEBPACK_IMPORTED_MODULE_29__.C2dGrayscaleShader,
            Blur: _renderer_c2d_shaders_BlurShader_mjs__WEBPACK_IMPORTED_MODULE_49__["default"]
        }
    },
    textures: {
        RectangleTexture: _textures_RectangleTexture_mjs__WEBPACK_IMPORTED_MODULE_13__["default"],
        NoiseTexture: _textures_NoiseTexture_mjs__WEBPACK_IMPORTED_MODULE_14__["default"],
        TextTexture: _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_15__["default"],
        ImageTexture: _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_16__["default"],
        HtmlTexture: _textures_HtmlTexture_mjs__WEBPACK_IMPORTED_MODULE_17__["default"],
        StaticTexture: _textures_StaticTexture_mjs__WEBPACK_IMPORTED_MODULE_18__["default"],
        StaticCanvasTexture: _textures_StaticCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_19__["default"],
        SourceTexture: _textures_SourceTexture_mjs__WEBPACK_IMPORTED_MODULE_20__["default"]
    },
    components: {
        FastBlurComponent: _components_FastBlurComponent_mjs__WEBPACK_IMPORTED_MODULE_22__["default"],
        BloomComponent: _components_BloomComponent_mjs__WEBPACK_IMPORTED_MODULE_23__["default"],
        SmoothScaleComponent: _components_SmoothScaleComponent_mjs__WEBPACK_IMPORTED_MODULE_24__["default"],
        BorderComponent: _components_BorderComponent_mjs__WEBPACK_IMPORTED_MODULE_25__["default"],
        ListComponent: _components_ListComponent_mjs__WEBPACK_IMPORTED_MODULE_21__["default"]
    },
    tools: {
        ObjMerger: _tools_ObjMerger_mjs__WEBPACK_IMPORTED_MODULE_10__["default"],
        ObjectListProxy: _tools_ObjectListProxy_mjs__WEBPACK_IMPORTED_MODULE_11__["default"],
        ObjectListWrapper: _tools_ObjectListWrapper_mjs__WEBPACK_IMPORTED_MODULE_12__["default"]
    }
};

if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isWeb) {
    window.lng = lightning;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lightning);


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/platforms/PlatformLoader.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/platforms/PlatformLoader.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PlatformLoader)
/* harmony export */ });
/* harmony import */ var _browser_WebPlatform_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser/WebPlatform.mjs */ "./node_modules/@lightningjs/core/src/platforms/browser/WebPlatform.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class PlatformLoader {
    static load(options) {
        if (options.platform) {
            return options.platform;
        } else {
            return _browser_WebPlatform_mjs__WEBPACK_IMPORTED_MODULE_0__["default"];
        }
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/platforms/browser/ImageWorker.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/platforms/browser/ImageWorker.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageWorker)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ImageWorker {

    constructor(options = {}) {
        this._items = new Map();
        this._id = 0;

        this._initWorker();
    }

    destroy() {
        if (this._worker) {
            this._worker.terminate();
        }
    }

    _initWorker() {
        const code = `(${createWorker.toString()})()`;
        const blob = new Blob([code.replace('"use strict";', '')]); // firefox adds "use strict"; to any function which might block worker execution so knock it off
        const blobURL = (window.URL ? URL : webkitURL).createObjectURL(blob, {
            type: 'application/javascript; charset=utf-8'
        });
        this._worker = new Worker(blobURL);

        this._worker.postMessage({type: 'config', config: {path: window.location.href, protocol: window.location.protocol}});

        this._worker.onmessage = (e) => {
            if (e.data && e.data.id) {
                const id = e.data.id;
                const item = this._items.get(id);
                if (item) {
                    if (e.data.type == 'data') {
                        this.finish(item, e.data.info);
                    } else {
                        this.error(item, e.data.info);
                    }
                }
            }
        }
    }

    create(src) {
        const id = ++this._id;
        const item = new ImageWorkerImage(this, id, src);
        this._items.set(id, item);
        this._worker.postMessage({type: "add", id: id, src: src});
        return item;
    }

    cancel(image) {
        this._worker.postMessage({type: "cancel", id: image.id});
        this._items.delete(image.id);
    }

    error(image, info) {
        image.error(info);
        this._items.delete(image.id);
    }

    finish(image, info) {
        image.load(info);
        this._items.delete(image.id);
    }

}

class ImageWorkerImage {

    constructor(manager, id, src) {
        this._manager = manager;
        this._id = id;
        this._src = src;
        this._onError = null;
        this._onLoad = null;
    }

    get id() {
        return this._id;
    }

    get src() {
        return this._src;
    }

    set onError(f) {
        this._onError = f;
    }

    set onLoad(f) {
        this._onLoad = f;
    }

    cancel() {
        this._manager.cancel(this);
    }

    load(info) {
        if (this._onLoad) {
            this._onLoad(info);
        }
    }

    error(info) {
        if (this._onError) {
            this._onError(info);
        }
    }

}

/**
 * Notice that, within the createWorker function, we must only use ES5 code to keep it ES5-valid after babelifying, as
 *  the converted code of this section is converted to a blob and used as the js of the web worker thread.
 */
const createWorker = function() {

    function ImageWorkerServer() {

        this.items = new Map();

        var t = this;
        onmessage = function(e) {
            t._receiveMessage(e);
        }

    }

    ImageWorkerServer.isPathAbsolute = function(path) {
        return /^(?:\/|[a-z]+:\/\/)/.test(path) || path.substr(0, 5) == 'data:';
    };

    ImageWorkerServer.prototype._receiveMessage = function(e) {
        if (e.data.type === 'config') {
            this.config = e.data.config;

            var base = this.config.path;
            // the constructing of the basepath fails
            // if location.hash contains a slash
            var hasHashPath = /#.*?\//;
            if(hasHashPath.test(base)){
                base = base.replace(/#.*$/,'');
            }

            var parts = base.split("/");
            parts.pop();
            this._relativeBase = parts.join("/") + "/";

        } else if (e.data.type === 'add') {
            this.add(e.data.id, e.data.src);
        } else if (e.data.type === 'cancel') {
            this.cancel(e.data.id);
        }
    };

    ImageWorkerServer.prototype.add = function(id, src) {
        // Convert relative URLs.
        if (!ImageWorkerServer.isPathAbsolute(src)) {
            src = this._relativeBase + src;
        }

        if (src.substr(0,2) === "//") {
            // This doesn't work for image workers.
            src = this.config.protocol + src;
        }

        var item = new ImageWorkerServerItem(id, src);
        var t = this;
        item.onFinish = function(result) {
            t.finish(item, result);
        };
        item.onError = function(info) {
            t.error(item, info);
        };
        this.items.set(id, item);
        item.start();
    };

    ImageWorkerServer.prototype.cancel = function(id) {
        var item = this.items.get(id);
        if (item) {
            item.cancel();
            this.items.delete(id);
        }
    }

    ImageWorkerServer.prototype.finish = function(item, {imageBitmap, hasAlphaChannel}) {
        postMessage({
            type: "data",
            id: item.id,
            info: {
                imageBitmap,
                hasAlphaChannel
            }
        }, [imageBitmap]);
        this.items.delete(item.id);
    };

    ImageWorkerServer.prototype.error = function(item, {type, message}) {
        postMessage({
            type: "error",
            id: item.id,
            info: {
                type,
                message
            }
        });
        this.items.delete(item.id);
    };

    ImageWorkerServer.isWPEBrowser = function() {
        return (navigator.userAgent.indexOf("WPE") !== -1);
    };

    function ImageWorkerServerItem(id, src) {

        this._onError = undefined;
        this._onFinish = undefined;
        this._id = id;
        this._src = src;
        this._xhr = undefined;
        this._mimeType = undefined;
        this._canceled = false;

    }

    Object.defineProperty(ImageWorkerServerItem.prototype, 'id', {
        get: function() {
            return this._id;
        }
    });

    Object.defineProperty(ImageWorkerServerItem.prototype, 'onFinish', {
        get: function() {
            return this._onFinish;
        },
        set: function(f) {
            this._onFinish = f;
        }
    });

    Object.defineProperty(ImageWorkerServerItem.prototype, 'onError', {
        get: function() {
            return this._onError;
        },
        set: function(f) {
            this._onError = f;
        }
    });

    ImageWorkerServerItem.prototype.start = function() {
        this._xhr = new XMLHttpRequest();
        this._xhr.open("GET", this._src, true);
        this._xhr.responseType = "blob";

        var t = this;
        this._xhr.onerror = function(oEvent) {
            t.error({type: "connection", message: "Connection error"});
        };

        this._xhr.onload = function(oEvent) {
            var blob = t._xhr.response;
            t._mimeType = blob.type;

            t._createImageBitmap(blob);
        };

        this._xhr.send();
    };

    ImageWorkerServerItem.prototype._createImageBitmap = function(blob) {
        var t = this;
        createImageBitmap(blob, {premultiplyAlpha: 'premultiply', colorSpaceConversion: 'none', imageOrientation: 'none'}).then(function(imageBitmap) {
            t.finish({
                imageBitmap,
                hasAlphaChannel: t._hasAlphaChannel()
            });
        }).catch(function(e) {
            t.error({type: "parse", message: "Error parsing image data"});
        });
    };

    ImageWorkerServerItem.prototype._hasAlphaChannel = function() {
        if (ImageWorkerServer.isWPEBrowser()) {
            // When using unaccelerated rendering image (https://github.com/WebPlatformForEmbedded/WPEWebKit/blob/wpe-20170728/Source/WebCore/html/ImageBitmap.cpp#L52),
            // everything including JPG images are in RGBA format. Upload is way faster when using an alpha channel.
            // @todo: after hardware acceleration is fixed and re-enabled, JPG should be uploaded in RGB to get the best possible performance and memory usage.
            return true;
        } else {
            return (this._mimeType.indexOf("image/png") !== -1);
        }
    };

    ImageWorkerServerItem.prototype.cancel = function() {
        if (this._canceled) return;
        if (this._xhr) {
            this._xhr.abort();
        }
        this._canceled = true;
    };

    ImageWorkerServerItem.prototype.error = function(type, message) {
        if (!this._canceled && this._onError) {
            this._onError({type, message});
        }
    };

    ImageWorkerServerItem.prototype.finish = function(info) {
        if (!this._canceled && this._onFinish) {
            this._onFinish(info);
        }
    };

    var worker = new ImageWorkerServer();
};


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/platforms/browser/WebPlatform.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/platforms/browser/WebPlatform.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebPlatform)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _ImageWorker_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageWorker.mjs */ "./node_modules/@lightningjs/core/src/platforms/browser/ImageWorker.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Platform-specific functionality.
 */
class WebPlatform {

    init(stage) {
        this.stage = stage;
        this._looping = false;
        this._awaitingLoop = false;

        if (this.stage.getOption("useImageWorker")) {
            if (!window.createImageBitmap || !window.Worker) {
                console.warn("[Lightning] Can't use image worker because browser does not have createImageBitmap and Web Worker support");
            } else {
                this._imageWorker = new _ImageWorker_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]();
            }
        }
    }

    destroy() {
        if (this._imageWorker) {
            this._imageWorker.destroy();
        }
        this._removeKeyHandler();
        this._removeClickHandler();
        this._removeHoverHandler();
        this._removeScrollWheelHandler();
    }

    startLoop() {
        this._looping = true;
        if (!this._awaitingLoop) {
            this.loop();
        }
    }

    stopLoop() {
        this._looping = false;
    }

    loop() {
        let self = this;
        let lp = function() {
            self._awaitingLoop = false;
            if (self._looping) {
                self.stage.drawFrame();
                requestAnimationFrame(lp);
                self._awaitingLoop = true;
            }
        }
        requestAnimationFrame(lp);
    }

    uploadGlTexture(gl, textureSource, source, options) {
        if (source instanceof ImageData || source instanceof HTMLImageElement || source instanceof HTMLVideoElement || (window.ImageBitmap && source instanceof ImageBitmap)) {
            // Web-specific data types.
            gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, source);
        } else if (source instanceof HTMLCanvasElement) {
            // Workaround for some browsers (e.g. Tizen) as they do not convert canvas data to texture correctly, sometimes causing artifacts.
            const ctx = source.getContext('2d');
            gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, ctx.getImageData(0, 0, source.width, source.height));
        } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, textureSource.w, textureSource.h, 0, options.format, options.type, source);
        }
    }

    loadSrcTexture({src, hasAlpha}, cb) {
        let cancelCb = undefined;
        let isPng = (src.indexOf(".png") >= 0) || src.substr(0, 21) == 'data:image/png;base64';
        if (this._imageWorker) {
            // WPE-specific image parser.
            const image = this._imageWorker.create(src);
            image.onError = function(err) {
                return cb("Image load error");
            };
            image.onLoad = function({imageBitmap, hasAlphaChannel}) {
                cb(null, {
                    source: imageBitmap,
                    renderInfo: {src: src},
                    hasAlpha: hasAlphaChannel,
                    premultiplyAlpha: true
                });
            };
            cancelCb = function() {
                image.cancel();
            }
        } else {
            let image = new Image();

            // On the PS4 platform setting the `crossOrigin` attribute on
            // images can cause CORS failures.
            if (!(src.substr(0,5) == "data:") && !_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isPS4) {
                // Base64.
                image.crossOrigin = "Anonymous";
            }
            image.onerror = function(err) {
                // Ignore error message when cancelled.
                if (image.src) {
                    return cb("Image load error");
                }
            };
            image.onload = function() {
                cb(null, {
                    source: image,
                    renderInfo: {src: src},
                    hasAlpha: isPng || hasAlpha
                });
            };
            image.src = src;

            cancelCb = function() {
                image.onerror = null;
                image.onload = null;
                image.removeAttribute('src');
            }
        }

        return cancelCb;
    }

    createWebGLContext(w, h) {
        let canvas = this.stage.getOption('canvas') || document.createElement('canvas');

        if (w && h) {
            canvas.width = w;
            canvas.height = h;
        }

        let opts = {
            alpha: true,
            antialias: false,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        };

        let gl = canvas.getContext('webgl', opts) || canvas.getContext('experimental-webgl', opts);
        if (!gl) {
            throw new Error('This browser does not support webGL.');
        }

        return gl;
    }

    createCanvasContext(w, h) {
        let canvas = this.stage.getOption('canvas') || document.createElement('canvas');

        if (w && h) {
            canvas.width = w;
            canvas.height = h;
        }

        let c2d = canvas.getContext('2d');
        if (!c2d) {
            throw new Error('This browser does not support 2d canvas.');
        }

        return c2d;
    }

    getHrTime() {
        return window.performance ? window.performance.now() : (new Date()).getTime();
    }

    getDrawingCanvas() {
        // We can't reuse this canvas because textures may load async.
        return document.createElement('canvas');
    }

    getTextureOptionsForDrawingCanvas(canvas) {
        let options = {};
        options.source = canvas;
        return options;
    }

    nextFrame(changes) {
        /* WebGL blits automatically */
    }

    registerKeydownHandler(keyhandler) {
        this._keydownListener = (e) => {
            keyhandler(e);
        };
        window.addEventListener('keydown', this._keydownListener);
    }

    registerKeyupHandler(keyhandler) {
        this._keyupListener = (e) => {
            keyhandler(e);
        };
        window.addEventListener('keyup', this._keyupListener);
    }

    _removeKeyHandler() {
        if (this._keydownListener) {
            window.removeEventListener('keydown', this._keydownListener);
        }

        if (this._keyupListener) {
            window.removeEventListener('keyup', this._keyupListener);
        }
    }

    registerClickHandler(clickHandler) {
        this._clickListener = e => {
            clickHandler(e);
        };
        window.addEventListener('mousedown', this._clickListener);
    }

    _removeClickHandler() {
        if (this._clickListener) {
            window.removeEventListener('mousedown', this._clickListener);
        }
    }

    registerHoverHandler(hoverHandler) {
        this._hoverListener = e => {
            hoverHandler(e);
        };
        window.addEventListener('mousemove', this._hoverListener);
    }

    _removeHoverHandler() {
        if (this._hoverListener) {
            window.removeEventListener('mousemove', this._hoverListener);
        }
    }

    registerScrollWheelHandler(registerScrollWheelHandler) {
        this._scrollWheelListener = e => {
            registerScrollWheelHandler(e);
        }
        window.addEventListener('wheel', this._scrollWheelListener);
    }

    _removeScrollWheelHandler() {
        if (this._scrollWheelListener) {
            window.removeEventListener('wheel', this._scrollWheelListener);
        }
    }
}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/Renderer.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/Renderer.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Renderer)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Renderer {

    constructor(stage) {
        this.stage = stage;
        this._defaultShader = undefined;
    }

    gc(aggressive) {
    }

    destroy() {
    }

    getDefaultShader(ctx = this.stage.ctx) {
        if (!this._defaultShader) {
            this._defaultShader = this._createDefaultShader(ctx);
        }
        return this._defaultShader;
    }

    _createDefaultShader(ctx) {
    }

    isValidShaderType(shaderType) {
        return (shaderType.prototype instanceof this._getShaderBaseType());
    }

    createShader(ctx, settings) {
        const shaderType = settings.type;
        // If shader type is not correct, use a different platform.
        if (!this.isValidShaderType(shaderType)) {
            const convertedShaderType = this._getShaderAlternative(shaderType);
            if (!convertedShaderType) {
                console.warn("[Lightning] Shader has no implementation for render target: " + shaderType.name);
                return this._createDefaultShader(ctx);
            }
            return new convertedShaderType(ctx);
        } else {
            const shader = new shaderType(ctx);
            _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].patchObject(this, settings);
            return shader;
        }
    }

    _getShaderBaseType() {
    }

    _getShaderAlternative(shaderType) {
        return this.getDefaultShader();
    }

    copyRenderTexture(renderTexture, nativeTexture, options) {
        console.warn('[Lightning] copyRenderTexture not supported by renderer');
    }
}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadList.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadList.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dCoreQuadList)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreQuadList.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class C2dCoreQuadList extends _tree_core_CoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        this.renderContexts = [];
        this.modes = [];
    }

    setRenderContext(index, v) {
        this.renderContexts[index] = v;
    }

    setSimpleTc(index, v) {
        if (v) {
            this.modes[index] |= 1;
        } else {
            this.modes[index] -= (this.modes[index] & 1);
        }
    }

    setWhite(index, v) {
        if (v) {
            this.modes[index] |= 2;
        } else {
            this.modes[index] -= (this.modes[index] & 2);
        }
    }

    getRenderContext(index) {
        return this.renderContexts[index];
    }

    getSimpleTc(index) {
        return (this.modes[index] & 1);
    }

    getWhite(index) {
        return (this.modes[index] & 2);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadOperation.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadOperation.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dCoreQuadOperation)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreQuadOperation.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadOperation.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class C2dCoreQuadOperation extends _tree_core_CoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    getRenderContext(index) {
        return this.quads.getRenderContext(this.index + index);
    }

    getSimpleTc(index) {
        return this.quads.getSimpleTc(this.index + index);
    }

    getWhite(index) {
        return this.quads.getWhite(this.index + index);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreRenderExecutor.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreRenderExecutor.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dCoreRenderExecutor)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreRenderExecutor.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderExecutor.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class C2dCoreRenderExecutor extends _tree_core_CoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    init() {
        this._mainRenderTexture = this.ctx.stage.getCanvas();
    }

    _renderQuadOperation(op) {
        let shader = op.shader;

        if (op.length || op.shader.addEmpty()) {
            const target = this._renderTexture || this._mainRenderTexture;
            shader.beforeDraw(op, target);
            shader.draw(op, target);
            shader.afterDraw(op, target);
        }
    }

    _clearRenderTexture() {
        const ctx = this._getContext();

        let clearColor = [0, 0, 0, 0];
        if (this._mainRenderTexture.ctx === ctx) {
            clearColor = this.ctx.stage.getClearColor();
        }

        const renderTexture = ctx.canvas;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (!clearColor[0] && !clearColor[1] && !clearColor[2] && !clearColor[3]) {
            ctx.clearRect(0, 0, renderTexture.width, renderTexture.height);
        } else {
            ctx.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaStringFromArray(clearColor);
            // Do not use fillRect because it produces artifacts.
            ctx.globalCompositeOperation = 'copy';
            ctx.beginPath();
            ctx.rect(0, 0, renderTexture.width, renderTexture.height);
            ctx.closePath();
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
        }
    }
    
    _getContext() {
        if (this._renderTexture) {
            return this._renderTexture.ctx;
        } else {
            return this._mainRenderTexture.ctx;
        } 
    }

    _restoreContext() {
        const ctx = this._getContext();
        ctx.restore();
        ctx.save();
        ctx._scissor = null;
    }

    _setScissor(area) {
        const ctx = this._getContext();

        if (!C2dCoreRenderExecutor._equalScissorAreas(ctx.canvas, ctx._scissor, area)) {
            // Clipping is stored in the canvas context state.
            // We can't reset clipping alone so we need to restore the full context.
            this._restoreContext();

            let precision = this.ctx.stage.getRenderPrecision();
            if (area) {
                ctx.beginPath();
                ctx.rect(Math.round(area[0] * precision), Math.round(area[1] * precision), Math.round(area[2] * precision), Math.round(area[3] * precision));
                ctx.closePath();
                ctx.clip();
            }
            ctx._scissor = area;
        }
    }

    static _equalScissorAreas(canvas, area, current) {
        if (!area) {
            area = [0, 0, canvas.width, canvas.height]
        }
        if (!current) {
            current = [0, 0, canvas.width, canvas.height]
        }
        return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].equalValues(area, current)
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dRenderer.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dRenderer.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dRenderer)
/* harmony export */ });
/* harmony import */ var _C2dCoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./C2dCoreQuadList.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadList.mjs");
/* harmony import */ var _C2dCoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./C2dCoreQuadOperation.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadOperation.mjs");
/* harmony import */ var _C2dCoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./C2dCoreRenderExecutor.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreRenderExecutor.mjs");
/* harmony import */ var _tree_core_CoreRenderState_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tree/core/CoreRenderState.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderState.mjs");
/* harmony import */ var _shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs");
/* harmony import */ var _C2dShader_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./C2dShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs");
/* harmony import */ var _Renderer_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Renderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/Renderer.mjs");
/* harmony import */ var _C2dTextureTintManager_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./C2dTextureTintManager.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dTextureTintManager.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










class C2dRenderer extends _Renderer_mjs__WEBPACK_IMPORTED_MODULE_6__["default"] {

    constructor(stage) {
        super(stage);

        this.tintManager = new _C2dTextureTintManager_mjs__WEBPACK_IMPORTED_MODULE_7__["default"](stage);

        this.setupC2d(this.stage.c2d.canvas);
    }

    destroy() {
        this.tintManager.destroy();
    }

    _createDefaultShader(ctx) {
        return new _shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](ctx);
    }

    _getShaderBaseType() {
        return _C2dShader_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]
    }

    _getShaderAlternative(shaderType) {
        return shaderType.getC2d && shaderType.getC2d();
    }

    createCoreQuadList(ctx) {
        return new _C2dCoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](ctx);
    }

    createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
        return new _C2dCoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
    }

    createCoreRenderExecutor(ctx) {
        return new _C2dCoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](ctx);
    }
    
    createCoreRenderState(ctx) {
        return new _tree_core_CoreRenderState_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](ctx);
    }

    createRenderTexture(w, h, pw, ph) {
        const canvas = document.createElement('canvas');
        canvas.width = pw;
        canvas.height = ph;
        this.setupC2d(canvas);
        return canvas;
    }
    
    freeRenderTexture(nativeTexture) {
        this.tintManager.delete(nativeTexture);
    }

    gc(aggressive) {
        this.tintManager.gc(aggressive);
    }

    uploadTextureSource(textureSource, options) {
        // For canvas, we do not need to upload.
        if (options.source.buffer) {
            // Convert RGBA buffer to canvas.
            const canvas = document.createElement('canvas');
            canvas.width = options.w;
            canvas.height = options.h;

            const imageData = new ImageData(new Uint8ClampedArray(options.source.buffer), options.w, options.h);
            canvas.getContext('2d').putImageData(imageData, 0, 0);
            return canvas;
        }

        return options.source;
    }

    freeTextureSource(textureSource) {
        this.tintManager.delete(textureSource.nativeTexture);
    }

    addQuad(renderState, quads, index) {
        // Render context changes while traversing so we save it by ref.
        const elementCore = quads.quadElements[index];
        quads.setRenderContext(index, elementCore._renderContext);
        quads.setWhite(index, elementCore.isWhite());
        quads.setSimpleTc(index, elementCore.hasSimpleTexCoords());
    }

    isRenderTextureReusable(renderState, renderTextureInfo) {
        // @todo: check render coords/matrix, maybe move this to core?
        return false;
    }

    finishRenderState(renderState) {
    }

    setupC2d(canvas) {
        const ctx = canvas.getContext('2d');
        canvas.ctx = ctx;

        ctx._scissor = null;

        // Save base state so we can restore the defaults later.
        canvas.ctx.save();
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dShader)
/* harmony export */ });
/* harmony import */ var _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class C2dShader extends _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    beforeDraw(operation) {
    }

    draw(operation) {
    }

    afterDraw(operation) {
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dTextureTintManager.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dTextureTintManager.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dTextureTintManager)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class C2dTextureTintManager {

    constructor(stage) {
        this.stage = stage;
        this._usedMemory = 0;
        this._cachedNativeTextures = new Set();
    }

    destroy() {
        this.gc(true);
    }

    _addMemoryUsage(delta) {
        this._usedMemory += delta;

        this.stage.addMemoryUsage(delta);
    }

    delete(nativeTexture) {
        // Should be called when native texture is cleaned up.
        if (this._hasCache(nativeTexture)) {
            const cache = this._getCache(nativeTexture);
            const prevMemUsage = cache.memoryUsage;
            cache.clear();
            this._cachedNativeTextures.delete(nativeTexture);
            this._addMemoryUsage(cache.memoryUsage - prevMemUsage);
        }
    }

    getTintTexture(nativeTexture, color) {
        const frame = this.stage.frameCounter;

        this._cachedNativeTextures.add(nativeTexture);

        const cache = this._getCache(nativeTexture);

        const item = cache.get(color);
        item.lf = frame;

        if (item.tx) {
            if (nativeTexture.update > item.u) {
                // Native texture was updated in the mean time: renew.
                this._tintTexture(item.tx, nativeTexture, color)
            }

            return item.tx;
        } else {
            const before = cache.memoryUsage;

            // Find blanco tint texture.
            let target = cache.reuseTexture(frame);
            if (target) {
                target.ctx.clearRect(0, 0, target.width, target.height);
            } else {
                // Allocate new.
                target = document.createElement('canvas');
                target.width = nativeTexture.w;
                target.height = nativeTexture.h;
                target.ctx = target.getContext('2d');
            }

            this._tintTexture(target, nativeTexture, color);
            cache.set(color, target, frame);

            const after = cache.memoryUsage;

            if (after !== before) {
                this._addMemoryUsage(after - before);
            }

            return target;
        }
    }

    _tintTexture(target, source, color) {
        let col = color.toString(16);
        while (col.length < 6) {
            col = "0" + col;
        }
        target.ctx.fillStyle = '#' + col;
        target.ctx.globalCompositeOperation = 'copy';
        target.ctx.fillRect(0, 0, source.w, source.h);
        target.ctx.globalCompositeOperation = 'multiply';
        target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);

        // Alpha-mix the texture.
        target.ctx.globalCompositeOperation = 'destination-in';
        target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);
    }

    _hasCache(nativeTexture) {
        return !!nativeTexture._tintCache;
    }

    _getCache(nativeTexture) {
        if (!nativeTexture._tintCache) {
            nativeTexture._tintCache = new C2dTintCache(nativeTexture);
        }
        return nativeTexture._tintCache;
    }

    gc(aggressive = false) {
        const frame = this.stage.frameCounter;
        let delta = 0;
        this._cachedNativeTextures.forEach(texture => {
            const cache = this._getCache(texture);
            if (aggressive) {
                delta += cache.memoryUsage;
                cache.clear();
            } else {
                const before = cache.memoryUsage;
                cache.cleanup(frame);
                cache.releaseBlancoTextures();
                delta += (cache.memoryUsage - before);
            }
        });

        if (aggressive) {
            this._cachedNativeTextures.clear();
        }

        if (delta) {
            this._addMemoryUsage(delta);
        }
    }

}

class C2dTintCache {

    constructor(nativeTexture) {
        this._tx = nativeTexture;
        this._colors = new Map();
        this._blancoTextures = null;
        this._lastCleanupFrame = 0;
        this._memTextures = 0;
    }

    get memoryUsage() {
        return this._memTextures * this._tx.w * this._tx.h;
    }

    releaseBlancoTextures() {
        this._memTextures -= this._blancoTextures.length;
        this._blancoTextures = [];
    }

    clear() {
        // Dereference the textures.
        this._blancoTextures = null;
        this._colors.clear();
        this._memTextures = 0;
    }

    get(color) {
        let item = this._colors.get(color);
        if (!item) {
            item = {lf: -1, tx: undefined, u: -1};
            this._colors.set(color, item);
        }
        return item;
    }

    set(color, texture, frame) {
        const item = this.get(color);
        item.lf = frame;
        item.tx = texture;
        item.u = frame;
        this._memTextures++;
    }

    cleanup(frame) {
        // We only need to clean up once per frame.
        if (this._lastCleanupFrame !== frame) {

            // We limit blanco textures reuse to one frame only to prevent memory usage growth.
            this._blancoTextures = [];

            this._colors.forEach((item, color) => {
                // Clean up entries that were not used last frame.
                if (item.lf < frame - 1) {
                    if (item.tx) {
                        // Keep as reusable blanco texture.
                        this._blancoTextures.push(item.tx);
                    }
                    this._colors.delete(color);
                }
            });

            this._lastCleanupFrame = frame;
        }
    }

    reuseTexture(frame) {
        // Try to reuse textures, because creating them every frame is expensive.
        this.cleanup(frame);
        if (this._blancoTextures && this._blancoTextures.length) {
            this._memTextures--;
            return this._blancoTextures.pop();
        }
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/BlurShader.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/shaders/BlurShader.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BlurShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class BlurShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);
        this._kernelRadius = 1;
    }

    get kernelRadius() {
        return this._kernelRadius;
    }

    set kernelRadius(v) {
        this._kernelRadius = v;
        this.redraw();
    }

    useDefault() {
        return this._amount === 0;
    }

    _beforeDrawEl({target}) {
        target.ctx.filter = "blur(" + this._kernelRadius + "px)";
    }

    _afterDrawEl({target}) {
        target.ctx.filter = "none";
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DefaultShader)
/* harmony export */ });
/* harmony import */ var _C2dShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../C2dShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class DefaultShader extends _C2dShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);
        this._rectangleTexture = ctx.stage.rectangleTexture.source.nativeTexture;
        this._tintManager = this.ctx.stage.renderer.tintManager;
    }

    draw(operation, target) {
        const ctx = target.ctx;
        let length = operation.length;
        for (let i = 0; i < length; i++) {
            const tx = operation.getTexture(i);
            const vc = operation.getElementCore(i);
            const rc = operation.getRenderContext(i);
            const white = operation.getWhite(i);
            const stc = operation.getSimpleTc(i);

            //@todo: try to optimize out per-draw transform setting. split translate, transform.
            const precision = this.ctx.stage.getRenderPrecision();
            ctx.setTransform(rc.ta * precision, rc.tc * precision, rc.tb * precision, rc.td * precision, rc.px * precision, rc.py * precision);

            const rect = (tx === this._rectangleTexture);
            const info = {operation, target, index: i, rect};

            if (rect) {
                // Check for gradient.
                if (white) {
                    ctx.fillStyle = 'white';
                } else {
                    this._setColorGradient(ctx, vc);
                }

                ctx.globalAlpha = rc.alpha;
                this._beforeDrawEl(info);
                ctx.fillRect(0, 0, vc.w, vc.h);
                this._afterDrawEl(info);
                ctx.globalAlpha = 1.0;
            } else {
                // @todo: set image smoothing based on the texture.

                // @todo: optimize by registering whether identity texcoords are used.
                ctx.globalAlpha = rc.alpha;
                this._beforeDrawEl(info);

                // @todo: test if rounding yields better performance.

                // Notice that simple texture coords can be turned on even though vc._ulx etc are not simple, because
                //  we are rendering a render-to-texture (texcoords were stashed). Same is true for 'white' color btw.
                const sourceX = stc ? 0 : (vc._ulx * tx.w);
                const sourceY = stc ? 0 : (vc._uly * tx.h);
                const sourceW = (stc ? 1 : (vc._brx - vc._ulx)) * tx.w;
                const sourceH = (stc ? 1 : (vc._bry - vc._uly)) * tx.h;

                let colorize = !white;
                if (colorize) {
                    // @todo: cache the tint texture for better performance.

                    // Draw to intermediate texture with background color/gradient.
                    // This prevents us from having to create a lot of render texture canvases.

                    // Notice that we don't support (non-rect) gradients, only color tinting for c2d. We'll just take the average color.
                    let color = vc._colorUl;
                    if (vc._colorUl !== vc._colorUr || vc._colorUr !== vc._colorBl || vc._colorBr !== vc._colorBl) {
                        color = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].mergeMultiColorsEqual([vc._colorUl, vc._colorUr, vc._colorBl, vc._colorBr]);
                    }

                    const alpha = ((color / 16777216) | 0) / 255.0;
                    ctx.globalAlpha *= alpha;

                    const rgb = color & 0x00FFFFFF;
                    const tintTexture = this._tintManager.getTintTexture(tx, rgb);

                    // Actually draw result.
                    ctx.fillStyle = 'white';
                    ctx.drawImage(tintTexture, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
                } else {
                    ctx.fillStyle = 'white';
                    ctx.drawImage(tx, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
                }
                this._afterDrawEl(info);
                ctx.globalAlpha = 1.0;
            }
        }
    }

    _setColorGradient(ctx, vc, w = vc.w, h = vc.h, transparency = true) {
        let color = vc._colorUl;
        let gradient;
        //@todo: quick single color check.
        //@todo: cache gradient/fill style (if possible, probably context-specific).

        if (vc._colorUl === vc._colorUr) {
            if (vc._colorBl === vc._colorBr) {
                if (vc._colorUl === vc.colorBl) {
                    // Single color.
                } else {
                    // Vertical gradient.
                    gradient = ctx.createLinearGradient(0, 0, 0, h);
                    if (transparency) {
                        gradient.addColorStop(0, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(vc._colorUl));
                        gradient.addColorStop(1, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(vc._colorBl));
                    } else {
                        gradient.addColorStop(0, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(vc._colorUl));
                        gradient.addColorStop(1, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(vc._colorBl));

                    }
                }
            } else {
                // Not supported gradient.
            }
        } else {
            if (vc._colorUl === vc._colorBl && vc._colorUr === vc._colorBr) {
                // Horizontal gradient.
                gradient = ctx.createLinearGradient(0, 0, w, 0);
                if (transparency) {
                    gradient.addColorStop(0, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(vc._colorUl));
                    gradient.addColorStop(1, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(vc._colorBr));
                } else {
                    gradient.addColorStop(0, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(vc._colorUl));
                    gradient.addColorStop(1, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(vc._colorBr));
                }
            }
        }

        if (gradient) {
            ctx.fillStyle = gradient;
        } else {
            ctx.fillStyle = transparency ? _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(color) : _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(color);
        }
    }

    _beforeDrawEl(info) {
    }

    _afterDrawEl(info) {
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/common/shaders/GrayscaleShader.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/common/shaders/GrayscaleShader.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C2dGrayscaleShader": () => (/* binding */ C2dGrayscaleShader),
/* harmony export */   "WebGLGrayscaleShader": () => (/* binding */ WebGLGrayscaleShader)
/* harmony export */ });
/* harmony import */ var _c2d_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../c2d/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs");
/* harmony import */ var _webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class WebGLGrayscaleShader extends _webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(context) {
        super(context);
        this._amount = 1;
    }

    static getC2d() {
        return C2dGrayscaleShader;
    }


    set amount(v) {
        this._amount = v;
        this.redraw();
    }

    get amount() {
        return this._amount;
    }

    useDefault() {
        return this._amount === 0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("amount", this._amount, this.gl.uniform1f);
    }

}

WebGLGrayscaleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float grayness = 0.2 * color.r + 0.6 * color.g + 0.2 * color.b;
        gl_FragColor = vec4(amount * vec3(grayness, grayness, grayness) + (1.0 - amount) * color.rgb, color.a);
    }
`;

class C2dGrayscaleShader extends _c2d_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);
        this._amount = 1;
    }

    static getWebGL() {
        return WebGLGrayscaleShader;
    }


    set amount(v) {
        this._amount = v;
        this.redraw();
    }

    get amount() {
        return this._amount;
    }

    useDefault() {
        return this._amount === 0;
    }

    _beforeDrawEl({target}) {
        target.ctx.filter = "grayscale(" + this._amount + ")";
    }

    _afterDrawEl({target}) {
        target.ctx.filter = "none";
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/spark/SparkRenderer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/spark/SparkRenderer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SparkRenderer)
/* harmony export */ });
/* harmony import */ var _webgl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/WebGLRenderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLRenderer.mjs");
/* harmony import */ var _shaders_SparkShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/SparkShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/spark/shaders/SparkShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class SparkRenderer extends _webgl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);
    }

    _createDefaultShader(ctx) {
        return new _shaders_SparkShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](ctx);
    }

    createCoreRenderExecutor(ctx) {
        global.beginDrawing();
        let ret = super.createCoreRenderExecutor(ctx);
        global.endDrawing();
        return ret;
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/spark/shaders/SparkShader.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/spark/shaders/SparkShader.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SparkShader)
/* harmony export */ });
/* harmony import */ var _webgl_WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../webgl/WebGLShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class SparkShader extends _webgl_WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    enableAttribs() {
        // Enables the attribs in the shader program.
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
        gl.enableVertexAttribArray(this._attrib("aVertexPosition"));

        if (this._attrib("aTextureCoord") !== -1) {
            gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
            gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
        }

        if (this._attrib("aColor") !== -1) {
            // Some shaders may ignore the color.
            gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
            gl.enableVertexAttribArray(this._attrib("aColor"));
        }
    }

    disableAttribs() {
        // Disables the attribs in the shader program.
        let gl = this.gl;
        gl.disableVertexAttribArray(this._attrib("aVertexPosition"));

        if (this._attrib("aTextureCoord") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
        }

        if (this._attrib("aColor") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aColor"));
        }
    }

    setupUniforms(operation) {
        this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
    }

    draw(operation) {
        let gl = this.gl;

        let length = operation.length;

        if (length) {
            let glTexture = operation.getTexture(0);
            let pos = 0;
            for (let i = 0; i < length; i++) {
                let tx = operation.getTexture(i);
                if (glTexture !== tx) {
                    if (glTexture.options && glTexture.options.imageRef) {
                        let elementPostion = (i > 0) ? (i - 1) : i;
                        const precision = this.ctx.stage.getOption('precision');
                        let vc = operation.getElementCore(elementPostion);
                        this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, vc._worldContext.px*precision, vc._worldContext.py*precision, vc._colorUl, vc);
                    } else {
                        gl.bindTexture(gl.TEXTURE_2D, glTexture);
                        gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                    }
                    glTexture = tx;
                    pos = i;
                }
            }
            if (pos < length) {
                if (glTexture.options && glTexture.options.imageRef) {
                    const precision = this.ctx.stage.getOption('precision');
                    let vc = operation.getElementCore(pos);
                    this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, vc._worldContext.px*precision, vc._worldContext.py*precision, vc._colorUl, vc);
                } else {
                    gl.bindTexture(gl.TEXTURE_2D, glTexture);
                    gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                }
            }
        }
    }

}

SparkShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

SparkShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadList.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadList.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLCoreQuadList)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreQuadList.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class WebGLCoreQuadList extends _tree_core_CoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        // Allocate a fairly big chunk of memory that should be enough to support ~100000 (default) quads.
        // We do not (want to) handle memory overflow.
        const byteSize = ctx.stage.getOption('bufferMemory');

        this.dataLength = 0;

        this.data = new ArrayBuffer(byteSize);
        this.floats = new Float32Array(this.data);
        this.uints = new Uint32Array(this.data);
    }

    getAttribsDataByteOffset(index) {
        // Where this quad can be found in the attribs buffer.
        return index * 80;
    }

    getQuadContents() {
        // Debug: log contents of quad buffer.
        let floats = this.floats;
        let uints = this.uints;
        let lines = [];
        for (let i = 1; i <= this.length; i++) {
            let str = 'entry ' + i + ': ';
            for (let j = 0; j < 4; j++) {
                let b = i * 20 + j * 4;
                str += floats[b] + ',' + floats[b+1] + ':' + floats[b+2] + ',' + floats[b+3] + '[' + uints[b+4].toString(16) + '] ';
            }
            lines.push(str);
        }

        return lines;
    }


}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadOperation.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadOperation.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLCoreQuadOperation)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreQuadOperation.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadOperation.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class WebGLCoreQuadOperation extends _tree_core_CoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
        super(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);

        this.extraAttribsDataByteOffset = 0;
    }

    getAttribsDataByteOffset(index) {
        // Where this quad can be found in the attribs buffer.
        return this.quads.getAttribsDataByteOffset(this.index + index);
    }

    /**
     * Returns the relative pixel coordinates in the shader owner to gl position coordinates in the render texture.
     * @param x
     * @param y
     * @return {number[]}
     */
    getNormalRenderTextureCoords(x, y) {
        let coords = this.shaderOwner.getRenderTextureCoords(x, y);
        coords[0] /= this.getRenderWidth();
        coords[1] /= this.getRenderHeight();
        coords[0] = coords[0] * 2 - 1;
        coords[1] = 1 - coords[1] * 2;
        return coords;
    }

    getProjection() {
        if (this.renderTextureInfo === null) {
            return this.ctx.renderExec._projection;
        } else {
            return this.renderTextureInfo.nativeTexture.projection;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreRenderExecutor.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreRenderExecutor.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLCoreRenderExecutor)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreRenderExecutor.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderExecutor.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class WebGLCoreRenderExecutor extends _tree_core_CoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx)

        this.gl = this.ctx.stage.gl;

        this.init();
    }

    init() {
        let gl = this.gl;

        // Create new sharable buffer for params.
        this._attribsBuffer = gl.createBuffer();

        let maxQuads = Math.floor(this.renderState.quads.data.byteLength / 80);

        // Init webgl arrays.
        let allIndices = new Uint16Array(maxQuads * 6);

        // fill the indices with the quads to draw.
        for (let i = 0, j = 0; i < maxQuads; i += 6, j += 4) {
            allIndices[i] = j;
            allIndices[i + 1] = j + 1;
            allIndices[i + 2] = j + 2;
            allIndices[i + 3] = j;
            allIndices[i + 4] = j + 2;
            allIndices[i + 5] = j + 3;
        }

        // The quads buffer can be (re)used to draw a range of quads.
        this._quadsBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, allIndices, gl.STATIC_DRAW);

        // The matrix that causes the [0,0 - W,H] box to map to [-1,-1 - 1,1] in the end results.
        this._projection = new Float32Array([2/this.ctx.stage.coordsWidth, -2/this.ctx.stage.coordsHeight]);

    }

    destroy() {
        super.destroy();
        this.gl.deleteBuffer(this._attribsBuffer);
        this.gl.deleteBuffer(this._quadsBuffer);
    }

    _reset() {
        super._reset();

        let gl = this.gl;
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        this._stopShaderProgram();
        this._setupBuffers();
    }

    _setupBuffers() {
        let gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
        let element = new Float32Array(this.renderState.quads.data, 0, this.renderState.quads.dataLength);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._attribsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, element, gl.DYNAMIC_DRAW);
    }

    _setupQuadOperation(quadOperation) {
        super._setupQuadOperation(quadOperation);
        this._useShaderProgram(quadOperation.shader, quadOperation);
    }

    _renderQuadOperation(op) {
        let shader = op.shader;

        if (op.length || op.shader.addEmpty()) {
            shader.beforeDraw(op);
            shader.draw(op);
            shader.afterDraw(op);
        }
    }

    /**
     * @param {WebGLShader} shader;
     * @param {CoreQuadOperation} operation;
     */
    _useShaderProgram(shader, operation) {
        if (!shader.hasSameProgram(this._currentShaderProgram)) {
            if (this._currentShaderProgram) {
                this._currentShaderProgram.stopProgram();
            }
            shader.useProgram();
            this._currentShaderProgram = shader;
        }
        shader.setupUniforms(operation);
    }

    _stopShaderProgram() {
        if (this._currentShaderProgram) {
            // The currently used shader program should be stopped gracefully.
            this._currentShaderProgram.stopProgram();
            this._currentShaderProgram = null;
        }
    }

    _bindRenderTexture(renderTexture) {
        super._bindRenderTexture(renderTexture);

        let gl = this.gl;
        if (!this._renderTexture) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0,0,this.ctx.stage.w,this.ctx.stage.h);
        } else {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._renderTexture.framebuffer);
            gl.viewport(0,0,this._renderTexture.w, this._renderTexture.h);
        }
    }

    _clearRenderTexture() {
        super._clearRenderTexture();
        let gl = this.gl;
        if (!this._renderTexture) {
            let glClearColor = this.ctx.stage.getClearColor();
            if (glClearColor) {
                gl.clearColor(glClearColor[0] * glClearColor[3], glClearColor[1] * glClearColor[3], glClearColor[2] * glClearColor[3], glClearColor[3]);
                gl.clear(gl.COLOR_BUFFER_BIT);
            }
        } else {
            // Clear texture.
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
    }

    _setScissor(area) {
        super._setScissor(area);

        if (this._scissor === area) {
            return;
        }
        this._scissor = area;

        let gl = this.gl;
        if (!area) {
            gl.disable(gl.SCISSOR_TEST);
        } else {
            gl.enable(gl.SCISSOR_TEST);
            let precision = this.ctx.stage.getRenderPrecision();
            let y = area[1];
            if (this._renderTexture === null) {
                // Flip.
                y = (this.ctx.stage.h / precision - (area[1] + area[3]));
            }
            gl.scissor(Math.round(area[0] * precision), Math.round(y * precision), Math.round(area[2] * precision), Math.round(area[3] * precision));
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLRenderer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLRenderer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLRenderer)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _WebGLCoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebGLCoreQuadList.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadList.mjs");
/* harmony import */ var _WebGLCoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WebGLCoreQuadOperation.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadOperation.mjs");
/* harmony import */ var _WebGLCoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WebGLCoreRenderExecutor.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreRenderExecutor.mjs");
/* harmony import */ var _tree_core_CoreRenderState_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../tree/core/CoreRenderState.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderState.mjs");
/* harmony import */ var _shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WebGLShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs");
/* harmony import */ var _Renderer_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Renderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/Renderer.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











class WebGLRenderer extends _Renderer_mjs__WEBPACK_IMPORTED_MODULE_8__["default"] {

    constructor(stage) {
        super(stage);
        this.shaderPrograms = new Map();
    }

    destroy() {
        this.shaderPrograms.forEach(shaderProgram => shaderProgram.destroy());
    }

    _createDefaultShader(ctx) {
        return new _shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_6__["default"](ctx);
    }

    _getShaderBaseType() {
        return _WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]
    }

    _getShaderAlternative(shaderType) {
        return shaderType.getWebGL && shaderType.getWebGL();
    }

    createCoreQuadList(ctx) {
        return new _WebGLCoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](ctx);
    }

    createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
        return new _WebGLCoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
    }

    createCoreRenderExecutor(ctx) {
        return new _WebGLCoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](ctx);
    }
    
    createCoreRenderState(ctx) {
        return new _tree_core_CoreRenderState_mjs__WEBPACK_IMPORTED_MODULE_5__["default"](ctx);
    }

    createRenderTexture(w, h, pw, ph) {
        const gl = this.stage.gl;
        const glTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, glTexture);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pw, ph, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        glTexture.params = {};
        glTexture.params[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
        glTexture.params[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
        glTexture.params[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
        glTexture.params[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;
        glTexture.options = {format: gl.RGBA, internalFormat: gl.RGBA, type: gl.UNSIGNED_BYTE};

        // We need a specific framebuffer for every render texture.
        glTexture.framebuffer = gl.createFramebuffer();
        glTexture.projection = new Float32Array([2/w, 2/h]);

        gl.bindFramebuffer(gl.FRAMEBUFFER, glTexture.framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture, 0);

        return glTexture;
    }
    
    freeRenderTexture(glTexture) {
        let gl = this.stage.gl;
        gl.deleteFramebuffer(glTexture.framebuffer);
        gl.deleteTexture(glTexture);
    }

    uploadTextureSource(textureSource, options) {
        const gl = this.stage.gl;

        const source = options.source;

        const format = {
            premultiplyAlpha: true,
            hasAlpha: true
        };

        if (options && options.hasOwnProperty('premultiplyAlpha')) {
            format.premultiplyAlpha = options.premultiplyAlpha;
        }

        if (options && options.hasOwnProperty('flipBlueRed')) {
            format.flipBlueRed = options.flipBlueRed;
        }

        if (options && options.hasOwnProperty('hasAlpha')) {
            format.hasAlpha = options.hasAlpha;
        }

        if (!format.hasAlpha) {
            format.premultiplyAlpha = false;
        }

        format.texParams = options.texParams || {}
        format.texOptions = options.texOptions || {}

        let glTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, glTexture);

        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, format.premultiplyAlpha);

        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNode) {
            gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, !!format.flipBlueRed);
        }

        const texParams = format.texParams;
        if (!texParams[gl.TEXTURE_MAG_FILTER]) texParams[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
        if (!texParams[gl.TEXTURE_MIN_FILTER]) texParams[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
        if (!texParams[gl.TEXTURE_WRAP_S]) texParams[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
        if (!texParams[gl.TEXTURE_WRAP_T]) texParams[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;

        Object.keys(texParams).forEach(key => {
            const value = texParams[key];
            gl.texParameteri(gl.TEXTURE_2D, parseInt(key), value);
        });

        const texOptions = format.texOptions;
        texOptions.format = texOptions.format || (format.hasAlpha ? gl.RGBA : gl.RGB);
        texOptions.type = texOptions.type || gl.UNSIGNED_BYTE;
        texOptions.internalFormat = texOptions.internalFormat || texOptions.format;
        if (options && options.imageRef) {
            texOptions.imageRef = options.imageRef;
        }

        this.stage.platform.uploadGlTexture(gl, textureSource, source, texOptions);

        glTexture.params = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cloneObjShallow(texParams);
        glTexture.options = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cloneObjShallow(texOptions);

        return glTexture;
    }

    freeTextureSource(textureSource) {
        this.stage.gl.deleteTexture(textureSource.nativeTexture);
    }

    addQuad(renderState, quads, index) {
        let offset = (index * 20);
        const elementCore = quads.quadElements[index];

        let r = elementCore._renderContext;

        let floats = renderState.quads.floats;
        let uints = renderState.quads.uints;
        const mca = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].mergeColorAlpha;

        if (r.tb !== 0 || r.tc !== 0) {
            floats[offset++] = r.px;
            floats[offset++] = r.py;
            floats[offset++] = elementCore._ulx;
            floats[offset++] = elementCore._uly;
            uints[offset++] = mca(elementCore._colorUl, r.alpha);
            floats[offset++] = r.px + elementCore._w * r.ta;
            floats[offset++] = r.py + elementCore._w * r.tc;
            floats[offset++] = elementCore._brx;
            floats[offset++] = elementCore._uly;
            uints[offset++] = mca(elementCore._colorUr, r.alpha);
            floats[offset++] = r.px + elementCore._w * r.ta + elementCore._h * r.tb;
            floats[offset++] = r.py + elementCore._w * r.tc + elementCore._h * r.td;
            floats[offset++] = elementCore._brx;
            floats[offset++] = elementCore._bry;
            uints[offset++] = mca(elementCore._colorBr, r.alpha);
            floats[offset++] = r.px + elementCore._h * r.tb;
            floats[offset++] = r.py + elementCore._h * r.td;
            floats[offset++] = elementCore._ulx;
            floats[offset++] = elementCore._bry;
            uints[offset] = mca(elementCore._colorBl, r.alpha);
        } else {
            // Simple.
            let cx = r.px + elementCore._w * r.ta;
            let cy = r.py + elementCore._h * r.td;

            floats[offset++] = r.px;
            floats[offset++] = r.py;
            floats[offset++] = elementCore._ulx;
            floats[offset++] = elementCore._uly;
            uints[offset++] = mca(elementCore._colorUl, r.alpha);
            floats[offset++] = cx;
            floats[offset++] = r.py;
            floats[offset++] = elementCore._brx;
            floats[offset++] = elementCore._uly;
            uints[offset++] = mca(elementCore._colorUr, r.alpha);
            floats[offset++] = cx;
            floats[offset++] = cy;
            floats[offset++] = elementCore._brx;
            floats[offset++] = elementCore._bry;
            uints[offset++] = mca(elementCore._colorBr, r.alpha);
            floats[offset++] = r.px;
            floats[offset++] = cy;
            floats[offset++] = elementCore._ulx;
            floats[offset++] = elementCore._bry;
            uints[offset] = mca(elementCore._colorBl, r.alpha);
        }
    }

    isRenderTextureReusable(renderState, renderTextureInfo) {
        let offset = (renderState._renderTextureInfo.offset * 80) / 4;
        let floats = renderState.quads.floats;
        let uints = renderState.quads.uints;
        return ((floats[offset] === 0) &&
            (floats[offset + 1] === 0) &&
            (floats[offset + 2] === 0) &&
            (floats[offset + 3] === 0) &&
            (uints[offset + 4] === 0xFFFFFFFF) &&
            (floats[offset + 5] === renderTextureInfo.w) &&
            (floats[offset + 6] === 0) &&
            (floats[offset + 7] === 1) &&
            (floats[offset + 8] === 0) &&
            (uints[offset + 9] === 0xFFFFFFFF) &&
            (floats[offset + 10] === renderTextureInfo.w) &&
            (floats[offset + 11] === renderTextureInfo.h) &&
            (floats[offset + 12] === 1) &&
            (floats[offset + 13] === 1) &&
            (uints[offset + 14] === 0xFFFFFFFF) &&
            (floats[offset + 15] === 0) &&
            (floats[offset + 16] === renderTextureInfo.h) &&
            (floats[offset + 17] === 0) &&
            (floats[offset + 18] === 1) &&
            (uints[offset + 19] === 0xFFFFFFFF));
    }

    finishRenderState(renderState) {
        // Set extra shader attribute data.
        let offset = renderState.length * 80;
        for (let i = 0, n = renderState.quadOperations.length; i < n; i++) {
            renderState.quadOperations[i].extraAttribsDataByteOffset = offset;
            let extra = renderState.quadOperations[i].shader.getExtraAttribBytesPerVertex() * 4 * renderState.quadOperations[i].length;
            offset += extra;
            if (extra) {
                renderState.quadOperations[i].shader.setExtraAttribsInBuffer(renderState.quadOperations[i], renderState.quads);
            }
        }
        renderState.quads.dataLength = offset;
    }

    copyRenderTexture(renderTexture, nativeTexture, options) {
        const gl = this.stage.gl;
        gl.bindTexture(gl.TEXTURE_2D, nativeTexture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture.framebuffer);
        const precision = renderTexture.precision;
        gl.copyTexSubImage2D(
            gl.TEXTURE_2D,
            0,
            precision * (options.sx || 0),
            precision * (options.sy || 0),
            precision * (options.x || 0),
            precision * (options.y || 0),
            precision * (options.w || renderTexture.ow),
            precision * (options.h || renderTexture.oh));
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLShader)
/* harmony export */ });
/* harmony import */ var _WebGLShaderProgram_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLShaderProgram.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShaderProgram.mjs");
/* harmony import */ var _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tree/Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class WebGLShader extends _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(ctx) {
        super(ctx);

        const stage = ctx.stage;

        this._program = stage.renderer.shaderPrograms.get(this.constructor);
        if (!this._program) {
            this._program = new _WebGLShaderProgram_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this.constructor.vertexShaderSource, this.constructor.fragmentShaderSource);

            // Let the vbo context perform garbage collection.
            stage.renderer.shaderPrograms.set(this.constructor, this._program);
        }

        this.gl = stage.gl;
    }

    get glProgram() {
        return this._program.glProgram;
    }

    _init() {
        if (!this._initialized) {
            this.initialize();
            this._initialized = true;
        }
    }

    initialize() {
        this._program.compile(this.gl);
    }

    get initialized() {
        return this._initialized;
    }

    _uniform(name) {
        return this._program.getUniformLocation(name);
    }

    _attrib(name) {
        return this._program.getAttribLocation(name);
    }

    _setUniform(name, value, glFunction) {
        this._program.setUniformValue(name, value, glFunction);
    }

    useProgram() {
        this._init();
        this.gl.useProgram(this.glProgram);
        this.beforeUsage();
        this.enableAttribs();
    }

    stopProgram() {
        this.afterUsage();
        this.disableAttribs();
    }

    hasSameProgram(other) {
        // For performance reasons, we first check for identical references.
        return (other && ((other === this) || (other._program === this._program)));
    }

    beforeUsage() {
        // Override to set settings other than the default settings (blend mode etc).
    }

    afterUsage() {
        // All settings changed in beforeUsage should be reset here.
    }

    enableAttribs() {

    }

    disableAttribs() {

    }

    getExtraAttribBytesPerVertex() {
        return 0;
    }

    getVertexAttribPointerOffset(operation) {
        return operation.extraAttribsDataByteOffset - operation.index * 4 * this.getExtraAttribBytesPerVertex();
    }

    setExtraAttribsInBuffer(operation) {
        // Set extra attrib data in in operation.quads.data/floats/uints, starting from
        // operation.extraAttribsBufferByteOffset.
    }

    setupUniforms(operation) {
        // Set all shader-specific uniforms.
        // Notice that all uniforms should be set, even if they have not been changed within this shader instance.
        // The uniforms are shared by all shaders that have the same type (and shader program).
    }

    _getProjection(operation) {
        return operation.getProjection();
    }

    getFlipY(operation) {
        return this._getProjection(operation)[1] < 0;
    }

    beforeDraw(operation) {
    }

    draw(operation) {
    }

    afterDraw(operation) {
    }

    cleanup() {
        this._initialized = false;
        // Program takes little resources, so it is only destroyed when the full stage is destroyed.
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShaderProgram.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShaderProgram.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLShaderProgram)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Base functionality for shader setup/destroy.
 */
class WebGLShaderProgram {

    constructor(vertexShaderSource, fragmentShaderSource) {

        this.vertexShaderSource = vertexShaderSource;
        this.fragmentShaderSource = fragmentShaderSource;

        this._program = null;

        this._uniformLocations = new Map();
        this._attributeLocations = new Map();

        this._currentUniformValues = {};
    }

    compile(gl) {
        if (this._program) return;

        this.gl = gl;

        this._program = gl.createProgram();

        let glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexShaderSource);
        let glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentShaderSource);

        gl.attachShader(this._program, glVertShader);
        gl.attachShader(this._program, glFragShader);
        gl.linkProgram(this._program);

        // if linking fails, then log and cleanup
        if (!gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
            console.error('[Lightning] Error: Could not initialize shader.');
            console.error('[Lightning] gl.VALIDATE_STATUS', gl.getProgramParameter(this._program, gl.VALIDATE_STATUS));
            console.error('[Lightning] gl.getError()', gl.getError());

            // if there is a program info log, log it
            if (gl.getProgramInfoLog(this._program) !== '') {
                console.warn('[Lightning] Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(this._program));
            }

            gl.deleteProgram(this._program);
            this._program = null;
        }

        // clean up some shaders
        gl.deleteShader(glVertShader);
        gl.deleteShader(glFragShader);
    }

    _glCompile(type, src) {
        let shader = this.gl.createShader(type);

        this.gl.shaderSource(shader, src);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('[Lightning]', this.constructor.name, 'Type: ' + (type === this.gl.VERTEX_SHADER ? 'vertex shader' : 'fragment shader') );
            console.error('[Lightning]', this.gl.getShaderInfoLog(shader));
            let idx = 0;
            console.error('[Lightning]', "========== source ==========\n" + src.split("\n").map(line => "" + (++idx) + ": " + line).join("\n"));
            return null;
        }

        return shader;
    }

    getUniformLocation(name) {
        let location = this._uniformLocations.get(name);
        if (location === undefined) {
            location = this.gl.getUniformLocation(this._program, name);
            this._uniformLocations.set(name, location);
        }

        return location;
    }

    getAttribLocation(name) {
        let location = this._attributeLocations.get(name);
        if (location === undefined) {
            location = this.gl.getAttribLocation(this._program, name);
            this._attributeLocations.set(name, location);
        }

        return location;
    }

    destroy() {
        if (this._program) {
            this.gl.deleteProgram(this._program);
            this._program = null;
        }
    }

    get glProgram() {
        return this._program;
    }

    get compiled() {
        return !!this._program;
    }

    _valueEquals(v1, v2) {
        // Uniform value is either a typed array or a numeric value.
        if (v1.length && v2.length) {
            for (let i = 0, n = v1.length; i < n; i++) {
                if (v1[i] !== v2[i]) return false;
            }
            return true;
        } else {
            return (v1 === v2);
        }
    }

    _valueClone(v) {
        if (v.length) {
            return v.slice(0);
        } else {
            return v;
        }
    }

    setUniformValue(name, value, glFunction) {
        let v = this._currentUniformValues[name];
        if (v === undefined || !this._valueEquals(v, value)) {
            let clonedValue = this._valueClone(value);
            this._currentUniformValues[name] = clonedValue;

            let loc = this.getUniformLocation(name);
            if (loc) {
                let isMatrix = (glFunction === this.gl.uniformMatrix2fv || glFunction === this.gl.uniformMatrix3fv || glFunction === this.gl.uniformMatrix4fv);
                if (isMatrix) {
                    glFunction.call(this.gl, loc, false, clonedValue);
                } else {
                    glFunction.call(this.gl, loc, clonedValue);
                }
            }
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BoxBlurShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * 4x4 box blur shader which works in conjunction with a 50% rescale.
 */
class BoxBlurShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const dx = 1.0 / operation.getTextureWidth(0);
        const dy = 1.0 / operation.getTextureHeight(0);
        this._setUniform("stepTextureCoord", new Float32Array([dx, dy]), this.gl.uniform2fv);
    }

}

BoxBlurShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 stepTextureCoord;
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec4 vColor;
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoordUl = aTextureCoord - stepTextureCoord;
        vTextureCoordBr = aTextureCoord + stepTextureCoord;
        vTextureCoordUr = vec2(vTextureCoordBr.x, vTextureCoordUl.y);
        vTextureCoordBl = vec2(vTextureCoordUl.x, vTextureCoordBr.y);
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

BoxBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = 0.25 * (texture2D(uSampler, vTextureCoordUl) + texture2D(uSampler, vTextureCoordUr) + texture2D(uSampler, vTextureCoordBl) + texture2D(uSampler, vTextureCoordBr));
        gl_FragColor = color * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/CircularPushShader.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/CircularPushShader.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CircularPushShader)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class CircularPushShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(ctx) {
        super(ctx);

        this._inputValue = 0;

        this._maxDerivative = 0.01;

        this._normalizedValue = 0;

        // The offset between buckets. A value between 0 and 1.
        this._offset = 0;

        this._amount = 0.1;

        this._aspectRatio = 1;

        this._offsetX = 0;

        this._offsetY = 0;

        this.buckets = 100;
    }

    get aspectRatio() {
        return this._aspectRatio;
    }

    set aspectRatio(v) {
        this._aspectRatio = v;
        this.redraw();
    }

    get offsetX() {
        return this._offsetX;
    }

    set offsetX(v) {
        this._offsetX = v;
        this.redraw();
    }

    get offsetY() {
        return this._offsetY;
    }

    set offsetY(v) {
        this._offsetY = v;
        this.redraw();
    }

    set amount(v) {
        this._amount = v;
        this.redraw();
    }

    get amount() {
        return this._amount;
    }

    set inputValue(v) {
        this._inputValue = v;
    }

    get inputValue() {
        return this._inputValue;
    }

    set maxDerivative(v) {
        this._maxDerivative = v;
    }

    get maxDerivative() {
        return this._maxDerivative;
    }

    set buckets(v) {
        if (v > 100) {
            console.warn("[Lightning] CircularPushShader: supports max 100 buckets");
            v = 100;
        }

        // This should be set before starting.
        this._buckets = v;

        // Init values array in the correct length.
        this._values = new Uint8Array(this._getValues(v));

        this.redraw();
    }

    get buckets() {
        return this._buckets;
    }

    _getValues(n) {
        const v = [];
        for (let i = 0; i < n; i++) {
            v.push(this._inputValue);
        }
        return v;
    }

    /**
     * Progresses the shader with the specified (fractional) number of buckets.
     * @param {number} o;
     *   A number from 0 to 1 (1 = all buckets).
     */
    progress(o) {
        this._offset += o * this._buckets;
        const full = Math.floor(this._offset);
        this._offset -= full;
        this._shiftBuckets(full);
        this.redraw();
    }

    _shiftBuckets(n) {
        for (let i = this._buckets - 1; i >= 0; i--) {
            const targetIndex = i - n;
            if (targetIndex < 0) {
                this._normalizedValue = Math.min(this._normalizedValue + this._maxDerivative, Math.max(this._normalizedValue - this._maxDerivative, this._inputValue));
                this._values[i] = 255 * this._normalizedValue;
            } else {
                this._values[i] = this._values[targetIndex];
            }
        }
    }

    set offset(v) {
        this._offset = v;
        this.redraw();
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("aspectRatio", this._aspectRatio, this.gl.uniform1f);
        this._setUniform("offsetX", this._offsetX, this.gl.uniform1f);
        this._setUniform("offsetY", this._offsetY, this.gl.uniform1f);
        this._setUniform("amount", this._amount, this.gl.uniform1f);
        this._setUniform("offset", this._offset, this.gl.uniform1f);
        this._setUniform("buckets", this._buckets, this.gl.uniform1f);
        this._setUniform("uValueSampler", 1, this.gl.uniform1i);
    }

    useDefault() {
        return this._amount === 0;
    }

    beforeDraw(operation) {
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE1);
        if (!this._valuesTexture) {
            this._valuesTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNode) {
                gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, false);
            }
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
        }

        // Upload new values.
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this._buckets, 1, 0, gl.ALPHA, gl.UNSIGNED_BYTE, this._values);
        gl.activeTexture(gl.TEXTURE0);
    }

    cleanup() {
        if (this._valuesTexture) {
            this.gl.deleteTexture(this._valuesTexture);
        }
    }


}

CircularPushShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    uniform float offsetX;
    uniform float offsetY;
    uniform float aspectRatio;
    varying vec2 vTextureCoord;
    varying vec2 vPos;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vPos = vTextureCoord * 2.0 - 1.0;
        vPos.y = vPos.y * aspectRatio;
        vPos.y = vPos.y + offsetY;
        vPos.x = vPos.x + offsetX;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

CircularPushShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vPos;
    uniform float amount;
    uniform float offset;
    uniform float values[100];
    uniform float buckets;
    uniform sampler2D uSampler;
    uniform sampler2D uValueSampler;
    void main(void){
        float l = length(vPos);
        float m = (l * buckets * 0.678 - offset) / buckets;
        float f = texture2D(uValueSampler, vec2(m, 0.0)).a * amount;
        vec2 unit = vPos / l;
        gl_FragColor = texture2D(uSampler, vTextureCoord - f * unit) * vColor;
    }
`;




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DefaultShader)
/* harmony export */ });
/* harmony import */ var _WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../WebGLShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class DefaultShader extends _WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    enableAttribs() {
        // Enables the attribs in the shader program.
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
        gl.enableVertexAttribArray(this._attrib("aVertexPosition"));

        if (this._attrib("aTextureCoord") !== -1) {
            gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
            gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
        }

        if (this._attrib("aColor") !== -1) {
            // Some shaders may ignore the color.
            gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
            gl.enableVertexAttribArray(this._attrib("aColor"));
        }
    }

    disableAttribs() {
        // Disables the attribs in the shader program.
        let gl = this.gl;
        gl.disableVertexAttribArray(this._attrib("aVertexPosition"));

        if (this._attrib("aTextureCoord") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
        }

        if (this._attrib("aColor") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aColor"));
        }
    }

    setupUniforms(operation) {
        this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
    }

    draw(operation) {
        let gl = this.gl;

        let length = operation.length;

        if (length) {
            let glTexture = operation.getTexture(0);
            let pos = 0;
            for (let i = 0; i < length; i++) {
                let tx = operation.getTexture(i);
                if (glTexture !== tx) {
                    gl.bindTexture(gl.TEXTURE_2D, glTexture);
                    gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                    glTexture = tx;
                    pos = i;
                }
            }
            if (pos < length) {
                gl.bindTexture(gl.TEXTURE_2D, glTexture);
                gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
            }
        }
    }

}

DefaultShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

DefaultShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DitheringShader.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DitheringShader.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DitheringShader)
/* harmony export */ });
/* harmony import */ var _textures_NoiseTexture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../textures/NoiseTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/NoiseTexture.mjs");
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * This shader can be used to fix a problem that is known as 'gradient banding'.
 */
class DitheringShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(ctx) {
        super(ctx);

        this._noiseTexture = new _textures_NoiseTexture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](ctx.stage);

        this._graining = 1/256;

        this._random = false;
    }

    set graining(v) {
        this._graining = v;
        this.redraw();
    }

    set random(v) {
        this._random = v;
        this.redraw();
    }

    setExtraAttribsInBuffer(operation) {
        // Make sure that the noise texture is uploaded to the GPU.
        this._noiseTexture.load();

        let offset = operation.extraAttribsDataByteOffset / 4;
        let floats = operation.quads.floats;

        let length = operation.length;

        for (let i = 0; i < length; i++) {

            // Calculate noise texture coordinates so that it spans the full element.
            let brx = operation.getElementWidth(i) / this._noiseTexture.getRenderWidth();
            let bry = operation.getElementHeight(i) / this._noiseTexture.getRenderHeight();

            let ulx = 0;
            let uly = 0;
            if (this._random) {
                ulx = Math.random();
                uly = Math.random();

                brx += ulx;
                bry += uly;

                if (Math.random() < 0.5) {
                    // Flip for more randomness.
                    const t = ulx;
                    ulx = brx;
                    brx = t;
                }

                if (Math.random() < 0.5) {
                    // Flip for more randomness.
                    const t = uly;
                    uly = bry;
                    bry = t;
                }
            }

            // Specify all corner points.
            floats[offset] = ulx;
            floats[offset + 1] = uly;

            floats[offset + 2] = brx;
            floats[offset + 3] = uly;

            floats[offset + 4] = brx;
            floats[offset + 5] = bry;

            floats[offset + 6] = ulx;
            floats[offset + 7] = bry;

            offset += 8;
        }
    }

    beforeDraw(operation) {
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aNoiseTextureCoord"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));

        let glTexture = this._noiseTexture.source.nativeTexture;
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.activeTexture(gl.TEXTURE0);
    }

    getExtraAttribBytesPerVertex() {
        return 8;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("uNoiseSampler", 1, this.gl.uniform1i);
        this._setUniform("graining", 2 * this._graining, this.gl.uniform1f);
    }

    enableAttribs() {
        super.enableAttribs();
        let gl = this.gl;
        gl.enableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
    }

    disableAttribs() {
        super.disableAttribs();
        let gl = this.gl;
        gl.disableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
    }

    useDefault() {
        return this._graining === 0;
    }

    afterDraw(operation) {
        if (this._random) {
            this.redraw();
        }
    }

}

DitheringShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec2 aNoiseTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vNoiseTextureCoord = aNoiseTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

DitheringShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uNoiseSampler;
    uniform float graining;
    void main(void){
        vec4 noise = texture2D(uNoiseSampler, vNoiseTextureCoord);
        vec4 color = texture2D(uSampler, vTextureCoord);
        gl_FragColor = (color * vColor) + graining * (noise.r - 0.5);
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/FadeOutShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/FadeOutShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FadeOutShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class FadeOutShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._fade = [0, 0, 0, 0];
    }

    set top(num) {
        this._fade[0] = num;
        this.redraw();
    }

    get top() {
        return this._fade[0];
    }

    set right(num) {
        this._fade[1] = num;
        this.redraw();
    }

    get right() {
        return this._fade[1];
    }

    set bottom(num) {
        this._fade[2] = num;
        this.redraw();
    }

    get bottom() {
        return this._fade[2];
    }

    set left(num) {
        this._fade[3] = num;
        this.redraw();
    }

    get left() {
        return this._fade[3];
    }

    set fade(v) {
        if(Array.isArray(v)) {
            if(v.length === 2) {
                this._fade = [v[0], v[1], v[0], v[1]];
            }
            else if(v.length === 3) {
                this._fade = [v[0], v[1], v[2], this._fade[3]];
            }
            else if (v.length === 4) {
                this._fade = v;
            }
            else {
                this._fade = [v[0], v[0], v[0], v[0]];
            }
        }
        else {
            this._fade = [v, v, v, v];
        }
        this.redraw();
    }

    get fade() {
        return this._fade;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner;

        const renderPrecision = this.ctx.stage.getRenderPrecision();
        const fade = this._fade.map((f) => f * renderPrecision);
        this._setUniform('fade',  new Float32Array(fade), this.gl.uniform4fv);
        this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }
}

FadeOutShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 fade;
    
    void main() {
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 point = vTextureCoord.xy * resolution.xy;
        
        vec2 pos1;
        vec2 pos2;
        vec2 d;
        float c;
        float t = 0.0;
             
        if(fade[0] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x, point.y + fade[0]);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[1] > 0.0) {
            vec2 pos1 = vec2(point.x - resolution.x - fade[1], vTextureCoord.y);
            vec2 pos2 = vec2(point.x - resolution.x, vTextureCoord.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[2] > 0.0) {
            vec2 pos1 = vec2(vTextureCoord.x, point.y - resolution.y - fade[2]);
            vec2 pos2 = vec2(vTextureCoord.x, point.y - resolution.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[3] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x + fade[3], point.y);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        gl_FragColor = color;
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/HoleShader.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/HoleShader.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HoleShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class HoleShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);
        this._x = 0;
        this._y = 0;
        this._w = 0;
        this._h = 0;
        this._radius = 0;
    }

    get x() {
        return this._x;
    }

    set x(v) {
        this._x = v;
        this.redraw();
    }

    get y() {
        return this._y;
    }

    set y(v) {
        this._y = v;
        this.redraw();
    }

    get w() {
        return this._w;
    }

    set w(v) {
        this._w = v;
        this.redraw();
    }

    get h() {
        return this._h;
    }

    set h(v) {
        this._h = v;
        this.redraw();
    }

    get radius() {
        return this._radius;
    }

    set radius(v) {
        this._radius = v;
        this.redraw();
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);

        const owner = operation.shaderOwner;
        const renderPrecision = this.ctx.stage.getRenderPrecision()

        this._setUniform("x", this._x * renderPrecision, this.gl.uniform1f);
        this._setUniform("y", this._y * renderPrecision, this.gl.uniform1f);
        this._setUniform("w", this._w * renderPrecision, this.gl.uniform1f);
        this._setUniform("h", this._h * renderPrecision, this.gl.uniform1f);
        this._setUniform('radius',  (this._radius + .5) * renderPrecision, this.gl.uniform1f);
        this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }

    useDefault() {
        return (this._x === 0 && this._y === 0 && this._w === 0 && this._h === 0)
    }
}

HoleShader.vertexShaderSource = _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].vertexShaderSource;

HoleShader.fragmentShaderSource = `
   #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float x;
    uniform float y;
    uniform float w;
    uniform float h;
    uniform vec2 resolution;
    uniform float radius;

    float roundBox(vec2 p, vec2 b, float r) {
        float d = length(max(abs(p)-b+r, 0.1))-r;
        return smoothstep(1.0, 0.0, d);
    }

    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        vec2 pos = vTextureCoord.xy * resolution - vec2(x, y) - vec2(w, h) / 2.0;
        vec2 size = vec2(w, h) / 2.0;
        float b = roundBox(pos, size, radius);
        gl_FragColor = mix(color, vec4(0.0), b);
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/InversionShader.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/InversionShader.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ InversionShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class InversionShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);
        this._amount = 1;
    }

    set amount(v) {
        this._amount = v;
        this.redraw();
    }

    get amount() {
        return this._amount;
    }

    useDefault() {
        return this._amount === 0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("amount", this._amount, this.gl.uniform1f);
    }

}

InversionShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        color.rgb = color.rgb * (1.0 - amount) + amount * (1.0 * color.a - color.rgb); 
        gl_FragColor = color * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/Light3dShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/Light3dShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Light3dShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class Light3dShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        this._strength = 0.5;
        this._ambient = 0.5;
        this._fudge = 0.4;

        this._rx = 0;
        this._ry = 0;

        this._z = 0;
        this._pivotX = NaN;
        this._pivotY = NaN;
        this._pivotZ = 0;

        this._lightY = 0;
        this._lightZ = 0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);

        let vr = operation.shaderOwner;
        let element = vr.element;

        let pivotX = isNaN(this._pivotX) ? element.pivotX * vr.w : this._pivotX;
        let pivotY = isNaN(this._pivotY) ? element.pivotY * vr.h : this._pivotY;
        let coords = vr.getRenderTextureCoords(pivotX, pivotY);

        // Counter normal rotation.

        let rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);

        let gl = this.gl;
        this._setUniform("pivot", new Float32Array([coords[0], coords[1], this._pivotZ]), gl.uniform3fv);
        this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);

        this._setUniform("z", this._z, gl.uniform1f);
        this._setUniform("lightY", this.lightY, gl.uniform1f);
        this._setUniform("lightZ", this.lightZ, gl.uniform1f);
        this._setUniform("strength", this._strength, gl.uniform1f);
        this._setUniform("ambient", this._ambient, gl.uniform1f);
        this._setUniform("fudge", this._fudge, gl.uniform1f);
    }

    set strength(v) {
        this._strength = v;
        this.redraw();
    }

    get strength() {
        return this._strength;
    }

    set ambient(v) {
        this._ambient = v;
        this.redraw();
    }

    get ambient() {
        return this._ambient;
    }

    set fudge(v) {
        this._fudge = v;
        this.redraw();
    }

    get fudge() {
        return this._fudge;
    }

    get rx() {
        return this._rx;
    }

    set rx(v) {
        this._rx = v;
        this.redraw();
    }

    get ry() {
        return this._ry;
    }

    set ry(v) {
        this._ry = v;
        this.redraw();
    }

    get z() {
        return this._z;
    }

    set z(v) {
        this._z = v;
        this.redraw();
    }

    get pivotX() {
        return this._pivotX;
    }

    set pivotX(v) {
        this._pivotX = v + 1;
        this.redraw();
    }

    get pivotY() {
        return this._pivotY;
    }

    set pivotY(v) {
        this._pivotY = v + 1;
        this.redraw();
    }

    get lightY() {
        return this._lightY;
    }

    set lightY(v) {
        this._lightY = v;
        this.redraw();
    }

    get pivotZ() {
        return this._pivotZ;
    }

    set pivotZ(v) {
        this._pivotZ = v;
        this.redraw();
    }

    get lightZ() {
        return this._lightZ;
    }

    set lightZ(v) {
        this._lightZ = v;
        this.redraw();
    }

    useDefault() {
        return (this._rx === 0 && this._ry === 0 && this._z === 0 && this._strength === 0 && this._ambient === 1);
    }

}

Light3dShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float fudge;
    uniform float strength;
    uniform float ambient;
    uniform float z;
    uniform float lightY;
    uniform float lightZ;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Set depth perspective
        float perspective = 1.0 + fudge * pos.z;

        pos.z += lightZ * projection.x;

        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, perspective);

        // Correct light source position.
        pos.y += lightY * abs(projection.y);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

Light3dShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec3 pos;
    uniform sampler2D uSampler;
    uniform float ambient;
    uniform float strength;
    void main(void){
        vec4 rgba = texture2D(uSampler, vTextureCoord);
        float d = length(pos);
        float n = 1.0 / max(0.1, d);
        rgba.rgb = rgba.rgb * (strength * n + ambient);
        gl_FragColor = rgba * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LinearBlurShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class LinearBlurShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);

        this._direction = new Float32Array([1, 0]);
        this._kernelRadius = 1;
    }

    get x() {
        return this._direction[0];
    }

    set x(v) {
        this._direction[0] = v;
        this.redraw();
    }

    get y() {
        return this._direction[1];
    }

    set y(v) {
        this._direction[1] = v;
        this.redraw();
    }

    get kernelRadius() {
        return this._kernelRadius;
    }

    set kernelRadius(v) {
        this._kernelRadius = v;
        this.redraw();
    }


    useDefault() {
        return (this._kernelRadius === 0);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("direction", this._direction, this.gl.uniform2fv);
        this._setUniform("kernelRadius", this._kernelRadius, this.gl.uniform1i);

        const w = operation.getRenderWidth();
        const h = operation.getRenderHeight();
        this._setUniform("resolution", new Float32Array([w, h]), this.gl.uniform2fv);
    }
}

LinearBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 resolution;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 direction;
    uniform int kernelRadius;
    
    vec4 blur1(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3333333333333333) * direction;
        color += texture2D(image, uv) * 0.29411764705882354;
        color += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;
        color += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;
        return color; 
    }
    
    vec4 blur2(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3846153846) * direction;
        vec2 off2 = vec2(3.2307692308) * direction;
        color += texture2D(image, uv) * 0.2270270270;
        color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;
        color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;
        return color;
    }
    
    vec4 blur3(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.411764705882353) * direction;
        vec2 off2 = vec2(3.2941176470588234) * direction;
        vec2 off3 = vec2(5.176470588235294) * direction;
        color += texture2D(image, uv) * 0.1964825501511404;
        color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;
        color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;
        return color;
    }    

    void main(void){
        if (kernelRadius == 1) {
            gl_FragColor = blur1(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else if (kernelRadius == 2) {
            gl_FragColor = blur2(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else {
            gl_FragColor = blur3(uSampler, vTextureCoord, resolution, direction) * vColor;
        }
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/MagnifierShader.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/MagnifierShader.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MagnifierShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class MagnifierShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
	constructor(context) {
	  super(context);
	  this._x = 0;
	  this._y = 0;
	  this._w = 0;
	  this._h = 0;
	  this._radius = 0;
	  this._magnification = 0.6;
	}
  
	get x() {
	  return this._x;
	}
  
	set x(v) {
	  this._x = v;
	  this.redraw();
	}
  
	get y() {
	  return this._y;
	}
  
	set y(v) {
	  this._y = v;
	  this.redraw();
	}
  
	get w() {
	  return this._w;
	}
  
	set w(v) {
	  this._w = v;
	  this.redraw();
	}
  
	get h() {
	  return this._h;
	}
  
	set h(v) {
	  this._h = v;
	  this.redraw();
	}
  
	get magnification() {
	  return this._magnification;
	}
  
	set magnification(v) {
	  this._magnification = v;
	  this.redraw();
	}
  
	get radius() {
	  return this._radius;
	}
  
	set radius(v) {
	  this._radius = v;
	  this.redraw();
	}
  
	setupUniforms(operation) {
	  super.setupUniforms(operation);
  
	  const owner = operation.shaderOwner;
	  const renderPrecision = this.ctx.stage.getRenderPrecision();
	  this._setUniform('x', this._x * renderPrecision, this.gl.uniform1f);
	  this._setUniform('y', this._y * renderPrecision, this.gl.uniform1f);
	  this._setUniform('w', this._w * renderPrecision, this.gl.uniform1f);
	  this._setUniform('h', this._h * renderPrecision, this.gl.uniform1f);
	  this._setUniform('magnification', this._magnification, this.gl.uniform1f);
	  this._setUniform(
		'radius',
		(this._radius + 0.5) * renderPrecision,
		this.gl.uniform1f
	  );
	  this._setUniform(
		'resolution',
		new Float32Array([
		  owner._w * renderPrecision,
		  owner._h * renderPrecision
		]),
		this.gl.uniform2fv
	  );
	}
 
	useDefault() {
	  return this._w === 0 && this._h === 0;
	}
  }
  
  MagnifierShader.vertexShaderSource = _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].vertexShaderSource;
  
  MagnifierShader.fragmentShaderSource = `
	  #ifdef GL_ES
		# ifdef GL_FRAGMENT_PRECISION_HIGH
		precision highp float;
		# else
		precision lowp float;
		# endif
	  #endif

	  varying vec2 vTextureCoord;
	  varying vec4 vColor;
	  uniform sampler2D uSampler;
	  uniform float x;
	  uniform float y;
	  uniform float w;
	  uniform float h;
	  uniform vec2 resolution;
	  uniform float radius;
	  uniform float magnification;
  
	  float roundBox(vec2 p, vec2 b, float r) {
		  float d = length(max(abs(p)-b+r, 0.1))-r;
		  return smoothstep(1.0, 0.0, d);
	  }

	  float inside(vec2 v) {
		vec2 s = step(vec2(0.0, 0.0), v) - step(vec2(1.0, 1.0), v);
		return s.x * s.y;   
      }
  
	  void main(void) {
		vec4 color = texture2D(uSampler, vTextureCoord);
		vec2 pos = vTextureCoord.xy * resolution - vec2(x, y) - vec2(w, h) / 2.0;
		vec2 size = vec2(w, h) / 2.0;
		float b = roundBox(pos, size, radius);
		vec2 pos2 = (vTextureCoord.xy * magnification * resolution + vec2(x, y) * magnification) / resolution;
		gl_FragColor = mix(color, texture2D(uSampler, pos2) * inside(pos2), b) * vColor;
	  }
  `;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/OutlineShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/OutlineShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OutlineShader)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class OutlineShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(ctx) {
        super(ctx);
        this._width = 5;
        this._col = 0xFFFFFFFF;
        this._color = [1,1,1,1];
    }

    set width(v) {
        this._width = v;
        this.redraw();
    }

    get color() {
        return this._col;
    }

    set color(v) {
        if (this._col !== v) {
            const col = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaComponentsNormalized(v);
            col[0] = col[0] * col[3];
            col[1] = col[1] * col[3];
            col[2] = col[2] * col[3];

            this._color = col;

            this.redraw();

            this._col = v;
        }
    }

    useDefault() {
        return (this._width === 0 || this._col[3] === 0);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        let gl = this.gl;
        this._setUniform("color", new Float32Array(this._color), gl.uniform4fv);
    }

    enableAttribs() {
        super.enableAttribs();
        this.gl.enableVertexAttribArray(this._attrib("aCorner"));
    }

    disableAttribs() {
        super.disableAttribs();
        this.gl.disableVertexAttribArray(this._attrib("aCorner"));
    }

    setExtraAttribsInBuffer(operation) {
        let offset = operation.extraAttribsDataByteOffset / 4;
        let floats = operation.quads.floats;

        let length = operation.length;

        for (let i = 0; i < length; i++) {

            const elementCore = operation.getElementCore(i);

            // We are setting attributes such that if the value is < 0 or > 1, a border should be drawn.
            const ddw = this._width / elementCore.w;
            const dw = ddw / (1 - 2 * ddw);
            const ddh = this._width / elementCore.h;
            const dh = ddh / (1 - 2 * ddh);

            // Specify all corner points.
            floats[offset] = -dw;
            floats[offset + 1] = -dh;

            floats[offset + 2] = 1 + dw;
            floats[offset + 3] = -dh;

            floats[offset + 4] = 1 + dw;
            floats[offset + 5] = 1 + dh;

            floats[offset + 6] = -dw;
            floats[offset + 7] = 1 + dh;

            offset += 8;
        }
    }

    beforeDraw(operation) {
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aCorner"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));
    }

    getExtraAttribBytesPerVertex() {
        return 8;
    }

}

OutlineShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aCorner;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vCorner;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vCorner = aCorner;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

OutlineShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vCorner;
    uniform vec4 color;
    uniform sampler2D uSampler;
    void main(void){
        vec2 m = min(vCorner, 1.0 - vCorner);
        float value = step(0.0, min(m.x, m.y));
        gl_FragColor = mix(color, texture2D(uSampler, vTextureCoord) * vColor, value);
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PerspectiveShader.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PerspectiveShader.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PerspectiveShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class PerspectiveShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        this._fudge = 0.2;
        this._rx = 0;
        this._ry = 0;
        this._z = 1.0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);

        const vr = operation.shaderOwner;
        const element = vr.element;

        const pivotX = element.pivotX * vr.w;
        const pivotY = element.pivotY * vr.h;
        const coords = vr.getRenderTextureCoords(pivotX, pivotY);

        // Counter normal rotation.
        const rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);

        const gl = this.gl;
        this._setUniform("pivot", new Float32Array([coords[0], coords[1], 0]), gl.uniform3fv);
        this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);
        this._setUniform("z", this._z, gl.uniform1f);
        this._setUniform("fudge", this._fudge, gl.uniform1f);
    }

    set fudge(v) {
        this._fudge = v;
        this.redraw();
    }

    get fudge() {
        return this._fudge;
    }

    get rx() {
        return this._rx;
    }

    set rx(v) {
        this._rx = v;
        this.redraw();
    }

    get ry() {
        return this._ry;
    }

    set ry(v) {
        this._ry = v;
        this.redraw();
    }

    get z() {
        return this._z;
    }

    set z(v) {
        this._z = v;
        this.redraw();
    }

    useDefault() {
        return (this._rx === 0 && this._ry === 0 && this._z === 0);
    }

}

PerspectiveShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float z;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, z);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

PerspectiveShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform vec3 rot;
    uniform float fudge;

    void main(void) {
        vec2 coords = vTextureCoord;

        coords.xy -= vec2(0.5);
        coords.y = coords.y + (sign(rot[0]) * 0.5 - coords.x) * sin(rot[0]) * fudge * coords.y;
        coords.x = coords.x + (sign(rot[1]) * 0.5 - coords.y) * sin(rot[1]) * fudge * coords.x;
        coords.xy += vec2(0.5);

        if (coords.x < 0.0 || coords.x > 1.0 || coords.y < 0.0 || coords.y > 1.0) {
            gl_FragColor = vec4(0.0);
        } else {
            gl_FragColor = texture2D(uSampler, coords) * vColor;
        }
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PixelateShader.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PixelateShader.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PixelateShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @see https://github.com/pixijs/pixi-filters/tree/master/filters/pixelate/src
 */
class PixelateShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        this._size = new Float32Array([4, 4]);
    }

    get x() {
        return this._size[0];
    }

    set x(v) {
        this._size[0] = v;
        this.redraw();
    }

    get y() {
        return this._size[1];
    }

    set y(v) {
        this._size[1] = v;
        this.redraw();
    }

    get size() {
        return this._size[0];
    }

    set size(v) {
        this._size[0] = v;
        this._size[1] = v;
        this.redraw();
    }

    useDefault() {
        return ((this._size[0] === 0) && (this._size[1] === 0));
    }

    static getWebGLImpl() {
        return WebGLPixelateShaderImpl;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        let gl = this.gl;
        this._setUniform("size", new Float32Array(this._size), gl.uniform2fv);
    }

    getExtraAttribBytesPerVertex() {
        return 8;
    }

    enableAttribs() {
        super.enableAttribs();
        this.gl.enableVertexAttribArray(this._attrib("aTextureRes"));
    }

    disableAttribs() {
        super.disableAttribs();
        this.gl.disableVertexAttribArray(this._attrib("aTextureRes"));
    }

    setExtraAttribsInBuffer(operation) {
        let offset = operation.extraAttribsDataByteOffset / 4;
        let floats = operation.quads.floats;

        let length = operation.length;
        for (let i = 0; i < length; i++) {
            let w = operation.quads.getTextureWidth(operation.index + i);
            let h = operation.quads.getTextureHeight(operation.index + i);

            floats[offset] = w;
            floats[offset + 1] = h;
            floats[offset + 2] = w;
            floats[offset + 3] = h;
            floats[offset + 4] = w;
            floats[offset + 5] = h;
            floats[offset + 6] = w;
            floats[offset + 7] = h;

            offset += 8;
        }
    }

    beforeDraw(operation) {
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aTextureRes"), 2, gl.FLOAT, false, this.getExtraAttribBytesPerVertex(), this.getVertexAttribPointerOffset(operation));
    }
}

PixelateShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aTextureRes;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        vTextureRes = aTextureRes;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

PixelateShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;

    uniform vec2 size;
    uniform sampler2D uSampler;
    
    vec2 mapCoord( vec2 coord )
    {
        coord *= vTextureRes.xy;
        return coord;
    }
    
    vec2 unmapCoord( vec2 coord )
    {
        coord /= vTextureRes.xy;
        return coord;
    }
    
    vec2 pixelate(vec2 coord, vec2 size)
    {
        return floor( coord / size ) * size;
    }
    
    void main(void)
    {
        vec2 coord = mapCoord(vTextureCoord);
        coord = pixelate(coord, size);
        coord = unmapCoord(coord);
        gl_FragColor = texture2D(uSampler, coord) * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialFilterShader.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialFilterShader.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RadialFilterShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class RadialFilterShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._radius = 0;
        this._cutoff = 1;
    }

    set radius(v) {
        this._radius = v;
        this.redraw();
    }

    get radius() {
        return this._radius;
    }

    set cutoff(v) {
        this._cutoff = v;
        this.redraw();
    }

    get cutoff() {
        return this._cutoff;
    }
    
    useDefault() {
        return this._radius === 0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        // We substract half a pixel to get a better cutoff effect.
        this._setUniform("radius", 2 * (this._radius - 0.5) / operation.getRenderWidth(), this.gl.uniform1f);
        this._setUniform("cutoff", 0.5 * operation.getRenderWidth() / this._cutoff, this.gl.uniform1f);
    }

}

RadialFilterShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 pos;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
        pos = gl_Position.xy;
    }
`;

RadialFilterShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 pos;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float radius;
    uniform float cutoff;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        float f = max(0.0, min(1.0, 1.0 - (length(pos) - radius) * cutoff));
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor * f;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialGradientShader.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialGradientShader.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RadialGradientShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class RadialGradientShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._pivot = [0, 0];
        this._ic = 0xffffffff;
        this._normalizedIC = this._getNormalizedColor(this._ic);
        this._oc = 0x00ffffff;
        this._normalizedOC = this._getNormalizedColor(this._oc);
        this._radius = 0;
    }

    set radiusX(v) {
        this.radius = v;
    }

    get radiusX() {
        return this._radius;
    }

    set radiusY(v) {
        this._radiusY = v;
        this.redraw();
    }

    get radiusY() {
        return this._radiusY;
    }

    set radius(v) {
        this._radius = v;
        this.redraw();
    }

    set innerColor(argb) {
        this._ic = argb;
        this._normalizedIC = this._getNormalizedColor(argb);
        this.redraw();
    }

    get innerColor() {
        return this._ic;
    }

    set outerColor(argb) {
        this._oc = argb;
        this._normalizedOC = this._getNormalizedColor(argb);
        this.redraw();
    }

    set color(argb) {
        this.innerColor = argb;
    }

    get color() {
        return this.innerColor;
    }

    get outerColor() {
        return this._ic;
    }

    set x(f) {
        this._x = f;
        this.redraw();
    }

    set y(f) {
        this._y = f;
        this.redraw();
    }

    set pivot(v) {
        if(Array.isArray(v) && v.length === 2) {
            this._pivot = v;
        }
        else if(Array.isArray(v)) {
            this._pivot = [v[0], v[1] || v[0]];
        }
        else {
            this._pivot = [v, v];
        }
        this.redraw();
    }

    get pivot() {
        return this._pivot[0];
    }

    set pivotY(f) {
        this._pivot[1] = f;
        this.redraw();
    }

    get pivotY() {
        return this._pivot[1];
    }

    set pivotX(f) {
        this._pivot[0] = f;
        this.redraw();
    }

    get pivotX() {
        return this._pivot[0];
    }

    _getNormalizedColor(color) {
        const col = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(color);
        col[0] *= col[3];
        col[1] *= col[3];
        col[2] *= col[3];
        return new Float32Array(col);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner;

        if(this._x) {
            this._pivot[0] = this._x / owner.w;
        }
        if(this._y) {
            this._pivot[1] = this._y / owner.h;
        }

        if(this._radius === 0) {
            this._radius = owner.w * 0.5;
        }

        this._setUniform('innerColor', this._normalizedIC, this.gl.uniform4fv);
        this._setUniform('fill', _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(this._oc)[3], this.gl.uniform1f);
        this._setUniform('outerColor', this._normalizedOC, this.gl.uniform4fv);
        this._setUniform('pivot', new Float32Array(this._pivot),  this.gl.uniform2fv);
        this._setUniform('resolution', new Float32Array([owner._w, owner._h]),  this.gl.uniform2fv);
        this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
        this._setUniform('radius',  this._radius, this.gl.uniform1f);
        this._setUniform('radiusY',  (this._radiusY || this._radius), this.gl.uniform1f);
    }
}

RadialGradientShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec2 pivot;
    uniform vec4 innerColor;
    uniform vec4 outerColor;
    uniform float radius;
    uniform float radiusY;
    uniform float alpha;
    uniform float fill;
    uniform float aspectRatio;
    
    void main() {
        vec2 point = vTextureCoord.xy * resolution;
        vec2 projection = vec2(pivot.x * resolution.x, pivot.y * resolution.y);
        float d = length((point - projection) / vec2(radius * 2.0, radiusY * 2.0));
        vec4 color = mix(texture2D(uSampler, vTextureCoord) * vColor, outerColor * alpha, fill);
        gl_FragColor = mix(innerColor * alpha, color, smoothstep(0.0, 1.0, d));
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RoundedRectangleShader.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RoundedRectangleShader.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RoundedRectangleShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class RoundedRectangleShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._blend = 0;
        this._radius = [1, 1, 1, 1];
        this._stroke = 0;
        this._fc = 0x00ffffff;
        this._fillColor = this._getNormalizedColor(0xffffffff);
        this._strokeColor = this._getNormalizedColor(0x00ffffff);
    }

    set blend(p) {
        this._blend = Math.min(Math.max(p, 0), 1);
    }

    set radius(v) {
        if(Array.isArray(v)) {
            if(v.length === 2) {
                this._radius = [v[0], v[1], v[0], v[1]];
            }
            else if(v.length === 3) {
                this._radius = [v[0], v[1], v[2], this._radius[3]];
            }
            else if (v.length === 4) {
                this._radius = v;
            }
            else {
                this._radius = [v[0], v[0], v[0], v[0]];
            }
        }
        else {
            this._radius = [v, v, v, v];
        }
        this.redraw();
    }

    get radius() {
        return this._radius;
    }

    set topLeft(num) {
        this._radius[0] = num;
        this.redraw();
    }

    get topLeft() {
        return this._radius[0];
    }

    set topRight(num) {
        this._radius[1] = num;
        this.redraw();
    }

    get topRight() {
        return this._radius[1];
    }

    set bottomRight(num) {
        this._radius[2] = num;
        this.redraw();
    }

    get bottomRight() {
        return this._radius[2];
    }

    set bottomLeft(num) {
        this._radius[3] = num;
        this.redraw();
    }

    get bottomLeft() {
        return this._radius[4];
    }

    set strokeColor(argb) {
        this._sc = argb;
        this._strokeColor = this._getNormalizedColor(argb);
        this.redraw();
    }

    get strokeColor() {
        return this._sc;
    }

    set fillColor(argb) {
        this._fc = argb;
        this._fillColor = this._getNormalizedColor(argb);
        this.redraw();
    }

    get fillColor() {
        return this._fc;
    }

    set stroke(num) {
        this._stroke = num;
        this.redraw();
    }

    get stroke() {
        return this._stroke;
    }

    _getNormalizedColor(color) {
        const col = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(color);
        col[0] *= col[3];
        col[1] *= col[3];
        col[2] *= col[3];
        return new Float32Array(col);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner;
        const renderPrecision = this.ctx.stage.getRenderPrecision();
        const _radius = this._radius.map((r) => (r + 0.5) * renderPrecision)
        this._setUniform('radius', new Float32Array(_radius), this.gl.uniform4fv);
        this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
        this._setUniform('blend', this._blend, this.gl.uniform1f);
        this._setUniform('strokeColor', this._strokeColor, this.gl.uniform4fv);
        this._setUniform('fillColor', this._fillColor, this.gl.uniform4fv);
        this._setUniform('stroke',  this._stroke * renderPrecision, this.gl.uniform1f);
        this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }
}

RoundedRectangleShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;

    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

RoundedRectangleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif

    #define PI 3.14159265359

    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 radius;
    uniform float stroke;
    uniform vec4 strokeColor;
    uniform vec4 fillColor;
    uniform float alpha;
    uniform float fill;
    uniform float blend;
    
    float boxDist(vec2 p, vec2 size, float radius){
        size -= vec2(radius);
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    float innerBorderMask(float dist, float width){
        float alpha1 = clamp(dist + width, 0.0, 1.0);
        float alpha2 = clamp(dist, 0.0, 1.0);
        return alpha1 - alpha2;
    }

    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        float r = 0.0;
        if (vTextureCoord.x < 0.5 && vTextureCoord.y < 0.5) {
            r = radius[0];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y < 0.5) {
            r = radius[1];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y >= 0.5) {
            r = radius[2];
        } else {
            r = radius[3];
        }
        
        float b = boxDist(vTextureCoord.xy * resolution - halfRes, halfRes - 0.005, r);
        vec4 tex = texture2D(uSampler, vTextureCoord) * vColor;
        vec4 blend = mix(vec4(1.0) * alpha, tex, blend);     
        vec4 layer1 = mix(vec4(0.0), tex * fillColor, fillMask(b));
        gl_FragColor = mix(layer1, blend * strokeColor, innerBorderMask(b, stroke));
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpinnerShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class SpinnerShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);
        this._radius = 100;
        this._width = 50;
        this._period = 1;
        this._angle = 0.5;
        this._smooth = 0.005;
        this._color = 0xffffffff;
        this._backgroundColor = 0xff000000;
        this._time = Date.now();
    }

    set radius(v) {
        this._radius = v;
        this.redraw();
    }

    set width(v) {
        this._width = v;
        this.redraw();
    }

    set period(v) {
        this._period = v;
        this.redraw();
    }

    set angle(v) {
        this._angle = v
        this.redraw();
    }

    set smooth(v) {
        this._smooth = v;
        this.redraw();
    }

    set color(v) {
        this._color = v;
        this.redraw();
    }

    set backgroundColor(v) {
        this._backgroundColor = v;
        this.redraw();
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner

        this._setUniform("iTime", Date.now() - this._time, this.gl.uniform1f);

        const renderPrecision = this.ctx.stage.getRenderPrecision();
        this._setUniform('radius', this._radius * renderPrecision, this.gl.uniform1f);
        this._setUniform('width', this._width * renderPrecision, this.gl.uniform1f);
        this._setUniform('period', this._period, this.gl.uniform1f);
        this._setUniform('angle', this._angle, this.gl.uniform1f);
        this._setUniform('smooth', this._smooth, this.gl.uniform1f);
        this._setUniform('color', new Float32Array(_tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(this._color)), this.gl.uniform4fv);
        this._setUniform('backgroundColor', new Float32Array(_tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(this._backgroundColor)), this.gl.uniform4fv);
        this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv)

        this.redraw()
    }
}

SpinnerShader.vertexShaderSource = _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].vertexShaderSource;

SpinnerShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float iTime;
    uniform float radius;
    uniform float width;
    uniform float period;
    uniform float angle;
    uniform float smooth;
    uniform vec2 resolution;

    uniform vec4 color;
    uniform vec4 backgroundColor;

    float ratio = resolution.y / resolution.x;

    vec2 transpose_pos(vec2 pos) {
        if (ratio < 1.) {
            float diff = 0.5 - pos.x;
            pos.x = 0.5 - diff / ratio;
        } else {
            float diff = 0.5 - pos.y;
            pos.y = 0.5 - diff * ratio;
        }
        return pos;
    }

    float get_angle(vec2 pos) {
        pos = transpose_pos(pos);
        float a = atan(pos.y - 0.5, pos.x - 0.5);
        a = (1.0+a/3.14159)/2.0;
        
        return a;
    }

    float dist(vec2 pos1, vec2 pos2) {
        pos1 = transpose_pos(pos1);
        return distance(pos1, pos2);
    }

    void main()
    {
        vec2 fragCoord = vTextureCoord;
        vec4 fragColor = vColor;
        
        vec2 st = vTextureCoord;
        float pct = dist(st, vec2(0.5));

        float a = get_angle(st);
        float t = iTime / 1000.0 / period;

        float inner = max((radius - width) / resolution.x, (radius - width) / resolution.y);
        float outer = max(radius / resolution.x, radius / resolution.y);

        float x1 = mod(t, 1.0);
        float x2 = mod(t + angle, 1.0);

        if (x1 < x2) {
            if (a > x1 && a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        } else {
            if (a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else if (a > x1) {
                float val = (1.0 - (1.0 + x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (1.0 + x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        }

        float s = smoothstep(inner, inner + smooth + 0.00001, pct) * (1.0 - smoothstep(outer, outer + smooth + 0.00001, pct));
        gl_FragColor = texture2D(uSampler, fragCoord) * vColor * (1. - s * fragColor.a) + fragColor * s;
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader2.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader2.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpinnerShader2)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class SpinnerShader2 extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._period = 1;
        this._stroke = 0;
        this._showDot = true;
        this._clockwise = true;
        this._bc = 0xff000000;
        this._normalizedBC = this._getNormalizedColor(this._bc);
        this._c = 0xffffffff;
        this._normalizedC = this._getNormalizedColor(this._c);
    }

    set radius(v) {
        if(v === 0) {
            v = 1;
        }
        this._radius = v;
    }

    set stroke(value) {
        this._stroke = Math.abs(value);
    }

    get stroke() {
        return this._stroke;
    }

    set color(argb) {
        this._c = argb;
        this._normalizedC = this._getNormalizedColor(argb);
    }

    get color() {
        return this._c;
    }

    set backgroundColor(argb) {
        this._bc = argb;
        this._normalizedBC = this._getNormalizedColor(argb);
    }

    get backgroundColor() {
        return this._sc;
    }

    set showDot(bool) {
        this._showDot = bool;
    }

    get showDot() {
        return this._showDot;
    }

    set clockwise(bool) {
        this._clockwise = bool;
    }

    get clockwise() {
        return this._clockwise;
    }

    set period(v) {
        this._period = v;
    }

    get period() {
        return this._period;
    }

    _getNormalizedColor(color) {
        const col = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(color);
        col[0] *= col[3];
        col[1] *= col[3];
        col[2] *= col[3];
        return new Float32Array(col);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner;
        const radius = this._radius || (owner._w / 2);

        if(this._stroke === 0) {
            this._stroke = radius * 0.33;
        }

        this._setUniform('resolution', new Float32Array([owner._w, owner._h]),  this.gl.uniform2fv);
        this._setUniform('color', this._normalizedC, this.gl.uniform4fv);
        this._setUniform('backgroundColor', this._normalizedBC, this.gl.uniform4fv);
        this._setUniform('stroke',  this._stroke, this.gl.uniform1f);
        this._setUniform('radius',  radius, this.gl.uniform1f);
        this._setUniform('direction',  this._clockwise ? -1 : 1, this.gl.uniform1f);
        this._setUniform('showDot', !!this._showDot, this.gl.uniform1f);
        this._setUniform('time', Date.now() - SpinnerShader2.spinSync, this.gl.uniform1f);
        this._setUniform('period', this._period, this.gl.uniform1f);
        this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);

        if(this._sc !== this._bc || this._stroke !== radius * 0.5) {
            this.redraw();
        }
    }
}

SpinnerShader2.spinSync = Date.now();

SpinnerShader2.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 color;
    uniform vec4 backgroundColor;
    uniform float direction;
    uniform float radius;
    uniform float time;
    uniform float stroke;
    uniform float showDot;
    uniform float period;
    uniform float alpha;
    
    float circleDist(vec2 p, float radius){
        return length(p) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 center = vTextureCoord.xy * resolution - halfRes;
        
        float c = max(-circleDist(center, radius - stroke), circleDist(center, radius));
        float rot = -(time / 1000.0 / period) * 6.0 * direction;
        center *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));
        
        float a = direction * atan(center.x, center.y) * PI * 0.05 + 0.45;
        
        float strokeRad = stroke * 0.5;
        a = mix(a, max(a, fillMask(circleDist(vec2(center.x, center.y + (radius - strokeRad)), strokeRad))), showDot);
        vec4 base = mix(vec4(0.0), backgroundColor * alpha, fillMask(c));
        gl_FragColor = mix(base, color * alpha, fillMask(c) * a);
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/VignetteShader.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/VignetteShader.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VignetteShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class VignetteShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._magnitude = 1.3;
        this._intensity = 0.7;
        this._pivot = [0.5, 0.5];
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);

        this._setUniform("magnitude", this._magnitude , this.gl.uniform1f);
        this._setUniform("intensity", this._intensity, this.gl.uniform1f);
        this._setUniform('pivot', new Float32Array(this._pivot), this.gl.uniform2fv);
        this.redraw()
    }

    set pivot(v) {
        if(Array.isArray(v)) {
            this._pivot = v;
        }
        else {
            this._pivot = [v, v];
        }
        this.redraw();
    }

    get pivotX() {
        return this._pivot[0];
    }

    set pivotX(v) {
        this._pivot[0] = v;
        this.redraw();
    }

    get pivotY() {
        return this._pivot[1];
    }

    set pivotY(v) {
        this._pivot[1] = v;
        this.redraw();
    }

    get intensity() {
        return this._intensity;
    }

    set intensity(v) {
        this._intensity = v;
        this.redraw();
    }

    get magnitude() {
        return this._magnitude;

    }

    set magnitude(v) {
        this._magnitude = v;
        this.redraw();
    }
}

VignetteShader.vertexShaderSource = _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].vertexShaderSource;

VignetteShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float magnitude;
    uniform float intensity;
    uniform vec2 pivot;

    void main() {
        vec2 uv = vTextureCoord.xy - pivot + vec2(0.5);
        uv.x = clamp(uv.x, 0.0, 1.0);
        uv.y = clamp(uv.y, 0.0, 1.0);
   
        uv *=  1.00 - uv.yx;
        float vig = uv.x * uv.y * 25.0 * intensity;
        vig = pow(vig, 0.45 * magnitude);
        vec4 fragColor = vec4(vig) * vColor;
        gl_FragColor = texture2D(uSampler, vTextureCoord) * fragColor;

    }
`


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/HtmlTexture.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/HtmlTexture.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HtmlTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class HtmlTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);
        this._htmlElement = undefined;
        this._scale = 1;
    }

    set htmlElement(v) {
        this._htmlElement = v;
        this._changed();
    }

    get htmlElement() {
        return this._htmlElement;
    }

    set scale(v) {
        this._scale = v;
        this._changed();
    }

    get scale() {
        return this._scale;
    }

    set html(v) {
        if (!v) {
            this.htmlElement = undefined;
        } else {
            const d = document.createElement('div');
            d.innerHTML = "<div>" + v + "</div>";
            this.htmlElement = d.firstElementChild;
        }
    }

    get html() {
        return this._htmlElement.innerHTML;
    }

    _getIsValid() {
        return this.htmlElement;
    }

    _getLookupId() {
        return this._scale + ":" + this._htmlElement.innerHTML;
    }

    _getSourceLoader() {
        const htmlElement = this._htmlElement;
        const scale = this._scale;
        return function(cb) {
            if (!window.html2canvas) {
                return cb(new Error("Please include html2canvas (https://html2canvas.hertzen.com/)"));
            }

            const area = HtmlTexture.getPreloadArea();
            area.appendChild(htmlElement);

            html2canvas(htmlElement, {backgroundColor: null, scale: scale}).then(function(canvas) {
                area.removeChild(htmlElement);
                if (canvas.height === 0) {
                    return cb(new Error("Canvas height is 0"));
                }
                cb(null, {source: canvas, width: canvas.width, height: canvas.height});
            }).catch(e => {
                console.error('[Lightning]', e);
            });
        }
    }

    static getPreloadArea() {
        if (!this._preloadArea) {
            // Preload area must be included in document body and must be visible to trigger html element rendering.
            this._preloadArea = document.createElement('div');
            if (this._preloadArea.attachShadow) {
                // Use a shadow DOM if possible to prevent styling from interfering.
                this._preloadArea.attachShadow({mode: 'closed'});
            }
            this._preloadArea.style.opacity = 0;
            this._preloadArea.style.pointerEvents = 'none';
            this._preloadArea.style.position = 'fixed';
            this._preloadArea.style.display = 'block';
            this._preloadArea.style.top = '100vh';
            this._preloadArea.style.overflow = 'hidden';
            document.body.appendChild(this._preloadArea);
        }
        return this._preloadArea;
    }
}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/ImageTexture.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/ImageTexture.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ImageTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);

        this._src = undefined;
        this._hasAlpha = false;
    }

    get src() {
        return this._src;
    }

    set src(v) {
        if (this._src !== v) {
            this._src = v;
            this._changed();
        }
    }

    get hasAlpha() {
        return this._hasAlpha;
    }

    set hasAlpha(v) {
        if (this._hasAlpha !== v) {
            this._hasAlpha = v;
            this._changed();
        }
    }

    _getIsValid() {
        return !!this._src;
    }

    _getLookupId() {
        return this._src;
    }

    _getSourceLoader() {
        let src = this._src;
        let hasAlpha = this._hasAlpha;
        if (this.stage.getOption('srcBasePath')) {
            var fc = src.charCodeAt(0);
            if ((src.indexOf("//") === -1) && ((fc >= 65 && fc <= 90) || (fc >= 97 && fc <= 122) || fc == 46)) {
                // Alphabetical or dot: prepend base path.
                src = this.stage.getOption('srcBasePath') + src;
            }
        }

        return (cb) => {
            return this.stage.platform.loadSrcTexture({src: src, hasAlpha: hasAlpha}, cb);
        }
    }

    getNonDefaults() {
        const obj = super.getNonDefaults();
        if (this._src) {
            obj.src = this._src;
        }
        return obj;
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/NoiseTexture.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/NoiseTexture.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ NoiseTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class NoiseTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    _getLookupId() {
        return '__noise';
    }

    _getSourceLoader() {
        const gl = this.stage.gl;
        return function(cb) {
            const noise = new Uint8Array(128 * 128 * 4);
            for (let i = 0; i < 128 * 128 * 4; i+=4) {
                const v = Math.floor(Math.random() * 256);
                noise[i] = v;
                noise[i+1] = v;
                noise[i+2] = v;
                noise[i+3] = 255;
            }
            const texParams = {}

            if (gl) {
                texParams[gl.TEXTURE_WRAP_S] = gl.REPEAT;
                texParams[gl.TEXTURE_WRAP_T] = gl.REPEAT;
                texParams[gl.TEXTURE_MIN_FILTER] = gl.NEAREST;
                texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
            }

            cb(null, {source: noise, w: 128, h: 128, texParams: texParams});
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/RectangleTexture.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/RectangleTexture.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RectangleTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class RectangleTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    _getLookupId() {
        return '__whitepix';
    }

    _getSourceLoader() {
        return function(cb) {
            var whitePixel = new Uint8Array([255, 255, 255, 255]);
            cb(null, {source: whitePixel, w: 1, h: 1, permanent: true});
        }
    }

    isAutosizeTexture() {
        return false;
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/SourceTexture.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/SourceTexture.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SourceTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class SourceTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);

        this._textureSource = undefined;
    }

    get textureSource() {
        return this._textureSource;
    }

    set textureSource(v) {
        if (v !== this._textureSource) {
            if (v.isResultTexture) {
                // In case of a result texture, automatically inherit the precision.
                this._precision = this.stage.getRenderPrecision();
            }
            this._textureSource = v;
            this._changed();
        }
    }

    _getTextureSource() {
        return this._textureSource;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/StaticCanvasTexture.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/StaticCanvasTexture.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StaticCanvasTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class StaticCanvasTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);
        this._factory = undefined;
        this._lookupId = undefined;
    }

    set content({factory, lookupId = undefined}) {
        this._factory = factory;
        this._lookupId = lookupId;
        this._changed();
    }

    _getIsValid() {
        return !!this._factory;
    }

    _getLookupId() {
        return this._lookupId;
    }

    _getSourceLoader() {
        const f = this._factory;
        return (cb) => {
            return f((err, canvas) => {
                if (err) {
                    return cb(err);
                }
                cb(null, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas));
            }, this.stage);
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/StaticTexture.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/StaticTexture.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StaticTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class StaticTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage, options) {
        super(stage);

        this._options = options;
    }

    set options(v) {
        if (this._options !== v) {
            this._options = v;
            this._changed();
        }
    }

    get options() {
        return this._options;
    }

    _getIsValid() {
        return !!this._options;
    }

    _getSourceLoader() {
        return (cb) => {
            cb(null, this._options);
        }
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/TextTexture.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/TextTexture.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _TextTextureRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TextTextureRenderer.mjs */ "./node_modules/@lightningjs/core/src/textures/TextTextureRenderer.mjs");
/* harmony import */ var _TextTextureRendererAdvanced_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TextTextureRendererAdvanced.mjs */ "./node_modules/@lightningjs/core/src/textures/TextTextureRendererAdvanced.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class TextTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);

        // We use the stage precision as the default precision in case of a text texture.
        this._precision = this.stage.getOption('precision');
    }

    static renderer(stage, canvas, settings) {
        if (this.advancedRenderer) {
            return new _TextTextureRendererAdvanced_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](stage, canvas, settings);
        } else {
            return new _TextTextureRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](stage, canvas, settings);
        }
    }

    get text() {
        return this._text;
    }

    set text(v) {
        if (this._text !== v) {
            this._text = "" + v;
            this._changed();
        }
    }

    get w() {
        return this._w;
    }

    set w(v) {
        if (this._w !== v) {
            this._w = v;
            this._changed();
        }
    }

    get h() {
        return this._h;
    }

    set h(v) {
        if (this._h !== v) {
            this._h = v;
            this._changed();
        }
    }

    get fontStyle() {
        return this._fontStyle;
    }

    set fontStyle(v) {
        if (this._fontStyle !== v) {
            this._fontStyle = v;
            this._changed();
        }
    }

    get fontSize() {
        return this._fontSize;
    }

    set fontSize(v) {
        if (this._fontSize !== v) {
            this._fontSize = v;
            this._changed();
        }
    }

    get fontFace() {
        return this._fontFace;
    }

    set fontFace(v) {
        if (this._fontFace !== v) {
            this._fontFace = v;
            this._changed();
        }
    }

    get wordWrap() {
        return this._wordWrap;
    }

    set wordWrap(v) {
        if (this._wordWrap !== v) {
            this._wordWrap = v;
            this._changed();
        }
    }

    get wordWrapWidth() {
        return this._wordWrapWidth;
    }

    set wordWrapWidth(v) {
        if (this._wordWrapWidth !== v) {
            this._wordWrapWidth = v;
            this._changed();
        }
    }

    get wordBreak() {
        return this._wordBreak;
    }

    set wordBreak(v) {
        if (this._wordBreak !== v) {
            this._wordBreak = v;
            this._changed();
        }
    }

    get textOverflow() {
        return this._textOverflow;
    }

    set textOverflow(v) {
        if (v != this._textOverflow) {
            this._textOverflow = v;
            this._changed();
        }
    }

    get lineHeight() {
        return this._lineHeight;
    }

    set lineHeight(v) {
        if (this._lineHeight !== v) {
            this._lineHeight = v;
            this._changed();
        }
    }

    get textBaseline() {
        return this._textBaseline;
    }

    set textBaseline(v) {
        if (this._textBaseline !== v) {
            this._textBaseline = v;
            this._changed();
        }
    }

    get textAlign() {
        return this._textAlign;
    }

    set textAlign(v) {
        if (this._textAlign !== v) {
            this._textAlign = v;
            this._changed();
        }
    }

    get verticalAlign() {
        return this._verticalAlign;
    }

    set verticalAlign(v) {
        if (this._verticalAlign !== v) {
            this._verticalAlign = v;
            this._changed();
        }
    }

    get offsetY() {
        return this._offsetY;
    }

    set offsetY(v) {
        if (this._offsetY !== v) {
            this._offsetY = v;
            this._changed();
        }
    }

    get maxLines() {
        return this._maxLines;
    }

    set maxLines(v) {
        if (this._maxLines !== v) {
            this._maxLines = v;
            this._changed();
        }
    }

    get maxLinesSuffix() {
        return this._maxLinesSuffix;
    }

    set maxLinesSuffix(v) {
        if (this._maxLinesSuffix !== v) {
            this._maxLinesSuffix = v;
            this._changed();
        }
    }

    get textColor() {
        return this._textColor;
    }

    set textColor(v) {
        if (this._textColor !== v) {
            this._textColor = v;
            this._changed();
        }
    }

    get paddingLeft() {
        return this._paddingLeft;
    }

    set paddingLeft(v) {
        if (this._paddingLeft !== v) {
            this._paddingLeft = v;
            this._changed();
        }
    }

    get paddingRight() {
        return this._paddingRight;
    }

    set paddingRight(v) {
        if (this._paddingRight !== v) {
            this._paddingRight = v;
            this._changed();
        }
    }

    get shadow() {
        return this._shadow;
    }

    set shadow(v) {
        if (this._shadow !== v) {
            this._shadow = v;
            this._changed();
        }
    }

    get shadowColor() {
        return this._shadowColor;
    }

    set shadowColor(v) {
        if (this._shadowColor !== v) {
            this._shadowColor = v;
            this._changed();
        }
    }

    get shadowOffsetX() {
        return this._shadowOffsetX;
    }

    set shadowOffsetX(v) {
        if (this._shadowOffsetX !== v) {
            this._shadowOffsetX = v;
            this._changed();
        }
    }

    get shadowOffsetY() {
        return this._shadowOffsetY;
    }

    set shadowOffsetY(v) {
        if (this._shadowOffsetY !== v) {
            this._shadowOffsetY = v;
            this._changed();
        }
    }

    get shadowBlur() {
        return this._shadowBlur;
    }

    set shadowBlur(v) {
        if (this._shadowBlur !== v) {
            this._shadowBlur = v;
            this._changed();
        }
    }

    get highlight() {
        return this._highlight;
    }

    set highlight(v) {
        if (this._highlight !== v) {
            this._highlight = v;
            this._changed();
        }
    }

    get highlightHeight() {
        return this._highlightHeight;
    }

    set highlightHeight(v) {
        if (this._highlightHeight !== v) {
            this._highlightHeight = v;
            this._changed();
        }
    }

    get highlightColor() {
        return this._highlightColor;
    }

    set highlightColor(v) {
        if (this._highlightColor !== v) {
            this._highlightColor = v;
            this._changed();
        }
    }

    get highlightOffset() {
        return this._highlightOffset;
    }

    set highlightOffset(v) {
        if (this._highlightOffset !== v) {
            this._highlightOffset = v;
            this._changed();
        }
    }

    get highlightPaddingLeft() {
        return this._highlightPaddingLeft;
    }

    set highlightPaddingLeft(v) {
        if (this._highlightPaddingLeft !== v) {
            this._highlightPaddingLeft = v;
            this._changed();
        }
    }

    get highlightPaddingRight() {
        return this._highlightPaddingRight;
    }

    set highlightPaddingRight(v) {
        if (this._highlightPaddingRight !== v) {
            this._highlightPaddingRight = v;
            this._changed();
        }
    }

    get cutSx() {
        return this._cutSx;
    }

    set cutSx(v) {
        if (this._cutSx !== v) {
            this._cutSx = v;
            this._changed();
        }
    }

    get cutEx() {
        return this._cutEx;
    }

    set cutEx(v) {
        if (this._cutEx !== v) {
            this._cutEx = v;
            this._changed();
        }
    }

    get cutSy() {
        return this._cutSy;
    }

    set cutSy(v) {
        if (this._cutSy !== v) {
            this._cutSy = v;
            this._changed();
        }
    }

    get cutEy() {
        return this._cutEy;
    }

    set cutEy(v) {
        if (this._cutEy !== v) {
            this._cutEy = v;
            this._changed();
        }
    }

    get advancedRenderer() {
        return this._advancedRenderer;
    }

    set advancedRenderer(v) {
        if (this._advancedRenderer !== v) {
            this._advancedRenderer = v;
            this._changed();
        }
    }

    set letterSpacing(v) {
        if (this._letterSpacing !== v) {
            this._letterSpacing = v;
            this._changed();
        }
    }

    get letterSpacing() {
        return this._letterSpacing;
    }

    set textIndent(v) {
        if (this._textIndent !== v) {
            this._textIndent = v;
            this._changed();
        }
    }

    get textIndent() {
        return this._textIndent;
    }

    get precision() {
        return super.precision;
    }

    set precision(v) {
        // We actually draw differently when the precision changes.
        if (this.precision !== v) {
            super.precision = v;
            this._changed();
        }
    }

    _getIsValid() {
        return !!this.text;
    }

    _getLookupId() {
        let parts = [];

        if (this.w !== 0) parts.push("w " + this.w);
        if (this.h !== 0) parts.push("h " + this.h);
        if (this.fontStyle !== "normal") parts.push("fS" + this.fontStyle);
        if (this.fontSize !== 40) parts.push("fs" + this.fontSize);
        if (this.fontFace !== null) parts.push("ff" + (Array.isArray(this.fontFace) ? this.fontFace.join(",") : this.fontFace));
        if (this.wordWrap !== true) parts.push("wr" + (this.wordWrap ? 1 : 0));
        if (this.wordWrapWidth !== 0) parts.push("ww" + this.wordWrapWidth);
        if (this.wordBreak !== false) parts.push("wb" + this.wordBreak ? 1 : 0);
        if (this.textOverflow != "") parts.push("to" + this.textOverflow);
        if (this.lineHeight !== null) parts.push("lh" + this.lineHeight);
        if (this.textBaseline !== "alphabetic") parts.push("tb" + this.textBaseline);
        if (this.textAlign !== "left") parts.push("ta" + this.textAlign);
        if (this.verticalAlign !== "top") parts.push("va" + this.verticalAlign);
        if (this.offsetY !== null) parts.push("oy" + this.offsetY);
        if (this.maxLines !== 0) parts.push("ml" + this.maxLines);
        if (this.maxLinesSuffix !== "..") parts.push("ms" + this.maxLinesSuffix);
        parts.push("pc" + this.precision);
        if (this.textColor !== 0xffffffff) parts.push("co" + this.textColor.toString(16));
        if (this.paddingLeft !== 0) parts.push("pl" + this.paddingLeft);
        if (this.paddingRight !== 0) parts.push("pr" + this.paddingRight);
        if (this.shadow !== false) parts.push("sh" + (this.shadow ? 1 : 0));
        if (this.shadowColor !== 0xff000000) parts.push("sc" + this.shadowColor.toString(16));
        if (this.shadowOffsetX !== 0) parts.push("sx" + this.shadowOffsetX);
        if (this.shadowOffsetY !== 0) parts.push("sy" + this.shadowOffsetY);
        if (this.shadowBlur !== 5) parts.push("sb" + this.shadowBlur);
        if (this.highlight !== false) parts.push("hL" + (this.highlight ? 1 : 0));
        if (this.highlightHeight !== 0) parts.push("hh" + this.highlightHeight);
        if (this.highlightColor !== 0xff000000) parts.push("hc" + this.highlightColor.toString(16));
        if (this.highlightOffset !== null) parts.push("ho" + this.highlightOffset);
        if (this.highlightPaddingLeft !== null) parts.push("hl" + this.highlightPaddingLeft);
        if (this.highlightPaddingRight !== null) parts.push("hr" + this.highlightPaddingRight);
        if (this.letterSpacing !== null) parts.push("ls" + this.letterSpacing);
        if (this.textIndent !== null) parts.push("ti" + this.textIndent);

        if (this.cutSx) parts.push("csx" + this.cutSx);
        if (this.cutEx) parts.push("cex" + this.cutEx);
        if (this.cutSy) parts.push("csy" + this.cutSy);
        if (this.cutEy) parts.push("cey" + this.cutEy);

        if (this.advancedRenderer) parts.push("aR" + this.advancedRenderer ? 1 : 0);

        let id = "TX$" + parts.join("|") + ":" + this.text;
        return id;
    }

    _getSourceLoader() {
        const args = this.cloneArgs();

        // Inherit font face from stage.
        if (args.fontFace === null) {
            args.fontFace = this.stage.getOption('defaultFontFace');
        }

        const gl = this.stage.gl;

        return function (cb) {
            const canvas = this.stage.platform.getDrawingCanvas();
            const renderer = (args.advancedRenderer)
              ? new _TextTextureRendererAdvanced_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this.stage, canvas, args)
              : new _TextTextureRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](this.stage, canvas, args);
            
            const p = renderer.draw();

            const texParams = {};

            const sharpCfg = this.stage.getOption('fontSharp');
            let sharpen = false;

            // Prevent text blur when text texture is downscaled
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isBoolean(sharpCfg)) {
                sharpen = sharpCfg;
            } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(sharpCfg)) {
                const precision = this.stage.getRenderPrecision();
                sharpen = precision <= sharpCfg.precision && args.fontSize <= sharpCfg.fontSize;
            }

            if (gl && sharpen) {
                texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
            }

            if (p) {
                p.then(() => {
                    /* FIXME: on some platforms (e.g. RPI), throttling text textures cause artifacts */
                    cb(null, Object.assign({
                        renderInfo: renderer.renderInfo,
                        throttle: false,
                        texParams: texParams,
                    }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas)));
                }).catch((err) => {
                    cb(err);
                });
            } else {
                cb(null, Object.assign({
                    renderInfo: renderer.renderInfo,
                    throttle: false,
                    texParams: texParams,
                }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas)));
            }
        };
    }


    getNonDefaults() {
        const nonDefaults = super.getNonDefaults();
        if (this.text !== "") nonDefaults['text'] = this.text;
        if (this.w !== 0) nonDefaults['w'] = this.w;
        if (this.h !== 0) nonDefaults['h'] = this.h;
        if (this.fontStyle !== "normal") nonDefaults['fontStyle'] = this.fontStyle;
        if (this.fontSize !== 40) nonDefaults["fontSize"] = this.fontSize;
        if (this.fontFace !== null) nonDefaults["fontFace"] = this.fontFace;
        if (this.wordWrap !== true) nonDefaults["wordWrap"] = this.wordWrap;
        if (this.wordWrapWidth !== 0) nonDefaults["wordWrapWidth"] = this.wordWrapWidth;
        if (this.wordBreak !== false) nonDefaults["wordBreak"] = this.wordBreak;
        if (this.textOverflow != "") nonDefaults["textOverflow"] = this.textOverflow;
        if (this.lineHeight !== null) nonDefaults["lineHeight"] = this.lineHeight;
        if (this.textBaseline !== "alphabetic") nonDefaults["textBaseline"] = this.textBaseline;
        if (this.textAlign !== "left") nonDefaults["textAlign"] = this.textAlign;
        if (this.verticalAlign !== "top") nonDefaults["verticalAlign"] = this.verticalAlign;
        if (this.offsetY !== null) nonDefaults["offsetY"] = this.offsetY;
        if (this.maxLines !== 0) nonDefaults["maxLines"] = this.maxLines;
        if (this.maxLinesSuffix !== "..") nonDefaults["maxLinesSuffix"] = this.maxLinesSuffix;
        if (this.precision !== this.stage.getOption('precision')) nonDefaults["precision"] = this.precision;
        if (this.textColor !== 0xffffffff) nonDefaults["textColor"] = this.textColor;
        if (this.paddingLeft !== 0) nonDefaults["paddingLeft"] = this.paddingLeft;
        if (this.paddingRight !== 0) nonDefaults["paddingRight"] = this.paddingRight;
        if (this.shadow !== false) nonDefaults["shadow"] = this.shadow;
        if (this.shadowColor !== 0xff000000) nonDefaults["shadowColor"] = this.shadowColor;
        if (this.shadowOffsetX !== 0) nonDefaults["shadowOffsetX"] = this.shadowOffsetX;
        if (this.shadowOffsetY !== 0) nonDefaults["shadowOffsetY"] = this.shadowOffsetY;
        if (this.shadowBlur !== 5) nonDefaults["shadowBlur"] = this.shadowBlur;
        if (this.highlight !== false) nonDefaults["highlight"] = this.highlight;
        if (this.highlightHeight !== 0) nonDefaults["highlightHeight"] = this.highlightHeight;
        if (this.highlightColor !== 0xff000000) nonDefaults["highlightColor"] = this.highlightColor;
        if (this.highlightOffset !== 0) nonDefaults["highlightOffset"] = this.highlightOffset;
        if (this.highlightPaddingLeft !== 0) nonDefaults["highlightPaddingLeft"] = this.highlightPaddingLeft;
        if (this.highlightPaddingRight !== 0) nonDefaults["highlightPaddingRight"] = this.highlightPaddingRight;
        if (this.letterSpacing !== 0) nonDefaults["letterSpacing"] = this.letterSpacing;
        if (this.textIndent !== 0) nonDefaults["textIndent"] = this.textIndent;

        if (this.cutSx) nonDefaults["cutSx"] = this.cutSx;
        if (this.cutEx) nonDefaults["cutEx"] = this.cutEx;
        if (this.cutSy) nonDefaults["cutSy"] = this.cutSy;
        if (this.cutEy) nonDefaults["cutEy"] = this.cutEy;

        if (this.advancedRenderer) nonDefaults["renderer"] = this.advancedRenderer;
        return nonDefaults;
    }

    cloneArgs() {
        let obj = {};
        obj.text = this._text;
        obj.w = this._w;
        obj.h = this._h;
        obj.fontStyle = this._fontStyle;
        obj.fontSize = this._fontSize;
        obj.fontFace = this._fontFace;
        obj.wordWrap = this._wordWrap;
        obj.wordWrapWidth = this._wordWrapWidth;
        obj.wordBreak = this._wordBreak;
        obj.textOverflow = this._textOverflow;
        obj.lineHeight = this._lineHeight;
        obj.textBaseline = this._textBaseline;
        obj.textAlign = this._textAlign;
        obj.verticalAlign = this._verticalAlign;
        obj.offsetY = this._offsetY;
        obj.maxLines = this._maxLines;
        obj.maxLinesSuffix = this._maxLinesSuffix;
        obj.precision = this._precision;
        obj.textColor = this._textColor;
        obj.paddingLeft = this._paddingLeft;
        obj.paddingRight = this._paddingRight;
        obj.shadow = this._shadow;
        obj.shadowColor = this._shadowColor;
        obj.shadowOffsetX = this._shadowOffsetX;
        obj.shadowOffsetY = this._shadowOffsetY;
        obj.shadowBlur = this._shadowBlur;
        obj.highlight = this._highlight;
        obj.highlightHeight = this._highlightHeight;
        obj.highlightColor = this._highlightColor;
        obj.highlightOffset = this._highlightOffset;
        obj.highlightPaddingLeft = this._highlightPaddingLeft;
        obj.highlightPaddingRight = this._highlightPaddingRight;
        obj.letterSpacing = this._letterSpacing;
        obj.textIndent = this._textIndent;
        obj.cutSx = this._cutSx;
        obj.cutEx = this._cutEx;
        obj.cutSy = this._cutSy;
        obj.cutEy = this._cutEy;
        obj.advancedRenderer = this._advancedRenderer;
        return obj;
    }


}

// Because there are so many properties, we prefer to use the prototype for default values.
// This causes a decrease in performance, but also a decrease in memory usage.
let proto = TextTexture.prototype;
proto._text = "";
proto._w = 0;
proto._h = 0;
proto._fontStyle = "normal";
proto._fontSize = 40;
proto._fontFace = null;
proto._wordWrap = true;
proto._wordWrapWidth = 0;
proto._wordBreak = false;
proto._textOverflow = "";
proto._lineHeight = null;
proto._textBaseline = "alphabetic";
proto._textAlign = "left";
proto._verticalAlign = "top";
proto._offsetY = null;
proto._maxLines = 0;
proto._maxLinesSuffix = "..";
proto._textColor = 0xFFFFFFFF;
proto._paddingLeft = 0;
proto._paddingRight = 0;
proto._shadow = false;
proto._shadowColor = 0xFF000000;
proto._shadowOffsetX = 0;
proto._shadowOffsetY = 0;
proto._shadowBlur = 5;
proto._highlight = false;
proto._highlightHeight = 0;
proto._highlightColor = 0xFF000000;
proto._highlightOffset = 0;
proto._highlightPaddingLeft = 0;
proto._highlightPaddingRight = 0;
proto._letterSpacing = 0;
proto._textIndent = 0;
proto._cutSx = 0;
proto._cutEx = 0;
proto._cutSy = 0;
proto._cutEy = 0;
proto._advancedRenderer = false;






/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/TextTextureRenderer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/TextTextureRenderer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextTextureRenderer)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class TextTextureRenderer {

    constructor(stage, canvas, settings) {
        this._stage = stage;
        this._canvas = canvas;
        this._context = this._canvas.getContext('2d');
        this._settings = settings;
    }

    getPrecision() {
        return this._settings.precision;
    };

    setFontProperties() {
        this._context.font = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.getFontSetting(this) : this._getFontSetting();
        this._context.textBaseline = this._settings.textBaseline;
    };

    _getFontSetting() {
        let ff = this._settings.fontFace;

        if (!Array.isArray(ff)) {
            ff = [ff];
        }

        let ffs = [];
        for (let i = 0, n = ff.length; i < n; i++) {
            if (ff[i] === "serif" || ff[i] === "sans-serif") {
                ffs.push(ff[i]);
            } else {
                ffs.push(`"${ff[i]}"`);
            }
        }

        return `${this._settings.fontStyle} ${this._settings.fontSize * this.getPrecision()}px ${ffs.join(",")}`
    }

    _load() {
        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isWeb && document.fonts) {
            const fontSetting = this._getFontSetting();
            try {
                if (!document.fonts.check(fontSetting, this._settings.text)) {
                    // Use a promise that waits for loading.
                    return document.fonts.load(fontSetting, this._settings.text).catch(err => {
                        // Just load the fallback font.
                        console.warn('[Lightning] Font load error', err, fontSetting);
                    }).then(() => {
                        if (!document.fonts.check(fontSetting, this._settings.text)) {
                            console.warn('[Lightning] Font not found', fontSetting);
                        }
                    });
                }
            } catch(e) {
                console.warn("[Lightning] Can't check font loading for " + fontSetting);
            }
        }
    }

    draw() {
        // We do not use a promise so that loading is performed syncronous when possible.
        const loadPromise = this._load();
        if (!loadPromise) {
            return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.drawText(this) : this._draw();
        } else {
            return loadPromise.then(() => {
                return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.drawText(this) : this._draw();
            });
        }
    }

    _calculateRenderInfo() {
        let renderInfo = {};

        const precision = this.getPrecision();

        const paddingLeft = this._settings.paddingLeft * precision;
        const paddingRight = this._settings.paddingRight * precision;
        const fontSize = this._settings.fontSize * precision;
        let offsetY = this._settings.offsetY === null ? null : (this._settings.offsetY * precision);
        let lineHeight = this._settings.lineHeight * precision;
        const w = this._settings.w * precision;
        const h = this._settings.h * precision;
        let wordWrapWidth = this._settings.wordWrapWidth * precision;
        const cutSx = this._settings.cutSx * precision;
        const cutEx = this._settings.cutEx * precision;
        const cutSy = this._settings.cutSy * precision;
        const cutEy = this._settings.cutEy * precision;
        const letterSpacing = (this._settings.letterSpacing || 0) * precision;
        const textIndent = this._settings.textIndent * precision;

        // Set font properties.
        this.setFontProperties();

        // Total width.
        let width = w || (2048 / this.getPrecision());

        // Inner width.
        let innerWidth = width - (paddingLeft);
        if (innerWidth < 10) {
            width += (10 - innerWidth);
            innerWidth += (10 - innerWidth);
        }

        if (!wordWrapWidth) {
            wordWrapWidth = innerWidth
        }

        // Text overflow
        if (this._settings.textOverflow && !this._settings.wordWrap) {
            let suffix;
            switch (this._settings.textOverflow) {
                case 'clip':
                    suffix = '';
                    break;
                case 'ellipsis':
                    suffix = this._settings.maxLinesSuffix;
                    break;
                default:
                    suffix = this._settings.textOverflow;
            }
            this._settings.text = this.wrapWord(this._settings.text, wordWrapWidth - textIndent, suffix)
        }

        // word wrap
        // preserve original text
        let linesInfo;
        if (this._settings.wordWrap) {
            linesInfo = this.wrapText(this._settings.text, wordWrapWidth, letterSpacing, textIndent);
        } else {
            linesInfo = {l: this._settings.text.split(/(?:\r\n|\r|\n)/), n: []};
            let i, n = linesInfo.l.length;
            for (let i = 0; i < n - 1; i++) {
                linesInfo.n.push(i);
            }
        }
        let lines = linesInfo.l;

        if (this._settings.maxLines && lines.length > this._settings.maxLines) {
            let usedLines = lines.slice(0, this._settings.maxLines);

            let otherLines = null;
            if (this._settings.maxLinesSuffix) {
                // Wrap again with max lines suffix enabled.
                let w = this._settings.maxLinesSuffix ? this.measureText(this._settings.maxLinesSuffix) : 0;
                let al = this.wrapText(usedLines[usedLines.length - 1], wordWrapWidth - w, letterSpacing, textIndent);
                usedLines[usedLines.length - 1] = al.l[0] + this._settings.maxLinesSuffix;
                otherLines = [al.l.length > 1 ? al.l[1] : ''];
            } else {
                otherLines = [''];
            }

            // Re-assemble the remaining text.
            let i, n = lines.length;
            let j = 0;
            let m = linesInfo.n.length;
            for (i = this._settings.maxLines; i < n; i++) {
                otherLines[j] += (otherLines[j] ? " " : "") + lines[i];
                if (i + 1 < m && linesInfo.n[i + 1]) {
                    j++;
                }
            }

            renderInfo.remainingText = otherLines.join("\n");

            renderInfo.moreTextLines = true;

            lines = usedLines;
        } else {
            renderInfo.moreTextLines = false;
            renderInfo.remainingText = "";
        }

        // calculate text width
        let maxLineWidth = 0;
        let lineWidths = [];
        for (let i = 0; i < lines.length; i++) {
            let lineWidth = this.measureText(lines[i], letterSpacing) + (i === 0 ? textIndent : 0);
            lineWidths.push(lineWidth);
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }

        renderInfo.lineWidths = lineWidths;

        if (!w) {
            // Auto-set width to max text length.
            width = maxLineWidth + paddingLeft + paddingRight;
            innerWidth = maxLineWidth;
        }

        // calculate text height
        lineHeight = lineHeight || fontSize;

        let height;
        if (h) {
            height = h;
        } else {
            const baselineOffset = (this._settings.textBaseline != 'bottom') ? 0.5 * fontSize : 0;
            height = lineHeight * (lines.length - 1) + baselineOffset + Math.max(lineHeight, fontSize) + offsetY;
        }

        if (offsetY === null) {
            offsetY = fontSize;
        }

        renderInfo.w = width;
        renderInfo.h = height;
        renderInfo.lines = lines;
        renderInfo.precision = precision;

        if (!width) {
            // To prevent canvas errors.
            width = 1;
        }

        if (!height) {
            // To prevent canvas errors.
            height = 1;
        }

        if (cutSx || cutEx) {
            width = Math.min(width, cutEx - cutSx);
        }

        if (cutSy || cutEy) {
            height = Math.min(height, cutEy - cutSy);
        }

        renderInfo.width = width;
        renderInfo.innerWidth = innerWidth;
        renderInfo.height = height;
        renderInfo.fontSize = fontSize;
        renderInfo.cutSx = cutSx;
        renderInfo.cutSy = cutSy;
        renderInfo.cutEx = cutEx;
        renderInfo.cutEy = cutEy;
        renderInfo.lineHeight = lineHeight;
        renderInfo.lineWidths = lineWidths;
        renderInfo.offsetY = offsetY;
        renderInfo.paddingLeft = paddingLeft;
        renderInfo.paddingRight = paddingRight;
        renderInfo.letterSpacing = letterSpacing;
        renderInfo.textIndent = textIndent;

        return renderInfo;
    }

    _draw() {
        const renderInfo = this._calculateRenderInfo();
        const precision = this.getPrecision();

        // Add extra margin to prevent issue with clipped text when scaling.
        this._canvas.width = Math.ceil(renderInfo.width + this._stage.getOption('textRenderIssueMargin'));
        this._canvas.height = Math.ceil(renderInfo.height);

        // Canvas context has been reset.
        this.setFontProperties();

        if (renderInfo.fontSize >= 128) {
            // WpeWebKit bug: must force compositing because cairo-traps-compositor will not work with text first.
            this._context.globalAlpha = 0.01;
            this._context.fillRect(0, 0, 0.01, 0.01);
            this._context.globalAlpha = 1.0;
        }

        if (renderInfo.cutSx || renderInfo.cutSy) {
            this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
        }

        let linePositionX;
        let linePositionY;

        let drawLines = [];

        // Draw lines line by line.
        for (let i = 0, n = renderInfo.lines.length; i < n; i++) {
            linePositionX = i === 0 ? renderInfo.textIndent : 0;

            // By default, text is aligned to top
            linePositionY = (i * renderInfo.lineHeight) + renderInfo.offsetY;

            if (this._settings.verticalAlign == 'middle') {
                linePositionY += (renderInfo.lineHeight - renderInfo.fontSize) / 2;
            } else if (this._settings.verticalAlign == 'bottom') {
                linePositionY += renderInfo.lineHeight - renderInfo.fontSize;
            }

            if (this._settings.textAlign === 'right') {
                linePositionX += (renderInfo.innerWidth - renderInfo.lineWidths[i]);
            } else if (this._settings.textAlign === 'center') {
                linePositionX += ((renderInfo.innerWidth - renderInfo.lineWidths[i]) / 2);
            }
            linePositionX += renderInfo.paddingLeft;

            drawLines.push({text: renderInfo.lines[i], x: linePositionX, y: linePositionY, w: renderInfo.lineWidths[i]});
        }

        // Highlight.
        if (this._settings.highlight) {
            let color = this._settings.highlightColor || 0x00000000;

            let hlHeight = (this._settings.highlightHeight * precision || renderInfo.fontSize * 1.5);
            const offset = this._settings.highlightOffset * precision;
            const hlPaddingLeft = (this._settings.highlightPaddingLeft !== null ? this._settings.highlightPaddingLeft * precision : renderInfo.paddingLeft);
            const hlPaddingRight = (this._settings.highlightPaddingRight !== null ? this._settings.highlightPaddingRight * precision : renderInfo.paddingRight);

            this._context.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(color);
            for (let i = 0; i < drawLines.length; i++) {
                let drawLine = drawLines[i];
                this._context.fillRect((drawLine.x - hlPaddingLeft), (drawLine.y - renderInfo.offsetY + offset), (drawLine.w + hlPaddingRight + hlPaddingLeft), hlHeight);
            }
        }

        // Text shadow.
        let prevShadowSettings = null;
        if (this._settings.shadow) {
            prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];

            this._context.shadowColor = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.shadowColor);
            this._context.shadowOffsetX = this._settings.shadowOffsetX * precision;
            this._context.shadowOffsetY = this._settings.shadowOffsetY * precision;
            this._context.shadowBlur = this._settings.shadowBlur * precision;
        }

        this._context.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.textColor);
        for (let i = 0, n = drawLines.length; i < n; i++) {
            let drawLine = drawLines[i];

            if (renderInfo.letterSpacing === 0) {
                this._context.fillText(drawLine.text, drawLine.x, drawLine.y);
            } else {
                const textSplit = drawLine.text.split('');
                let x = drawLine.x;
                for (let i = 0, j = textSplit.length; i < j; i++) {
                    this._context.fillText(textSplit[i], x, drawLine.y);
                    x += this.measureText(textSplit[i], renderInfo.letterSpacing);
                }
            }
        }

        if (prevShadowSettings) {
            this._context.shadowColor = prevShadowSettings[0];
            this._context.shadowOffsetX = prevShadowSettings[1];
            this._context.shadowOffsetY = prevShadowSettings[2];
            this._context.shadowBlur = prevShadowSettings[3];
        }

        if (renderInfo.cutSx || renderInfo.cutSy) {
            this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
        }

        this.renderInfo = renderInfo;
    };

    wrapWord(word, wordWrapWidth, suffix) {
        const suffixWidth = this._context.measureText(suffix).width;
        const wordLen = word.length
        const wordWidth = this._context.measureText(word).width;

        /* If word fits wrapWidth, do nothing */
        if (wordWidth <= wordWrapWidth) {
            return word;
        }

        /* Make initial guess for text cuttoff */
        let cutoffIndex = Math.floor((wordWrapWidth * wordLen) / wordWidth);
        let truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;

        /* In case guess was overestimated, shrink it letter by letter. */
        if (truncWordWidth > wordWrapWidth) {
            while (cutoffIndex > 0) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth > wordWrapWidth) {
                    cutoffIndex -= 1;
                } else {
                    break;
                }
            }

        /* In case guess was underestimated, extend it letter by letter. */
        } else {
            while (cutoffIndex < wordLen) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth < wordWrapWidth) {
                    cutoffIndex += 1;
                } else {
                    // Finally, when bound is crossed, retract last letter.
                    cutoffIndex -=1;
                    break;
                }
            }
        }

        /* If wrapWidth is too short to even contain suffix alone, return empty string */
        return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : '');
    }

    /**
     * Applies newlines to a string to have it optimally fit into the horizontal
     * bounds set by the Text object's wordWrapWidth property.
     */
    wrapText(text, wordWrapWidth, letterSpacing, indent = 0) {
        // Greedy wrapping algorithm that will wrap words as the line grows longer.
        // than its horizontal bounds.
        let lines = text.split(/\r?\n/g);
        let allLines = [];
        let realNewlines = [];
        for (let i = 0; i < lines.length; i++) {
            let resultLines = [];
            let result = '';
            let spaceLeft = wordWrapWidth - indent;
            let words = lines[i].split(' ');
            for (let j = 0; j < words.length; j++) {
                const wordWidth = this.measureText(words[j], letterSpacing);
                const wordWidthWithSpace = wordWidth + this.measureText(' ',letterSpacing);
                if (j === 0 || wordWidthWithSpace > spaceLeft) {
                    // Skip printing the newline if it's the first word of the line that is.
                    // greater than the word wrap width.
                    if (j > 0) {
                        resultLines.push(result);
                        result = '';
                    }
                    result += words[j];
                    spaceLeft = wordWrapWidth - wordWidth - (j === 0 ? indent : 0);
                }
                else {
                    spaceLeft -= wordWidthWithSpace;
                    result += ' ' + words[j];
                }
            }

            resultLines.push(result);
            result = '';

            allLines = allLines.concat(resultLines);

            if (i < lines.length - 1) {
                realNewlines.push(allLines.length);
            }
        }

        return {l: allLines, n: realNewlines};
    };

    measureText(word, space = 0) {
        if (!space) {
            return this._context.measureText(word).width;
        }
        return word.split('').reduce((acc, char) => {
            return acc + this._context.measureText(char).width + space;
        }, 0);
    }
    
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/TextTextureRendererAdvanced.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/TextTextureRendererAdvanced.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextTextureRendererAdvanced)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class TextTextureRendererAdvanced {

    constructor(stage, canvas, settings) {
        this._stage = stage;
        this._canvas = canvas;
        this._context = this._canvas.getContext('2d');
        this._settings = settings;
    }

    getPrecision() {
        return this._settings.precision;
    };

    setFontProperties() {
        const font = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.getFontSetting(this) : this._getFontSetting();
        this._context.font = font;
        this._context.textBaseline = this._settings.textBaseline;
        return font;
    };

    _getFontSetting() {
        let ff = this._settings.fontFace;

        if (!Array.isArray(ff)) {
            ff = [ff];
        }

        let ffs = [];
        for (let i = 0, n = ff.length; i < n; i++) {
            if (ff[i] === "serif" || ff[i] === "sans-serif") {
                ffs.push(ff[i]);
            } else {
                ffs.push(`"${ff[i]}"`);
            }
        }

        return `${this._settings.fontStyle} ${this._settings.fontSize * this.getPrecision()}px ${ffs.join(",")}`
    }

    _load() {
        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isWeb && document.fonts) {
            const fontSetting = this._getFontSetting();
            try {
                if (!document.fonts.check(fontSetting, this._settings.text)) {
                    // Use a promise that waits for loading.
                    return document.fonts.load(fontSetting, this._settings.text).catch(err => {
                        // Just load the fallback font.
                        console.warn('Font load error', err, fontSetting);
                    }).then(() => {
                        if (!document.fonts.check(fontSetting, this._settings.text)) {
                            console.warn('Font not found', fontSetting);
                        }
                    });
                }
            } catch(e) {
                console.warn("Can't check font loading for " + fontSetting);
            }
        }
    }

    draw() {
        // We do not use a promise so that loading is performed syncronous when possible.
        const loadPromise = this._load();
        if (!loadPromise) {
            return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.drawText(this) : this._draw();
        } else {
            return loadPromise.then(() => {
                return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.drawText(this) : this._draw();
            });
        }
    }

    _calculateRenderInfo() {
        let renderInfo = {};

        const precision = this.getPrecision();

        const paddingLeft = this._settings.paddingLeft * precision;
        const paddingRight = this._settings.paddingRight * precision;
        const fontSize = this._settings.fontSize * precision;
        // const offsetY = this._settings.offsetY === null ? null : (this._settings.offsetY * precision);
        const lineHeight = this._settings.lineHeight * precision || fontSize;
        const w = this._settings.w != 0 ? this._settings.w * precision : 2048 / precision;
        // const h = this._settings.h * precision;
        const wordWrapWidth = this._settings.wordWrapWidth * precision;
        const cutSx = this._settings.cutSx * precision;
        const cutEx = this._settings.cutEx * precision;
        const cutSy = this._settings.cutSy * precision;
        const cutEy = this._settings.cutEy * precision;
        const letterSpacing = this._settings.letterSpacing || 0;

        // Set font properties.
        renderInfo.baseFont = this.setFontProperties();

        renderInfo.w = w;
        renderInfo.width = w;
        renderInfo.text = this._settings.text;
        renderInfo.precision = precision;
        renderInfo.fontSize = fontSize;
        renderInfo.lineHeight = lineHeight;
        renderInfo.letterSpacing = letterSpacing;
        renderInfo.textAlign = this._settings.textAlign;
        renderInfo.textColor = this._settings.textColor;
        renderInfo.verticalAlign = this._settings.verticalAlign;
        renderInfo.highlight = this._settings.highlight;
        renderInfo.highlightColor = this._settings.highlightColor;
        renderInfo.highlightHeight = this._settings.highlightHeight;
        renderInfo.highlightPaddingLeft = this._settings.highlightPaddingLeft;
        renderInfo.highlightPaddingRight = this._settings.highlightPaddingRight;
        renderInfo.highlightOffset = this._settings.highlightOffset;
        renderInfo.paddingLeft = this._settings.paddingLeft;
        renderInfo.paddingRight = this._settings.paddingRight;
        renderInfo.maxLines = this._settings.maxLines;
        renderInfo.maxLinesSuffix = this._settings.maxLinesSuffix;
        renderInfo.textOverflow = this._settings.textOverflow;
        renderInfo.wordWrap = this._settings.wordWrap;
        renderInfo.wordWrapWidth = wordWrapWidth;
        renderInfo.shadow = this._settings.shadow;
        renderInfo.shadowColor = this._settings.shadowColor;
        renderInfo.shadowOffsetX = this._settings.shadowOffsetX;
        renderInfo.shadowOffsetY = this._settings.shadowOffsetY;
        renderInfo.shadowBlur = this._settings.shadowBlur;
        renderInfo.cutSx = cutSx;
        renderInfo.cutEx = cutEx;
        renderInfo.cutSy = cutSy;
        renderInfo.cutEy = cutEy;
        renderInfo.textIndent = this._settings.textIndent * precision;
        renderInfo.wordBreak = this._settings.wordBreak;

        let text = renderInfo.text;
        let wrapWidth = renderInfo.wordWrap ? (renderInfo.wordWrapWidth || renderInfo.width) : renderInfo.width;

        // Text overflow
        if (renderInfo.textOverflow && !renderInfo.wordWrap) {
            let suffix;
            switch (this._settings.textOverflow) {
                case 'clip':
                    suffix = '';
                    break;
                case 'ellipsis':
                    suffix = this._settings.maxLinesSuffix;
                    break;
                default:
                    suffix = this._settings.textOverflow;
            }
            text = this.wrapWord(text, wordWrapWidth || renderInfo.w, suffix);
        }

        text = this.tokenize(text);
        text = this.parse(text);
        text = this.measure(text, letterSpacing, renderInfo.baseFont);

        if (renderInfo.textIndent) {
            text = this.indent(text, renderInfo.textIndent);
        }

        if (renderInfo.wordBreak) {
            text = text.reduce((acc, t) => acc.concat(this.wordBreak(t, wrapWidth, renderInfo.baseFont)), [])
            this.resetFontStyle()
        }

        // Calculate detailed drawing information
        let x = paddingLeft;
        let lineNo = 0;

        for (const t of text) {
            // Wrap text
            if (renderInfo.wordWrap && x + t.width > wrapWidth || t.text == '\n') {
                x = paddingLeft;
                lineNo += 1;
            }
            t.lineNo = lineNo;

            if (t.text == '\n') {
                continue;
            }

            t.x = x;
            x += t.width;
        }
        renderInfo.lineNum = lineNo + 1;

        // Vertical align
        let vaOffset = 0;
        if (renderInfo.verticalAlign == 'middle') {
            vaOffset += (renderInfo.lineHeight - renderInfo.fontSize) / 2;
        } else if (this._settings.verticalAlign == 'bottom') {
            vaOffset += renderInfo.lineHeight - renderInfo.fontSize;
        }

        // Calculate lines information
        renderInfo.lines = []
        for (let i = 0; i < renderInfo.lineNum; i++) {
            renderInfo.lines[i] = {
                width: 0,
                x: 0,
                y: renderInfo.lineHeight * i + vaOffset,
                text: [],
            }
        }

        for (let t of text) {
            renderInfo.lines[t.lineNo].text.push(t);
        }

        // Filter out white spaces at beginning and end of each line
        for (const l of renderInfo.lines) {
            if (l.text.length == 0) {
                continue;
            }

            const firstWord = l.text[0].text;
            const lastWord = l.text[l.text.length - 1].text;

            if (firstWord == '\n') {
                l.text.shift();
            }
            if (lastWord == ' ' || lastWord == '\n') {
                l.text.pop();
            }
        }


        // Calculate line width
        for (let l of renderInfo.lines) {
            l.width = l.text.reduce((acc, t) => acc + t.width, 0);
        }

        renderInfo.width = this._settings.w != 0 ? this._settings.w * precision : Math.max(...renderInfo.lines.map((l) => l.width)) + paddingRight;
        renderInfo.w = renderInfo.width;

        // Apply maxLinesSuffix
        if (renderInfo.maxLines && renderInfo.lineNum > renderInfo.maxLines && renderInfo.maxLinesSuffix) {
            const index = renderInfo.maxLines - 1;
            let lastLineText = text.filter((t) => t.lineNo == index)
            let suffix = renderInfo.maxLinesSuffix;
            suffix = this.tokenize(suffix);
            suffix = this.parse(suffix);
            suffix = this.measure(suffix, renderInfo.letterSpacing, renderInfo.baseFont)[0];
            suffix.lineNo = index;
            if (lastLineText.length) {
                suffix.x = lastLineText[lastLineText.length - 1].x + lastLineText[lastLineText.length - 1].width;
            } else {
                suffix.x = 0;
            }
            lastLineText.push(suffix)

            let _w = lastLineText.reduce((acc, t) => acc + t.width, 0);
            while (_w > renderInfo.width || lastLineText[lastLineText.length - 2].text == ' ') {
                lastLineText.splice(lastLineText.length - 2, 1);
                _w = lastLineText.reduce((acc, t) => acc + t.width, 0);
                const prev = lastLineText[lastLineText.length - 2] || {x: 0, width: 0}
                suffix.x = prev.x + prev.width;
                if (lastLineText.length < 2) {
                    break;
                }
            }

            renderInfo.lines[index].text = lastLineText;
            renderInfo.lines[index].width = _w;
        }

        if (this._settings.h) {
            renderInfo.h = this._settings.h;
        } else if (renderInfo.maxLines && renderInfo.maxLines < renderInfo.lineNum) {
            renderInfo.h = renderInfo.maxLines * renderInfo.lineHeight + fontSize / 2;
        } else {
            renderInfo.h = renderInfo.lineNum * renderInfo.lineHeight + fontSize / 2;
        }

        // Horizontal alignment offset
        if (renderInfo.textAlign == 'center') {
            for (let l of renderInfo.lines) {
                l.x = (renderInfo.width - l.width - paddingLeft) / 2;
            }
        } else if (renderInfo.textAlign == 'right') {
            for (let l of renderInfo.lines) {
                l.x = renderInfo.width - l.width - paddingLeft;
            }
        }

        return renderInfo;
    }

    _draw() {
        const renderInfo = this._calculateRenderInfo();
        const precision = this.getPrecision();
        const paddingLeft = renderInfo.paddingLeft * precision;

        // Set canvas dimensions
        let canvasWidth = renderInfo.w || renderInfo.width;
        if (renderInfo.cutSx || renderInfo.cutEx) {
            canvasWidth = Math.min(renderInfo.w, renderInfo.cutEx - renderInfo.cutSx);
        }

        let canvasHeight = renderInfo.h;
        if (renderInfo.cutSy || renderInfo.cutEy) {
            canvasHeight = Math.min(renderInfo.h, renderInfo.cutEy - renderInfo.cutSy);
        }

        this._canvas.width = Math.ceil(canvasWidth + this._stage.getOption('textRenderIssueMargin'));
        this._canvas.height = Math.ceil(canvasHeight);

        // Canvas context has been reset.
        this.setFontProperties();

        if (renderInfo.fontSize >= 128) {
            // WpeWebKit bug: must force compositing because cairo-traps-compositor will not work with text first.
            this._context.globalAlpha = 0.01;
            this._context.fillRect(0, 0, 0.01, 0.01);
            this._context.globalAlpha = 1.0;
        }

        // Cut
        if (renderInfo.cutSx || renderInfo.cutSy) {
            this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
        }

        // Highlight
        if (renderInfo.highlight) {
            const hlColor = renderInfo.highlightColor || 0x00000000;
            const hlHeight = renderInfo.highlightHeight ? renderInfo.highlightHeight * precision :  renderInfo.fontSize * 1.5;
            const hlOffset = renderInfo.highlightOffset ? renderInfo.highlightOffset * precision : 0;
            const hlPaddingLeft = (renderInfo.highlightPaddingLeft !== null ? renderInfo.highlightPaddingLeft * precision : renderInfo.paddingLeft);
            const hlPaddingRight = (renderInfo.highlightPaddingRight !== null ? renderInfo.highlightPaddingRight * precision : renderInfo.paddingRight);

            this._context.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(hlColor);
            const lineNum = renderInfo.maxLines ? Math.min(renderInfo.maxLines, renderInfo.lineNum) : renderInfo.lineNum; 
            for (let i = 0; i < lineNum; i++) {
                const l = renderInfo.lines[i];
                this._context.fillRect(l.x - hlPaddingLeft + paddingLeft, l.y + hlOffset, l.width + hlPaddingLeft + hlPaddingRight, hlHeight);
            }
        }

        // Text shadow.
        let prevShadowSettings = null;
        if (this._settings.shadow) {
            prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];

            this._context.shadowColor = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.shadowColor);
            this._context.shadowOffsetX = this._settings.shadowOffsetX * precision;
            this._context.shadowOffsetY = this._settings.shadowOffsetY * precision;
            this._context.shadowBlur = this._settings.shadowBlur * precision;
        }

        // Draw text
        const defaultColor = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.textColor);
        let currentColor = defaultColor;
        this._context.fillStyle = defaultColor;
        for (const line of renderInfo.lines) {
            for (const t of line.text) {
                let lx = 0;

                if (t.text == '\n') {
                    continue;
                }

                if (renderInfo.maxLines && t.lineNo >= renderInfo.maxLines) {
                    continue;
                }

                if (t.color != currentColor) {
                    currentColor = t.color;
                    this._context.fillStyle = currentColor;
                }

                this._context.font = t.fontStyle;

                // Draw with letter spacing
                if (t.letters) {
                    for (let l of t.letters) {
                        const _x = renderInfo.lines[t.lineNo].x + t.x + lx;
                        this._context.fillText(l.text, _x, renderInfo.lines[t.lineNo].y + renderInfo.fontSize);
                        lx += l.width;
                    }
                // Standard drawing
                } else {
                    const _x = renderInfo.lines[t.lineNo].x + t.x;
                    this._context.fillText(t.text, _x, renderInfo.lines[t.lineNo].y + renderInfo.fontSize);
                }
            }
        }

        // Reset text shadow
        if (prevShadowSettings) {
            this._context.shadowColor = prevShadowSettings[0];
            this._context.shadowOffsetX = prevShadowSettings[1];
            this._context.shadowOffsetY = prevShadowSettings[2];
            this._context.shadowBlur = prevShadowSettings[3];
        }

        // Reset cut translation
        if (renderInfo.cutSx || renderInfo.cutSy) {
            this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
        }
 
        // Postprocess renderInfo.lines to be compatible with standard version
        renderInfo.lines = renderInfo.lines.map((l) => l.text.reduce((acc, v) => acc + v.text, ''));
        if (renderInfo.maxLines) {
            renderInfo.lines = renderInfo.lines.slice(0, renderInfo.maxLines);
        }


        this.renderInfo = renderInfo;

    };

    measureText(word, space = 0) {
        if (!space) {
            return this._context.measureText(word).width;
        }
        return word.split('').reduce((acc, char) => {
            return acc + this._context.measureText(char).width + space;
        }, 0);
    }

    tokenize(text) {
        const re =/ |\n|<i>|<\/i>|<b>|<\/b>|<color=0[xX][0-9a-fA-F]{8}>|<\/color>/g
    
        const delimeters = text.match(re) || [];
        const words = text.split(re) || [];
    
        let final = [];
        for (let i = 0; i < words.length; i++) {
            final.push(words[i], delimeters[i])
        }
        final.pop()
        return final.filter((word) => word != '');
    
    }
    
    parse(tokens) {
        let italic = 0;
        let bold = 0;
        let colorStack = [_tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.textColor)];
        let color = 0;

        const colorRegexp = /<color=(?<color>0[xX][0-9a-fA-F]{8})/;
    
        return tokens.map((t) => {
            if (t == '<i>') {
                italic += 1;
                t = '';
            } else if (t == '</i>' && italic > 0) {
                italic -= 1;
                t = '';
            } else if (t == '<b>') {
                bold += 1;
                t = '';
            } else if (t == '</b>' && bold > 0) {
                bold -= 1;
                t = '';
            } else if (t == '</color>') {
                if (colorStack.length > 1) {
                    color -= 1;
                    colorStack.pop();
                }
                t = '';
            } else if (colorRegexp.test(t)) {
                colorStack.push(_tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(parseInt(colorRegexp.exec(t).groups['color'])));
                color += 1;
                t = '';
            }

            return {
                text: t,
                italic: italic,
                bold: bold,
                color: colorStack[color],
            }
        })
        .filter((o) => o.text != '');
    }

    applyFontStyle(word, baseFont) {
        let font = baseFont;
        if (word.bold) {
            font = 'bold ' + font;
        }
        if (word.italic) {
            font = 'italic ' + font;
        }
        this._context.font = font
        word.fontStyle = font;
    }

    resetFontStyle(baseFont) {
        this._context.font = baseFont;
    }

    measure(parsed, letterSpacing = 0, baseFont) {
        for (const p of parsed) {
            this.applyFontStyle(p, baseFont);
            p.width = this.measureText(p.text, letterSpacing);

            // Letter by letter detail for letter spacing
            if (letterSpacing > 0) {
                p.letters = p.text.split('').map((l) => {return {text: l}});
                for (let l of p.letters) {
                    l.width = this.measureText(l.text, letterSpacing);
                }
            }

        }
        this.resetFontStyle(baseFont);
        return parsed;
    }

    indent(parsed, textIndent) {
        parsed.splice(0, 0, {text: "", width: textIndent});
        return parsed;
    }

    wrapWord(word, wordWrapWidth, suffix) {
        const suffixWidth = this._context.measureText(suffix).width;
        const wordLen = word.length
        const wordWidth = this._context.measureText(word).width;

        /* If word fits wrapWidth, do nothing */
        if (wordWidth <= wordWrapWidth) {
            return word;
        }

        /* Make initial guess for text cuttoff */
        let cutoffIndex = Math.floor((wordWrapWidth * wordLen) / wordWidth);
        let truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;

        /* In case guess was overestimated, shrink it letter by letter. */
        if (truncWordWidth > wordWrapWidth) {
            while (cutoffIndex > 0) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth > wordWrapWidth) {
                    cutoffIndex -= 1;
                } else {
                    break;
                }
            }

        /* In case guess was underestimated, extend it letter by letter. */
        } else {
            while (cutoffIndex < wordLen) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth < wordWrapWidth) {
                    cutoffIndex += 1;
                } else {
                    // Finally, when bound is crossed, retract last letter.
                    cutoffIndex -=1;
                    break;
                }
            }
        }

        /* If wrapWidth is too short to even contain suffix alone, return empty string */
        return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : '')
    }

    _getBreakIndex(word, width) {
        const wordLen = word.length;
        const wordWidth = this.measureText(word);

        if (wordWidth <= width) {
            return {breakIndex: word.length, truncWordWidth: wordWidth};
        }

        let breakIndex = Math.floor((width * wordLen) / wordWidth);
        let truncWordWidth = this.measureText(word.substring(0, breakIndex))

        /* In case guess was overestimated, shrink it letter by letter. */
        if (truncWordWidth > width) {
            while (breakIndex > 0) {
                truncWordWidth = this.measureText(word.substring(0, breakIndex));
                if (truncWordWidth > width) {
                    breakIndex -= 1;
                } else {
                    break;
                }
            }

        /* In case guess was underestimated, extend it letter by letter. */
        } else {
            while (breakIndex < wordLen) {
                truncWordWidth = this.measureText(word.substring(0, breakIndex));
                if (truncWordWidth < width) {
                    breakIndex += 1;
                } else {
                    // Finally, when bound is crossed, retract last letter.
                    breakIndex -=1;
                    truncWordWidth = this.measureText(word.substring(0, breakIndex));
                    break;
                }
            }
        }
        return {breakIndex, truncWordWidth};

    }

    wordBreak(word, width, baseFont) {
        if (!word.text) {
            return word
        }
        this.applyFontStyle(word, baseFont)
        const parts = [];
        let text = word.text;
        if (!word.letters) {
            while (true) {
                const {breakIndex, truncWordWidth} = this._getBreakIndex(text, width);
                parts.push({...word});
                parts[parts.length - 1].text = text.slice(0, breakIndex);
                parts[parts.length - 1].width = truncWordWidth;

                if (breakIndex === text.length) {
                    break;
                }

                text = text.slice(breakIndex);
            }
        } else {
            let totalWidth = 0;
            let letters = [];
            let breakIndex = 0;
            for (const l of word.letters) {
                if (totalWidth + l.width >= width) {
                    parts.push({...word});
                    parts[parts.length - 1].text = text.slice(0, breakIndex);
                    parts[parts.length - 1].width = totalWidth;
                    parts[parts.length - 1].letters = letters;
                    text = text.slice(breakIndex);
                    totalWidth = 0;
                    letters = [];
                    breakIndex = 0;

                } else {
                    breakIndex += 1;
                    letters.push(l);
                    totalWidth += l.width;
                }
            }

            if (totalWidth > 0) {
                parts.push({...word});
                parts[parts.length - 1].text = text.slice(0, breakIndex);
                parts[parts.length - 1].width = totalWidth;
                parts[parts.length - 1].letters = letters;
            }
        }

        return parts;
    }
}

/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/MultiSpline.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/MultiSpline.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MultiSpline)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class MultiSpline {

    constructor() {
        this._clear();
    }

    _clear() {
        this._p = [];
        this._pe = [];
        this._idp = [];
        this._f = [];
        this._v = [];
        this._lv = [];
        this._sm = [];
        this._s = [];
        this._ve = [];
        this._sme = [];
        this._se = [];

        this._length = 0;
    }

    parse(rgba, def) {
        let i, n;
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(def)) {
            def = {0: def}
        }

        let defaultSmoothness = 0.5;

        let items = [];
        for (let key in def) {
            if (def.hasOwnProperty(key)) {
                let obj = def[key];
                if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(obj)) {
                    obj = {v: obj}
                }

                let p = parseFloat(key);

                if (key === "sm") {
                    defaultSmoothness = obj.v;
                } else if (!isNaN(p) && p >= 0 && p <= 2) {
                    obj.p = p;

                    obj.f = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(obj.v);
                    obj.lv = obj.f ? obj.v(0, 0) : obj.v;

                    items.push(obj);
                }
            }
        }

        // Sort by progress value.
        items = items.sort(function(a, b) {return a.p - b.p});

        n = items.length;

        for (i = 0; i < n; i++) {
            let last = (i === n - 1);
            if (!items[i].hasOwnProperty('pe')) {
                // Progress.
                items[i].pe = last ? (items[i].p <= 1 ? 1 : 2 /* support onetotwo stop */) : items[i + 1].p;
            } else {
                // Prevent multiple items at the same time.
                const max = i < n - 1 ? items[i + 1].p : 1;
                if (items[i].pe > max) {
                    items[i].pe = max;
                }
            }
            if (items[i].pe === items[i].p) {
                items[i].idp = 0;
            } else {
                items[i].idp = 1 / (items[i].pe - items[i].p);
            }
        }

        // Color merger: we need to split/combine RGBA components.

        // Calculate bezier helper values.;
        for (i = 0; i < n; i++) {
            if (!items[i].hasOwnProperty('sm')) {
                // Smoothness.;
                items[i].sm = defaultSmoothness;
            }
            if (!items[i].hasOwnProperty('s')) {
                // Slope.;
                if (i === 0 || i === n - 1 || (items[i].p === 1 /* for onetotwo */)) {
                    // Horizontal slope at start and end.;
                    items[i].s = rgba ? [0, 0, 0, 0] : 0;
                } else {
                    const pi = items[i - 1];
                    const ni = items[i + 1];
                    if (pi.p === ni.p) {
                        items[i].s = rgba ? [0, 0, 0, 0] : 0;
                    } else {
                        if (rgba) {
                            const nc = MultiSpline.getRgbaComponents(ni.lv);
                            const pc = MultiSpline.getRgbaComponents(pi.lv);
                            const d = 1 / (ni.p - pi.p);
                            items[i].s = [
                                d * (nc[0] - pc[0]),
                                d * (nc[1] - pc[1]),
                                d * (nc[2] - pc[2]),
                                d * (nc[3] - pc[3])
                            ];
                        } else {
                            items[i].s = (ni.lv - pi.lv) / (ni.p - pi.p);
                        }
                    }
                }
            }
        }

        for (i = 0; i < n - 1; i++) {
            // Calculate value function.;
            if (!items[i].f) {

                let last = (i === n - 1);
                if (!items[i].hasOwnProperty('ve')) {
                    items[i].ve = last ? items[i].lv : items[i + 1].lv;
                }

                // We can only interpolate on numeric values. Non-numeric values are set literally when reached time.
                if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(items[i].v) && _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(items[i].lv)) {
                    if (!items[i].hasOwnProperty('sme')) {
                        items[i].sme = last ? defaultSmoothness : items[i + 1].sm;
                    }
                    if (!items[i].hasOwnProperty('se')) {
                        items[i].se = last ? (rgba ? [0, 0, 0, 0] : 0) : items[i + 1].s;
                    }

                    // Generate spline.;
                    if (rgba) {
                        items[i].v = MultiSpline.getSplineRgbaValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
                    } else {
                        items[i].v = MultiSpline.getSplineValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
                    }

                    items[i].f = true;
                }
            }
        }

        if (this.length) {
            this._clear();
        }

        for (i = 0, n = items.length; i < n; i++) {
            this._add(items[i]);
        }
    }

    _add(item) {
        this._p.push(item.p || 0);
        this._pe.push(item.pe || 0);
        this._idp.push(item.idp || 0);
        this._f.push(item.f || false);
        this._v.push(item.hasOwnProperty('v') ? item.v : 0 /* v might be false or null */ );
        this._lv.push(item.lv || 0);
        this._sm.push(item.sm || 0);
        this._s.push(item.s || 0);
        this._ve.push(item.ve || 0);
        this._sme.push(item.sme || 0);
        this._se.push(item.se || 0);
        this._length++;
    }

    _getItem(p) {
        const n = this._length;
        if (!n) {
            return -1;
        }

        if (p < this._p[0]) {
            return 0;
        }

        for (let i = 0; i < n; i++) {
            if (this._p[i] <= p && p < this._pe[i]) {
                return i;
            }
        }

        return n - 1;
    }

    getValue(p) {
        const i = this._getItem(p);
        if (i === -1) {
            return undefined;
        } else {
            if (this._f[i]) {
                const o = Math.min(1, Math.max(0, (p - this._p[i]) * this._idp[i]));
                return this._v[i](o);
            } else {
                return this._v[i];
            }
        }
    }

    get length() {
        return this._length;
    }

    static getRgbaComponents(argb) {
        let r = ((argb / 65536) | 0) % 256;
        let g = ((argb / 256) | 0) % 256;
        let b = argb % 256;
        let a = ((argb / 16777216) | 0);
        return [r, g, b, a];
    };

    static getSplineValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
        // Normalize slopes because we use a spline that goes from 0 to 1.
        let dp = p2 - p1;
        s1 *= dp;
        s2 *= dp;

        let helpers = MultiSpline.getSplineHelpers(v1, v2, o1, i2, s1, s2);
        if (!helpers) {
            return function (p) {
                if (p === 0) return v1;
                if (p === 1) return v2;

                return v2 * p + v1 * (1 - p);
            };
        } else {
            return function (p) {
                if (p === 0) return v1;
                if (p === 1) return v2;
                return MultiSpline.calculateSpline(helpers, p);
            };
        }
    };

    static getSplineRgbaValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
        // Normalize slopes because we use a spline that goes from 0 to 1.
        let dp = p2 - p1;
        s1[0] *= dp;
        s1[1] *= dp;
        s1[2] *= dp;
        s1[3] *= dp;
        s2[0] *= dp;
        s2[1] *= dp;
        s2[2] *= dp;
        s2[3] *= dp;

        let cv1 = MultiSpline.getRgbaComponents(v1);
        let cv2 = MultiSpline.getRgbaComponents(v2);

        let helpers = [
            MultiSpline.getSplineHelpers(cv1[0], cv2[0], o1, i2, s1[0], s2[0]),
            MultiSpline.getSplineHelpers(cv1[1], cv2[1], o1, i2, s1[1], s2[1]),
            MultiSpline.getSplineHelpers(cv1[2], cv2[2], o1, i2, s1[2], s2[2]),
            MultiSpline.getSplineHelpers(cv1[3], cv2[3], o1, i2, s1[3], s2[3])
        ];

        if (!helpers[0]) {
            return function (p) {
                // Linear.
                if (p === 0) return v1;
                if (p === 1) return v2;

                return MultiSpline.mergeColors(v2, v1, p);
            };
        } else {
            return function (p) {
                if (p === 0) return v1;
                if (p === 1) return v2;

                return MultiSpline.getArgbNumber([
                    Math.min(255, MultiSpline.calculateSpline(helpers[0], p)),
                    Math.min(255, MultiSpline.calculateSpline(helpers[1], p)),
                    Math.min(255, MultiSpline.calculateSpline(helpers[2], p)),
                    Math.min(255, MultiSpline.calculateSpline(helpers[3], p))
                ]);
            };
        }

    };

    /**
     * Creates helpers to be used in the spline function.
     * @param {number} v1
     *   From value.
     * @param {number} v2
     *   To value.
     * @param {number} o1
     *   From smoothness (0 = linear, 1 = smooth).
     * @param {number} s1
     *   From slope (0 = horizontal, infinite = vertical).
     * @param {number} i2
     *   To smoothness.
     * @param {number} s2
     *   To slope.
     * @returns {Number[]}
     *   The helper values to be supplied to the spline function.
     *   If the configuration is actually linear, null is returned.
     */
    static getSplineHelpers(v1, v2, o1, i2, s1, s2) {
        if (!o1 && !i2) {
            // Linear.
            return null;
        }

        // Cubic bezier points.
        // http://cubic-bezier.com/
        let csx = o1;
        let csy = v1 + s1 * o1;
        let cex = 1 - i2;
        let cey = v2 - s2 * i2;

        let xa = 3 * csx - 3 * cex + 1;
        let xb = -6 * csx + 3 * cex;
        let xc = 3 * csx;

        let ya = 3 * csy - 3 * cey + v2 - v1;
        let yb = 3 * (cey + v1) - 6 * csy;
        let yc = 3 * (csy - v1);
        let yd = v1;

        return [xa, xb, xc, ya, yb, yc, yd];
    };

    /**
     * Calculates the intermediate spline value based on the specified helpers.
     * @param {number[]} helpers
     *   Obtained from getSplineHelpers.
     * @param {number} p
     * @return {number}
     */
    static calculateSpline(helpers, p) {
        let xa = helpers[0];
        let xb = helpers[1];
        let xc = helpers[2];
        let ya = helpers[3];
        let yb = helpers[4];
        let yc = helpers[5];
        let yd = helpers[6];

        if (xa === -2 && ya === -2 && xc === 0 && yc === 0) {
            // Linear.
            return p;
        }

        // Find t for p.
        let t = 0.5, cbx, dx;

        for (let it = 0; it < 20; it++) {
            // Cubic bezier function: f(t)=t*(t*(t*a+b)+c).
            cbx = t * (t * (t * xa + xb) + xc);

            dx = p - cbx;
            if (dx > -1e-8 && dx < 1e-8) {
                // Solution found!
                return t * (t * (t * ya + yb) + yc) + yd;
            }

            // Cubic bezier derivative function: f'(t)=t*(t*(3*a)+2*b)+c
            let cbxd = t * (t * (3 * xa) + 2 * xb) + xc;

            if (cbxd > 1e-10 && cbxd < 1e-10) {
                // Problematic. Fall back to binary search method.
                break;
            }

            t += dx / cbxd;
        }

        // Fallback: binary search method. This is more reliable when there are near-0 slopes.
        let minT = 0;
        let maxT = 1;
        for (let it = 0; it < 20; it++) {
            t = 0.5 * (minT + maxT);

            // Cubic bezier function: f(t)=t*(t*(t*a+b)+c)+d.
            cbx = t * (t * (t * xa + xb) + xc);

            dx = p - cbx;
            if (dx > -1e-8 && dx < 1e-8) {
                // Solution found!
                return t * (t * (t * ya + yb) + yc) + yd;
            }

            if (dx < 0) {
                maxT = t;
            } else {
                minT = t;
            }
        }

        return t;
    };

    static mergeColors(c1, c2, p) {
        let r1 = ((c1 / 65536) | 0) % 256;
        let g1 = ((c1 / 256) | 0) % 256;
        let b1 = c1 % 256;
        let a1 = ((c1 / 16777216) | 0);

        let r2 = ((c2 / 65536) | 0) % 256;
        let g2 = ((c2 / 256) | 0) % 256;
        let b2 = c2 % 256;
        let a2 = ((c2 / 16777216) | 0);

        let r = r1 * p + r2 * (1 - p);
        let g = g1 * p + g2 * (1 - p);
        let b = b1 * p + b2 * (1 - p);
        let a = a1 * p + a2 * (1 - p);

        return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
    };

    static getArgbNumber(rgba) {
        rgba[0] = Math.max(0, Math.min(255, rgba[0]));
        rgba[1] = Math.max(0, Math.min(255, rgba[1]));
        rgba[2] = Math.max(0, Math.min(255, rgba[2]));
        rgba[3] = Math.max(0, Math.min(255, rgba[3]));
        let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
        if (v < 0) {
            v = 0xFFFFFFFF + v + 1;
        }
        return v;
    };
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/ObjMerger.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/ObjMerger.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ObjMerger)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ObjMerger {

    static isMf(f) {
        return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(f) && f.__mf;
    }

    static mf(f) {
        // Set as merge function.
        f.__mf = true;
        return f;
    }

    static merge(a, b) {
        const aks = Object.keys(a);
        const bks = Object.keys(b);

        if (!bks.length) {
            return a;
        }

        // Create index array for all elements.
        const ai = {};
        const bi = {};
        for (let i = 0, n = bks.length; i < n; i++) {
            const key = bks[i];
            ai[key] = -1;
            bi[key] = i;
        }
        for (let i = 0, n = aks.length; i < n; i++) {
            const key = aks[i];
            ai[key] = i;
            if (bi[key] === undefined) {
                bi[key] = -1;
            }
        }

        const aksl = aks.length;

        const result = {};
        for (let i = 0, n = bks.length; i < n; i++) {
            const key = bks[i];

            // Prepend all items in a that are not in b - before the now added b attribute.
            const aIndex = ai[key];
            let curIndex = aIndex;
            while(--curIndex >= 0) {
                const akey = aks[curIndex];
                if (bi[akey] !== -1) {
                    // Already found? Stop processing.
                    // Not yet found but exists in b? Also stop processing: wait until we find it in b.
                    break;
                }
            }
            while(++curIndex < aIndex) {
                const akey = aks[curIndex];
                result[akey] = a[akey];
            }

            const bv = b[key];
            const av = a[key];
            let r;
            if (this.isMf(bv)) {
                r = bv(av);
            } else {
                if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(av) || !_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(bv)) {
                    r = bv;
                } else {
                    r = ObjMerger.merge(av, bv);
                }
            }

            // When marked as undefined, property is deleted.
            if (r !== undefined) {
                result[key] = r;
            }
        }

        // Append remaining final items in a.
        let curIndex = aksl;
        while(--curIndex >= 0) {
            const akey = aks[curIndex];
            if (bi[akey] !== -1) {
                break;
            }
        }
        while(++curIndex < aksl) {
            const akey = aks[curIndex];
            result[akey] = a[akey];
        }

        return result;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/ObjectListProxy.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/ObjectListProxy.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ObjectListProxy)
/* harmony export */ });
/* harmony import */ var _tree_ObjectList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/ObjectList.mjs */ "./node_modules/@lightningjs/core/src/tree/ObjectList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Manages the list of children for an element.
 */



class ObjectListProxy extends _tree_ObjectList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(target) {
        super();
        this._target = target;
    }

    onAdd(item, index) {
        this._target.addAt(item, index);
    }

    onRemove(item, index) {
        this._target.removeAt(index);
    }

    onSync(removed, added, order) {
        this._target._setByArray(order);
    }

    onSet(item, index) {
        this._target.setAt(item, index);
    }

    onMove(item, fromIndex, toIndex) {
        this._target.setAt(item, toIndex);
    }

    createItem(object) {
        return this._target.createItem(object);
    }

    isItem(object) {
        return this._target.isItem(object);
    }

}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/ObjectListWrapper.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/ObjectListWrapper.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ObjectListWrapper)
/* harmony export */ });
/* harmony import */ var _ObjectListProxy_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObjectListProxy.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjectListProxy.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Manages the list of children for an element.
 */



class ObjectListWrapper extends _ObjectListProxy_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(target, wrap) {
        super(target);
        this._wrap = wrap;
    }

    wrap(item) {
        let wrapper = this._wrap(item);
        item._wrapper = wrapper;
        return wrapper;
    }

    onAdd(item, index) {
        item = this.wrap(item);
        super.onAdd(item, index);
    }

    onRemove(item, index) {
        super.onRemove(item, index);
    }

    onSync(removed, added, order) {
        added.forEach(a => this.wrap(a));
        order = order.map(a => a._wrapper);
        super.onSync(removed, added, order);
    }

    onSet(item, index) {
        item = this.wrap(item);
        super.onSet(item, index);
    }

    onMove(item, fromIndex, toIndex) {
        super.onMove(item, fromIndex, toIndex);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/Tools.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/Tools.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tools)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _textures_StaticCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../textures/StaticCanvasTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/StaticCanvasTexture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class Tools {

    static getCanvasTexture(canvasFactory, lookupId) {
        return {type: _textures_StaticCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], content: {factory: canvasFactory, lookupId: lookupId}}
    }

    static getRoundRect(w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
        if (!Array.isArray(radius)){
            // upper-left, upper-right, bottom-right, bottom-left.
            radius = [radius, radius, radius, radius];
        }

        let factory = (cb, stage) => {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isSpark) {
                stage.platform.createRoundRect(cb, stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor);
            } else {
                cb(null, this.createRoundRect(stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor));
            }
        };
        let id = 'rect' + [w, h, strokeWidth, strokeColor, fill ? 1 : 0, fillColor].concat(radius).join(",");
        return Tools.getCanvasTexture(factory, id);
    }

    static createRoundRect(stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
        if (fill === undefined) fill = true;
        if (strokeWidth === undefined) strokeWidth = 0;

        let canvas = stage.platform.getDrawingCanvas();
        let ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;

        canvas.width = w + strokeWidth + 2;
        canvas.height = h + strokeWidth + 2;

        ctx.beginPath();
        let x = 0.5 * strokeWidth + 1, y = 0.5 * strokeWidth + 1;

        ctx.moveTo(x + radius[0], y);
        ctx.lineTo(x + w - radius[1], y);
        ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
        ctx.lineTo(x + w, y + h - radius[2]);
        ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
        ctx.lineTo(x + radius[3], y + h);
        ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
        ctx.lineTo(x, y + radius[0]);
        ctx.arcTo(x, y, x + radius[0], y, radius[0]);
        ctx.closePath();

        if (fill) {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(fillColor)) {
                ctx.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(fillColor);
            } else {
                ctx.fillStyle = "white";
            }
            ctx.fill();
        }

        if (strokeWidth) {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(strokeColor)) {
                ctx.strokeStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(strokeColor);
            } else {
                ctx.strokeStyle = "white";
            }
            ctx.lineWidth = strokeWidth;
            ctx.stroke();
        }

        return canvas;
    }

    static getShadowRect(w, h, radius = 0, blur = 5, margin = blur * 2) {
        if (!Array.isArray(radius)){
            // upper-left, upper-right, bottom-right, bottom-left.
            radius = [radius, radius, radius, radius];
        }

        let factory = (cb, stage) => {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isSpark) {
                stage.platform.createShadowRect(cb, stage, w, h, radius, blur, margin);
            } else {
                cb(null, this.createShadowRect(stage, w, h, radius, blur, margin));
            }
        };
        let id = 'shadow' + [w, h, blur, margin].concat(radius).join(",");
        return Tools.getCanvasTexture(factory, id);
    }

    static createShadowRect(stage, w, h, radius, blur, margin) {
        let canvas = stage.platform.getDrawingCanvas();
        let ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;

        canvas.width = w + margin * 2;
        canvas.height = h + margin * 2;

        // WpeWebKit bug: we experienced problems without this with shadows in noncompositedwebgl mode.
        ctx.globalAlpha = 0.01;
        ctx.fillRect(0, 0, 0.01, 0.01);
        ctx.globalAlpha = 1.0;

        ctx.shadowColor = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(0xFFFFFFFF);
        ctx.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(0xFFFFFFFF);
        ctx.shadowBlur = blur;
        ctx.shadowOffsetX = (w + 10) + margin;
        ctx.shadowOffsetY = margin;

        ctx.beginPath();
        const x = -(w + 10);
        const y = 0;

        ctx.moveTo(x + radius[0], y);
        ctx.lineTo(x + w - radius[1], y);
        ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
        ctx.lineTo(x + w, y + h - radius[2]);
        ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
        ctx.lineTo(x + radius[3], y + h);
        ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
        ctx.lineTo(x, y + radius[0]);
        ctx.arcTo(x, y, x + radius[0], y, radius[0]);
        ctx.closePath();
        ctx.fill();

        return canvas;
    }

    static getSvgTexture(url, w, h) {
        let factory = (cb, stage) => {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isSpark) {
                stage.platform.createSvg(cb, stage, url, w, h);
            } else {
                this.createSvg(cb, stage, url, w, h);
            }
        };
        let id = 'svg' + [w, h, url].join(",");
        return Tools.getCanvasTexture(factory, id);
    }

    static createSvg(cb, stage, url, w, h) {
        let canvas = stage.platform.getDrawingCanvas();
        let ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;

        let img = new Image();
        img.onload = () => {
            canvas.width = w;
            canvas.height = h;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            cb(null, canvas);
        }
        img.onError = (err) => {
            cb(err);
        }

        // On the PS4 platform setting the `crossOrigin` attribute on images
        // can cause CORS failures.
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isPS4) {
            img.crossOrigin = "Anonymous";
        }

        img.src = url;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/WebGLStateManager.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/WebGLStateManager.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Utils {

    static isFunction(value) {
        return typeof value === 'function';
    }

    static isNumber(value) {
        return typeof value === 'number';
    }

    static isInteger(value) {
        return (typeof value === 'number' && (value % 1) === 0);
    }

    static isBoolean(value) {
        return value === true || value === false;
    }

    static isString(value) {
        return typeof value == 'string';
    }

    static isObject(value) {
        let type = typeof value;
        return !!value && (type == 'object' || type == 'function');
    }

    static isPlainObject(value) {
        let type = typeof value;
        return !!value && (type == 'object');
    }

    static isObjectLiteral(value){
        return typeof value === 'object' && value && value.constructor === Object
    }

    static getArrayIndex(index, arr) {
        return Utils.getModuloIndex(index, arr.length);
    }

    static equalValues(v1, v2) {
        if ((typeof v1) !== (typeof v2)) return false
        if (Utils.isObjectLiteral(v1)) {
            return Utils.isObjectLiteral(v2) && Utils.equalObjectLiterals(v1, v2)
        } else if (Array.isArray(v1)) {
            return Array.isArray(v2) && Utils.equalArrays(v1, v2)
        } else {
            return v1 === v2
        }
    }

    static equalObjectLiterals(obj1, obj2) {
        let keys1 = Object.keys(obj1);
        let keys2 = Object.keys(obj2);
        if (keys1.length !== keys2.length) {
            return false
        }

        for (let i = 0, n = keys1.length; i < n; i++) {
            const k1 = keys1[i];
            const k2 = keys2[i];
            if (k1 !== k2) {
                return false
            }

            const v1 = obj1[k1];
            const v2 = obj2[k2];

            if (!Utils.equalValues(v1, v2)) {
                return false
            }
        }

        return true;
    }

    static equalArrays(v1, v2) {
        if (v1.length !== v2.length) {
            return false
        }
        for (let i = 0, n = v1.length; i < n; i++) {
            if (!this.equalValues(v1[i], v2[i])) {
                return false
            }
        }

        return true
    }

}

/**
 * Maintains the state of a WebGLRenderingContext.
 */
class WebGLState {

    constructor(id, gl) {
        this._id = id;
        this._gl = gl;
        this._program = undefined;
        this._buffers = new Map();
        this._framebuffers = new Map();
        this._renderbuffers = new Map();

        // Contains vertex attribute definition arrays (enabled, size, type, normalized, stride, offset).
        this._vertexAttribs = new Array(16);
        this._nonDefaultFlags = new Set();
        this._settings = new Map();
        this._textures = new Array(8);
        this._maxTexture = 0;
        this._activeTexture = gl.TEXTURE0;
        this._pixelStorei = new Array(5);
    }

    _getDefaultFlag(cap) {
        return (cap === this._gl.DITHER);
    }

    setFlag(cap, v) {
        const def = this._getDefaultFlag(cap);
        if (v === def) {
            return this._nonDefaultFlags.delete(cap);
        } else {
            if (!this._nonDefaultFlags.has(cap)) {
                this._nonDefaultFlags.add(cap);
                return true;
            } else {
                return false;
            }
        }
    }

    setBuffer(target, buffer) {
        const change = this._buffers.get(target) !== buffer;
        this._buffers.set(target, buffer);

        if (change && (target === this._gl.ARRAY_BUFFER)) {
            // When the array buffer is changed all attributes are cleared.
            this._vertexAttribs = [];
        }

        return change;
    }

    setFramebuffer(target, buffer) {
        const change = this._framebuffers.get(target) !== buffer;
        this._framebuffers.set(target, buffer);
        return change;
    }

    setRenderbuffer(target, buffer) {
        const change = this._renderbuffers.get(target) !== buffer;
        this._renderbuffers.set(target, buffer);
        return change;
    }

    setProgram(program) {
        const change = this._program !== program;
        this._program = program;
        return change
    }

    setSetting(func, v) {
        const s = this._settings.get(func);
        const change = !s || !Utils.equalValues(s, v);
        this._settings.set(func, v);
        return change
    }

    disableVertexAttribArray(index) {
        const va = this._vertexAttribs[index];
        if (va && va[5]) {
            va[5] = false;
            return true;
        }
        return false;
    }

    enableVertexAttribArray(index) {
        const va = this._vertexAttribs[index];
        if (va) {
            if (!va[0]) {
                va[0] = true;
                return true;
            }
        } else {
            this._vertexAttribs[index] = [0, 0, 0, 0, 0, true];
            return true;
        }
        return false;
    }

    vertexAttribPointer(index, props) {
        let va = this._vertexAttribs[index];
        let equal = false;
        if (va) {
            equal = va[0] === props[0] &&
                va[1] === props[1] &&
                va[2] === props[2] &&
                va[3] === props[3] &&
                va[4] === props[4];
        }

        if (equal) {
            return false;
        } else {
            props[5] = va ? va[5] : false;
            return true;
        }
    }

    setActiveTexture(texture) {
        const changed = this._activeTexture !== texture;
        this._activeTexture = texture;
        return changed;
    }

    bindTexture(target, texture) {
        const activeIndex = WebGLState._getTextureIndex(this._activeTexture);
        this._maxTexture = Math.max(this._maxTexture, activeIndex + 1);
        const current = this._textures[activeIndex];
        const targetIndex = WebGLState._getTextureTargetIndex(target);
        if (current) {
            if (current[targetIndex] === texture) {
                return false;
            }
            current[targetIndex] = texture;
            return true;
        } else {
            if (texture) {
                this._textures[activeIndex] = [];
                this._textures[activeIndex][targetIndex] = texture;
                return true
            } else {
                return false
            }
        }
    }

    setPixelStorei(pname, param) {
        const i = WebGLState._getPixelStoreiIndex(pname);
        const change = !Utils.equalValues(this._pixelStorei[i], param);
        this._pixelStorei[i] = param;
        return change;
    }

    migrate(s) {
        const t = this;

        // Warning: migrate should call the original prototype methods directly.

        this._migrateFlags(t, s);

        // useProgram
        if (s._program !== t._program) {
            this._gl._useProgram(s._program);
        }

        this._migrateFramebuffers(t, s);
        this._migrateRenderbuffers(t, s);

        const buffersChanged = this._migrateBuffers(t, s);
        this._migrateAttributes(t, s, buffersChanged);

        this._migrateFlags(t, s);

        this._migrateSettings(t, s);

        this._migratePixelStorei(t, s);
        
        this._migrateTextures(t, s);
        
    }

    _migratePixelStorei(t, s) {
        for (let i = 0, n = t._pixelStorei.length; i < n; i++) {
            if (t._pixelStorei[i] !== s._pixelStorei[i]) {
                const value = s._pixelStorei[i] !== undefined ? s._pixelStorei[i] : WebGLState._getDefaultPixelStoreiByIndex(i);
                this._gl._pixelStorei(WebGLState._getPixelStoreiByIndex(i), value);
            }
        }
    }

    _migrateTextures(t, s) {
        const max = Math.max(t._maxTexture, s._maxTexture);

        let activeTexture = t._activeTexture;

        for (let i = 0; i < max; i++) {
            const sTargets = s._textures[i];
            const tTargets = t._textures[i];
            const textureNumb = WebGLState._getTextureByIndex(i);

            const targetMax = Math.max(tTargets ? tTargets.length : 0, sTargets ? sTargets.length : 0);
            for (let j = 0, n = targetMax; j < n; j++) {
                const target = WebGLState._getTextureTargetByIndex(j);
                if (activeTexture !== textureNumb) {
                    this._gl._activeTexture(textureNumb);
                    activeTexture = textureNumb;
                }

                const texture = (sTargets && sTargets[j]) || null;
                this._gl._bindTexture(target, texture);
            }
        }

        if (s._activeTexture !== activeTexture) {
            this._gl._activeTexture(s._activeTexture);
        }
    }

    _migrateBuffers(t, s) {
        s._buffers.forEach((framebuffer, target) => {
            if (t._buffers.get(target) !== framebuffer) {
                this._gl._bindBuffer(target, framebuffer);
            }
        });

        t._buffers.forEach((buffer, target) => {
            const b = s._buffers.get(target);
            if (b === undefined) {
                this._gl._bindBuffer(target, null);
            }
        });
        return (s._buffers.get(this._gl.ARRAY_BUFFER) !== t._buffers.get(this._gl.ARRAY_BUFFER))
    }

    _migrateFramebuffers(t, s) {
        s._framebuffers.forEach((framebuffer, target) => {
            if (t._framebuffers.get(target) !== framebuffer) {
                this._gl._bindFramebuffer(target, framebuffer);
            }
        });

        t._framebuffers.forEach((framebuffer, target) => {
            const fb = s._framebuffers.get(target);
            if (fb === undefined) {
                this._gl._bindFramebuffer(target, null);
            }
        });
    }

    _migrateRenderbuffers(t, s) {
        s._renderbuffers.forEach((renderbuffer, target) => {
            if (t._renderbuffers.get(target) !== renderbuffer) {
                this._gl._bindRenderbuffer(target, renderbuffer);
            }
        });

        t._renderbuffers.forEach((renderbuffer, target) => {
            const fb = s._renderbuffers.get(target);
            if (fb === undefined) {
                this._gl._bindRenderbuffer(target, null);
            }
        });
    }

    _migrateAttributes(t, s, buffersChanged) {

        if (!buffersChanged) {
            t._vertexAttribs.forEach((attrib, index) => {
                if (!s._vertexAttribs[index]) {
                    // We can't 'delete' a vertex attrib so we'll disable it.
                    this._gl._disableVertexAttribArray(index);
                }
            });

            s._vertexAttribs.forEach((attrib, index) => {
                this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[4]);
                if (attrib[5]) {
                    this._gl._enableVertexAttribArray(index);
                } else {
                    this._gl._disableVertexAttribArray(index);
                }
            });
        } else {
            // When buffers are changed, previous attributes were reset automatically.
            s._vertexAttribs.forEach((attrib, index) => {
                if (attrib[0]) {
                    // Do not set vertex attrib pointer when it was just the default value.
                    this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[3], attrib[4]);
                }
                if (attrib[5]) {
                    this._gl._enableVertexAttribArray(index);
                }
            });
        }
    }

    _migrateSettings(t, s) {
        const defaults = this.constructor.getDefaultSettings();
        t._settings.forEach((value, func) => {
            const name = func.name || func.xname;
            if (!s._settings.has(func)) {
                let args = defaults.get(name);
                if (Utils.isFunction(args)) {
                    args = args(this._gl);
                }
                // We are actually setting the setting for optimization purposes.
                s._settings.set(func, args);
                func.apply(this._gl, args);
            }
        });
        s._settings.forEach((value, func) => {
            const tValue = t._settings.get(func);
            if (!tValue || !Utils.equalValues(tValue, value)) {
                func.apply(this._gl, value);
            }
        });
    }

    _migrateFlags(t, s) {
        t._nonDefaultFlags.forEach(setting => {
            if (!s._nonDefaultFlags.has(setting)) {
                if (this._getDefaultFlag(setting)) {
                    this._gl._enable(setting);
                } else {
                    this._gl._disable(setting);
                }
            }
        });
        s._nonDefaultFlags.forEach(setting => {
            if (!t._nonDefaultFlags.has(setting)) {
                if (this._getDefaultFlag(setting)) {
                    this._gl._disable(setting);
                } else {
                    this._gl._enable(setting);
                }
            }
        });
    }

    static getDefaultSettings() {
        if (!this._defaultSettings) {
            this._defaultSettings = new Map();
            const d = this._defaultSettings;
            const g = WebGLRenderingContext.prototype;
            d.set("viewport", function(gl) {return [0,0,gl.canvas.width, gl.canvas.height]});
            d.set("scissor", function(gl) {return [0,0,gl.canvas.width, gl.canvas.height]});
            d.set("blendColor", [0, 0, 0, 0]);
            d.set("blendEquation", [g.FUNC_ADD]);
            d.set("blendEquationSeparate", [g.FUNC_ADD, g.FUNC_ADD]);
            d.set("blendFunc", [g.ONE, g.ZERO]);
            d.set("blendFuncSeparate", [g.ONE, g.ZERO, g.ONE, g.ZERO]);
            d.set("clearColor", [0, 0, 0, 0]);
            d.set("clearDepth", [1]);
            d.set("clearStencil", [0]);
            d.set("colorMask", [true, true, true, true]);
            d.set("cullFace", [g.BACK]);
            d.set("depthFunc", [g.LESS]);
            d.set("depthMask", [true]);
            d.set("depthRange", [0, 1]);
            d.set("frontFace", [g.CCW]);
            d.set("lineWidth", [1]);
            d.set("polygonOffset", [0, 0]);
            d.set("sampleCoverage", [1, false]);
            d.set("stencilFunc", [g.ALWAYS, 0, 1]);
            d.set("_stencilFuncSeparateFront", [g.ALWAYS, 0, 1]);
            d.set("_stencilFuncSeparateBack", [g.ALWAYS, 0, 1]);
            d.set("_stencilFuncSeparateFrontAndBack", [g.ALWAYS, 0, 1]);
            d.set("stencilMask", [1]);
            d.set("_stencilMaskSeparateFront", [1]);
            d.set("_stencilMaskSeparateBack", [1]);
            d.set("_stencilMaskSeparateFrontAndBack", [1]);
            d.set("stencilOp", [g.KEEP, g.KEEP, g.KEEP]);
            d.set("_stencilOpSeparateFront", [g.KEEP, g.KEEP, g.KEEP]);
            d.set("_stencilOpSeparateBack", [g.KEEP, g.KEEP, g.KEEP]);
            d.set("_stencilOpSeparateFrontAndBack", [g.KEEP, g.KEEP, g.KEEP]);
            d.set("vertexAttrib1f", []);
            d.set("vertexAttrib1fv", []);
            d.set("vertexAttrib2f", []);
            d.set("vertexAttrib2fv", []);
            d.set("vertexAttrib3f", []);
            d.set("vertexAttrib3fv", []);
            d.set("vertexAttrib4f", []);
            d.set("vertexAttrib4fv", []);
        }
        return this._defaultSettings
    }

    static _getTextureTargetIndex(target) {
        switch(target) {
            case 0x0DE1:
                /* TEXTURE_2D */
                return 0;
            case 0x8513:
                /* TEXTURE_CUBE_MAP */
                return 1;
            default:
                // Shouldn't happen.
                throw new Error('Unknown texture target: ' + target);
        }
    }

    static _getTextureTargetByIndex(index) {
        if (!this._textureTargetIndices) {
            this._textureTargetIndices = [0x0DE1, 0x8513];
        }
        return this._textureTargetIndices[index]
    }

    static _getTextureIndex(index) {
        return index - 0x84C0 /* GL_TEXTURE0 */;
    }

    static _getTextureByIndex(index) {
        return index + 0x84C0;
    }

    static _getPixelStoreiIndex(pname) {
        switch(pname) {
            case 0x0D05:
                /* PACK_ALIGNMENT */
                return 0;
            case 0x0CF5:
                /* UNPACK_ALIGNMENT */
                return 1;
            case 0x9240:
                /* UNPACK_FLIP_Y_WEBGL */
                return 2;
            case 0x9241:
                /* UNPACK_PREMULTIPLY_ALPHA_WEBGL */
                return 3;
            case 0x9243:
                /* UNPACK_COLORSPACE_CONVERSION_WEBGL */
                return 4;
                //@todo: support WebGL2 properties, see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei
            case 0x9245:
                /* UNPACK_FLIP_BLUE_RED */
                return 5;
            default:
                // Shouldn't happen.
                throw new Error('Unknown pixelstorei: ' + pname);
        }
    }

    static _getPixelStoreiByIndex(index) {
        if (!this._pixelStoreiIndices) {
            this._pixelStoreiIndices = [0x0D05, 0x0CF5, 0x9240, 0x9241, 0x9243];
        }
        return this._pixelStoreiIndices[index]
    }

    static _getDefaultPixelStoreiByIndex(index) {
        if (!this._pixelStoreiDefaults) {
            this._pixelStoreiDefaults = [4, 4, false, false, WebGLRenderingContext.prototype.BROWSER_DEFAULT_WEBGL];
        }
        return this._pixelStoreiDefaults[index]
    }
}

class WebGLStateManager {

    _initStateManager(id = "default") {
        this._states = {};
        this._state = this._getState(id);
    }

    _getState(id) {
        if (!this._states[id]) {
            this._states[id] = new WebGLState(id, this);
        }
        return this._states[id];
    }

    switchState(id = "default") {
        if (this._state._id !== id) {
            const newState = this._getState(id);
            this._state.migrate(newState);
            this._state = newState;
        }
    }

    $useProgram(program) {
        if (this._state.setProgram(program))
            this._useProgram(program);
    }

    $bindBuffer(target, fb) {
        if (this._state.setBuffer(target, fb))
            this._bindBuffer(target, fb);
    }

    $bindFramebuffer(target, fb) {
        if (this._state.setFramebuffer(target, fb))
            this._bindFramebuffer(target, fb);
    }

    $bindRenderbuffer(target, fb) {
        if (this._state.setRenderbuffer(target, fb))
            this._bindRenderbuffer(target, fb);
    }

    $enable(cap) {
        if (this._state.setFlag(cap, true))
            this._enable(cap);
    }

    $disable(cap) {
        if (this._state.setFlag(cap, false))
            this._disable(cap);
    }

    $viewport(x, y, w, h) {
        if (this._state.setSetting(this._viewport, [x, y, w, h]))
            this._viewport(x, y, w, h);
    }

    $scissor(x, y, w, h) {
        if (this._state.setSetting(this._scissor, [x, y, w, h]))
            this._scissor(x, y, w, h);
    }

    $disableVertexAttribArray(index) {
        if (this._state.disableVertexAttribArray(index))
            this._disableVertexAttribArray(index);
    }

    $enableVertexAttribArray(index) {
        if (this._state.enableVertexAttribArray(index))
            this._enableVertexAttribArray(index);
    }

    $vertexAttribPointer(index, size, type, normalized, stride, offset) {
        if (this._state.vertexAttribPointer(index, [size, type, normalized, stride, offset]))
            this._vertexAttribPointer(index, size, type, normalized, stride, offset);
    }

    $activeTexture(texture) {
        if (this._state.setActiveTexture(texture))
            this._activeTexture(texture);
    }

    $bindTexture(target, texture) {
        if (this._state.bindTexture(target, texture))
            this._bindTexture(target, texture);
    }

    $pixelStorei(pname, param) {
        if (this._state.setPixelStorei(pname, param)) {
            this._pixelStorei(pname, param);
        }
    }

    $stencilFuncSeparate(face, func, ref, mask) {
        let f;
        switch(face) {
            case this.FRONT:
                f = this._stencilFuncSeparateFront;
                break;
            case this.BACK:
                f = this._stencilFuncSeparateBack;
                break;
            case this.FRONT_AND_BACK:
                f = this._stencilFuncSeparateFrontAndBack;
                break;
        }

        if (this._state.setSetting(f, [func, ref, mask]))
            f.apply(this, [func, ref, mask]);
    }

    _stencilFuncSeparateFront(func, ref, mask) {
        this._stencilFuncSeparate(this.FRONT, func, ref, mask);
    }

    _stencilFuncSeparateBack(func, ref, mask) {
        this._stencilFuncSeparate(this.BACK, func, ref, mask);
    }

    _stencilFuncSeparateFrontAndBack(func, ref, mask) {
        this._stencilFuncSeparate(this.FRONT_AND_BACK, func, ref, mask);
    }

    $stencilMaskSeparate(face, mask) {
        let f;
        switch(face) {
            case this.FRONT:
                f = this._stencilMaskSeparateFront;
                break;
            case this.BACK:
                f = this._stencilMaskSeparateBack;
                break;
            case this.FRONT_AND_BACK:
                f = this._stencilMaskSeparateFrontAndBack;
                break;
        }

        if (this._state.setSetting(f, [mask]))
            f.apply(this, [mask]);
    }

    _stencilMaskSeparateFront(mask) {
        this._stencilMaskSeparate(this.FRONT, mask);
    }

    _stencilMaskSeparateBack(mask) {
        this._stencilMaskSeparate(this.BACK, mask);
    }

    _stencilMaskSeparateFrontAndBack(mask) {
        this._stencilMaskSeparate(this.FRONT_AND_BACK, mask);
    }

    $stencilOpSeparate(face, fail, zfail, zpass) {
        let f;
        switch(face) {
            case this.FRONT:
                f = this._stencilOpSeparateFront;
                break;
            case this.BACK:
                f = this._stencilOpSeparateBack;
                break;
            case this.FRONT_AND_BACK:
                f = this._stencilOpSeparateFrontAndBack;
                break;
        }

        if (this._state.setSetting(f, [fail, zfail, zpass]))
            f.apply(this, [fail, zfail, zpass]);
    }

    _stencilOpSeparateFront(fail, zfail, zpass) {
        this._stencilOpSeparate(this.FRONT, fail, zfail, zpass);
    }

    _stencilOpSeparateBack(fail, zfail, zpass) {
        this._stencilOpSeparate(this.BACK, fail, zfail, zpass);
    }

    _stencilOpSeparateFrontAndBack(fail, zfail, zpass) {
        this._stencilOpSeparate(this.FRONT_AND_BACK, fail, zfail, zpass);
    }

    $blendColor(red, green, blue, alpha) {
        if (this._state.setSetting(this._blendColor, [red, green, blue, alpha]))
            this._blendColor(red, green, blue, alpha);
    }

    $blendEquation(mode) {
        if (this._state.setSetting(this._blendEquation, [mode]))
            this._blendEquation(mode);
    }

    $blendEquationSeparate(modeRGB, modeAlpha) {
        if (this._state.setSetting(this._blendEquationSeparate, [modeRGB, modeAlpha]))
            this._blendEquationSeparate(modeRGB, modeAlpha);
    }

    $blendFunc(sfactor, dfactor) {
        if (this._state.setSetting(this._blendFunc, [sfactor, dfactor]))
            this._blendFunc(sfactor, dfactor);
    }

    $blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
        if (this._state.setSetting(this._blendFuncSeparate, [srcRGB, dstRGB, srcAlpha, dstAlpha]))
            this._blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
    }

    $clearColor(red, green, blue, alpha) {
        if (this._state.setSetting(this._clearColor, [red, green, blue, alpha]))
            this._clearColor(red, green, blue, alpha);
    }

    $clearDepth(depth) {
        if (this._state.setSetting(this._clearDepth, [depth]))
            this._clearDepth(depth);
    }

    $clearStencil(s) {
        if (this._state.setSetting(this._clearStencil, [s]))
            this._clearStencil(s);
    }

    $colorMask(red, green, blue, alpha) {
        if (this._state.setSetting(this._colorMask, [red, green, blue, alpha]))
            this._colorMask(red, green, blue, alpha);
    }

    $cullFace(mode) {
        if (this._state.setSetting(this._cullFace, [mode]))
            this._cullFace(mode);
    }

    $depthFunc(func) {
        if (this._state.setSetting(this._depthFunc, [func]))
            this._depthFunc(func);
    }

    $depthMask(flag) {
        if (this._state.setSetting(this._depthMask, [flag]))
            this._depthMask(flag);
    }

    $depthRange(zNear, zFar) {
        if (this._state.setSetting(this._depthRange, [zNear, zFar]))
            this._depthRange(zNear, zFar);
    }

    $frontFace(mode) {
        if (this._state.setSetting(this._frontFace, [mode]))
            this._frontFace(mode);
    }

    $lineWidth(width) {
        if (this._state.setSetting(this._lineWidth, [width]))
            this._lineWidth(width);
    }

    $polygonOffset(factor, units) {
        if (this._state.setSetting(this._polygonOffset, [factor, units]))
            this._polygonOffset(factor, units);
    }

    $sampleCoverage(value, invert) {
        if (this._state.setSetting(this._sampleCoverage, [value, invert]))
            this._sampleCoverage(value, invert);
    }

    $stencilFunc(func, ref, mask) {
        if (this._state.setSetting(this._stencilFunc, [func, ref, mask]))
            this._stencilFunc(func, ref, mask);
    }

    $stencilMask(mask) {
        if (this._state.setSetting(this._stencilMask, [mask]))
            this._stencilMask(mask);
    }

    $stencilOp(fail, zfail, zpass) {
        if (this._state.setSetting(this._stencilOp, [fail, zfail, zpass]))
            this._stencilOp(fail, zfail, zpass);
    }

    $vertexAttrib1f(indx, x) {
        if (this._state.setSetting(this._vertexAttrib1f, [indx, x]))
            this._vertexAttrib1f(indx, x);
    }

    $vertexAttrib1fv(indx, values) {
        if (this._state.setSetting(this._vertexAttrib1fv, [indx, values]))
            this._vertexAttrib1fv(indx, values);
    }

    $vertexAttrib2f(indx, x, y) {
        if (this._state.setSetting(this._vertexAttrib2f, [indx, x, y]))
            this._vertexAttrib2f(indx, x, y);
    }

    $vertexAttrib2fv(indx, values) {
        if (this._state.setSetting(this._vertexAttrib2fv, [indx, values]))
            this._vertexAttrib2fv(indx, values);
    }

    $vertexAttrib3f(indx, x, y, z) {
        if (this._state.setSetting(this._vertexAttrib3f, [indx, x, y, z]))
            this._vertexAttrib3f(indx, x, y, z);
    }

    $vertexAttrib3fv(indx, values) {
        if (this._state.setSetting(this._vertexAttrib3fv, [indx, values]))
            this._vertexAttrib3fv(indx, values);
    }

    $vertexAttrib4f(indx, x, y, z, w) {
        if (this._state.setSetting(this._vertexAttrib4f, [indx, x, y, z, w]))
            this._vertexAttrib4f(indx, x, y, z, w);
    }

    $vertexAttrib4fv(indx, values) {
        if (this._state.setSetting(this._vertexAttrib4fv, [indx, values]))
            this._vertexAttrib4fv(indx, values);
    }

    /**
     * Sets up the rendering context for context sharing.
     * @param {WebGLRenderingContext} gl
     * @param {string} id
     */
    static enable(gl, id = "default") {
        const names = Object.getOwnPropertyNames(WebGLStateManager.prototype);
        const WebGLRenderingContextProto = gl.__proto__;
        names.forEach(name => {
            if (name !== "constructor") {
                const method = WebGLStateManager.prototype[name];
                if (name.charAt(0) === "$") {
                    name = name.substr(1);
                }
                if (gl[name] !== method) {
                    if (gl[name]) {
                        if (!gl[name].name) {
                            // We do this for compatibility with the Chrome WebGL Inspector plugin.
                            gl[name].xname = name;
                        }
                        gl['_' + name] = gl[name];
                    }
                    gl[name] = method;
                }
            }
        });

        WebGLStateManager.prototype._initStateManager.call(gl, id);

        return gl;
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebGLStateManager);


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Base.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Base.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Base)
/* harmony export */ });
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Base {

    static defaultSetter(obj, name, value) {
        obj[name] = value;
    }

    static patchObject(obj, settings) {
        if (!_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(settings)) {
            console.error("[Lightning] Settings must be object literal");
        } else {
            let names = Object.keys(settings);
            for (let i = 0, n = names.length; i < n; i++) {
                let name = names[i];

                this.patchObjectProperty(obj, name, settings[name]);
            }
        }
    }

    static patchObjectProperty(obj, name, value) {
        let setter = obj.setSetting || Base.defaultSetter;

        if (name.charAt(0) === "_") {
            // Disallow patching private variables.
            if (name !== "__create") {
                console.error("[Lightning] Patch of private property '" + name + "' is not allowed");
            }
        } else if (name !== "type") {
            // Type is a reserved keyword to specify the class type on creation.
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(value) && value.__local) {
                // Local function (Base.local(s => s.something))
                value = value.__local(obj);
            }

            setter(obj, name, value);
        }
    }

    static local(func) {
        // This function can be used as an object setting, which is called with the target object.
        func.__local = true;
    }


}





/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Element.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Element.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Element)
/* harmony export */ });
/* harmony import */ var _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _core_ElementCore_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/ElementCore.mjs */ "./node_modules/@lightningjs/core/src/tree/core/ElementCore.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/* harmony import */ var _Shader_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/* harmony import */ var _Texture_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/* harmony import */ var _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../textures/ImageTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/ImageTexture.mjs");
/* harmony import */ var _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../textures/TextTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/TextTexture.mjs");
/* harmony import */ var _textures_SourceTexture_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../textures/SourceTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/SourceTexture.mjs");
/* harmony import */ var _animation_Transition_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../animation/Transition.mjs */ "./node_modules/@lightningjs/core/src/animation/Transition.mjs");
/* harmony import */ var _ElementChildList_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ElementChildList.mjs */ "./node_modules/@lightningjs/core/src/tree/ElementChildList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Render tree node.
 */









class Element {

    constructor(stage) {
        this.stage = stage;

        this.__id = Element.id++;

        this.__start();

        // EventEmitter constructor.
        this._hasEventListeners = false;

        this.__core = new _core_ElementCore_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);

        /**
         * A reference that can be used while merging trees.
         * @type {string}
         */
        this.__ref = null;

        /**
         * An element is attached if it is a descendant of the stage root.
         * @type {boolean}
         */
        this.__attached = false;

        /**
         * An element is enabled when it is attached and it is visible (worldAlpha > 0).
         * @type {boolean}
         */
        this.__enabled = false;

        /**
         * An element is active when it is enabled and it is within bounds.
         * @type {boolean}
         */
        this.__active = false;

        /**
         * @type {Element}
         */
        this.__parent = null;

        /**
         * The texture that is currently set.
         * @type {Texture}
         */
        this.__texture = null;

        /**
         * The currently displayed texture. While this.texture is loading, this one may be different.
         * @type {Texture}
         */
        this.__displayedTexture = null;

        /**
         * Tags that can be used to identify/search for a specific element.
         * @type {String[]}
         */
        this.__tags = null;

        /**
         * The tree's tags mapping.
         * This contains all elements for all known tags, at all times.
         * @type {Map}
         */
        this.__treeTags = null;

        /**
         * Creates a tag context: tagged elements in this branch will not be reachable from ancestors of this elements.
         * @type {boolean}
         */
        this.__tagRoot = false;

        /**
         * (Lazy-initialised) list of children owned by this elements.
         * @type {ElementChildList}
         */
        this.__childList = null;

        this._w = 0;

        this._h = 0;
    }

    __start() {
    }

    get id() {
        return this.__id;
    }

    set ref(ref) {
        if (this.__ref !== ref) {
            const charcode = ref.charCodeAt(0);
            if (!_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isUcChar(charcode)) {
                this._throwError("Ref must start with an upper case character: " + ref);
            }
            if (this.__ref !== null) {
                this.removeTag(this.__ref);
                if (this.__parent) {
                    this.__parent.__childList.clearRef(this.__ref);
                }
            }

            this.__ref = ref;

            if (this.__ref) {
                this._addTag(this.__ref);
                if (this.__parent) {
                    this.__parent.__childList.setRef(this.__ref, this);
                }
            }
        }
    }

    get ref() {
        return this.__ref;
    }

    get core() {
        return this.__core;
    }

    setAsRoot() {
        this.__core.setAsRoot();
        this._updateAttachedFlag();
        this._updateEnabledFlag();
    }

    get isRoot() {
        return this.__core.isRoot;
    }

    _setParent(parent) {
        if (this.__parent === parent) return;

        if (this.__parent) {
            this._unsetTagsParent();
        }

        this.__parent = parent;

        if (parent) {
            this._setTagsParent();
        }

        this._updateAttachedFlag();
        this._updateEnabledFlag();
        this._updateCollision();

        if (this.isRoot && parent) {
            this._throwError("Root should not be added as a child! Results are unspecified!");
        }
    };

    getDepth() {
        let depth = 0;

        let p = this.__parent;
        while(p) {
            depth++;
            p = p.__parent;
        }

        return depth;
    };

    getAncestor(l) {
        let p = this;
        while (l > 0 && p.__parent) {
            p = p.__parent;
            l--;
        }
        return p;
    };

    getAncestors() {
        const a = [];
        let p = this;
        while (p) {
            a.push(p);
            p = p.__parent;
        }
        return a;
    }

    getAncestorAtDepth(depth) {
        let levels = this.getDepth() - depth;
        if (levels < 0) {
            return null;
        }
        return this.getAncestor(levels);
    };

    isAncestorOf(c) {
        let p = c;
        while(p = p.parent) {
            if (this === p) {
                return true;
            }
        }
        return false;
    };

    getSharedAncestor(c) {
        let o1 = this;
        let o2 = c;
        let l1 = o1.getDepth();
        let l2 = o2.getDepth();
        if (l1 > l2) {
            o1 = o1.getAncestor(l1 - l2);
        } else if (l2 > l1) {
            o2 = o2.getAncestor(l2 - l1);
        }

        do {
            if (o1 === o2) {
                return o1;
            }

            o1 = o1.__parent;
            o2 = o2.__parent;
        } while (o1 && o2);

        return null;
    };

    get attached() {
        return this.__attached;
    }

    get enabled() {
        return this.__enabled;
    }

    get active() {
        return this.__active;
    }

    _isAttached() {
        return (this.__parent ? this.__parent.__attached : (this.stage.root === this));
    };

    _isEnabled() {
        return this.__core.visible && (this.__core.alpha > 0) && (this.__parent ? this.__parent.__enabled : (this.stage.root === this));
    };

    _isActive() {
        return this._isEnabled() && this.withinBoundsMargin;
    };

    /**
     * Updates the 'attached' flag for this branch.
     */
    _updateAttachedFlag() {
        let newAttached = this._isAttached();
        if (this.__attached !== newAttached) {
            this.__attached = newAttached;

            if (newAttached) {
                this._onSetup();
            }

            let children = this._children.get();
            if (children) {
                let m = children.length;
                if (m > 0) {
                    for (let i = 0; i < m; i++) {
                        children[i]._updateAttachedFlag();
                    }
                }
            }

            if (newAttached) {
                this._onAttach();
            } else {
                this._onDetach();
            }
        }
    };

    /**
     * Updates the 'enabled' flag for this branch.
     */
    _updateEnabledFlag() {
        let newEnabled = this._isEnabled();
        if (this.__enabled !== newEnabled) {
            if (newEnabled) {
                this._onEnabled();
                this._setEnabledFlag();
            } else {
                this._onDisabled();
                this._unsetEnabledFlag();
            }

            let children = this._children.get();
            if (children) {
                let m = children.length;
                if (m > 0) {
                    for (let i = 0; i < m; i++) {
                        children[i]._updateEnabledFlag();
                    }
                }
            }
        }
    };

    _setEnabledFlag() {
        this.__enabled = true;

        // Force re-check of texture because dimensions might have changed (cutting).
        this._updateDimensions();
        this._updateTextureCoords();

        if (this.__texture) {
            this.__texture.addElement(this);
        }

        if (this.withinBoundsMargin) {
            this._setActiveFlag();
        }

        if (this.__core.shader) {
            this.__core.shader.addElement(this.__core);
        }

    }

    _unsetEnabledFlag() {
        if (this.__active) {
            this._unsetActiveFlag();
        }

        if (this.__texture) {
            this.__texture.removeElement(this);
        }

        if (this.__core.shader) {
            this.__core.shader.removeElement(this.__core);
        }

        if (this._texturizer) {
            this.texturizer.filters.forEach(filter => filter.removeElement(this.__core));
        }

        this.__enabled = false;
    }

    _setActiveFlag() {
        this.__active = true;

        // This must happen before enabling the texture, because it may already be loaded or load directly.
        if (this.__texture) {
            this.__texture.incActiveCount();
        }

        if (this.__texture) {
            this._enableTexture();
        }
        this._onActive();
    }

    _unsetActiveFlag() {
        if (this.__texture) {
            this.__texture.decActiveCount();
        }

        this.__active = false;
        if (this.__texture) {
            this._disableTexture();
        }

        if (this._hasTexturizer()) {
            this.texturizer.deactivate();
        }

        this._onInactive();
    }

    _onSetup() {
    }

    _onAttach() {
    }

    _onDetach() {
    }

    _onEnabled() {
    }

    _onDisabled() {
    }

    _onActive() {
    }

    _onInactive() {
    }

    _onResize() {
    }

    _getRenderWidth() {
        if (this._w) {
            return this._w;
        } else if (this.__displayedTexture) {
            return this.__displayedTexture.getRenderWidth();
        } else if (this.__texture) {
            // Texture already loaded, but not yet updated (probably because this element is not active).
            return this.__texture.getRenderWidth();
        } else {
            return 0;
        }
    };

    _getRenderHeight() {
        if (this._h) {
            return this._h;
        } else if (this.__displayedTexture) {
            return this.__displayedTexture.getRenderHeight();
        } else if (this.__texture) {
            // Texture already loaded, but not yet updated (probably because this element is not active).
            return this.__texture.getRenderHeight();
        } else {
            return 0;
        }
    };

    get renderWidth() {
        if (this.__enabled) {
            // Render width is only maintained if this element is enabled.
            return this.__core.getRenderWidth();
        } else {
            return this._getRenderWidth();
        }
    }

    get renderHeight() {
        if (this.__enabled) {
            return this.__core.getRenderHeight();
        } else {
            return this._getRenderHeight();
        }
    }

    get finalX() {
        return this.__core.x;
    }

    get finalY() {
        return this.__core.y;
    }

    get finalW() {
        return this.__core.w;
    }

    get finalH() {
        return this.__core.h;
    }

    textureIsLoaded() {
        return this.__texture && this.__texture.isLoaded();
    }

    loadTexture() {
        if (this.__texture) {
            this.__texture.load();

            if (!this.__texture.isUsed() || !this._isEnabled()) {
                // Loading the texture will have no effect on the dimensions of this element.
                // Manually update them, so that calcs can be performed immediately in userland.
                this._updateDimensions();
            }
        }
    }

    _enableTextureError() {
        // txError event should automatically be re-triggered when a element becomes active.
        const loadError = this.__texture.loadError;
        if (loadError) {
            this.emit('txError', loadError, this.__texture._source);
        }
    }

    _enableTexture() {
        if (this.__texture.isLoaded()) {
            this._setDisplayedTexture(this.__texture);
        } else {
            // We don't want to retain the old 'ghost' image as it wasn't visible anyway.
            this._setDisplayedTexture(null);

            this._enableTextureError();
        }
    }

    _disableTexture() {
        // We disable the displayed texture because, when the texture changes while invisible, we should use that w, h,
        // mw, mh for checking within bounds.
        this._setDisplayedTexture(null);
    }

    get texture() {
        return this.__texture;
    }

    set texture(v) {
        let texture;
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(v)) {
            if (v.type) {
                texture = new v.type(this.stage);
            } else {
                texture = this.texture;
            }

            if (texture) {
                _Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].patchObject(texture, v);
            }
        } else if (!v) {
            texture = null;
        } else {
            if (v.isTexture) {
                texture = v;
            } else if (v.isTextureSource) {
                texture = new _textures_SourceTexture_mjs__WEBPACK_IMPORTED_MODULE_6__["default"](this.stage);
                texture.textureSource = v;
            } else {
                console.error("[Lightning] Please specify a texture type.");
                return;
            }
        }

        const prevTexture = this.__texture;
        if (texture !== prevTexture) {
            this.__texture = texture;

            if (this.__texture) {
                if (this.__enabled) {
                    this.__texture.addElement(this);

                    if (this.withinBoundsMargin) {
                        if (this.__texture.isLoaded()) {
                            this._setDisplayedTexture(this.__texture);
                        } else {
                            this._enableTextureError();
                        }
                    }
                }
            } else {
                // Make sure that current texture is cleared when the texture is explicitly set to null.
                this._setDisplayedTexture(null);
            }

            if (prevTexture && prevTexture !== this.__displayedTexture) {
                prevTexture.removeElement(this);
            }

            this._updateDimensions();
        }
    }

    get displayedTexture() {
        return this.__displayedTexture;
    }

    _setDisplayedTexture(v) {
        let prevTexture = this.__displayedTexture;

        if (prevTexture && (v !== prevTexture)) {
            if (this.__texture !== prevTexture) {
                // The old displayed texture is deprecated.
                prevTexture.removeElement(this);
            }
        }

        const prevSource = this.__core.displayedTextureSource ? this.__core.displayedTextureSource._source : null;
        const sourceChanged = (v ? v._source : null) !== prevSource;

        this.__displayedTexture = v;
        this._updateDimensions();

        if (this.__displayedTexture) {
            if (sourceChanged) {
                // We don't need to reference the displayed texture because it was already referenced (this.texture === this.displayedTexture).
                this._updateTextureCoords();
                this.__core.setDisplayedTextureSource(this.__displayedTexture._source);
            }
        } else {
            this.__core.setDisplayedTextureSource(null);
        }

        if (sourceChanged) {
            if (this.__displayedTexture) {
                this.emit('txLoaded', this.__displayedTexture);
            } else {
                this.emit('txUnloaded', this.__displayedTexture);
            }
        }
    }

    onTextureSourceLoaded() {
        // This function is called when element is enabled, but we only want to set displayed texture for active elements.
        if (this.active) {
            // We may be dealing with a texture reloading, so we must force update.
            this._setDisplayedTexture(this.__texture);
        }
    };

    onTextureSourceLoadError(e) {
        this.emit('txError', e, this.__texture._source);
    };

    forceRenderUpdate() {
        this.__core.setHasRenderUpdates(3);
    }

    onDisplayedTextureClippingChanged() {
        this._updateDimensions();
        this._updateTextureCoords();
    };

    onPrecisionChanged() {
        this._updateDimensions();
    };

    onDimensionsChanged(w, h) {
        if (this.texture instanceof _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]) {
            this.texture.w = w;
            this.texture.h = h;
            this.w = w;
            this.h = h;
        }
    }

    _updateDimensions() {
        let w = this._getRenderWidth();
        let h = this._getRenderHeight();

        let unknownSize = false;
        if (!w || !h) {
            if (!this.__displayedTexture && this.__texture) {
                // We use a 'max width' replacement instead in the ElementCore calcs.
                // This makes sure that it is able to determine withinBounds.
                w = w || this.__texture.mw;
                h = h || this.__texture.mh;

                if ((!w || !h) && this.__texture.isAutosizeTexture()) {
                    unknownSize = true;
                }
            }
        }

        if (this.__core.setDimensions(w, h, unknownSize)) {
            this._onResize();
        }
    }

    _updateTextureCoords() {
        if (this.displayedTexture && this.displayedTexture._source) {
            let displayedTexture = this.displayedTexture;
            let displayedTextureSource = this.displayedTexture._source;

            let tx1 = 0, ty1 = 0, tx2 = 1.0, ty2 = 1.0;
            if (displayedTexture.clipping) {
                // Apply texture clipping.
                let w = displayedTextureSource.getRenderWidth();
                let h = displayedTextureSource.getRenderHeight();
                let iw, ih, rw, rh;
                iw = 1 / w;
                ih = 1 / h;

                if (displayedTexture.pw) {
                    rw = (displayedTexture.pw) * iw;
                } else {
                    rw = (w - displayedTexture.px) * iw;
                }

                if (displayedTexture.ph) {
                    rh = displayedTexture.ph * ih;
                } else {
                    rh = (h - displayedTexture.py) * ih;
                }

                iw *= (displayedTexture.px);
                ih *= (displayedTexture.py);

                tx1 = iw;
                ty1 = ih;
                tx2 = tx2 * rw + iw;
                ty2 = ty2 * rh + ih;

                tx1 = Math.max(0, tx1);
                ty1 = Math.max(0, ty1);
                tx2 = Math.min(1, tx2);
                ty2 = Math.min(1, ty2);
            }

            if (displayedTextureSource._flipTextureY) {
                let tempty = ty2;
                ty2 = ty1;
                ty1 = tempty;
            }
            this.__core.setTextureCoords(tx1, ty1, tx2, ty2);
        }
    }

    getCornerPoints() {
        return this.__core.getCornerPoints();
    }

    _unsetTagsParent() {
        if (this.__tags) {
            this.__tags.forEach((tag) => {
                // Remove from treeTags.
                let p = this;
                while (p = p.__parent) {
                    let parentTreeTags = p.__treeTags.get(tag);
                    parentTreeTags.delete(this);

                    if (p.__tagRoot) {
                        break;
                    }
                }
            });
        }

        let tags = null;
        let n = 0;
        if (this.__treeTags) {
            if (!this.__tagRoot) {
                tags = _Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].iteratorToArray(this.__treeTags.keys());
                n = tags.length;

                if (n > 0) {
                    for (let i = 0; i < n; i++) {
                        let tagSet = this.__treeTags.get(tags[i]);

                        // Remove from treeTags.
                        let p = this;
                        while ((p = p.__parent)) {
                            let parentTreeTags = p.__treeTags.get(tags[i]);

                            tagSet.forEach(function (comp) {
                                parentTreeTags.delete(comp);
                            });

                            if (p.__tagRoot) {
                                break;
                            }
                        }
                    }
                }
            }
        }
    };

    _setTagsParent() {
        // Just copy over the 'local' tags.
        if (this.__tags) {
            this.__tags.forEach((tag) => {
                let p = this;
                while (p = p.__parent) {
                    if (!p.__treeTags) {
                        p.__treeTags = new Map();
                    }

                    let s = p.__treeTags.get(tag);
                    if (!s) {
                        s = new Set();
                        p.__treeTags.set(tag, s);
                    }

                    s.add(this);

                    if (p.__tagRoot) {
                        break;
                    }
                }
            });
        }

        if (this.__treeTags && this.__treeTags.size) {
            if (!this.__tagRoot) {
                this.__treeTags.forEach((tagSet, tag) => {
                    let p = this;
                    while (!p.__tagRoot && (p = p.__parent)) {
                        if (p.__tagRoot) {
                            // Do not copy all subs.
                        }
                        if (!p.__treeTags) {
                            p.__treeTags = new Map();
                        }

                        let s = p.__treeTags.get(tag);
                        if (!s) {
                            s = new Set();
                            p.__treeTags.set(tag, s);
                        }

                        tagSet.forEach(function (comp) {
                            s.add(comp);
                        });
                    }
                });
            }
        }
    };


    _getByTag(tag) {
        if (!this.__treeTags) {
            return [];
        }
        let t = this.__treeTags.get(tag);
        return t ? _Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].setToArray(t) : [];
    };

    getTags() {
        return this.__tags ? this.__tags : [];
    };

    setTags(tags) {
        tags = tags.reduce((acc, tag) => {
            return acc.concat(tag.split(' '));
        }, []);

        if (this.__ref) {
            tags.push(this.__ref);
        }

        let i, n = tags.length;
        let removes = [];
        let adds = [];
        for (i = 0; i < n; i++) {
            if (!this.hasTag(tags[i])) {
                adds.push(tags[i]);
            }
        }

        let currentTags = this.tags || [];
        n = currentTags.length;
        for (i = 0; i < n; i++) {
            if (tags.indexOf(currentTags[i]) == -1) {
                removes.push(currentTags[i]);
            }
        }

        for (i = 0; i < removes.length; i++) {
            this.removeTag(removes[i]);
        }

        for (i = 0; i < adds.length; i++) {
            this.addTag(adds[i]);
        }
    }

    addTag(tag) {
        if (tag.indexOf(' ') === -1) {
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isUcChar(tag.charCodeAt(0))) {
                this._throwError("Tag may not start with an upper case character.");
            }

            this._addTag(tag);
        } else {
            const tags = tag.split(' ');
            for (let i = 0, m = tags.length; i < m; i++) {
                const tag = tags[i];

                if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isUcChar(tag.charCodeAt(0))) {
                    this._throwError("Tag may not start with an upper case character.");
                }

                this._addTag(tag);
            }
        }
    }

    _addTag(tag) {
        if (!this.__tags) {
            this.__tags = [];
        }
        if (this.__tags.indexOf(tag) === -1) {
            this.__tags.push(tag);

            // Add to treeTags hierarchy.
            let p = this.__parent;
            if (p) {
                do {
                    if (!p.__treeTags) {
                        p.__treeTags = new Map();
                    }

                    let s = p.__treeTags.get(tag);
                    if (!s) {
                        s = new Set();
                        p.__treeTags.set(tag, s);
                    }

                    s.add(this);

                } while (!p.__tagRoot && (p = p.__parent));
            }
        }
    }

    removeTag(tag) {
        let i = this.__tags.indexOf(tag);
        if (i !== -1) {
            this.__tags.splice(i, 1);

            // Remove from treeTags hierarchy.
            let p = this.__parent;
            if (p) {
                do {
                    let list = p.__treeTags.get(tag);
                    if (list) {
                        list.delete(this);
                    }
                } while (!p.__tagRoot && (p = p.__parent));
            }
        }
    }

    hasTag(tag) {
        return (this.__tags && (this.__tags.indexOf(tag) !== -1));
    }

    /**
     * Returns one of the elements from the subtree that have this tag.
     * @param {string} tag
     * @returns {Element}
     */
    _tag(tag) {
        if (tag.indexOf(".") !== -1) {
            return this.mtag(tag)[0];
        } else {
            if (this.__treeTags) {
                let t = this.__treeTags.get(tag);
                if (t) {
                    const item = t.values().next();
                    return item ? item.value : undefined;
                }
            }
        }
    };

    get tag() {
        return this._tag;
    }

    set tag(t) {
        this.tags = t;
    }

    /**
     * Returns all elements from the subtree that have this tag.
     * @param {string} tag
     * @returns {Element[]}
     */
    mtag(tag) {
        let idx = tag.indexOf(".");
        if (idx >= 0) {
            let parts = tag.split('.');
            let res = this._getByTag(parts[0]);
            let level = 1;
            let c = parts.length;
            while (res.length && level < c) {
                let resn = [];
                for (let j = 0, n = res.length; j < n; j++) {
                    resn = resn.concat(res[j]._getByTag(parts[level]));
                }

                res = resn;
                level++;
            }
            return res;
        } else {
            return this._getByTag(tag);
        }
    };

    stag(tag, settings) {
        let t = this.mtag(tag);
        let n = t.length;
        for (let i = 0; i < n; i++) {
            _Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].patchObject(t[i], settings);
        }
    }

    get tagRoot() {
        return this.__tagRoot;
    }

    set tagRoot(v) {
        if (this.__tagRoot !== v) {
            if (!v) {
                this._setTagsParent();
            } else {
                this._unsetTagsParent();
            }

            this.__tagRoot = v;
        }
    }

    sel(path) {
        const results = this.select(path);
        if (results.length) {
            return results[0];
        } else {
            return undefined;
        }
    }

    select(path) {
        if (path.indexOf(",") !== -1) {
            let selectors = path.split(',');
            let res = [];
            for (let i = 0; i < selectors.length; i++) {
                res = res.concat(this._select(selectors[i]));
            }
            return res;
        } else {
            return this._select(path);
        }
    }

    _select(path) {
        if (path === "") return [this];


        let pointIdx = path.indexOf(".");
        let arrowIdx = path.indexOf(">");
        if (pointIdx === -1 && arrowIdx === -1) {
            // Quick case.
            return this.mtag(path);
        }

        // Detect by first char.
        let isRef;
        if (arrowIdx === 0) {
            isRef = true;
            path = path.substr(1);
        } else if (pointIdx === 0) {
            isRef = false;
            path = path.substr(1);
        } else {
            isRef = false;
        }

        return this._selectChilds(path, isRef);
    }

    _selectChilds(path, isRef) {
        const pointIdx = path.indexOf(".");
        const arrowIdx = path.indexOf(">");

        if (pointIdx === -1 && arrowIdx === -1) {
            if (isRef) {
                const ref = this.getByRef(path);
                return ref ? [ref] : [];
            } else {
                return this.mtag(path);
            }
        }

        if ((arrowIdx === -1) || (pointIdx !== -1 && pointIdx < arrowIdx)) {
            let next;
            const str = path.substr(0, pointIdx);
            if (isRef) {
                const ref = this.getByRef(str);
                next = ref ? [ref] : [];
            } else {
                next = this.mtag(str);
            }
            let total = [];
            const subPath = path.substr(pointIdx + 1);
            for (let i = 0, n = next.length; i < n; i++) {
                total = total.concat(next[i]._selectChilds(subPath, false));
            }
            return total;
        } else {
            let next;
            const str = path.substr(0, arrowIdx);
            if (isRef) {
                const ref = this.getByRef(str);
                next = ref ? [ref] : [];
            } else {
                next = this.mtag(str);
            }
            let total = [];
            const subPath = path.substr(arrowIdx + 1);
            for (let i = 0, n = next.length; i < n; i++) {
                total = total.concat(next[i]._selectChilds(subPath, true));
            }
            return total;
        }
    }

    getByRef(ref) {
        return this.childList.getByRef(ref);
    }

    getLocationString() {
        let i;
        i = this.__parent ? this.__parent._children.getIndex(this) : "R";
        let localTags = this.getTags();
        let str = this.__parent ? this.__parent.getLocationString(): "";
        if (this.ref) {
            str += ":[" + i + "]" + this.ref;
        } else if (localTags.length) {
            str += ":[" + i + "]" + localTags.join(",");
        } else {
            str += ":[" + i + "]#" + this.id;
        }
        return str;
    }

    toString() {
        let obj = this.getSettings();
        return Element.getPrettyString(obj, "");
    };

    static getPrettyString(obj, indent) {
        let children = obj.children;
        delete obj.children;


        // Convert singular json settings object.
        let colorKeys = ["color", "colorUl", "colorUr", "colorBl", "colorBr"];
        let str = JSON.stringify(obj, function (k, v) {
            if (colorKeys.indexOf(k) !== -1) {
                return "COLOR[" + v.toString(16) + "]";
            }
            return v;
        });
        str = str.replace(/"COLOR\[([a-f0-9]{1,8})\]"/g, "0x$1");

        if (children) {
            let childStr = "";
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(children)) {
                let refs = Object.keys(children);
                childStr = "";
                for (let i = 0, n = refs.length; i < n; i++) {
                    childStr += `\n${indent}  "${refs[i]}":`
                    delete children[refs[i]].ref;
                    childStr += Element.getPrettyString(children[refs[i]], indent + "  ") + (i < n - 1 ? "," : "");
                }
                let isEmpty = (str === "{}");
                str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + childStr + "\n" + indent + "}";
            } else {
                let n = children.length;
                childStr = "[";
                for (let i = 0; i < n; i++) {
                    childStr += Element.getPrettyString(children[i], indent + "  ") + (i < n - 1 ? "," : "") + "\n";
                }
                childStr += indent + "]}";
                let isEmpty = (str === "{}");
                str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + "\"children\":\n" + indent + childStr + "}";
            }

        }

        return str;
    }

    getSettings() {
        let settings = this.getNonDefaults();

        let children = this._children.get();
        if (children) {
            let n = children.length;
            if (n) {
                const childArray = [];
                let missing = false;
                for (let i = 0; i < n; i++) {
                    childArray.push(children[i].getSettings());
                    missing = missing || !children[i].ref;
                }

                if (!missing) {
                    settings.children = {}
                    childArray.forEach(child => {
                        settings.children[child.ref] = child;
                    });
                } else {
                    settings.children = childArray;
                }
            }
        }

        settings.id = this.id;

        return settings;
    }

    getNonDefaults() {
        let settings = {};

        if (this.constructor !== Element) {
            settings.type = this.constructor.name;
        }

        if (this.__ref) {
            settings.ref = this.__ref;
        }

        if (this.__tags && this.__tags.length) {
            settings.tags = this.__tags;
        }

        if (this.x !== 0) settings.x = this.x;
        if (this.y !== 0) settings.y = this.y;
        if (this.w !== 0) settings.w = this.w;
        if (this.h !== 0) settings.h = this.h;

        if (this.scaleX === this.scaleY) {
            if (this.scaleX !== 1) settings.scale = this.scaleX;
        } else {
            if (this.scaleX !== 1) settings.scaleX = this.scaleX;
            if (this.scaleY !== 1) settings.scaleY = this.scaleY;
        }

        if (this.pivotX === this.pivotY) {
            if (this.pivotX !== 0.5) settings.pivot = this.pivotX;
        } else {
            if (this.pivotX !== 0.5) settings.pivotX = this.pivotX;
            if (this.pivotY !== 0.5) settings.pivotY = this.pivotY;
        }

        if (this.mountX === this.mountY) {
            if (this.mountX !== 0) settings.mount = this.mountX;
        } else {
            if (this.mountX !== 0) settings.mountX = this.mountX;
            if (this.mountY !== 0) settings.mountY = this.mountY;
        }

        if (this.alpha !== 1) settings.alpha = this.alpha;

        if (!this.visible) settings.visible = false;

        if (this.rotation !== 0) settings.rotation = this.rotation;

        if (this.colorUl === this.colorUr && this.colorBl === this.colorBr && this.colorUl === this.colorBl) {
            if (this.colorUl !== 0xFFFFFFFF) settings.color = this.colorUl.toString(16);
        } else {
            if (this.colorUl !== 0xFFFFFFFF) settings.colorUl = this.colorUl.toString(16);
            if (this.colorUr !== 0xFFFFFFFF) settings.colorUr = this.colorUr.toString(16);
            if (this.colorBl !== 0xFFFFFFFF) settings.colorBl = this.colorBl.toString(16);
            if (this.colorBr !== 0xFFFFFFFF) settings.colorBr = this.colorBr.toString(16);
        }

        if (this.zIndex) settings.zIndex = this.zIndex;

        if (this.forceZIndexContext) settings.forceZIndexContext = true;

        if (this.clipping) settings.clipping = this.clipping;

        if (!this.clipbox) settings.clipbox = this.clipbox;

        if (this.__texture) {
            let tnd = this.__texture.getNonDefaults();
            if (Object.keys(tnd).length) {
                settings.texture = tnd;
            }
        }

        if (this.shader && _Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(this.shader.getNonDefaults)) {
            let tnd = this.shader.getNonDefaults();
            if (Object.keys(tnd).length) {
                settings.shader = tnd;
            }
        }

        if (this._hasTexturizer()) {
            if (this.texturizer.enabled) {
                settings.renderToTexture = this.texturizer.enabled;
            }
            if (this.texturizer.lazy) {
                settings.renderToTextureLazy = this.texturizer.lazy;
            }
            if (this.texturizer.colorize) {
                settings.colorizeResultTexture = this.texturizer.colorize;
            }
            if (this.texturizer.renderOffscreen) {
                settings.renderOffscreen = this.texturizer.renderOffscreen;
            }
        }

        return settings;
    };

    static getGetter(propertyPath) {
        let getter = Element.PROP_GETTERS.get(propertyPath);
        if (!getter) {
            getter = new Function('obj', 'return obj.' + propertyPath);
            Element.PROP_GETTERS.set(propertyPath, getter);
        }
        return getter;
    }

    static getSetter(propertyPath) {
        let setter = Element.PROP_SETTERS.get(propertyPath);
        if (!setter) {
            setter = new Function('obj', 'v', 'obj.' + propertyPath + ' = v');
            Element.PROP_SETTERS.set(propertyPath, setter);
        }
        return setter;
    }

    get withinBoundsMargin() {
        return this.__core._withinBoundsMargin;
    }

    _enableWithinBoundsMargin() {
        // Iff enabled, this toggles the active flag.
        if (this.__enabled) {
            this._setActiveFlag();
        }
    }

    _disableWithinBoundsMargin() {
        // Iff active, this toggles the active flag.
        if (this.__active) {
            this._unsetActiveFlag();
        }
    }

    set boundsMargin(v) {
        if (!Array.isArray(v) && v !== null) {
            throw new Error("boundsMargin should be an array of left-top-right-bottom values or null (inherit margin)");
        }
        this.__core.boundsMargin = v;
    }

    get boundsMargin() {
        return this.__core.boundsMargin;
    }

    get x() {
        return this.__core.offsetX;
    }

    set x(v) {
        this.__core.offsetX = v;
    }

    get y() {
        return this.__core.offsetY;
    }

    set y(v) {
        this.__core.offsetY = v;
    }

    get w() {
        return this._w;
    }

    set w(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(v)) {
            this._w = 0;
            this.__core.funcW = v;
        } else {
            v = Math.max(v, 0);
            if (this._w !== v) {
                this.__core.disableFuncW();
                this._w = v;
                this._updateDimensions();
            }
        }
    }

    get h() {
        return this._h;
    }

    set h(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(v)) {
            this._h = 0;
            this.__core.funcH = v;
        } else {
            v = Math.max(v, 0);
            if (this._h !== v) {
                this.__core.disableFuncH();
                this._h = v;
                this._updateDimensions();
            }
        }
    }

    get collision() {
        return this._collision;
    }

    set collision(v) {
        this._collision = v;
    }

    _updateCollision() {
        if (this.collision && this.__parent && this.__parent.collision === undefined) {
            /**
             * Mark collision as 2 to indicate atleast one descendant has collision enabled.
             * This narrows down the search for elements with active collision.
            */
            this.__parent.collision = 2;
        }
    }

    get scaleX() {
        return this.__core.scaleX;
    }

    set scaleX(v) {
        this.__core.scaleX = v;
    }

    get scaleY() {
        return this.__core.scaleY;
    }

    set scaleY(v) {
        this.__core.scaleY = v;
    }

    get scale() {
        return this.__core.scale;
    }

    set scale(v) {
        this.__core.scale = v;
    }

    get pivotX() {
        return this.__core.pivotX;
    }

    set pivotX(v) {
        this.__core.pivotX = v;
    }

    get pivotY() {
        return this.__core.pivotY;
    }

    set pivotY(v) {
        this.__core.pivotY = v;
    }

    get pivot() {
        return this.__core.pivot;
    }

    set pivot(v) {
        this.__core.pivot = v;
    }

    get mountX() {
        return this.__core.mountX;
    }

    set mountX(v) {
        this.__core.mountX = v;
    }

    get mountY() {
        return this.__core.mountY;
    }

    set mountY(v) {
        this.__core.mountY = v;
    }

    get mount() {
        return this.__core.mount;
    }

    set mount(v) {
        this.__core.mount = v;
    }

    get rotation() {
        return this.__core.rotation;
    }

    set rotation(v) {
        this.__core.rotation = v;
    }

    get alpha() {
        return this.__core.alpha;
    }

    set alpha(v) {
        this.__core.alpha = v;
    }

    get visible() {
        return this.__core.visible;
    }

    set visible(v) {
        this.__core.visible = v;
    }
    
    get colorUl() {
        return this.__core.colorUl;
    }

    set colorUl(v) {
        this.__core.colorUl = v;
    }

    get colorUr() {
        return this.__core.colorUr;
    }

    set colorUr(v) {
        this.__core.colorUr = v;
    }

    get colorBl() {
        return this.__core.colorBl;
    }

    set colorBl(v) {
        this.__core.colorBl = v;
    }

    get colorBr() {
        return this.__core.colorBr;
    }

    set colorBr(v) {
        this.__core.colorBr = v;
    }

    get color() {
        return this.__core.colorUl;
    }

    set color(v) {
        if (this.colorUl !== v || this.colorUr !== v || this.colorBl !== v || this.colorBr !== v) {
            this.colorUl = v;
            this.colorUr = v;
            this.colorBl = v;
            this.colorBr = v;
        }
    }

    get colorTop() {
        return this.colorUl;
    }

    set colorTop(v) {
        if (this.colorUl !== v || this.colorUr !== v) {
            this.colorUl = v;
            this.colorUr = v;
        }
    }

    get colorBottom() {
        return this.colorBl;
    }

    set colorBottom(v) {
        if (this.colorBl !== v || this.colorBr !== v) {
            this.colorBl = v;
            this.colorBr = v;
        }
    }

    get colorLeft() {
        return this.colorUl;
    }

    set colorLeft(v) {
        if (this.colorUl !== v || this.colorBl !== v) {
            this.colorUl = v;
            this.colorBl = v;
        }
    }

    get colorRight() {
        return this.colorUr;
    }

    set colorRight(v) {
        if (this.colorUr !== v || this.colorBr !== v) {
            this.colorUr = v;
            this.colorBr = v;
        }
    }

    get zIndex() {return this.__core.zIndex}
    set zIndex(v) {
        this.__core.zIndex = v;
    }

    get forceZIndexContext() {return this.__core.forceZIndexContext}
    set forceZIndexContext(v) {
        this.__core.forceZIndexContext = v;
    }

    get clipping() {return this.__core.clipping}
    set clipping(v) {
        this.__core.clipping = v;
    }

    get clipbox() {return this.__core.clipbox}
    set clipbox(v) {
        this.__core.clipbox = v;
    }

    get tags() {
        return this.getTags();
    }

    set tags(v) {
        if (!Array.isArray(v)) v = [v];
        this.setTags(v);
    }

    set t(v) {
        this.tags = v;
    }

    get _children() {
        if (!this.__childList) {
            this.__childList = new _ElementChildList_mjs__WEBPACK_IMPORTED_MODULE_8__["default"](this, false);
        }
        return this.__childList;
    }

    get childList() {
        if (!this._allowChildrenAccess()) {
            this._throwError("Direct access to children is not allowed in " + this.getLocationString());
        }
        return this._children;
    }

    hasChildren() {
        return this._allowChildrenAccess() && this.__childList && (this.__childList.length > 0);
    }

    _allowChildrenAccess() {
        return true;
    }

    get children() {
        return this.childList.get();
    }

    set children(children) {
        this.childList.patch(children);
    }

    add(o) {
        return this.childList.a(o);
    }

    get p() {
        return this.__parent;
    }

    get parent() {
        return this.__parent;
    }

    get src() {
        if (this.texture && this.texture instanceof _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_9__["default"]) {
            return this.texture._src;
        } else {
            return undefined;
        }
    }

    set src(v) {
        const texture = new _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_9__["default"](this.stage);
        texture.src = v;
        this.texture = texture;
    }

    set mw(v) {
        if (this.texture) {
            this.texture.mw = v;
            this._updateDimensions();
        } else {
            this._throwError('Please set mw after setting a texture.');
        }
    }

    set mh(v) {
        if (this.texture) {
            this.texture.mh = v;
            this._updateDimensions();
        } else {
            this._throwError('Please set mh after setting a texture.');
        }
    }

    get rect() {
        return (this.texture === this.stage.rectangleTexture);
    }

    set rect(v) {
        if (v) {
            this.texture = this.stage.rectangleTexture;
        } else {
            this.texture = null;
        }
    }

    enableTextTexture() {
        if (!this.texture || !(this.texture instanceof _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])) {
            this.texture = new _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"](this.stage);

            if (!this.texture.w && !this.texture.h) {
                // Inherit dimensions from element.
                // This allows userland to set dimensions of the Element and then later specify the text.
                this.texture.w = this.w;
                this.texture.h = this.h;
            }
        }
        return this.texture;
    }

    get text() {
        if (this.texture && (this.texture instanceof _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])) {
            return this.texture;
        } else {
            return null;
        }
    }

    set text(v) {
        if (!this.texture || !(this.texture instanceof _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])) {
            this.enableTextTexture();
        }
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isString(v)) {
            this.texture.text = v;
        } else {
            this.texture.patch(v);
        }
    }

    set onUpdate(f) {
        this.__core.onUpdate = f;
    }

    set onAfterCalcs(f) {
        this.__core.onAfterCalcs = f;
    }

    set onAfterUpdate(f) {
        this.__core.onAfterUpdate = f;
    }

    forceUpdate() {
        // Make sure that the update loop is run.
        this.__core._setHasUpdates();
    }

    get shader() {
        return this.__core.shader;
    }

    set shader(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(v) && !v.type) {
            // Setting properties on an existing shader.
            if (this.shader) {
                this.shader.patch(v);
            }
        } else {
            const shader = _Shader_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].create(this.stage, v);

            if (this.__enabled && this.__core.shader) {
                this.__core.shader.removeElement(this.__core);
            }

            this.__core.shader = shader;

            if (this.__enabled && this.__core.shader) {
                this.__core.shader.addElement(this.__core);
            }
        }
    }

    _hasTexturizer() {
        return !!this.__core._texturizer;
    }

    get renderToTexture() {
        return this.rtt
    }

    set renderToTexture(v) {
        this.rtt = v
    }

    get rtt() {
        return this._hasTexturizer() && this.texturizer.enabled;
    }

    set rtt(v) {
        this.texturizer.enabled = v;
    }

    get rttLazy() {
        return this._hasTexturizer() && this.texturizer.lazy;
    }

    set rttLazy(v) {
        this.texturizer.lazy = v;
    }

    get renderOffscreen() {
        return this._hasTexturizer() && this.texturizer.renderOffscreen;
    }

    set renderOffscreen(v) {
        this.texturizer.renderOffscreen = v;
    }

    get colorizeResultTexture() {
        return this._hasTexturizer() && this.texturizer.colorize;
    }

    set colorizeResultTexture(v) {
        this.texturizer.colorize = v;
    }

    getTexture() {
        return this.texturizer._getTextureSource();
    }

    get texturizer() {
        return this.__core.texturizer;
    }

    patch(settings) {
        let paths = Object.keys(settings);

        for (let i = 0, n = paths.length; i < n; i++) {
            let path = paths[i];
            const v = settings[path];

            const firstCharCode = path.charCodeAt(0);
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isUcChar(firstCharCode)) {
                // Ref.
                const child = this.getByRef(path);
                if (!child) {
                    if (v !== undefined) {
                        // Add to list immediately.
                        let c;
                        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(v)) {
                            // Catch this case to capture createMode flag.
                            c = this.childList.createItem(v);
                            c.patch(v);
                        } else if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObject(v)) {
                            c = v;
                        }
                        if (c.isElement) {
                            c.ref = path;
                        }

                        this.childList.a(c);
                    }
                } else {
                    if (v === undefined) {
                        if (child.parent) {
                            child.parent.childList.remove(child);
                        }
                    } else if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(v)) {
                        child.patch(v);
                    } else if (v.isElement) {
                        // Replace element by new element.
                        v.ref = path;
                        this.childList.replace(v, child);
                    } else {
                        this._throwError("Unexpected value for path: " + path);
                    }
                }
            } else {
                // Property.
                _Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].patchObjectProperty(this, path, v);
            }
        }
    }

    _throwError(message) {
        throw new Error(this.constructor.name + " (" + this.getLocationString() + "): " + message);
    }

    animation(settings) {
        return this.stage.animations.createAnimation(this, settings);
    }

    transition(property, settings = null) {
        if (settings === null) {
            return this._getTransition(property);
        } else {
            this._setTransition(property, settings);
            // We do not create/return the transition, because it would undo the 'lazy transition creation' optimization.
            return null;
        }
    }

    set transitions(object) {
        let keys = Object.keys(object);
        keys.forEach(property => {
            this.transition(property, object[property]);
        });
    }

    set smooth(object) {
        let keys = Object.keys(object);
        keys.forEach(property => {
            let value = object[property];
            if (Array.isArray(value)) {
                this.setSmooth(property, value[0], value[1]);
            } else {
                this.setSmooth(property, value);
            }
        });
    }

    fastForward(property) {
        if (this._transitions) {
            let t = this._transitions[property];
            if (t && t.isTransition) {
                t.finish();
            }
        }
    }

    _getTransition(property) {
        if (!this._transitions) {
            this._transitions = {};
        }
        let t = this._transitions[property];
        if (!t) {
            // Create default transition.
            t = new _animation_Transition_mjs__WEBPACK_IMPORTED_MODULE_10__["default"](this.stage.transitions, this.stage.transitions.defaultTransitionSettings, this, property);
        } else if (t.isTransitionSettings) {
            // Upgrade to 'real' transition.
            t = new _animation_Transition_mjs__WEBPACK_IMPORTED_MODULE_10__["default"](
                this.stage.transitions,
                t,
                this,
                property
            );
        }
        this._transitions[property] = t;
        return t;
    }

    _setTransition(property, settings) {
        if (!settings) {
            this._removeTransition(property);
        } else {
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(settings)) {
                // Convert plain object to proper settings object.
                settings = this.stage.transitions.createSettings(settings);
            }

            if (!this._transitions) {
                this._transitions = {};
            }

            let current = this._transitions[property];
            if (current && current.isTransition) {
                // Runtime settings change.
                current.settings = settings;
                return current;
            } else {
                // Initially, only set the settings and upgrade to a 'real' transition when it is used.
                this._transitions[property] = settings;
            }
        }
    }

    _removeTransition(property) {
        if (this._transitions) {
            delete this._transitions[property];
        }
    }

    getSmooth(property, v) {
        let t = this._getTransition(property);
        if (t && t.isAttached()) {
            return t.targetValue;
        } else {
            return v;
        }
    }

    setSmooth(property, v, settings) {
        if (settings) {
            this._setTransition(property, settings);
        }
        let t = this._getTransition(property);
        t.start(v);
        return t;
    }

    get flex() {
        return this.__core.flex;
    }

    set flex(v) {
        this.__core.flex = v;
    }

    get flexItem() {
        return this.__core.flexItem;
    }

    set flexItem(v) {
        this.__core.flexItem = v;
    }

    static isColorProperty(property) {
        return property.toLowerCase().indexOf("color") >= 0;
    }

    static getMerger(property) {
        if (Element.isColorProperty(property)) {
            return _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].mergeColors;
        } else {
            return _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].mergeNumbers;
        }
    }

    toJSON() {
        const ref = [`${this.constructor.name}`];
        const tree = {};
        tree[ref] = {};

        if (this.hasChildren()) {
            Element.collectChildren(tree[ref], this.__childList);
        } else {
            tree[ref] = {...Element.getProperties(this)};
        }
        return tree;
    }

    static collectChildren(tree, children) {
        const childList = children;
        for (let i = 0, j = childList.length; i < j; i++) {
            const element = childList.getAt(i);
            const ref = `${element.__ref || `Element-${element.id}`}`;
            const properties = this.getProperties(element);

            tree[ref] = {...properties};

            if (element.hasChildren()) {
                tree[ref].children = {};
                this.collectChildren(
                    tree[ref].children, element.__childList
                );
            }
        }
    }

    static getProperties(element) {
        const props = {};
        const list = [
            "alpha", "active", "attached", "boundsMargin", "color", "clipping", "enabled", "h", "id", "isComponent",
            "mount", "mountY", "mountX", "pivot", "pivotX", "pivotY", "ref", "renderOfScreen", "renderToTexture", "scale",
            "scaleX", "scaleY", "state", "tag", "visible", "w", "x", "y", "zIndex",
            "!!flex", "!!flexItem", "hasFocus()", "hasFinalFocus()"
        ];
        let n = list.length;

        while (n--) {
            let key = list[n];
            const getBoolean = /^!{2}/;
            const isFunction = /\(\)$/;

            if (getBoolean.test(key)) {
                key = key.substring(2, key.length);
                props[key] = !!element[key];
            } else if (isFunction.test(key)) {
                key = key.substring(0, key.length - 2);
                if (typeof element[key] === "function") {
                    props[key] = element[key]();
                }
            } else {
                props[key] = element[key];
            }
        }
        return {...props, ...element.getNonDefaults()};
    }
}

// This gives a slight performance benefit compared to extending EventEmitter.
_EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].addAsMixin(Element);

Element.prototype.isElement = 1;

Element.id = 1;

// Getters reused when referencing element (subobject) properties by a property path, as used in a transition or animation ('x', 'texture.x', etc).
Element.PROP_GETTERS = new Map();

// Setters reused when referencing element (subobject) properties by a property path, as used in a transition or animation ('x', 'texture.x', etc).
Element.PROP_SETTERS = new Map();









/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/ElementChildList.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/ElementChildList.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementChildList)
/* harmony export */ });
/* harmony import */ var _ObjectList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObjectList.mjs */ "./node_modules/@lightningjs/core/src/tree/ObjectList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Manages the list of children for an element.
 */



class ElementChildList extends _ObjectList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(element) {
        super();
        this._element = element;
    }

    _connectParent(item) {
        const prevParent = item.parent;
        if (prevParent && prevParent !== this._element) {
            // Cleanup in previous child list, without
            const prevChildList = item.parent.childList;
            const index = prevChildList.getIndex(item);

            if (item.ref) {
                prevChildList._refs[item.ref] = undefined;
            }
            prevChildList._items.splice(index, 1);

            // Also clean up element core.
            prevParent.core.removeChildAt(index);

        }

        item._setParent(this._element);

        // We are expecting the caller to sync it to the core.
    }

    onAdd(item, index) {
        this._connectParent(item);
        this._element.core.addChildAt(index, item.core);
    }

    onRemove(item, index) {
        item._setParent(null);
        this._element.core.removeChildAt(index);
    }

    onSync(removed, added, order) {
        for (let i = 0, n = removed.length; i < n; i++) {
            removed[i]._setParent(null);
        }
        for (let i = 0, n = added.length; i < n; i++) {
            this._connectParent(added[i]);
        }
        let gc = i => i.core;
        this._element.core.syncChildren(removed.map(gc), added.map(gc), order.map(gc));
    }

    onSet(item, index, prevItem) {
        prevItem._setParent(null);

        this._connectParent(item);
        this._element.core.setChildAt(index, item.core);
    }

    onMove(item, fromIndex, toIndex) {
        this._element.core.moveChild(fromIndex, toIndex);
    }

    createItem(object) {
        if (object.type) {
            return new object.type(this._element.stage);
        } else {
            return this._element.stage.createElement();
        }
    }

    isItem(object) {
        return object.isElement;
    }

}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/ObjectList.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/ObjectList.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ObjectList)
/* harmony export */ });
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Manages a list of objects.
 * Objects may be patched. Then, they can be referenced using the 'ref' (string) property.
 */
class ObjectList {

    constructor() {
        this._items = [];
        this._refs = {}
    }

    get() {
        return this._items;
    }

    get first() {
        return this._items[0];
    }

    get last() {
        return this._items.length ? this._items[this._items.length - 1] : undefined;
    }

    add(item) {
        this.addAt(item, this._items.length);
    }

    addAt(item, index) {
        if (index >= 0 && index <= this._items.length) {
            let currentIndex = this._items.indexOf(item);
            if (currentIndex === index) {
                return item;
            }

            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(item)) {
                const o = item;
                item = this.createItem(o);
                item.patch(o);
            }

            if (currentIndex != -1) {
                this.setAt(item, index);
            } else {
                if (item.ref) {
                    this._refs[item.ref] = item;
                }
                this._items.splice(index, 0, item);
                this.onAdd(item, index);
            }
        } else {
            throw new Error('addAt: The index ' + index + ' is out of bounds ' + this._items.length);
        }
    }

    replaceByRef(item) {
        if (item.ref) {
            const existingItem = this.getByRef(item.ref);
            if (!existingItem) {
                throw new Error('replaceByRef: no item found with reference: ' + item.ref);
            }
            this.replace(item, existingItem);
        } else {
            throw new Error('replaceByRef: no ref specified in item');
        }
        this.addAt(item, this._items.length);

    }

    replace(item, prevItem) {
        const index = this.getIndex(prevItem);
        if (index === -1) {
            throw new Error('replace: The previous item does not exist');
        }
        this.setAt(item, index);
    }

    setAt(item, index) {
        if (index >= 0 && index < this._items.length) {

            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(item)) {
                const o = item;
                item = this.createItem(o);
                item.patch(o);
            }

            let currentIndex = this._items.indexOf(item);
            if (currentIndex != -1) {
                if (currentIndex !== index) {
                    const fromIndex = currentIndex;
                    if (fromIndex !== index) {
                        this._items.splice(fromIndex, 1);
                        this._items.splice(index, 0, item);
                        this.onMove(item, fromIndex, index);
                    }
                }
            } else {
                if (index < this._items.length) {
                    if (this._items[index].ref) {
                        this._refs[this._items[index].ref] = undefined;
                    }
                }

                const prevItem = this._items[index];

                // Doesn't exist yet: overwrite current.
                this._items[index] = item;

                if (item.ref) {
                    this._refs[item.ref] = item;
                }

                this.onSet(item, index, prevItem);
            }
        } else {
            throw new Error('setAt: The index ' + index + ' is out of bounds ' + this._items.length);
        }
    }

    getAt(index) {
        return this._items[index];
    }

    getIndex(item) {
        return this._items.indexOf(item);
    }

    remove(item) {
        let index = this._items.indexOf(item);

        if (index !== -1) {
            this.removeAt(index);
        }
    };

    removeAt(index) {
        if (index >= 0 && index < this._items.length) {
            const item = this._items[index];

            if (item.ref) {
                this._refs[item.ref] = undefined;
            }

            this._items.splice(index, 1);

            this.onRemove(item, index);

            return item;
        } else {
            throw new Error(`removeAt: The index ${index} is out of bounds ${this._items.length - 1}`);
        }
    };

    clear() {
        let n = this._items.length;
        if (n) {
            let prev = this._items;
            this._items = [];
            this._refs = {}
            this.onSync(prev, [], []);
        }
    };

    a(o) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(o)) {
            let c = this.createItem(o);
            c.patch(o);
            this.add(c);
            return c;
        } else if (Array.isArray(o)) {
            for (let i = 0, n = o.length; i < n; i++) {
                this.a(o[i]);
            }
            return null;
        } else if (this.isItem(o)) {
            this.add(o);
            return o;
        }
    };

    get length() {
        return this._items.length;
    }

    _getRefs() {
        return this._refs;
    }

    getByRef(ref) {
        return this._refs[ref];
    }

    clearRef(ref) {
        delete this._refs[ref];
    }

    setRef(ref, child) {
        this._refs[ref] = child;
    }

    patch(settings) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(settings)) {
            this._setByObject(settings);
        } else if (Array.isArray(settings)) {
            this._setByArray(settings);
        }
    }

    _setByObject(settings) {
        // Overrule settings of known referenced items.
        let refs = this._getRefs();
        let crefs = Object.keys(settings);
        for (let i = 0, n = crefs.length; i < n; i++) {
            let cref = crefs[i];
            let s = settings[cref];

            let c = refs[cref];
            if (!c) {
                if (this.isItem(s)) {
                    // Replace previous item;
                    s.ref = cref;
                    this.add(s);
                } else {
                    // Create new item.
                    c = this.createItem(s);
                    c.ref = cref;
                    c.patch(s);
                    this.add(c);
                }
            } else {
                if (this.isItem(s)) {
                    if (c !== s) {
                        // Replace previous item;
                        let idx = this.getIndex(c);
                        s.ref = cref;
                        this.setAt(s, idx);
                    }
                } else {
                    c.patch(s);
                }
            }
        }
    }

    _equalsArray(array) {
        let same = true;
        if (array.length === this._items.length) {
            for (let i = 0, n = this._items.length; (i < n) && same; i++) {
                same = same && (this._items[i] === array[i]);
            }
        } else {
            same = false;
        }
        return same;
    }

    _setByArray(array) {
        // For performance reasons, first check if the arrays match exactly and bail out if they do.
        if (this._equalsArray(array)) {
            return;
        }

        for (let i = 0, n = this._items.length; i < n; i++) {
            this._items[i].marker = true;
        }

        let refs;
        let newItems = [];
        for (let i = 0, n = array.length; i < n; i++) {
            let s = array[i];
            if (this.isItem(s)) {
                s.marker = false;
                newItems.push(s);
            } else {
                let cref = s.ref;
                let c;
                if (cref) {
                    if (!refs) refs = this._getRefs();
                    c = refs[cref];
                }

                if (!c) {
                    // Create new item.
                    c = this.createItem(s);
                } else {
                    c.marker = false;
                }

                if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(s)) {
                    c.patch(s);
                }

                newItems.push(c);
            }
        }

        this._setItems(newItems);
    }

    _setItems(newItems) {
        let prevItems = this._items;
        this._items = newItems;

        // Remove the items.
        let removed = prevItems.filter(item => {let m = item.marker; delete item.marker; return m});
        let added = newItems.filter(item => (prevItems.indexOf(item) === -1));

        if (removed.length || added.length) {
            // Recalculate refs.
            this._refs = {}
            for (let i = 0, n = this._items.length; i < n; i++) {
                let ref = this._items[i].ref;
                if (ref) {
                    this._refs[ref] = this._items[i];
                }
            }
        }

        this.onSync(removed, added, newItems);
    }

    sort(f) {
        const items = this._items.slice();
        items.sort(f);
        this._setByArray(items);
    }

    onAdd(item, index) {
    }

    onRemove(item, index) {
    }

    onSync(removed, added, order) {
    }

    onSet(item, index, prevItem) {
    }

    onMove(item, fromIndex, toIndex) {
    }

    createItem(object) {
        throw new Error("ObjectList.createItem must create and return a new object");
    }

    isItem(object) {
        return false;
    }

    forEach(f) {
        this.get().forEach(f);
    }

}






/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Shader.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Shader.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Shader)
/* harmony export */ });
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class Shader {

    constructor(coreContext) {
        this._initialized = false;

        this.ctx = coreContext;

        /**
         * The (enabled) elements that use this shader.
         * @type {Set<ElementCore>}
         */
        this._elements = new Set();
    }

    static create(stage, v) {
        let shader;
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(v)) {
            if (v.type) {
                shader = stage.renderer.createShader(stage.ctx, v);
            } else {
                shader = this.shader;
            }

            if (shader) {
                _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].patchObject(shader, v);
            }
        } else if (v === null) {
            shader = stage.ctx.renderState.defaultShader;
        } else if (v === undefined) {
            shader = null;
        } else {
            if (v.isShader) {
                if (!stage.renderer.isValidShaderType(v.constructor)) {
                    console.error("[Lightning] Invalid shader type");
                    v = null;
                }
                shader = v;
            } else {
                console.error("[Lightning] Please specify a shader type.");
                return;
            }
        }

        return shader;
    }

    static getWebGL() {
        return undefined;
    }

    static getC2d() {
        return undefined;
    }

    addElement(elementCore) {
        this._elements.add(elementCore);
    }

    removeElement(elementCore) {
        this._elements.delete(elementCore);
        if (!this._elements) {
            this.cleanup();
        }
    }

    redraw() {
        this._elements.forEach(elementCore => {
            elementCore.setHasRenderUpdates(2);
        });
    }

    patch(settings) {
        _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].patchObject(this, settings);
    }

    useDefault() {
        // Should return true if this shader is configured (using it's properties) to not have any effect.
        // This may allow the render engine to avoid unnecessary shader program switches or even texture copies.
        return false;
    }

    addEmpty() {
        // Draws this shader even if there are no quads to be added.
        // This is handy for custom shaders.
        return false;
    }

    cleanup() {
        // Called when no more enabled elements have this shader.
    }

    get isShader() {
        return true;
    }
}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Stage.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Stage.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Stage)
/* harmony export */ });
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _renderer_webgl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/webgl/WebGLRenderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLRenderer.mjs");
/* harmony import */ var _renderer_c2d_C2dRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/c2d/C2dRenderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dRenderer.mjs");
/* harmony import */ var _renderer_spark_SparkRenderer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/spark/SparkRenderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/spark/SparkRenderer.mjs");
/* harmony import */ var _platforms_PlatformLoader_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platforms/PlatformLoader.mjs */ "./node_modules/@lightningjs/core/src/platforms/PlatformLoader.mjs");
/* harmony import */ var _tools_WebGLStateManager_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tools/WebGLStateManager.mjs */ "./node_modules/@lightningjs/core/src/tools/WebGLStateManager.mjs");
/* harmony import */ var _Shader_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/* harmony import */ var _Element_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Element.mjs */ "./node_modules/@lightningjs/core/src/tree/Element.mjs");
/* harmony import */ var _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _TextureManager_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./TextureManager.mjs */ "./node_modules/@lightningjs/core/src/tree/TextureManager.mjs");
/* harmony import */ var _TextureThrottler_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./TextureThrottler.mjs */ "./node_modules/@lightningjs/core/src/tree/TextureThrottler.mjs");
/* harmony import */ var _core_CoreContext_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/CoreContext.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreContext.mjs");
/* harmony import */ var _animation_TransitionManager_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../animation/TransitionManager.mjs */ "./node_modules/@lightningjs/core/src/animation/TransitionManager.mjs");
/* harmony import */ var _animation_AnimationManager_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../animation/AnimationManager.mjs */ "./node_modules/@lightningjs/core/src/animation/AnimationManager.mjs");
/* harmony import */ var _textures_RectangleTexture_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../textures/RectangleTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/RectangleTexture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Application render tree.
 */










class Stage extends _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(options = {}) {
        super();
        this._setOptions(options);

        this._usedMemory = 0;
        this._lastGcFrame = 0;

        const platformType = Stage.platform ? Stage.platform : _platforms_PlatformLoader_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].load(options);
        this.platform = new platformType();

        if (this.platform.init) {
            this.platform.init(this);
        }

        this.gl = null;
        this.c2d = null;

        const context = this.getOption('context');
        if (context) {
            if (context.useProgram) {
                this.gl = context;
            } else {
                this.c2d = context;
            }
        } else {
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isWeb && (!Stage.isWebglSupported() || this.getOption('canvas2d'))) {
                this.c2d = this.platform.createCanvasContext(this.getOption('w'), this.getOption('h'));
            } else {
                this.gl = this.platform.createWebGLContext(this.getOption('w'), this.getOption('h'));
            }
        }

        if (this.gl) {
            // Wrap in WebGLStateManager.
            // This prevents unnecessary double WebGL commands from being executed, and allows context switching.
            // Context switching is necessary when reusing the same context for Three.js.
            // Note that the user must make sure that the WebGL context is untouched before creating the application,
            //  when manually passing over a canvas or context in the options.
            _tools_WebGLStateManager_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].enable(this.gl, "lightning")
        }

        this._mode = this.gl ? 0 : 1;

        // Override width and height.
        if (this.getCanvas()) {
            this._options.w = this.getCanvas().width;
            this._options.h = this.getCanvas().height;
        }

        if (this._mode === 0) {
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark) {
                this._renderer = new _renderer_spark_SparkRenderer_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](this);
            } else {
                this._renderer = new _renderer_webgl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this);
            }
        } else {
            this._renderer = new _renderer_c2d_C2dRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](this);
        }

        this.setClearColor(this.getOption('clearColor'));

        this.frameCounter = 0;

        this.transitions = new _animation_TransitionManager_mjs__WEBPACK_IMPORTED_MODULE_8__["default"](this);
        this.animations = new _animation_AnimationManager_mjs__WEBPACK_IMPORTED_MODULE_9__["default"](this);

        this.textureManager = new _TextureManager_mjs__WEBPACK_IMPORTED_MODULE_10__["default"](this);
        this.textureThrottler = new _TextureThrottler_mjs__WEBPACK_IMPORTED_MODULE_11__["default"](this);

        this.startTime = 0;
        this.currentTime = 0;
        this.dt = 0;

        // Preload rectangle texture, so that we can skip some border checks for loading textures.
        this.rectangleTexture = new _textures_RectangleTexture_mjs__WEBPACK_IMPORTED_MODULE_12__["default"](this);
        this.rectangleTexture.load();

        // Never clean up because we use it all the time.
        this.rectangleTexture.source.permanent = true;

        this.ctx = new _core_CoreContext_mjs__WEBPACK_IMPORTED_MODULE_13__["default"](this);

        this._updateSourceTextures = new Set();
    }

    get renderer() {
        return this._renderer;
    }

    static isWebglSupported() {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNode) {
            return true;
        }

        try {
            return !!window.WebGLRenderingContext;
        } catch(e) {
            return false;
        }
    }

    /**
     * Returns the rendering mode.
     * @returns {number}
     *  0: WebGL
     *  1: Canvas2d
     */
    get mode() {
        return this._mode;
    }

    isWebgl() {
        return this.mode === 0;
    }

    isC2d() {
        return this.mode === 1;
    }

    getOption(name) {
        return this._options[name];
    }

    _setOptions(o) {
        this._options = {};

        let opt = (name, def) => {
            let value = o[name];

            if (value === undefined) {
                this._options[name] = def;
            } else {
                this._options[name] = value;
            }
        }

        opt('canvas', null);
        opt('context', null);
        opt('w', 1920);
        opt('h', 1080);
        opt('srcBasePath', null);
        opt('memoryPressure', 24e6);
        opt('bufferMemory', 2e6);
        opt('textRenderIssueMargin', 0);
        opt('fontSharp',{precision:0.6666666667, fontSize: 24})
        opt('clearColor', [0, 0, 0, 0]);
        opt('defaultFontFace', 'sans-serif');
        opt('fixedDt', 0);
        opt('useImageWorker', true);
        opt('autostart', true);
        opt('precision', 1);
        opt('canvas2d', false);
        opt('platform', null);
        opt('readPixelsBeforeDraw', false);
    }

    setApplication(app) {
        this.application = app;
    }

    init() {

        if (this.application.getOption('debug') && this.platform._imageWorker) {
            console.log('[Lightning] Using image worker!');
        }

        if (this.application.getOption('debug') && this.c2d) {
            console.log('[Lightning] Using canvas2d renderer');
        }

        this.application.setAsRoot();
        if (this.getOption('autostart')) {
            this.platform.startLoop();
        }
    }

    destroy() {
        this.platform.stopLoop();
        this.platform.destroy();
        this.ctx.destroy();
        this.textureManager.destroy();
        this._renderer.destroy();
    }

    stop() {
        this.platform.stopLoop();
    }

    resume() {
        this.platform.startLoop();
    }

    get root() {
        return this.application;
    }

    getCanvas() {
        return this._mode ? this.c2d.canvas : this.gl.canvas;
    }

    getRenderPrecision() {
        return this._options.precision;
    }

    /**
     * Marks a texture for updating it's source upon the next drawFrame.
     * @param texture
     */
    addUpdateSourceTexture(texture) {
        if (this._updatingFrame) {
            // When called from the upload loop, we must immediately load the texture in order to avoid a 'flash'.
            texture._performUpdateSource();
        } else {
            this._updateSourceTextures.add(texture);
        }
    }

    removeUpdateSourceTexture(texture) {
        if (this._updateSourceTextures) {
            this._updateSourceTextures.delete(texture);
        }
    }

    hasUpdateSourceTexture(texture) {
        return (this._updateSourceTextures && this._updateSourceTextures.has(texture));
    }

    drawFrame() {
        this.startTime = this.currentTime;
        this.currentTime = this.platform.getHrTime();

        if (this._options.fixedDt) {
            this.dt = this._options.fixedDt;
        } else {
            this.dt = (!this.startTime) ? .02 : .001 * (this.currentTime - this.startTime);
        }

        this.emit('frameStart');

        if (this._updateSourceTextures.size) {
            this._updateSourceTextures.forEach(texture => {
                texture._performUpdateSource();
            });
            this._updateSourceTextures = new Set();
        }

        this.emit('update');

        const changes = this.ctx.hasRenderUpdates();

        // Update may cause textures to be loaded in sync, so by processing them here we may be able to show them
        // during the current frame already.
        this.textureThrottler.processSome();

        if (changes) {
            this._updatingFrame = true;
            this.ctx.update();
            this.ctx.render();
            this._updatingFrame = false;
        }

        this.platform.nextFrame(changes);

        this.emit('frameEnd');

        this.frameCounter++;
    }

    isUpdatingFrame() {
        return this._updatingFrame;
    }

    renderFrame() {
        this.ctx.frame();
    }

    forceRenderUpdate() {
        // Enforce re-rendering.
        if (this.root) {
            this.root.core._parent.setHasRenderUpdates(1);
        }
    }

    setClearColor(clearColor) {
        this.forceRenderUpdate();
        if (clearColor === null) {
            // Do not clear.
            this._clearColor = null;
        } else if (Array.isArray(clearColor)) {
            this._clearColor = clearColor;
        } else {
            this._clearColor = _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_14__["default"].getRgbaComponentsNormalized(clearColor);
        }
    }

    getClearColor() {
        return this._clearColor;
    }

    createElement(settings) {
        if (settings) {
            return this.element(settings);
        } else {
            return new _Element_mjs__WEBPACK_IMPORTED_MODULE_15__["default"](this);
        }
    }

    createShader(settings) {
        return _Shader_mjs__WEBPACK_IMPORTED_MODULE_7__["default"].create(this, settings);
    }

    element(settings) {
        if (settings.isElement) return settings;

        let element;
        if (settings.type) {
            element = new settings.type(this);
        } else {
            element = new _Element_mjs__WEBPACK_IMPORTED_MODULE_15__["default"](this);
        }

        element.patch(settings);

        return element;
    }

    c(settings) {
        return this.element(settings);
    }

    get w() {
        return this._options.w;
    }

    get h() {
        return this._options.h;
    }

    get coordsWidth() {
        return this.w / this._options.precision;
    }

    get coordsHeight() {
        return this.h / this._options.precision;
    }

    addMemoryUsage(delta) {
        this._usedMemory += delta;
        if (this._lastGcFrame !== this.frameCounter) {
            if (this._usedMemory > this.getOption('memoryPressure')) {
                this.gc(false);
                if (this._usedMemory > this.getOption('memoryPressure') - 2e6) {
                    // Too few released. Aggressive cleanup.
                    this.gc(true);
                }
            }
        }
    }

    get usedMemory() {
        return this._usedMemory;
    }

    gc(aggressive) {
        if (this._lastGcFrame !== this.frameCounter) {
            this._lastGcFrame = this.frameCounter;
            const memoryUsageBefore = this._usedMemory;
            this.gcTextureMemory(aggressive);
            this.gcRenderTextureMemory(aggressive);
            this.renderer.gc(aggressive);

            if (this.application.getOption('debug')) {
                console.log(`[Lightning] GC${aggressive ? "[aggressive]" : ""}! Frame ${this._lastGcFrame} Freed ${((memoryUsageBefore - this._usedMemory) / 1e6).toFixed(2)}MP from GPU memory. Remaining: ${(this._usedMemory / 1e6).toFixed(2)}MP`);
                const other = this._usedMemory - this.textureManager.usedMemory - this.ctx.usedMemory;
                console.log(`[Lightning] Textures: ${(this.textureManager.usedMemory / 1e6).toFixed(2)}MP, Render Textures: ${(this.ctx.usedMemory / 1e6).toFixed(2)}MP, Renderer caches: ${(other / 1e6).toFixed(2)}MP`);
            }
        }
    }

    gcTextureMemory(aggressive = false) {
        if (aggressive && this.ctx.root.visible) {
            // Make sure that ALL textures are cleaned;
            this.ctx.root.visible = false;
            this.textureManager.gc();
            this.ctx.root.visible = true;
        } else {
            this.textureManager.gc();
        }
    }

    gcRenderTextureMemory(aggressive = false) {
        if (aggressive && this.root.visible) {
            // Make sure that ALL render textures are cleaned;
            this.root.visible = false;
            this.ctx.freeUnusedRenderTextures(0);
            this.root.visible = true;
        } else {
            this.ctx.freeUnusedRenderTextures(0);
        }
    }

    getDrawingCanvas() {
        return this.platform.getDrawingCanvas();
    }

    update() {
        this.ctx.update()
    }

    addServiceProvider(serviceprovider) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark) {
            this.platform.addServiceProvider(serviceprovider);
        }
    }

    getChildrenByPosition(x, y){
        const children = [];
        this.root.core.update();
        this.root.core.collectAtCoord(x,y,children);

        return children;
    }
}











/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/StageUtils.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StageUtils)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class StageUtils {

    static mergeNumbers(v1, v2, p) {
        return v1 * p + v2 * (1 - p);
    };

    static rgb(r, g, b) {
        return (r << 16) + (g << 8) + b + (255 * 16777216);
    };

    static rgba(r, g, b, a) {
        return (r << 16) + (g << 8) + b + (((a * 255) | 0) * 16777216);
    };

    static getRgbString(color) {
        let r = ((color / 65536) | 0) % 256;
        let g = ((color / 256) | 0) % 256;
        let b = color % 256;
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    };

    static getRgbaString(color) {
        let r = ((color / 65536) | 0) % 256;
        let g = ((color / 256) | 0) % 256;
        let b = color % 256;
        let a = ((color / 16777216) | 0) / 255;
        return 'rgba(' + r + ',' + g + ',' + b + ',' + a.toFixed(4) + ')';
    };

    static getRgbaStringFromArray(color) {
        let r = Math.floor(color[0] * 255);
        let g = Math.floor(color[1] * 255);
        let b = Math.floor(color[2] * 255);
        let a = Math.floor(color[3] * 255) / 255;
        return 'rgba(' + r + ',' + g + ',' + b + ',' + a.toFixed(4) + ')';
    };

    static getRgbaComponentsNormalized(argb) {
        let r = ((argb / 65536) | 0) % 256;
        let g = ((argb / 256) | 0) % 256;
        let b = argb % 256;
        let a = ((argb / 16777216) | 0);
        return [r / 255, g / 255, b / 255, a / 255];
    };

    static getRgbComponentsNormalized(argb) {
        let r = ((argb / 65536) | 0) % 256;
        let g = ((argb / 256) | 0) % 256;
        let b = argb % 256;
        return [r / 255, g / 255, b / 255];
    };

    static getRgbaComponents(argb) {
        let r = ((argb / 65536) | 0) % 256;
        let g = ((argb / 256) | 0) % 256;
        let b = argb % 256;
        let a = ((argb / 16777216) | 0);
        return [r, g, b, a];
    };

    static getArgbNumber(rgba) {
        rgba[0] = Math.max(0, Math.min(255, rgba[0]));
        rgba[1] = Math.max(0, Math.min(255, rgba[1]));
        rgba[2] = Math.max(0, Math.min(255, rgba[2]));
        rgba[3] = Math.max(0, Math.min(255, rgba[3]));
        let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
        if (v < 0) {
            v = 0xFFFFFFFF + v + 1;
        }
        return v;
    };

    static mergeColors(c1, c2, p) {
        let r1 = ((c1 / 65536) | 0) % 256;
        let g1 = ((c1 / 256) | 0) % 256;
        let b1 = c1 % 256;
        let a1 = ((c1 / 16777216) | 0);

        let r2 = ((c2 / 65536) | 0) % 256;
        let g2 = ((c2 / 256) | 0) % 256;
        let b2 = c2 % 256;
        let a2 = ((c2 / 16777216) | 0);

        let r = r1 * p + r2 * (1 - p);
        let g = g1 * p + g2 * (1 - p);
        let b = b1 * p + b2 * (1 - p);
        let a = a1 * p + a2 * (1 - p);

        return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
    };

    static mergeMultiColors(c, p) {
        let r = 0, g = 0, b = 0, a = 0, t = 0;
        let n = c.length;
        for (let i = 0; i < n; i++) {
            let r1 = ((c[i] / 65536) | 0) % 256;
            let g1 = ((c[i] / 256) | 0) % 256;
            let b1 = c[i] % 256;
            let a1 = ((c[i] / 16777216) | 0);
            r += r1 * p[i];
            g += g1 * p[i];
            b += b1 * p[i];
            a += a1 * p[i];
            t += p[i];
        }

        t = 1 / t;
        return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
    };

    static mergeMultiColorsEqual(c) {
        let r = 0, g = 0, b = 0, a = 0, t = 0;
        let n = c.length;
        for (let i = 0; i < n; i++) {
            let r1 = ((c[i] / 65536) | 0) % 256;
            let g1 = ((c[i] / 256) | 0) % 256;
            let b1 = c[i] % 256;
            let a1 = ((c[i] / 16777216) | 0);
            r += r1;
            g += g1;
            b += b1;
            a += a1;
            t += 1.0;
        }

        t = 1 / t;
        return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
    };

    static mergeColorAlpha(c, alpha) {
        let a = ((c / 16777216 | 0) * alpha) | 0;
        return (((((c >> 16) & 0xff) * a) / 255) & 0xff) +
            ((((c & 0xff00) * a) / 255) & 0xff00) +
            (((((c & 0xff) << 16) * a) / 255) & 0xff0000) +
            (a << 24);
    };

    static rad(deg) {
        return deg * (Math.PI / 180);
    };

    static getTimingBezier(a, b, c, d) {
        let xc = 3.0 * a;
        let xb = 3.0 * (c - a) - xc;
        let xa = 1.0 - xc - xb;
        let yc = 3.0 * b;
        let yb = 3.0 * (d - b) - yc;
        let ya = 1.0 - yc - yb;

        return function (time) {
            if (time >= 1.0) {
                return 1;
            }
            if (time <= 0) {
                return 0;
            }

            let t = 0.5, cbx, cbxd, dx;

            for (let it = 0; it < 20; it++) {
                cbx = t * (t * (t * xa + xb) + xc);
                dx = time - cbx;
                if (dx > -1e-8 && dx < 1e-8) {
                    return t * (t * (t * ya + yb) + yc);
                }

                // Cubic bezier derivative.
                cbxd = t * (t * (3 * xa) + 2 * xb) + xc;

                if (cbxd > 1e-10 && cbxd < 1e-10) {
                    // Problematic. Fall back to binary search method.
                    break;
                }

                t += dx / cbxd;
            }

            // Fallback: binary search method. This is more reliable when there are near-0 slopes.
            let minT = 0;
            let maxT = 1;
            for (let it = 0; it < 20; it++) {
                t = 0.5 * (minT + maxT);

                cbx = t * (t * (t * xa + xb) + xc);

                dx = time - cbx;
                if (dx > -1e-8 && dx < 1e-8) {
                    // Solution found!
                    return t * (t * (t * ya + yb) + yc);
                }

                if (dx < 0) {
                    maxT = t;
                } else {
                    minT = t;
                }
            }

        };
    };

    static getTimingFunction(str) {
        switch (str) {
            case "linear":
                return function (time) {
                    return time
                };
            case "ease":
                return StageUtils.getTimingBezier(0.25, 0.1, 0.25, 1.0);
            case "ease-in":
                return StageUtils.getTimingBezier(0.42, 0, 1.0, 1.0);
            case "ease-out":
                return StageUtils.getTimingBezier(0, 0, 0.58, 1.0);
            case "ease-in-out":
                return StageUtils.getTimingBezier(0.42, 0, 0.58, 1.0);
            case "step-start":
                return function () {
                    return 1
                };
            case "step-end":
                return function (time) {
                    return time === 1 ? 1 : 0;
                };
            default:
                let s = "cubic-bezier(";
                if (str && str.indexOf(s) === 0) {
                    let parts = str.substr(s.length, str.length - s.length - 1).split(",");
                    if (parts.length !== 4) {
                        console.warn("[Lightning] Unknown timing function: " + str);

                        // Fallback: use linear.
                        return function (time) {
                            return time
                        };
                    }
                    let a = parseFloat(parts[0]);
                    let b = parseFloat(parts[1]);
                    let c = parseFloat(parts[2]);
                    let d = parseFloat(parts[3]);
                    if (isNaN(a) || isNaN(b) || isNaN(c) || isNaN(d)) {
                        console.warn("[Lightning] Unknown timing function: " + str);
                        // Fallback: use linear.
                        return function (time) {
                            return time
                        };
                    }

                    return StageUtils.getTimingBezier(a, b, c, d);
                } else {
                    console.warn("[Lightning] Unknown timing function: " + str);
                    // Fallback: use linear.
                    return function (time) {
                        return time
                    };
                }
        }
    };

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Texture.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Texture.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Texture)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Texture {

    /**
     * @param {Stage} stage
     */
    constructor(stage) {
        this.stage = stage;

        this.manager = this.stage.textureManager;

        this.id = Texture.id++;

        /**
         * All enabled elements that use this texture object (either as texture or displayedTexture).
         * @type {Set<Element>}
         */
        this.elements = new Set();

        /**
         * The number of enabled elements that are active.
         * @type {number}
         */
        this._activeCount = 0;

        /**
         * The associated texture source.
         * Should not be changed.
         * @type {TextureSource}
         */
        this._source = null;

        /**
         * A resize mode can be set to cover or contain a certain area.
         * It will reset the texture clipping settings.
         * When manual texture clipping is performed, the resizeMode is reset.
         * @type {{type: string, width: number, height: number}}
         * @private
         */
        this._resizeMode = null;

        /**
         * The texture clipping x-offset.
         * @type {number}
         */
        this._x = 0;

        /**
         * The texture clipping y-offset.
         * @type {number}
         */
        this._y = 0;

        /**
         * The texture clipping width. If 0 then full width.
         * @type {number}
         */
        this._w = 0;

        /**
         * The texture clipping height. If 0 then full height.
         * @type {number}
         */
        this._h = 0;

        /**
         * Render precision (0.5 = fuzzy, 1 = normal, 2 = sharp even when scaled twice, etc.).
         * @type {number}
         * @private
         */
        this._precision = 1;

        /**
         * The (maximum) expected texture source width. Used for within bounds determination while texture is not yet loaded.
         * If not set, 2048 is used by ElementCore.update.
         * @type {number}
         */
        this.mw = 0;

        /**
         * The (maximum) expected texture source height. Used for within bounds determination while texture is not yet loaded.
         * If not set, 2048 is used by ElementCore.update.
         * @type {number}
         */
        this.mh = 0;

        /**
         * Indicates if Texture.prototype.texture uses clipping.
         * @type {boolean}
         */
        this.clipping = false;

        /**
         * Indicates whether this texture must update (when it becomes used again).
         * @type {boolean}
         * @private
         */
        this._mustUpdate = true;

    }

    get source() {
        if (this._mustUpdate || this.stage.hasUpdateSourceTexture(this)) {
            this._performUpdateSource(true);
            this.stage.removeUpdateSourceTexture(this);
        }
        return this._source;
    }

    addElement(v) {
        if (!this.elements.has(v)) {
            this.elements.add(v);

            if (this.elements.size === 1) {
                if (this._source) {
                    this._source.addTexture(this);
                }
            }

            if (v.active) {
                this.incActiveCount();
            }
        }
    }

    removeElement(v) {
        if (this.elements.delete(v)) {
            if (this.elements.size === 0) {
                if (this._source) {
                    this._source.removeTexture(this);
                }
            }

            if (v.active) {
                this.decActiveCount();
            }
        }
    }

    incActiveCount() {
        // Ensure that texture source's activeCount has transferred ownership.
        const source = this.source;

        if (source) {
            this._checkForNewerReusableTextureSource();
        }

        this._activeCount++;
        if (this._activeCount === 1) {
            this.becomesUsed();
        }
    }

    decActiveCount() {
        const source = this.source; // Force updating the source.
        this._activeCount--;
        if (!this._activeCount) {
            this.becomesUnused();
        }
    }

    becomesUsed() {
        if (this.source) {
            this.source.incActiveTextureCount();
        }
    }

    onLoad() {
        if (this._resizeMode) {
            this._applyResizeMode();
        }

        this.elements.forEach(element => {
            if (element.active) {
                element.onTextureSourceLoaded();
            }
        });
    }

    _checkForNewerReusableTextureSource() {
        // When this source became unused and cleaned up, it may have disappeared from the reusable texture map.
        // In the meantime another texture may have been generated loaded with the same lookup id.
        // If this is the case, use that one instead to make sure only one active texture source per lookup id exists.
        const source = this.source;
        if (!source.isLoaded()) {
            const reusable = this._getReusableTextureSource();
            if (reusable && reusable.isLoaded() && (reusable !== source)) {
                this._replaceTextureSource(reusable);
            }
        } else {
            if (this._resizeMode) {
                this._applyResizeMode();
            }
        }
    }

    becomesUnused() {
        if (this.source) {
            this.source.decActiveTextureCount();
        }
    }

    isUsed() {
        return this._activeCount > 0;
    }

    /**
     * Returns the lookup id for the current texture settings, to be able to reuse it.
     * @returns {string|null}
     */
    _getLookupId() {
        // Default: do not reuse texture.
        return null;
    }

    /**
     * Generates a loader function that is able to generate the texture for the current settings of this texture.
     * It should return a function that receives a single callback argument.
     * That callback should be called with the following arguments:
     *   - err
     *   - options: object
     *     - source: ArrayBuffer|WebGlTexture|ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap
     *     - w: Number
     *     - h: Number
     *     - permanent: Boolean
     *     - hasAlpha: boolean
     *     - permultiplyAlpha: boolean
     *     - flipBlueRed: boolean
     *     - renderInfo: object
     * The loader itself may return a Function that is called when loading of the texture is cancelled. This can be used
     * to stop fetching an image when it is no longer in element, for example.
     */
    _getSourceLoader() {
        throw new Error("Texture.generate must be implemented.");
    }

    get isValid() {
        return this._getIsValid();
    }

    /**
     * If texture is not 'valid', no source can be created for it.
     * @returns {boolean}
     */
    _getIsValid() {
        return true;
    }

    /**
     * This must be called when the texture source must be re-generated.
     */
    _changed() {
        // If no element is actively using this texture, ignore it altogether.
        if (this.isUsed()) {
            this._updateSource();
        } else {
            this._mustUpdate = true;
        }
    }

    _updateSource() {
        // We delay all updateSource calls to the next drawFrame, so that we can bundle them.
        // Otherwise we may reload a texture more often than necessary, when, for example, patching multiple text
        // properties.
        this.stage.addUpdateSourceTexture(this);
    }

    _performUpdateSource(force = false) {
        // If, in the meantime, the texture was no longer used, just remember that it must update until it becomes used
        // again.
        if (force || this.isUsed()) {
            this._mustUpdate = false;
            let source = this._getTextureSource();
            this._replaceTextureSource(source);
        }
    }

    _getTextureSource() {
        let source = null;
        if (this._getIsValid()) {
            const lookupId = this._getLookupId();
            source = this._getReusableTextureSource(lookupId);
            if (!source) {
                source = this.manager.getTextureSource(this._getSourceLoader(), lookupId);
            }
        }
        return source;
    }

    _getReusableTextureSource(lookupId = this._getLookupId()) {
        if (this._getIsValid()) {
            if (lookupId) {
                return this.manager.getReusableTextureSource(lookupId);
            }
        }
        return null;
    }

    _replaceTextureSource(newSource = null) {
        let oldSource = this._source;

        this._source = newSource;

        if (this.elements.size) {
            if (oldSource) {
                if (this._activeCount) {
                    oldSource.decActiveTextureCount();
                }

                oldSource.removeTexture(this);
            }

            if (newSource) {
                // Must happen before setDisplayedTexture to ensure sprite map texcoords are used.
                newSource.addTexture(this);
                if (this._activeCount) {
                    newSource.incActiveTextureCount();
                }
            }
        }

        if (this.isUsed()) {
            if (newSource) {
                if (newSource.isLoaded()) {

                    // Apply resizeMode
                    if (this._resizeMode) {
                        this._applyResizeMode();
                    }

                    this.elements.forEach(element => {
                        if (element.active) {
                            element._setDisplayedTexture(this);
                        }
                    });
                } else {
                    const loadError = newSource.loadError;
                    if (loadError) {
                        this.elements.forEach(element => {
                            if (element.active) {
                                element.onTextureSourceLoadError(loadError);
                            }
                        });
                    }
                }
            } else {
                this.elements.forEach(element => {
                    if (element.active) {
                        element._setDisplayedTexture(null);
                    }
                });
            }
        }
    }

    load() {
        // Make sure that source is up to date.
        if (this.source) {
            if (!this.isLoaded()) {
                this.source.load(true);
            }
        }
    }

    isLoaded() {
        return this._source && this._source.isLoaded();
    }

    get loadError() {
        return this._source && this._source.loadError;
    }

    free() {
        if (this._source) {
            this._source.free();
        }
    }

    set resizeMode({type = "cover", w = 0, h = 0, clipX = 0.5, clipY = 0.5}) {
        this._resizeMode = {type, w, h, clipX, clipY};
        if (this.isLoaded()) {
            this._applyResizeMode();
        }
    }

    get resizeMode() {
        return this._resizeMode;
    }

    _clearResizeMode() {
        this._resizeMode = null;
    }

    _applyResizeMode() {
        if (this._resizeMode.type === "cover") {
            this._applyResizeCover();
        } else if (this._resizeMode.type === "contain") {
            this._applyResizeContain();
        }
        this._updatePrecision();
        this._updateClipping();
    }

    _applyResizeCover() {
        const scaleX = this._resizeMode.w / this._source.w;
        const scaleY = this._resizeMode.h / this._source.h;
        let scale = Math.max(scaleX, scaleY);
        if (!scale) return;
        this._precision = 1/scale;
        if (scaleX && scaleX < scale) {
            const desiredSize = this._precision * this._resizeMode.w;
            const choppedOffPixels = this._source.w - desiredSize;
            this._x = choppedOffPixels * this._resizeMode.clipX;
            this._w = this._source.w - choppedOffPixels;
        }
        if (scaleY && scaleY < scale) {
            const desiredSize = this._precision * this._resizeMode.h;
            const choppedOffPixels = this._source.h - desiredSize;
            this._y = choppedOffPixels * this._resizeMode.clipY;
            this._h = this._source.h - choppedOffPixels;
        }
    }

    _applyResizeContain() {
        const scaleX = this._resizeMode.w / this._source.w;
        const scaleY = this._resizeMode.h / this._source.h;
        let scale = scaleX;
        if (!scale || scaleY < scale) {
            scale = scaleY;
        }
        if (!scale) return;
        this._precision = 1/scale;
    }

    enableClipping(x, y, w, h) {
        this._clearResizeMode();

        x *= this._precision;
        y *= this._precision;
        w *= this._precision;
        h *= this._precision;
        if (this._x !== x || this._y !== y || this._w !== w || this._h !== h) {
            this._x = x;
            this._y = y;
            this._w = w;
            this._h = h;

            this._updateClipping(true);
        }
    }

    disableClipping() {
        this._clearResizeMode();

        if (this._x || this._y || this._w || this._h) {
            this._x = 0;
            this._y = 0;
            this._w = 0;
            this._h = 0;

            this._updateClipping();
        }
    }

    _updateClipping() {
        this.clipping = !!(this._x || this._y || this._w || this._h);

        let self = this;
        this.elements.forEach(function(element) {
            // Ignore if not the currently displayed texture.
            if (element.displayedTexture === self) {
                element.onDisplayedTextureClippingChanged();
            }
        });
    }

    _updatePrecision() {
        let self = this;
        this.elements.forEach(function(element) {
            // Ignore if not the currently displayed texture.
            if (element.displayedTexture === self) {
                element.onPrecisionChanged();
            }
        });
    }

    getNonDefaults() {
        let nonDefaults = {};
        nonDefaults['type'] = this.constructor.name;
        if (this.x !== 0) nonDefaults['x'] = this.x;
        if (this.y !== 0) nonDefaults['y'] = this.y;
        if (this.w !== 0) nonDefaults['w'] = this.w;
        if (this.h !== 0) nonDefaults['h'] = this.h;
        if (this.precision !== 1) nonDefaults['precision'] = this.precision;
        return nonDefaults;
    }

    get px() {
        return this._x;
    }

    get py() {
        return this._y;
    }

    get pw() {
        return this._w;
    }

    get ph() {
        return this._h;
    }

    get x() {
        return this._x / this._precision;
    }
    set x(v) {
        this._clearResizeMode();
        v = v * this._precision;
        if (this._x !== v) {
            this._x = v;
            this._updateClipping();
        }
    }

    get y() {
        return this._y / this._precision;
    }
    set y(v) {
        this._clearResizeMode();
        v = v * this._precision;
        if (this._y !== v) {
            this._y = v;
            this._updateClipping();
        }
    }

    get w() {
        return this._w / this._precision;
    }

    set w(v) {
        this._clearResizeMode();
        v = v * this._precision;
        if (this._w !== v) {
            this._w = v;
            this._updateClipping();
        }
    }

    get h() {
        return this._h / this._precision;
    }

    set h(v) {
        this._clearResizeMode();
        v = v * this._precision;
        if (this._h !== v) {
            this._h = v;
            this._updateClipping();
        }
    }

    get precision() {
        return this._precision;
    }

    set precision(v) {
        this._clearResizeMode();
        if (this._precision !== v) {
            this._precision = v;
            this._updatePrecision();
        }
    }

    isAutosizeTexture() {
        return true;
    }

    getRenderWidth() {
        if (!this.isAutosizeTexture()) {
            // In case of the rectangle texture, we'd prefer to not cause a 1x1 w,h as it would interfere with flex layout fit-to-contents.
            return 0;
        }

        // If dimensions are unknown (texture not yet loaded), use maximum width as a fallback as render width to allow proper bounds checking.
        return (this._w || (this._source ? this._source.getRenderWidth() - this._x : 0)) / this._precision;
    }

    getRenderHeight() {
        if (!this.isAutosizeTexture()) {
            // In case of the rectangle texture, we'd prefer to not cause a 1x1 w,h as it would interfere with flex layout fit-to-contents.
            return 0;
        }

        return (this._h || (this._source ? this._source.getRenderHeight() - this._y : 0)) / this._precision;
    }

    patch(settings) {
        _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].patchObject(this, settings);
    }

}

Texture.prototype.isTexture = true;

Texture.id = 0;




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/TextureManager.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/TextureManager.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextureManager)
/* harmony export */ });
/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextureSource.mjs */ "./node_modules/@lightningjs/core/src/tree/TextureSource.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class TextureManager {

    constructor(stage) {
        this.stage = stage;

        /**
         * The currently used amount of texture memory.
         * @type {number}
         */
        this._usedMemory = 0;

        /**
         * All uploaded texture sources.
         * @type {TextureSource[]}
         */
        this._uploadedTextureSources = [];

        /**
         * The texture source lookup id to texture source hashmap.
         * @type {Map<String, TextureSource>}
         */
        this.textureSourceHashmap = new Map();

    }

    get usedMemory() {
        return this._usedMemory;
    }

    destroy() {
        for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
            this._nativeFreeTextureSource(this._uploadedTextureSources[i]);
        }
        
        this.textureSourceHashmap.clear();
        this._usedMemory = 0;
    }

    getReusableTextureSource(id) {
        return this.textureSourceHashmap.get(id);
    }

    getTextureSource(func, id) {
        // Check if texture source is already known.
        let textureSource = id ? this.textureSourceHashmap.get(id) : null;
        if (!textureSource) {
            // Create new texture source.
            textureSource = new _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this, func);

            if (id) {
                textureSource.lookupId = id;
                this.textureSourceHashmap.set(id, textureSource);
            }
        }

        return textureSource;
    }

    uploadTextureSource(textureSource, options) {
        if (textureSource.isLoaded()) return;

        this._addMemoryUsage(textureSource.w * textureSource.h);

        // Load texture.
        const nativeTexture = this._nativeUploadTextureSource(textureSource, options);

        textureSource._nativeTexture = nativeTexture;

        // We attach w and h to native texture (we need it in CoreRenderState._isRenderTextureReusable).
        nativeTexture.w = textureSource.w;
        nativeTexture.h = textureSource.h;

        nativeTexture.update = this.stage.frameCounter;

        this._uploadedTextureSources.push(textureSource);
        
        this.addToLookupMap(textureSource);
    }

    _addMemoryUsage(delta) {
        this._usedMemory += delta;
        this.stage.addMemoryUsage(delta);
    }
    
    addToLookupMap(textureSource) {
        const lookupId = textureSource.lookupId;
        if (lookupId) {
            if (!this.textureSourceHashmap.has(lookupId)) {
                this.textureSourceHashmap.set(lookupId, textureSource);
            }
        }
    }

    gc() {
        this.freeUnusedTextureSources();
        this._cleanupLookupMap();
    }
    
    freeUnusedTextureSources() {
        let remainingTextureSources = [];
        for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
            let ts = this._uploadedTextureSources[i];
            if (ts.allowCleanup()) {
                this._freeManagedTextureSource(ts);
            } else {
                remainingTextureSources.push(ts);
            }
        }

        this._uploadedTextureSources = remainingTextureSources;

        this._cleanupLookupMap();
    }

    _freeManagedTextureSource(textureSource) {
        if (textureSource.isLoaded()) {
            this._nativeFreeTextureSource(textureSource);
            this._addMemoryUsage(-textureSource.w * textureSource.h);
        }

        // Should be reloaded.
        textureSource.loadingSince = null;
    }

    _cleanupLookupMap() {
        // We keep those that still have value (are being loaded or already loaded, or are likely to be reused).
        this.textureSourceHashmap.forEach((textureSource, lookupId) => {
            if (!(textureSource.isLoaded() || textureSource.isLoading()) && !textureSource.isUsed()) {
                this.textureSourceHashmap.delete(lookupId);
            }
        });
    }

    /**
     * Externally free texture source.
     * @param textureSource
     */
    freeTextureSource(textureSource) {
        const index = this._uploadedTextureSources.indexOf(textureSource);
        const managed = (index !== -1);

        if (textureSource.isLoaded()) {
            if (managed) {
                this._addMemoryUsage(-textureSource.w * textureSource.h);
                this._uploadedTextureSources.splice(index, 1);
            }
            this._nativeFreeTextureSource(textureSource);
        }

        // Should be reloaded.
        textureSource.loadingSince = null;
    }

    _nativeUploadTextureSource(textureSource, options) {
        return this.stage.renderer.uploadTextureSource(textureSource, options);
    }

    _nativeFreeTextureSource(textureSource) {
        this.stage.renderer.freeTextureSource(textureSource);
        textureSource.clearNativeTexture();
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/TextureSource.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/TextureSource.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextureSource)
/* harmony export */ });
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class TextureSource {

    constructor(manager, loader = null) {
        this.id = TextureSource.id++;

        this.manager = manager;

        this.stage = manager.stage;

        /**
         * All enabled textures (textures that are used by visible elements).
         * @type {Set<Texture>}
         */
        this.textures = new Set();

        /**
         * The number of active textures (textures that have at least one active element).
         * @type {number}
         * @private
         */
        this._activeTextureCount = 0;

        /**
         * The factory for the source of this texture.
         * @type {Function}
         */
        this.loader = loader;

        /**
         * Identifier for reuse.
         * @type {String}
         */
        this.lookupId = null;

        /**
         * If set, this.is called when the texture source is no longer displayed (this.components.size becomes 0).
         * @type {Function}
         */
        this._cancelCb = null;

        /**
         * Loading since timestamp in millis.
         * @type {number}
         */
        this.loadingSince = 0;

        this.w = 0;
        this.h = 0;

        this._nativeTexture = null;

        /**
         * If true, then this.texture source is never freed from memory during garbage collection.
         * @type {boolean}
         */
        this.permanent = false;

        /**
         * Sub-object with texture-specific rendering information.
         * For images, contains the src property, for texts, contains handy rendering information.
         * @type {Object}
         */
        this.renderInfo = null;

        /**
         * Generated for 'renderToTexture'.
         * @type {boolean}
         * @private
         */
        this._isResultTexture = !this.loader;

        /**
         * Contains the load error, if the texture source could previously not be loaded.
         * @type {object}
         * @private
         */
        this._loadError = null;

        /**
         *  Hold a reference to the javascript variable which contains the texture, this is not required for WebGL in WebBrowsers but is required for Spark runtime.
         * @type {object}
         * @private
         */
        this._imageRef = null;

    }

    get loadError() {
        return this._loadError;
    }

    addTexture(v) {
        if (!this.textures.has(v)) {
            this.textures.add(v);
        }
    }

    removeTexture(v) {
        this.textures.delete(v);
    }

    incActiveTextureCount() {
        this._activeTextureCount++;
        if (this._activeTextureCount === 1) {
            this.becomesUsed();
        }
    }

    decActiveTextureCount() {
        this._activeTextureCount--;
        if (this._activeTextureCount === 0) {
            this.becomesUnused();
        }
    }

    get isResultTexture() {
        return this._isResultTexture;
    }

    set isResultTexture(v) {
        this._isResultTexture = v;
    }

    forEachEnabledElement(cb) {
        this.textures.forEach(texture => {
            texture.elements.forEach(cb);
        });
    }

    hasEnabledElements() {
        return this.textures.size > 0;
    }

    forEachActiveElement(cb) {
        this.textures.forEach(texture => {
            texture.elements.forEach(element => {
                if (element.active) {
                    cb(element);
                }
            });
        });
    }

    getRenderWidth() {
        return this.w;
    }

    getRenderHeight() {
        return this.h;
    }

    allowCleanup() {
        return !this.permanent && !this.isUsed();
    }

    becomesUsed() {
        // Even while the texture is being loaded, make sure it is on the lookup map so that others can reuse it.
        this.load();
    }

    becomesUnused() {
        this.cancel();
    }

    cancel() {
        if (this.isLoading()) {
            if (this._cancelCb) {
                this._cancelCb(this);

                // Clear callback to avoid memory leaks.
                this._cancelCb = null;
            }
            this.loadingSince = 0;
        }
    }

    isLoaded() {
        return !!this._nativeTexture;
    }

    isLoading() {
        return (this.loadingSince > 0);
    }

    isError() {
        return !!this._loadError;
    }

    reload() {
        this.free();
        if (this.isUsed()) {
            this.load();
        }
    }

    load(forceSync = false) {
        // From the moment of loading (when a texture source becomes used by active elements)
        if (this.isResultTexture) {
            // Element result texture source, for which the loading is managed by the core.
            return;
        }

        if (!this._nativeTexture && !this.isLoading()) {
            this.loadingSince = (new Date()).getTime();
            this._cancelCb = this.loader((err, options) => {
                // Ignore loads that come in after a cancel.
                if (this.isLoading()) {
                    // Clear callback to avoid memory leaks.
                    this._cancelCb = null;

                    if (this.manager.stage.destroyed) {
                        // Ignore async load when stage is destroyed.
                        return;
                    }
                    if (err) {
                        // Emit txError.
                        this.onError(err);
                    } else if (options && options.source) {
                        if (!this.stage.isUpdatingFrame() && !forceSync && (options.throttle !== false)) {
                            const textureThrottler = this.stage.textureThrottler;
                            this._cancelCb = textureThrottler.genericCancelCb;
                            textureThrottler.add(this, options);
                        } else {
                            this.processLoadedSource(options);
                        }
                    }
                }
            }, this);
        }
    }

    processLoadedSource(options) {
        this.loadingSince = 0;
        this.setSource(options);
    }

    setSource(options) {
        const source = options.source;

        this.w = source.width || (options && options.w) || 0;
        this.h = source.height || (options && options.h) || 0;

        if (options && options.renderInfo) {
            // Assign to id in cache so that it can be reused.
            this.renderInfo = options.renderInfo;
        }

        this.permanent = !!options.permanent;

        if (options && options.imageRef)
            this._imageRef = options.imageRef;
        if (options && options.flipTextureY) {
            this._flipTextureY = options.flipTextureY;
        } else {
            this._flipTextureY = false;
        }

        if (this._isNativeTexture(source)) {
            // Texture managed by caller.
            this._nativeTexture = source;

            this.w = this.w || source.w;
            this.h = this.h || source.h;

            // WebGLTexture objects are by default;
            this.permanent = options.hasOwnProperty('permanent') ? options.permanent : true;
        } else {
            this.manager.uploadTextureSource(this, options);
        }

        // Must be cleared when reload is succesful.
        this._loadError = null;

        this.onLoad();
    }

    isUsed() {
        return this._activeTextureCount > 0;
    }

    onLoad() {
        if (this.isUsed()) {
            this.textures.forEach(texture => {
                texture.onLoad();
            });
        }
    }

    forceRenderUpdate() {
        // Userland should call this method after changing the nativeTexture manually outside of the framework
        //  (using tex[Sub]Image2d for example).

        if (this._nativeTexture) {
            // Change 'update' flag. This is currently not used by the framework but is handy in userland.
            this._nativeTexture.update = this.stage.frameCounter;
        }

        this.forEachActiveElement(function (element) {
            element.forceRenderUpdate();
        });

    }

    forceUpdateRenderCoords() {
        this.forEachActiveElement(function (element) {
            element._updateTextureCoords();
        });
    }

    get nativeTexture() {
        return this._nativeTexture;
    }

    clearNativeTexture() {
        this._nativeTexture = null;
        //also clear the reference to the texture variable.
        this._imageRef = null;
    }

    /**
     * Used for result textures.
     */
    replaceNativeTexture(newNativeTexture, w, h) {
        let prevNativeTexture = this._nativeTexture;
        // Loaded by core.
        this._nativeTexture = newNativeTexture;
        this.w = w;
        this.h = h;

        if (!prevNativeTexture && this._nativeTexture) {
            this.forEachActiveElement(element => element.onTextureSourceLoaded());
        }

        if (!this._nativeTexture) {
            this.forEachActiveElement(element => element._setDisplayedTexture(null));
        }

        // Dimensions must be updated also on enabled elements, as it may force it to go within bounds.
        this.forEachEnabledElement(element => element._updateDimensions());

        // Notice that the sprite map must never contain render textures.
    }

    onError(e) {
        this._loadError = e;
        this.loadingSince = 0;
        console.error('[Lightning] texture load error', e, this.lookupId);
        this.forEachActiveElement(element => element.onTextureSourceLoadError(e));
    }

    free() {
        if (this.isLoaded()) {
            this.manager.freeTextureSource(this);
        }
    }

    _isNativeTexture(source) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNode) {
            return source.constructor.name === "WebGLTexture";
        }

        if ('WebGLTexture' in window) {
            return source instanceof WebGLTexture;
        }

        return false;
    }

}

TextureSource.prototype.isTextureSource = true;

TextureSource.id = 1;




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/TextureThrottler.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/TextureThrottler.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextureThrottler)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Allows throttling of loading texture sources, keeping the app responsive.
 */
class TextureThrottler {

    constructor(stage) {
        this.stage = stage;

        this.genericCancelCb = (textureSource) => {
            this._remove(textureSource);
        };

        this._sources = [];
        this._data = [];
    }

    destroy() {
        this._sources = [];
        this._data = [];
    }

    processSome() {
        if (this._sources.length) {
            const start = Date.now();
            do {
                this._processItem();
            } while(this._sources.length && (Date.now() - start < TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME));
        }
    }

    _processItem() {
        const source = this._sources.pop();
        const data = this._data.pop();
        if (source.isLoading()) {
            source.processLoadedSource(data);
        }
    }

    add(textureSource, data) {
        this._sources.push(textureSource);
        this._data.push(data);
    }

    _remove(textureSource) {
        const index = this._sources.indexOf(textureSource);
        if (index >= 0) {
            this._sources.splice(index, 1);
            this._data.splice(index, 1);
        }
    }

}

TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME = 10;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Utils.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Utils.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Utils)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Utils {

    static isFunction(value) {
        return typeof value === 'function';
    }

    static isNumber(value) {
        return typeof value === 'number';
    }

    static isInteger(value) {
        return (typeof value === 'number' && (value % 1) === 0);
    }

    static isBoolean(value) {
        return value === true || value === false;
    }

    static isString(value) {
        return typeof value === 'string';
    }

    static clone(v) {
        if (Utils.isObjectLiteral(v) || Array.isArray(v)) {
            return Utils.getDeepClone(v);
        } else {
            // Copy by value.
            return v;
        }
    }

    static cloneObjShallow(obj) {
        let keys = Object.keys(obj);
        let clone = {}
        for (let i = 0; i < keys.length; i++) {
            clone[keys[i]] = obj[keys[i]];
        }
        return clone;
    }

    static merge(obj1, obj2) {
        let keys = Object.keys(obj2);
        for (let i = 0; i < keys.length; i++) {
            obj1[keys[i]] = obj2[keys[i]];
        }
        return obj1;
    }

    static isObject(value) {
        let type = typeof value;
        return !!value && (type === 'object' || type === 'function');
    }

    static isPlainObject(value) {
        let type = typeof value;
        return !!value && (type === 'object');
    }

    static isObjectLiteral(value){
        return typeof value === 'object' && value && value.constructor === Object;
    }

    static getArrayIndex(index, arr) {
        return Utils.getModuloIndex(index, arr.length);
    }

    static getModuloIndex(index, len) {
        if (len === 0) return index;
        while (index < 0) {
            index += Math.ceil(-index / len) * len;
        }
        index = index % len;
        return index;
    }

    static getDeepClone(obj) {
        let i, c;
        if (Utils.isFunction(obj)) {
            // Copy functions by reference.
            return obj;
        }
        if (Array.isArray(obj)) {
            c = [];
            let keys = Object.keys(obj);
            for (i = 0; i < keys.length; i++) {
                c[keys[i]] = Utils.getDeepClone(obj[keys[i]]);
            }
            return c;
        } else if (Utils.isObject(obj)) {
            c = {}
            let keys = Object.keys(obj);
            for (i = 0; i < keys.length; i++) {
                c[keys[i]] = Utils.getDeepClone(obj[keys[i]]);
            }
            return c;
        } else {
            return obj;
        }
    }

    static equalValues(v1, v2) {
        if ((typeof v1) !== (typeof v2)) return false;
        if (Utils.isObjectLiteral(v1)) {
            return Utils.isObjectLiteral(v2) && Utils.equalObjectLiterals(v1, v2);
        } else if (Array.isArray(v1)) {
            return Array.isArray(v2) && Utils.equalArrays(v1, v2);
        } else {
            return v1 === v2;
        }
    }

    static equalObjectLiterals(obj1, obj2) {
        let keys1 = Object.keys(obj1);
        let keys2 = Object.keys(obj2);
        if (keys1.length !== keys2.length) {
            return false;
        }

        for (let i = 0, n = keys1.length; i < n; i++) {
            const k1 = keys1[i];
            const k2 = keys2[i];
            if (k1 !== k2) {
                return false;
            }

            const v1 = obj1[k1];
            const v2 = obj2[k2];

            if (!Utils.equalValues(v1, v2)) {
                return false;
            }
        }

        return true;
    }

    static equalArrays(v1, v2) {
        if (v1.length !== v2.length) {
            return false;
        }
        for (let i = 0, n = v1.length; i < n; i++) {
            if (!this.equalValues(v1[i], v2[i])) {
                return false;
            }
        }

        return true;
    }

    static setToArray(s) {
        let result = [];
        s.forEach(function (value) {
            result.push(value);
        });
        return result;
    }

    static iteratorToArray(iterator) {
        let result = [];
        let iteratorResult = iterator.next();
        while (!iteratorResult.done) {
            result.push(iteratorResult.value);
            iteratorResult = iterator.next();
        }
        return result;
    }

    static isUcChar(charcode) {
        return charcode >= 65 && charcode <= 90;
    }

}

Utils.isWeb = (typeof window !== "undefined") && (typeof sparkscene === "undefined");
Utils.isWPE = Utils.isWeb && (navigator.userAgent.indexOf("WPE") !== -1);
Utils.isSpark = (typeof sparkscene !== "undefined");
Utils.isNode = (typeof window === "undefined") || Utils.isSpark;
Utils.isPS4 = Utils.isWeb && (navigator.userAgent.indexOf("PlayStation 4") !== -1);


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreContext.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreContext.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreContext)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class CoreContext {

    constructor(stage) {
        this.stage = stage;

        this.root = null;

        this.updateTreeOrder = 0;

        this.renderState = this.stage.renderer.createCoreRenderState(this);

        this.renderExec = this.stage.renderer.createCoreRenderExecutor(this);
        this.renderExec.init();

        this._usedMemory = 0;
        this._renderTexturePool = [];

        this._renderTextureId = 1;

        this._zSorts = [];
    }

    get usedMemory() {
        return this._usedMemory;
    }

    destroy() {
        this._renderTexturePool.forEach(texture => this._freeRenderTexture(texture));
        this._usedMemory = 0;
    }

    hasRenderUpdates() {
        return !!this.root._parent._hasRenderUpdates;
    }

    render() {
        // Clear flag to identify if anything changes before the next frame.
        this.root._parent._hasRenderUpdates = 0;

        this._render();
    }

    update() {
        this._update();

        // Due to the boundsVisibility flag feature (and onAfterUpdate hook), it is possible that other elements were
        // changed during the update loop (for example due to the txLoaded event). We process these changes immediately
        // (but not recursively to prevent infinite loops).
        if (this.root._hasUpdates) {
            this._update();
        }

        this._performForcedZSorts();
    }

    /**
     * Certain ElementCore items may be forced to zSort to strip out references to prevent memleaks..
     */
    _performForcedZSorts() {
        const n = this._zSorts.length;
        if (n) {
            // Forced z-sorts (ElementCore may force a z-sort in order to free memory/prevent memory leaks).
            for (let i = 0, n = this._zSorts.length; i < n; i++) {
                if (this._zSorts[i].zSort) {
                    this._zSorts[i].sortZIndexedChildren();
                }
            }
            this._zSorts = [];
        }
    }

    _update() {
        this.updateTreeOrder = 0;

        this.root.update();
    }

    _render() {
        // Obtain a sequence of the quad operations.
        this._fillRenderState();

        if (this.stage.getOption('readPixelsBeforeDraw')) {
            const pixels = new Uint8Array(4);
            const gl = this.stage.gl;
            gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        }

        // Now run them with the render executor.
        this._performRender();
    }

    _fillRenderState() {
        this.renderState.reset();
        this.root.render();
        this.renderState.finish();
    }

    _performRender() {
        this.renderExec.execute();
    }

    _addMemoryUsage(delta) {
        this._usedMemory += delta;
        this.stage.addMemoryUsage(delta);
    }

    allocateRenderTexture(w, h) {
        let prec = this.stage.getRenderPrecision();
        let pw = Math.max(1, Math.round(w * prec));
        let ph = Math.max(1, Math.round(h * prec));

        // Search last item first, so that last released render texture is preferred (may cause memory cache benefits).
        const n = this._renderTexturePool.length;
        for (let i = n - 1; i >= 0; i--) {
            const texture = this._renderTexturePool[i];
            // We don't want to reuse the same render textures within the same frame because that will create gpu stalls.
            if (texture.w === pw && texture.h === ph && (texture.update !== this.stage.frameCounter)) {
                texture.f = this.stage.frameCounter;
                this._renderTexturePool.splice(i, 1);
                return texture;
            }
        }

        const texture = this._createRenderTexture(w, h, pw, ph);
        texture.precision = prec;
        return texture;
    }

    releaseRenderTexture(texture) {
        this._renderTexturePool.push(texture);
    }

    freeUnusedRenderTextures(maxAge = 60) {
        // Clean up all textures that are no longer used.
        // This cache is short-lived because it is really just meant to supply running shaders that are
        // updated during a number of frames.
        let limit = this.stage.frameCounter - maxAge;

        this._renderTexturePool = this._renderTexturePool.filter(texture => {
            if (texture.f <= limit) {
                this._freeRenderTexture(texture);
                return false;
            }
            return true;
        });
    }

    _createRenderTexture(w, h, pw, ph) {
        this._addMemoryUsage(pw * ph);

        const texture = this.stage.renderer.createRenderTexture(w, h, pw, ph);
        texture.id = this._renderTextureId++;
        texture.f = this.stage.frameCounter;
        texture.ow = w;
        texture.oh = h;
        texture.w = pw;
        texture.h = ph;

        return texture;
    }

    _freeRenderTexture(nativeTexture) {
        this.stage.renderer.freeRenderTexture(nativeTexture);
        this._addMemoryUsage(-nativeTexture.w * nativeTexture.h);
    }

    copyRenderTexture(renderTexture, nativeTexture, options) {
        this.stage.renderer.copyRenderTexture(renderTexture, nativeTexture, options);
    }

    forceZSort(elementCore) {
        this._zSorts.push(elementCore);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadList.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreQuadList.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreQuadList)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class CoreQuadList {

    constructor(ctx) {

        this.ctx = ctx;

        this.quadTextures = [];

        this.quadElements = [];
    }

    get length() {
        return this.quadTextures.length;
    }

    reset() {
        this.quadTextures = [];
        this.quadElements = [];
        this.dataLength = 0;
    }

    getElement(index) {
        return this.quadElements[index]._element;
    }

    getElementCore(index) {
        return this.quadElements[index];
    }

    getTexture(index) {
        return this.quadTextures[index];
    }

    getTextureWidth(index) {
        let nativeTexture = this.quadTextures[index];
        if (nativeTexture.w) {
            // Render texture;
            return nativeTexture.w;
        } else {
            return this.quadElements[index]._displayedTextureSource.w;
        }
    }

    getTextureHeight(index) {
        let nativeTexture = this.quadTextures[index];
        if (nativeTexture.h) {
            // Render texture;
            return nativeTexture.h;
        } else {
            return this.quadElements[index]._displayedTextureSource.h;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadOperation.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreQuadOperation.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreQuadOperation)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class CoreQuadOperation {

    constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {

        this.ctx = ctx;
        this.shader = shader;
        this.shaderOwner = shaderOwner;
        this.renderTextureInfo = renderTextureInfo;
        this.scissor = scissor;
        this.index = index;
        this.length = 0;

    }

    get quads() {
        return this.ctx.renderState.quads;
    }

    getTexture(index) {
        return this.quads.getTexture(this.index + index);
    }

    getElementCore(index) {
        return this.quads.getElementCore(this.index + index);
    }

    getElement(index) {
        return this.quads.getElement(this.index + index);
    }

    getElementWidth(index) {
        return this.getElement(index).renderWidth;
    }

    getElementHeight(index) {
        return this.getElement(index).renderHeight;
    }

    getTextureWidth(index) {
        return this.quads.getTextureWidth(this.index + index);
    }

    getTextureHeight(index) {
        return this.quads.getTextureHeight(this.index + index);
    }

    getRenderWidth() {
        if (this.renderTextureInfo) {
            return this.renderTextureInfo.w;
        } else {
            return this.ctx.stage.w;
        }
    }

    getRenderHeight() {
        if (this.renderTextureInfo) {
            return this.renderTextureInfo.h;
        } else {
            return this.ctx.stage.h;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderExecutor.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreRenderExecutor.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreRenderExecutor)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class CoreRenderExecutor {

    constructor(ctx) {
        this.ctx = ctx;

        this.renderState = ctx.renderState;

        this.gl = this.ctx.stage.gl;
    }

    destroy() {
    }

    _reset() {
        this._bindRenderTexture(null);
        this._setScissor(null);
        this._clearRenderTexture();
    }

    execute() {
        this._reset();

        let qops = this.renderState.quadOperations;

        let i = 0, j = 0, n = qops.length;
        while (i < n) {
            this._processQuadOperation(qops[i]);
            i++;
        }
    }

    _processQuadOperation(quadOperation) {
        if (quadOperation.renderTextureInfo && quadOperation.renderTextureInfo.ignore) {
            // Ignore quad operations when we are 're-using' another texture as the render texture result.
            return;
        }

        this._setupQuadOperation(quadOperation);
        this._execQuadOperation(quadOperation);

    }

    _setupQuadOperation(quadOperation) {
    }

    _execQuadOperation(op) {
        // Set render texture.
        let nativeTexture = op.renderTextureInfo ? op.renderTextureInfo.nativeTexture : null;

        if (this._renderTexture !== nativeTexture) {
            this._bindRenderTexture(nativeTexture);
        }

        if (op.renderTextureInfo && !op.renderTextureInfo.cleared) {
            this._setScissor(null);
            this._clearRenderTexture();
            op.renderTextureInfo.cleared = true;
            this._setScissor(op.scissor);
        } else {
            this._setScissor(op.scissor);
        }

        this._renderQuadOperation(op);
    }

    _renderQuadOperation(op) {
    }

    _bindRenderTexture(renderTexture) {
        this._renderTexture = renderTexture;
    }

    _clearRenderTexture(renderTexture) {
    }

    _setScissor(area) {
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderState.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreRenderState.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreRenderState)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class CoreRenderState {

    constructor(ctx) {
        this.ctx = ctx;

        this.stage = ctx.stage;

        this.defaultShader = this.stage.renderer.getDefaultShader(ctx);

        this.renderer = ctx.stage.renderer;

        this.quads = this.renderer.createCoreQuadList(ctx);

    }

    reset() {
        this._renderTextureInfo = null;

        this._scissor = null;

        this._shader = null;

        this._shaderOwner = null;

        this._realShader = null;

        this._check = false;

        this.quadOperations = [];

        this._texturizer = null;

        this._texturizerTemporary = false;

        this._quadOperation = null;

        this.quads.reset();

        this._temporaryTexturizers = [];
        
        this._isCachingTexturizer = false;

    }

    get length() {
        return this.quads.quadTextures.length;
    }

    setShader(shader, owner) {
        if (this._shaderOwner !== owner || this._realShader !== shader) {
            // Same shader owner: active shader is also the same.
            // Prevent any shader usage to save performance.

            this._realShader = shader;

            if (shader.useDefault()) {
                // Use the default shader when possible to prevent unnecessary program changes.
                shader = this.defaultShader;
            }
            if (this._shader !== shader || this._shaderOwner !== owner) {
                this._shader = shader;
                this._shaderOwner = owner;
                this._check = true;
            }
        }
    }

    get renderTextureInfo() {
        return this._renderTextureInfo;
    }

    setScissor(area) {
        if (this._scissor !== area) {
            if (area) {
                this._scissor = area;
            } else {
                this._scissor = null;
            }
            this._check = true;
        }
    }

    getScissor() {
        return this._scissor;
    }

    setRenderTextureInfo(renderTextureInfo) {
        if (this._renderTextureInfo !== renderTextureInfo) {
            this._renderTextureInfo = renderTextureInfo;
            this._scissor = null;
            this._check = true;
        }
    }

    /**
     * Sets the texturizer to be drawn during subsequent addQuads.
     * @param {ElementTexturizer} texturizer
     */
    setTexturizer(texturizer, cache = false) {
        this._texturizer = texturizer;
        this._cacheTexturizer = cache;
    }

    set isCachingTexturizer(v) {
        this._isCachingTexturizer = v;
    }

    get isCachingTexturizer() {
        return this._isCachingTexturizer;
    }

    addQuad(elementCore) {
        if (!this._quadOperation) {
            this._createQuadOperation();
        } else if (this._check && this._hasChanges()) {
            this._finishQuadOperation();
            this._check = false;
        }

        let nativeTexture = null;
        if (this._texturizer) {
            nativeTexture = this._texturizer.getResultTexture();

            if (!this._cacheTexturizer) {
                // We can release the temporary texture immediately after finalizing this quad operation.
                this._temporaryTexturizers.push(this._texturizer);
            }
        }

        if (!nativeTexture) {
            nativeTexture = elementCore._displayedTextureSource.nativeTexture;
        }

        if (this._renderTextureInfo) {
            if (this._shader === this.defaultShader && this._renderTextureInfo.empty) {
                // The texture might be reusable under some conditions. We will check them in ElementCore.renderer.
                this._renderTextureInfo.nativeTexture = nativeTexture;
                this._renderTextureInfo.offset = this.length;
            } else {
                // It is not possible to reuse another texture when there is more than one quad.
                this._renderTextureInfo.nativeTexture = null;
            }
            this._renderTextureInfo.empty = false;
        }

        this.quads.quadTextures.push(nativeTexture);
        this.quads.quadElements.push(elementCore);

        this._quadOperation.length++;

        this.renderer.addQuad(this, this.quads, this.length - 1)
    }

    finishedRenderTexture() {
        if (this._renderTextureInfo.nativeTexture) {
            // There was only one texture drawn in this render texture.
            // Check if we can reuse it so that we can optimize out an unnecessary render texture operation.
            // (it should exactly span this render texture).
            if (!this._isRenderTextureReusable()) {
                this._renderTextureInfo.nativeTexture = null;
            }
        }
    }

    _isRenderTextureReusable() {
        const offset = this._renderTextureInfo.offset;
        return (this.quads.quadTextures[offset].w === this._renderTextureInfo.w) &&
            (this.quads.quadTextures[offset].h === this._renderTextureInfo.h) &&
            this.renderer.isRenderTextureReusable(this, this._renderTextureInfo)
    }

    _hasChanges() {
        let q = this._quadOperation;
        if (this._shader !== q.shader) return true;
        if (this._shaderOwner !== q.shaderOwner) return true;
        if (this._renderTextureInfo !== q.renderTextureInfo) return true;
        if (this._scissor !== q.scissor) {
            if ((this._scissor[0] !== q.scissor[0]) || (this._scissor[1] !== q.scissor[1]) || (this._scissor[2] !== q.scissor[2]) || (this._scissor[3] !== q.scissor[3])) {
                return true;
            }
        }

        return false;
    }

    _finishQuadOperation(create = true) {
        if (this._quadOperation) {
            if (this._quadOperation.length || this._shader.addEmpty()) {
                if (!this._quadOperation.scissor || ((this._quadOperation.scissor[2] > 0) && (this._quadOperation.scissor[3] > 0))) {
                    // Ignore empty clipping regions.
                    this.quadOperations.push(this._quadOperation);
                }
            }

            if (this._temporaryTexturizers.length) {
                for (let i = 0, n = this._temporaryTexturizers.length; i < n; i++) {
                    // We can now reuse these render-to-textures in subsequent stages.
                    // Huge performance benefit when filtering (fast blur).
                    this._temporaryTexturizers[i].releaseRenderTexture();
                }
                this._temporaryTexturizers = [];
            }

            this._quadOperation = null;
        }

        if (create) {
            this._createQuadOperation();
        }
    }

    _createQuadOperation() {
        this._quadOperation = this.renderer.createCoreQuadOperation(
            this.ctx,
            this._shader,
            this._shaderOwner,
            this._renderTextureInfo,
            this._scissor,
            this.length
        );
        this._check = false;
    }

    finish() {
        if (this._quadOperation) {
            // Add remaining.
            this._finishQuadOperation(false);
        }

        this.renderer.finishRenderState(this);
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/ElementCore.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/ElementCore.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementCore)
/* harmony export */ });
/* harmony import */ var _flex_FlexTarget_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../flex/FlexTarget.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexTarget.mjs");
/* harmony import */ var _ElementTexturizer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ElementTexturizer.mjs */ "./node_modules/@lightningjs/core/src/tree/core/ElementTexturizer.mjs");
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ElementCore {

    constructor(element) {
        this._element = element;

        this.ctx = element.stage.ctx;

        // The memory layout of the internal variables is affected by their position in the constructor.
        // It boosts performance to order them by usage of cpu-heavy functions (renderSimple and update).

        this._recalc = 0;

        this._parent = null;

        this._onUpdate = null;

        this._pRecalc = 0;

        this._worldContext = new ElementCoreContext();

        this._hasUpdates = false;

        this._localAlpha = 1;

        this._onAfterCalcs = null;

        this._onAfterUpdate = null;

        // All local translation/transform updates: directly propagated from x/y/w/h/scale/whatever.
        this._localPx = 0;
        this._localPy = 0;

        this._localTa = 1;
        this._localTb = 0;
        this._localTc = 0;
        this._localTd = 1;

        this._isComplex = false;

        this._dimsUnknown = false;

        this._clipping = false;

        // Used by both update and render.
        this._zSort = false;

        this._outOfBounds = 0;

        /**
         * The texture source to be displayed.
         * @type {TextureSource}
         */
        this._displayedTextureSource = null;

        this._zContextUsage = 0;

        this._children = null;

        this._hasRenderUpdates = 0;

        this._zIndexedChildren = null;

        this._renderContext = this._worldContext;

        this.renderState = this.ctx.renderState;

        this._scissor = null;

        // The ancestor ElementCore that owns the inherited shader. Null if none is active (default shader).
        this._shaderOwner = null;


        this._updateTreeOrder = 0;

        this._colorUl = this._colorUr = this._colorBl = this._colorBr = 0xFFFFFFFF;

        this._x = 0;
        this._y = 0;
        this._w = 0;
        this._h = 0;

        this._optFlags = 0;
        this._funcX = null;
        this._funcY = null;
        this._funcW = null;
        this._funcH = null;

        this._scaleX = 1;
        this._scaleY = 1;
        this._pivotX = 0.5;
        this._pivotY = 0.5;
        this._mountX = 0;
        this._mountY = 0;
        this._rotation = 0;

        this._alpha = 1;
        this._visible = true;

        this._ulx = 0;
        this._uly = 0;
        this._brx = 1;
        this._bry = 1;

        this._zIndex = 0;
        this._forceZIndexContext = false;
        this._zParent = null;

        this._isRoot = false;

        /**
         * Iff true, during zSort, this element should be 're-sorted' because either:
         * - zIndex did chang
         * - zParent did change
         * - element was moved in the render tree
         * @type {boolean}
         */
        this._zIndexResort = false;

        this._shader = null;

        // Element is rendered on another texture.
        this._renderToTextureEnabled = false;

        this._texturizer = null;

        this._useRenderToTexture = false;

        this._boundsMargin = null;

        this._recBoundsMargin = null;

        this._withinBoundsMargin = false;

        this._viewport = null;

        this._clipbox = true;

        this.render = this._renderSimple;

        this._layout = null;
    }

    get offsetX() {
        if (this._funcX) {
            return this._funcX;
        } else {
            if (this.hasFlexLayout()) {
                return this._layout.originalX;
            } else {
                return this._x;
            }
        }
    }

    set offsetX(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(v)) {
            this.funcX = v;
        } else {
            this._disableFuncX();
            if (this.hasFlexLayout()) {
                this.x += (v - this._layout.originalX);
                this._layout.setOriginalXWithoutUpdatingLayout(v);
            } else {
                this.x = v;
            }
        }
    }

    get x() {
        return this._x;
    }

    set x(v) {
        if (v !== this._x) {
            this._updateLocalTranslateDelta(v - this._x, 0);
            this._x = v;
        }
    }

    get funcX() {
        return (this._optFlags & 1 ? this._funcX : null);
    }

    set funcX(v) {
        if (this._funcX !== v) {
            this._optFlags |= 1;
            this._funcX = v;
            if (this.hasFlexLayout()) {
                this._layout.setOriginalXWithoutUpdatingLayout(0);
                this.layout.forceLayout();
            } else {
                this._x = 0;
                this._triggerRecalcTranslate();
            }
        }
    }

    _disableFuncX() {
        this._optFlags = this._optFlags & (0xFFFF - 1);
        this._funcX = null;
    }

    get offsetY() {
        if (this._funcY) {
            return this._funcY;
        } else {
            if (this.hasFlexLayout()) {
                return this._layout.originalY;
            } else {
                return this._y;
            }
        }
    }

    set offsetY(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(v)) {
            this.funcY = v;
        } else {
            this._disableFuncY();
            if (this.hasFlexLayout()) {
                this.y += (v - this._layout.originalY);
                this._layout.setOriginalYWithoutUpdatingLayout(v);
            } else {
                this.y = v;
            }
        }
    }

    get y() {
        return this._y;
    }

    set y(v) {
        if (v !== this._y) {
            this._updateLocalTranslateDelta(0, v - this._y);
            this._y = v;
        }
    }

    get funcY() {
        return (this._optFlags & 2 ? this._funcY : null);
    }

    set funcY(v) {
        if (this._funcY !== v) {
            this._optFlags |= 2;
            this._funcY = v;
            if (this.hasFlexLayout()) {
                this._layout.setOriginalYWithoutUpdatingLayout(0);
                this.layout.forceLayout();
            } else {
                this._y = 0;
                this._triggerRecalcTranslate();
            }
        }
    }

    _disableFuncY() {
        this._optFlags = this._optFlags & (0xFFFF - 2);
        this._funcY = null;
    }

    get funcW() {
        return (this._optFlags & 4 ? this._funcW : null);
    }

    set funcW(v) {
        if (this._funcW !== v) {
            this._optFlags |= 4;
            this._funcW = v;
            if (this.hasFlexLayout()) {
                this._layout._originalWidth = 0;
                this.layout.changedDimensions(true, false);
            } else {
                this._w = 0;
                this._triggerRecalcTranslate();
            }
        }
    }

    disableFuncW() {
        this._optFlags = this._optFlags & (0xFFFF - 4);
        this._funcW = null;
    }

    get funcH() {
        return (this._optFlags & 8 ? this._funcH : null);
    }

    set funcH(v) {
        if (this._funcH !== v) {
            this._optFlags |= 8;
            this._funcH = v;
            if (this.hasFlexLayout()) {
                this._layout._originalHeight = 0;
                this.layout.changedDimensions(false, true);
            } else {
                this._h = 0;
                this._triggerRecalcTranslate();
            }
        }
    }

    disableFuncH() {
        this._optFlags = this._optFlags & (0xFFFF - 8);
        this._funcH = null;
    }

    get w() {
        return this._w;
    }

    getRenderWidth() {
        if (this.hasFlexLayout()) {
            return this._layout.originalWidth;
        } else {
            return this._w;
        }
    }

    get h() {
        return this._h;
    }

    getRenderHeight() {
        if (this.hasFlexLayout()) {
            return this._layout.originalHeight;
        } else {
            return this._h;
        }
    }

    get scaleX() {
        return this._scaleX;
    }

    set scaleX(v) {
        if (this._scaleX !== v) {
            this._scaleX = v;
            this._updateLocalTransform();
        }
    }

    get scaleY() {
        return this._scaleY;
    }

    set scaleY(v) {
        if (this._scaleY !== v) {
            this._scaleY = v;
            this._updateLocalTransform();
        }
    }

    get scale() {
        return this.scaleX;
    }

    set scale(v) {
        if (this._scaleX !== v || this._scaleY !== v) {
            this._scaleX = v;
            this._scaleY = v;
            this._updateLocalTransform();
        }
    }

    get pivotX() {
        return this._pivotX;
    }

    set pivotX(v) {
        if (this._pivotX !== v) {
            this._pivotX = v;
            this._updateLocalTranslate();
        }
    }

    get pivotY() {
        return this._pivotY;
    }

    set pivotY(v) {
        if (this._pivotY !== v) {
            this._pivotY = v;
            this._updateLocalTranslate();
        }
    }

    get pivot() {
        return this._pivotX;
    }

    set pivot(v) {
        if (this._pivotX !== v || this._pivotY !== v) {
            this._pivotX = v;
            this._pivotY = v;
            this._updateLocalTranslate();
        }
    }

    get mountX() {
        return this._mountX;
    }

    set mountX(v) {
        if (this._mountX !== v) {
            this._mountX = v;
            this._updateLocalTranslate();
        }
    }

    get mountY() {
        return this._mountY;
    }

    set mountY(v) {
        if (this._mountY !== v) {
            this._mountY = v;
            this._updateLocalTranslate();
        }
    }

    get mount() {
        return this._mountX;
    }

    set mount(v) {
        if (this._mountX !== v || this._mountY !== v) {
            this._mountX = v;
            this._mountY = v;
            this._updateLocalTranslate();
        }
    }

    get rotation() {
        return this._rotation;
    }

    set rotation(v) {
        if (this._rotation !== v) {
            this._rotation = v;
            this._updateLocalTransform();
        }
    }

    get alpha() {
        return this._alpha;
    }

    set alpha(v) {
        // Account for rounding errors.
        v = (v > 1 ? 1 : (v < 1e-14 ? 0 : v));
        if (this._alpha !== v) {
            let prev = this._alpha;
            this._alpha = v;
            this._updateLocalAlpha();
            if ((prev === 0) !== (v === 0)) {
                this._element._updateEnabledFlag();
            }
        }
    }

    get visible() {
        return this._visible;
    }

    set visible(v) {
        if (this._visible !== v) {
            this._visible = v;
            this._updateLocalAlpha();
            this._element._updateEnabledFlag();

            if (this.hasFlexLayout()) {
                this.layout.setVisible(v);
            }
        }
    }

    _updateLocalTransform() {
        if (this._rotation !== 0 && this._rotation % (2 * Math.PI)) {
            // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes
            let _sr = Math.sin(this._rotation);
            let _cr = Math.cos(this._rotation);

            this._setLocalTransform(
                _cr * this._scaleX,
                -_sr * this._scaleY,
                _sr * this._scaleX,
                _cr * this._scaleY
            );
        } else {
            this._setLocalTransform(
                this._scaleX,
                0,
                0,
                this._scaleY
            );
        }
        this._updateLocalTranslate();
    };

    _updateLocalTranslate() {
        this._recalcLocalTranslate();
        this._triggerRecalcTranslate();
    };

    _recalcLocalTranslate() {
        let pivotXMul = this._pivotX * this._w;
        let pivotYMul = this._pivotY * this._h;
        let px = this._x - (pivotXMul * this._localTa + pivotYMul * this._localTb) + pivotXMul;
        let py = this._y - (pivotXMul * this._localTc + pivotYMul * this._localTd) + pivotYMul;
        px -= this._mountX * this._w;
        py -= this._mountY * this._h;
        this._localPx = px;
        this._localPy = py;
    }

    _updateLocalTranslateDelta(dx, dy) {
        this._addLocalTranslate(dx, dy);
    };

    _updateLocalAlpha() {
        this._setLocalAlpha(this._visible ? this._alpha : 0);
    };

    /**
     * @param {number} type
     * 0: no updates
     * 1: re-invoke shader
     * 3: re-create render texture and re-invoke shader
     */
    setHasRenderUpdates(type) {
        if (this._worldContext.alpha) {
            // Ignore if 'world invisible'. Render updates will be reset to 3 for every element that becomes visible.
            let p = this;
            p._hasRenderUpdates = Math.max(type, p._hasRenderUpdates);
            while ((p = p._parent) && (p._hasRenderUpdates !== 3)) {
                p._hasRenderUpdates = 3;
            }
        }
    }

    /**
     * @param {Number} type
     *   1: alpha
     *   2: translate
     *   4: transform
     * 128: becomes visible
     * 256: flex layout updated
     */
    _setRecalc(type) {
        this._recalc |= type;

        this._setHasUpdates();

        // Any changes in descendants should trigger texture updates.
        if (this._parent) {
            this._parent.setHasRenderUpdates(3);
        }
    }

    _setHasUpdates() {
        let p = this;
        while (p && !p._hasUpdates) {
            p._hasUpdates = true;
            p = p._parent;
        }
    }

    getParent() {
        return this._parent;
    }

    setParent(parent) {
        if (parent !== this._parent) {
            let prevIsZContext = this.isZContext();
            let prevParent = this._parent;
            this._parent = parent;

            // Notify flex layout engine.
            if (this._layout || (parent && parent.isFlexContainer())) {
                this.layout.setParent(prevParent, parent);
            }

            if (prevParent) {
                // When elements are deleted, the render texture must be re-rendered.
                prevParent.setHasRenderUpdates(3);
            }

            this._setRecalc(1 + 2 + 4);

            if (this._parent) {
                // Force parent to propagate hasUpdates flag.
                this._parent._setHasUpdates();
            }

            if (this._zIndex === 0) {
                this.setZParent(parent);
            } else {
                this.setZParent(parent ? parent.findZContext() : null);
            }

            if (prevIsZContext !== this.isZContext()) {
                if (!this.isZContext()) {
                    this.disableZContext();
                } else {
                    this.enableZContext(prevParent.findZContext());
                }
            }

            // Tree order did change: even if zParent stays the same, we must resort.
            this._zIndexResort = true;
            if (this._zParent) {
                this._zParent.enableZSort();
            }

            if (!this._shader) {
                let newShaderOwner = parent && !parent._renderToTextureEnabled ? parent._shaderOwner : null;
                if (newShaderOwner !== this._shaderOwner) {
                    this.setHasRenderUpdates(1);
                    this._setShaderOwnerRecursive(newShaderOwner);
                }
            }
        }
    };

    enableZSort(force = false) {
        if (!this._zSort && this._zContextUsage > 0) {
            this._zSort = true;
            if (force) {
                // ZSort must be done, even if this element is invisible.
                // This is done to prevent memory leaks when removing element from inactive render branches.
                this.ctx.forceZSort(this);
            }
        }
    }

    addChildAt(index, child) {
        if (!this._children) this._children = [];
        this._children.splice(index, 0, child);
        child.setParent(this);
    };

    setChildAt(index, child) {
        if (!this._children) this._children = [];
        this._children[index].setParent(null);
        this._children[index] = child;
        child.setParent(this);
    }

    removeChildAt(index) {
        let child = this._children[index];
        this._children.splice(index, 1);
        child.setParent(null);
    };

    removeChildren() {
        if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                this._children[i].setParent(null);
            }

            this._children.splice(0);

            if (this._zIndexedChildren) {
                this._zIndexedChildren.splice(0);
            }
        }
    };

    syncChildren(removed, added, order) {
        this._children = order;
        for (let i = 0, n = removed.length; i < n; i++) {
            removed[i].setParent(null);
        }
        for (let i = 0, n = added.length; i < n; i++) {
            added[i].setParent(this);
        }
    }

    moveChild(fromIndex, toIndex) {
        let c = this._children[fromIndex];
        this._children.splice(fromIndex, 1);
        this._children.splice(toIndex, 0, c);

        // Tree order changed: must resort!;
        this._zIndexResort = true;
        if (this._zParent) {
            this._zParent.enableZSort();
        }
    }

    _setLocalTransform(a, b, c, d) {
        this._setRecalc(4);
        this._localTa = a;
        this._localTb = b;
        this._localTc = c;
        this._localTd = d;

        // We also regard negative scaling as a complex case, so that we can optimize the non-complex case better.
        this._isComplex = (b !== 0) || (c !== 0) || (a < 0) || (d < 0);
    };

    _addLocalTranslate(dx, dy) {
        this._localPx += dx;
        this._localPy += dy;
        this._triggerRecalcTranslate();
    }

    _setLocalAlpha(a) {
        if (!this._worldContext.alpha && ((this._parent && this._parent._worldContext.alpha) && a)) {
            // Element is becoming visible. We need to force update.
            this._setRecalc(1 + 128);
        } else {
            this._setRecalc(1);
        }

        if (a < 1e-14) {
            // Tiny rounding errors may cause failing visibility tests.
            a = 0;
        }

        this._localAlpha = a;
    };

    setDimensions(w, h, isEstimate = this._dimsUnknown) {
        // In case of an estimation, the update loop should perform different bound checks.
        this._dimsUnknown = isEstimate;

        if (this.hasFlexLayout()) {
            this._layout.originalWidth = w;
            this._layout.originalHeight = h;
        } else {
            if (this._w !== w || this._h !== h) {
                this._updateDimensions(w, h);
                return true;
            }
        }
        return false;
    };

    _updateDimensions(w, h) {
        if (this._w !== w || this._h !== h) {
            this._w = w;
            this._h = h;

            this._triggerRecalcTranslate();

            if (this._texturizer) {
                this._texturizer.releaseRenderTexture();
                this._texturizer.updateResultTexture();
            }
            // Due to width/height change: update the translation vector.
            this._updateLocalTranslate();
        }
    }

    setTextureCoords(ulx, uly, brx, bry) {
        this.setHasRenderUpdates(3);

        this._ulx = ulx;
        this._uly = uly;
        this._brx = brx;
        this._bry = bry;
    };

    get displayedTextureSource() {
        return this._displayedTextureSource;
    }

    setDisplayedTextureSource(textureSource) {
        this.setHasRenderUpdates(3);
        this._displayedTextureSource = textureSource;
    };

    get isRoot() {
        return this._isRoot;
    }

    setAsRoot() {
        // Use parent dummy.
        this._parent = new ElementCore(this._element);

        // After setting root, make sure it's updated.
        this._parent._hasRenderUpdates = 3;
        this._parent._hasUpdates = true;

        // Root is, and will always be, the primary zContext.
        this._isRoot = true;

        this.ctx.root = this;

        // Set scissor area of 'fake parent' to stage's viewport.
        this._parent._viewport = [0, 0, this.ctx.stage.coordsWidth, this.ctx.stage.coordsHeight];
        this._parent._scissor = this._parent._viewport;

        // When recBoundsMargin is null, the defaults are used (100 for all sides).
        this._parent._recBoundsMargin = null;

        this._setRecalc(1 + 2 + 4);
    };

    isAncestorOf(c) {
        let p = c;
        while (p = p._parent) {
            if (this === p) {
                return true;
            }
        }
        return false;
    };

    isZContext() {
        return (this._forceZIndexContext || this._renderToTextureEnabled || this._zIndex !== 0 || this._isRoot || !this._parent);
    };

    findZContext() {
        if (this.isZContext()) {
            return this;
        } else {
            return this._parent.findZContext();
        }
    };

    setZParent(newZParent) {
        if (this._zParent !== newZParent) {
            if (this._zParent !== null) {
                if (this._zIndex !== 0) {
                    this._zParent.decZContextUsage();
                }

                // We must filter out this item upon the next resort.
                this._zParent.enableZSort();
            }

            if (newZParent !== null) {
                let hadZContextUsage = (newZParent._zContextUsage > 0);

                // @pre: new parent's children array has already been modified.
                if (this._zIndex !== 0) {
                    newZParent.incZContextUsage();
                }

                if (newZParent._zContextUsage > 0) {
                    if (!hadZContextUsage && (this._parent === newZParent)) {
                        // This child was already in the children list.
                        // Do not add double.
                    } else {
                        // Add new child to array.
                        newZParent._zIndexedChildren.push(this);
                    }

                    // Order should be checked.
                    newZParent.enableZSort();
                }
            }

            this._zParent = newZParent;

            // Newly added element must be marked for resort.
            this._zIndexResort = true;
        }
    };

    incZContextUsage() {
        this._zContextUsage++;
        if (this._zContextUsage === 1) {
            if (!this._zIndexedChildren) {
                this._zIndexedChildren = [];
            }
            if (this._children) {
                // Copy.
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._zIndexedChildren.push(this._children[i]);
                }
                // Initially, children are already sorted properly (tree order).
                this._zSort = false;
            }
        }
    };

    decZContextUsage() {
        this._zContextUsage--;
        if (this._zContextUsage === 0) {
            this._zSort = false;
            this._zIndexedChildren.splice(0);
        }
    };

    get zIndex() {
        return this._zIndex;
    }

    set zIndex(zIndex) {
        if (this._zIndex !== zIndex) {
            this.setHasRenderUpdates(1);

            let newZParent = this._zParent;

            let prevIsZContext = this.isZContext();
            if (zIndex === 0 && this._zIndex !== 0) {
                if (this._parent === this._zParent) {
                    if (this._zParent) {
                        this._zParent.decZContextUsage();
                    }
                } else {
                    newZParent = this._parent;
                }
            } else if (zIndex !== 0 && this._zIndex === 0) {
                newZParent = this._parent ? this._parent.findZContext() : null;
                if (newZParent === this._zParent) {
                    if (this._zParent) {
                        this._zParent.incZContextUsage();
                        this._zParent.enableZSort();
                    }
                }
            } else if (zIndex !== this._zIndex) {
                if (this._zParent && this._zParent._zContextUsage) {
                    this._zParent.enableZSort();
                }
            }

            if (newZParent !== this._zParent) {
                this.setZParent(null);
            }

            this._zIndex = zIndex;

            if (newZParent !== this._zParent) {
                this.setZParent(newZParent);
            }

            if (prevIsZContext !== this.isZContext()) {
                if (!this.isZContext()) {
                    this.disableZContext();
                } else {
                    this.enableZContext(this._parent.findZContext());
                }
            }

            // Make sure that resort is done.
            this._zIndexResort = true;
            if (this._zParent) {
                this._zParent.enableZSort();
            }
        }
    };

    get forceZIndexContext() {
        return this._forceZIndexContext;
    }

    set forceZIndexContext(v) {
        this.setHasRenderUpdates(1);

        let prevIsZContext = this.isZContext();
        this._forceZIndexContext = v;

        if (prevIsZContext !== this.isZContext()) {
            if (!this.isZContext()) {
                this.disableZContext();
            } else {
                this.enableZContext(this._parent.findZContext());
            }
        }
    };

    enableZContext(prevZContext) {
        if (prevZContext && prevZContext._zContextUsage > 0) {
            // Transfer from upper z context to this z context.
            const results = this._getZIndexedDescs();
            results.forEach((c) => {
                if (this.isAncestorOf(c) && c._zIndex !== 0) {
                    c.setZParent(this);
                }
            });
        }
    }

    _getZIndexedDescs() {
        const results = [];
        if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                this._children[i]._getZIndexedDescsRec(results);
            }
        }
        return results;
    }

    _getZIndexedDescsRec(results) {
        if (this._zIndex) {
            results.push(this);
        } else if (this._children && !this.isZContext()) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                this._children[i]._getZIndexedDescsRec(results);
            }
        }
    }

    disableZContext() {
        // Transfer from this z context to upper z context.
        if (this._zContextUsage > 0) {
            let newZParent = this._parent.findZContext();

            // Make sure that z-indexed children are up to date (old ones removed).
            if (this._zSort) {
                this.sortZIndexedChildren();
            }

            this._zIndexedChildren.slice().forEach(function (c) {
                if (c._zIndex !== 0) {
                    c.setZParent(newZParent);
                }
            });
        }
    };

    get colorUl() {
        return this._colorUl;
    }

    set colorUl(color) {
        if (this._colorUl !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorUl = color;
        }
    }

    get colorUr() {
        return this._colorUr;
    }

    set colorUr(color) {
        if (this._colorUr !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorUr = color;
        }
    };

    get colorBl() {
        return this._colorBl;
    }

    set colorBl(color) {
        if (this._colorBl !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorBl = color;
        }
    };

    get colorBr() {
        return this._colorBr;
    }

    set colorBr(color) {
        if (this._colorBr !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorBr = color;
        }
    };


    set onUpdate(f) {
        this._onUpdate = f;
        this._setRecalc(7);
    }

    set onAfterUpdate(f) {
        this._onAfterUpdate = f;
        this._setRecalc(7);
    }

    set onAfterCalcs(f) {
        this._onAfterCalcs = f;
        this._setRecalc(7);
    }

    get shader() {
        return this._shader;
    }

    set shader(v) {
        this.setHasRenderUpdates(1);

        let prevShader = this._shader;
        this._shader = v;
        if (!v && prevShader) {
            // Disabled shader.
            let newShaderOwner = (this._parent && !this._parent._renderToTextureEnabled ? this._parent._shaderOwner : null);
            this._setShaderOwnerRecursive(newShaderOwner);
        } else if (v) {
            // Enabled shader.
            this._setShaderOwnerRecursive(this);
        }
    }

    get activeShader() {
        return this._shaderOwner ? this._shaderOwner.shader : this.renderState.defaultShader;
    }

    get activeShaderOwner() {
        return this._shaderOwner;
    }

    get clipping() {
        return this._clipping;
    }

    set clipping(v) {
        if (this._clipping !== v) {
            this._clipping = v;

            // Force update of scissor by updating translate.
            // Alpha must also be updated because the scissor area may have been empty.
            this._setRecalc(1 + 2);
        }
    }

    get clipbox() {
        return this._clipbox;
    }

    set clipbox(v) {
        // In case of out-of-bounds element, all children will also be ignored.
        // It will save us from executing the update/render loops for those.
        // The optimization will be used immediately during the next frame.
        this._clipbox = v;
    }

    _setShaderOwnerRecursive(elementCore) {
        this._shaderOwner = elementCore;

        if (this._children && !this._renderToTextureEnabled) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                let c = this._children[i];
                if (!c._shader) {
                    c._setShaderOwnerRecursive(elementCore);
                    c._hasRenderUpdates = 3;
                }
            }
        }
    };

    _setShaderOwnerChildrenRecursive(elementCore) {
        if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                let c = this._children[i];
                if (!c._shader) {
                    c._setShaderOwnerRecursive(elementCore);
                    c._hasRenderUpdates = 3;
                }
            }
        }
    };

    _hasRenderContext() {
        return this._renderContext !== this._worldContext;
    }

    get renderContext() {
        return this._renderContext;
    }

    updateRenderToTextureEnabled() {
        // Enforce texturizer initialisation.
        let v = this.texturizer._enabled;

        if (v) {
            this._enableRenderToTexture();
        } else {
            this._disableRenderToTexture();
            this._texturizer.releaseRenderTexture();
        }
    }

    _enableRenderToTexture() {
        if (!this._renderToTextureEnabled) {
            let prevIsZContext = this.isZContext();

            this._renderToTextureEnabled = true;

            this._renderContext = new ElementCoreContext();

            // If render to texture is active, a new shader context is started.
            this._setShaderOwnerChildrenRecursive(null);

            if (!prevIsZContext) {
                // Render context forces z context.
                this.enableZContext(this._parent ? this._parent.findZContext() : null);
            }

            this.setHasRenderUpdates(3);

            // Make sure that the render coordinates get updated.
            this._setRecalc(7);

            this.render = this._renderAdvanced;
        }
    }

    _disableRenderToTexture() {
        if (this._renderToTextureEnabled) {
            this._renderToTextureEnabled = false;

            this._setShaderOwnerChildrenRecursive(this._shaderOwner);

            this._renderContext = this._worldContext;

            if (!this.isZContext()) {
                this.disableZContext();
            }

            // Make sure that the render coordinates get updated.
            this._setRecalc(7);

            this.setHasRenderUpdates(3);

            this.render = this._renderSimple;
        }
    }

    isWhite() {
        return (this._colorUl === 0xFFFFFFFF) && (this._colorUr === 0xFFFFFFFF) && (this._colorBl === 0xFFFFFFFF) && (this._colorBr === 0xFFFFFFFF);
    }

    hasSimpleTexCoords() {
        return (this._ulx === 0) && (this._uly === 0) && (this._brx === 1) && (this._bry === 1);
    }

    _stashTexCoords() {
        this._stashedTexCoords = [this._ulx, this._uly, this._brx, this._bry];
        this._ulx = 0;
        this._uly = 0;
        this._brx = 1;
        this._bry = 1;
    }

    _unstashTexCoords() {
        this._ulx = this._stashedTexCoords[0];
        this._uly = this._stashedTexCoords[1];
        this._brx = this._stashedTexCoords[2];
        this._bry = this._stashedTexCoords[3];
        this._stashedTexCoords = null;
    }

    _stashColors() {
        this._stashedColors = [this._colorUl, this._colorUr, this._colorBr, this._colorBl];
        this._colorUl = 0xFFFFFFFF;
        this._colorUr = 0xFFFFFFFF;
        this._colorBr = 0xFFFFFFFF;
        this._colorBl = 0xFFFFFFFF;
    }

    _unstashColors() {
        this._colorUl = this._stashedColors[0];
        this._colorUr = this._stashedColors[1];
        this._colorBr = this._stashedColors[2];
        this._colorBl = this._stashedColors[3];
        this._stashedColors = null;
    }

    isVisible() {
        return (this._localAlpha > 1e-14);
    };

    get outOfBounds() {
        return this._outOfBounds;
    }

    set boundsMargin(v) {

        /**
         *  null: inherit from parent.
         *  number[4]: specific margins: left, top, right, bottom.
         */
        this._boundsMargin = v ? v.slice() : null;

        // We force recalc in order to set all boundsMargin recursively during the next update.
        this._triggerRecalcTranslate();
    }

    get boundsMargin() {
        return this._boundsMargin;
    }

    update() {
        this._recalc |= this._parent._pRecalc;

        if (this._layout && this._layout.isEnabled()) {
            if (this._recalc & 256) {
                this._layout.layoutFlexTree();
            }
        } else if ((this._recalc & 2) && this._optFlags) {
            this._applyRelativeDimFuncs();
        }

        if (this._onUpdate) {
            // Block all 'upwards' updates when changing things in this branch.
            this._hasUpdates = true;
            this._onUpdate(this.element, this);
        }

        const pw = this._parent._worldContext;
        let w = this._worldContext;
        const visible = (pw.alpha && this._localAlpha);

        /**
         * We must update if:
         * - branch contains updates (even when invisible because it may contain z-indexed descendants)
         * - there are (inherited) updates and this branch is visible
         * - this branch becomes invisible (descs may be z-indexed so we must update all alpha values)
         */
        if (this._hasUpdates || (this._recalc && visible) || (w.alpha && !visible)) {
            let recalc = this._recalc;

            // Update world coords/alpha.
            if (recalc & 1) {
                if (!w.alpha && visible) {
                    // Becomes visible.
                    this._hasRenderUpdates = 3;
                }
                w.alpha = pw.alpha * this._localAlpha;

                if (w.alpha < 1e-14) {
                    // Tiny rounding errors may cause failing visibility tests.
                    w.alpha = 0;
                }
            }

            if (recalc & 6) {
                w.px = pw.px + this._localPx * pw.ta;
                w.py = pw.py + this._localPy * pw.td;
                if (pw.tb !== 0) w.px += this._localPy * pw.tb;
                if (pw.tc !== 0) w.py += this._localPx * pw.tc;
            }

            if (recalc & 4) {
                w.ta = this._localTa * pw.ta;
                w.tb = this._localTd * pw.tb;
                w.tc = this._localTa * pw.tc;
                w.td = this._localTd * pw.td;

                if (this._isComplex) {
                    w.ta += this._localTc * pw.tb;
                    w.tb += this._localTb * pw.ta;
                    w.tc += this._localTc * pw.td;
                    w.td += this._localTb * pw.tc;
                }
            }

            // Update render coords/alpha.
            const pr = this._parent._renderContext;
            if (this._parent._hasRenderContext()) {
                const init = this._renderContext === this._worldContext;
                if (init) {
                    // First render context build: make sure that it is fully initialized correctly.
                    // Otherwise, if we get into bounds later, the render context would not be initialized correctly.
                    this._renderContext = new ElementCoreContext();
                }

                const r = this._renderContext;

                // Update world coords/alpha.
                if (init || (recalc & 1)) {
                    r.alpha = pr.alpha * this._localAlpha;

                    if (r.alpha < 1e-14) {
                        r.alpha = 0;
                    }
                }

                if (init || (recalc & 6)) {
                    r.px = pr.px + this._localPx * pr.ta;
                    r.py = pr.py + this._localPy * pr.td;
                    if (pr.tb !== 0) r.px += this._localPy * pr.tb;
                    if (pr.tc !== 0) r.py += this._localPx * pr.tc;
                }

                if (init) {
                    // We set the recalc toggle, because we must make sure that the scissor is updated.
                    recalc |= 2;
                }

                if (init || (recalc & 4)) {
                    r.ta = this._localTa * pr.ta;
                    r.tb = this._localTd * pr.tb;
                    r.tc = this._localTa * pr.tc;
                    r.td = this._localTd * pr.td;

                    if (this._isComplex) {
                        r.ta += this._localTc * pr.tb;
                        r.tb += this._localTb * pr.ta;
                        r.tc += this._localTc * pr.td;
                        r.td += this._localTb * pr.tc;
                    }
                }
            } else {
                this._renderContext = this._worldContext;
            }

            if (this.ctx.updateTreeOrder === -1) {
                this.ctx.updateTreeOrder = this._updateTreeOrder + 1;
            } else {
                this._updateTreeOrder = this.ctx.updateTreeOrder++;
            }

            // Determine whether we must use a 'renderTexture'.
            const useRenderToTexture = this._renderToTextureEnabled && this._texturizer.mustRenderToTexture();
            if (this._useRenderToTexture !== useRenderToTexture) {
                // Coords must be changed.
                this._recalc |= 2 + 4;

                // Scissor may change: force update.
                recalc |= 2;

                if (!this._useRenderToTexture) {
                    // We must release the texture.
                    this._texturizer.release();
                }
            }
            this._useRenderToTexture = useRenderToTexture;

            const r = this._renderContext;

            const bboxW = this._dimsUnknown ? 2048 : this._w;
            const bboxH = this._dimsUnknown ? 2048 : this._h;

            // Calculate a bbox for this element.
            let sx, sy, ex, ey;
            const rComplex = (r.tb !== 0) || (r.tc !== 0) || (r.ta < 0) || (r.td < 0);
            if (rComplex) {
                sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
            } else {
                sx = r.px;
                ex = r.px + r.ta * bboxW;
                sy = r.py;
                ey = r.py + r.td * bboxH;
            }

            if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
                // If we are dealing with a non-identity matrix, we must extend the bbox so that withinBounds and
                //  scissors will include the complete range of (positive) dimensions up to ,lh.
                const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
                const ny = this._x * pr.tc + this._y * pr.td + pr.py;
                if (nx < sx) sx = nx;
                if (ny < sy) sy = ny;
                if (nx > ex) ex = nx;
                if (ny > ey) ey = ny;
            }

            if (recalc & 6 || !this._scissor /* initial */) {
                // Determine whether we must 'clip'.
                if (this._clipping && r.isSquare()) {
                    // If the parent renders to a texture, it's scissor should be ignored;
                    const area = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
                    if (area) {
                        // Merge scissor areas.
                        const lx = Math.max(area[0], sx);
                        const ly = Math.max(area[1], sy);
                        this._scissor = [
                            lx,
                            ly,
                            Math.min(area[2] + area[0], ex) - lx,
                            Math.min(area[3] + area[1], ey) - ly
                        ];
                    } else {
                        this._scissor = [sx, sy, ex - sx, ey - sy];
                    }
                } else {
                    // No clipping: reuse parent scissor.
                    this._scissor = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
                }
            }

            // Calculate the outOfBounds margin.
            if (this._boundsMargin) {
                this._recBoundsMargin = this._boundsMargin;
            } else {
                this._recBoundsMargin = this._parent._recBoundsMargin;
            }

            if (this._onAfterCalcs) {
                // After calcs may change render coords, scissor and/or recBoundsMargin.
                if (this._onAfterCalcs(this.element)) {
                    // Recalculate bbox.
                    if (rComplex) {
                        sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                        ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                        sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                        ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                    } else {
                        sx = r.px;
                        ex = r.px + r.ta * bboxW;
                        sy = r.py;
                        ey = r.py + r.td * bboxH;
                    }

                    if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
                        const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
                        const ny = this._x * pr.tc + this._y * pr.td + pr.py;
                        if (nx < sx) sx = nx;
                        if (ny < sy) sy = ny;
                        if (nx > ex) ex = nx;
                        if (ny > ey) ey = ny;
                    }
                }
            }

            if (this._parent._outOfBounds === 2) {
                // Inherit parent out of boundsness.
                this._outOfBounds = 2;

                if (this._withinBoundsMargin) {
                    this._withinBoundsMargin = false;
                    this.element._disableWithinBoundsMargin();
                }
            } else {
                if (recalc & 6) {
                    // Recheck if element is out-of-bounds (all settings that affect this should enable recalc bit 2 or 4).
                    this._outOfBounds = 0;
                    let withinMargin = true;

                    // Offscreens are always rendered as long as the parent is within bounds.
                    if (!this._renderToTextureEnabled || !this._texturizer || !this._texturizer.renderOffscreen) {
                        if (this._scissor && (this._scissor[2] <= 0 || this._scissor[3] <= 0)) {
                            // Empty scissor area.
                            this._outOfBounds = 2;
                        } else {
                            // Use bbox to check out-of-boundness.
                            if ((this._scissor[0] > ex) ||
                                (this._scissor[1] > ey) ||
                                (sx > (this._scissor[0] + this._scissor[2])) ||
                                (sy > (this._scissor[1] + this._scissor[3]))
                            ) {
                                this._outOfBounds = 1;
                            }

                            if (this._outOfBounds) {
                                if (this._clipping || this._useRenderToTexture || (this._clipbox && (bboxW && bboxH))) {
                                    this._outOfBounds = 2;
                                }
                            }
                        }

                        withinMargin = (this._outOfBounds === 0);
                        if (!withinMargin) {
                            // Re-test, now with margins.
                            if (this._recBoundsMargin) {
                                withinMargin = !((ex < this._scissor[0] - this._recBoundsMargin[2]) ||
                                    (ey < this._scissor[1] - this._recBoundsMargin[3]) ||
                                    (sx > this._scissor[0] + this._scissor[2] + this._recBoundsMargin[0]) ||
                                    (sy > this._scissor[1] + this._scissor[3] + this._recBoundsMargin[1]));
                            } else {
                                withinMargin = !((ex < this._scissor[0] - 100) ||
                                    (ey < this._scissor[1] - 100) ||
                                    (sx > this._scissor[0] + this._scissor[2] + 100) ||
                                    (sy > this._scissor[1] + this._scissor[3] + 100));
                            }
                            if (withinMargin && this._outOfBounds === 2) {
                                // Children must be visited because they may contain elements that are within margin, so must be visible.
                                this._outOfBounds = 1;
                            }
                        }
                    }

                    if (this._withinBoundsMargin !== withinMargin) {
                        this._withinBoundsMargin = withinMargin;

                        if (this._withinBoundsMargin) {
                            // This may update things (txLoaded events) in the element itself, but also in descendants and ancestors.

                            // Changes in ancestors should be executed during the next call of the stage update. But we must
                            // take care that the _recalc and _hasUpdates flags are properly registered. That's why we clear
                            // both before entering the children, and use _pRecalc to transfer inherited updates instead of
                            // _recalc directly.

                            // Changes in descendants are automatically executed within the current update loop, though we must
                            // take care to not update the hasUpdates flag unnecessarily in ancestors. We achieve this by making
                            // sure that the hasUpdates flag of this element is turned on, which blocks it for ancestors.
                            this._hasUpdates = true;

                            const recalc = this._recalc;
                            this._recalc = 0;
                            this.element._enableWithinBoundsMargin();

                            if (this._recalc) {
                                // This element needs to be re-updated now, because we want the dimensions (and other changes) to be updated.
                                return this.update();
                            }

                            this._recalc = recalc;
                        } else {
                            this.element._disableWithinBoundsMargin();
                        }
                    }
                }
            }

            if (this._useRenderToTexture) {
                // Set viewport necessary for children scissor calculation.
                if (this._viewport) {
                    this._viewport[2] = bboxW;
                    this._viewport[3] = bboxH;
                } else {
                    this._viewport = [0, 0, bboxW, bboxH];
                }
            }

            // Filter out bits that should not be copied to the children (currently all are).
            this._pRecalc = (this._recalc & 135);

            // Clear flags so that future updates are properly detected.
            this._recalc = 0;
            this._hasUpdates = false;

            if (this._outOfBounds < 2) {
                if (this._useRenderToTexture) {
                    if (this._worldContext.isIdentity()) {
                        // Optimization.
                        // The world context is already identity: use the world context as render context to prevents the
                        // ancestors from having to update the render context.
                        this._renderContext = this._worldContext;
                    } else {
                        // Temporarily replace the render coord attribs by the identity matrix.
                        // This allows the children to calculate the render context.
                        this._renderContext = ElementCoreContext.IDENTITY;
                    }
                }

                if (this._children) {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        this._children[i].update();
                    }
                }

                if (this._useRenderToTexture) {
                    this._renderContext = r;
                }
            } else {
                if (this._children) {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        if (this._children[i]._hasUpdates) {
                            this._children[i].update();
                        } else {
                            // Make sure we don't lose the 'inherited' updates.
                            this._children[i]._recalc |= this._pRecalc;
                            this._children[i].updateOutOfBounds();
                        }
                    }
                }
            }

            if (this._onAfterUpdate) {
                this._onAfterUpdate(this.element);
            }
        } else {
            if (this.ctx.updateTreeOrder === -1 || this._updateTreeOrder >= this.ctx.updateTreeOrder) {
                // If new tree order does not interfere with the current (gaps allowed) there's no need to traverse the branch.
                this.ctx.updateTreeOrder = -1;
            } else {
                this.updateTreeOrder();
            }
        }
    }

    _applyRelativeDimFuncs() {
        if (this._optFlags & 1) {
            const x = this._funcX(this._parent.w);
            if (x !== this._x) {
                this._localPx += (x - this._x);
                this._x = x;
            }
        }
        if (this._optFlags & 2) {
            const y = this._funcY(this._parent.h);
            if (y !== this._y) {
                this._localPy += (y - this._y);
                this._y = y;
            }
        }

        let changedDims = false;
        if (this._optFlags & 4) {
            const w = this._funcW(this._parent.w);
            if (w !== this._w) {
                this._w = w;
                changedDims = true;
            }
        }
        if (this._optFlags & 8) {
            const h = this._funcH(this._parent.h);
            if (h !== this._h) {
                this._h = h;
                changedDims = true;
            }
        }

        if (changedDims) {
            // Recalc mount, scale position.
            this._recalcLocalTranslate();

            this.element.onDimensionsChanged(this._w, this._h);
        }
    }

    updateOutOfBounds() {
        // Propagate outOfBounds flag to descendants (necessary because of z-indexing).
        // Invisible elements are not drawn anyway. When alpha is updated, so will _outOfBounds.
        if (this._outOfBounds !== 2 && this._renderContext.alpha > 0) {

            // Inherit parent out of boundsness.
            this._outOfBounds = 2;

            if (this._withinBoundsMargin) {
                this._withinBoundsMargin = false;
                this.element._disableWithinBoundsMargin();
            }

            if (this._children) {
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._children[i].updateOutOfBounds();
                }
            }
        }
    }

    updateTreeOrder() {
        if (this._localAlpha && (this._outOfBounds !== 2)) {
            this._updateTreeOrder = this.ctx.updateTreeOrder++;

            if (this._children) {
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._children[i].updateTreeOrder();
                }
            }
        }
    }

    _renderSimple() {
        this._hasRenderUpdates = 0;

        if (this._zSort) {
            this.sortZIndexedChildren();
        }

        if (this._outOfBounds < 2 && this._renderContext.alpha) {
            let renderState = this.renderState;

            if ((this._outOfBounds === 0) && this._displayedTextureSource) {
                renderState.setShader(this.activeShader, this._shaderOwner);
                renderState.setScissor(this._scissor);
                this.renderState.addQuad(this);
            }

            // Also add children to the VBO.
            if (this._children) {
                if (this._zContextUsage) {
                    for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
                        this._zIndexedChildren[i].render();
                    }
                } else {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        if (this._children[i]._zIndex === 0) {
                            // If zIndex is set, this item already belongs to a zIndexedChildren array in one of the ancestors.
                            this._children[i].render();
                        }

                    }
                }
            }
        }
    }

    _renderAdvanced() {
        const hasRenderUpdates = this._hasRenderUpdates;

        // We must clear the hasRenderUpdates flag before rendering, because updating result textures in combination
        // with z-indexing may trigger render updates on a render branch that is 'half done'.
        // We need to ensure that the full render branch is marked for render updates, not only half (leading to freeze).
        this._hasRenderUpdates = 0;

        if (this._zSort) {
            this.sortZIndexedChildren();
        }

        if (this._outOfBounds < 2 && this._renderContext.alpha) {
            let renderState = this.renderState;

            let mustRenderChildren = true;
            let renderTextureInfo;
            let prevRenderTextureInfo;
            if (this._useRenderToTexture) {
                if (this._w === 0 || this._h === 0) {
                    // Ignore this branch and don't draw anything.
                    return;
                } else if (!this._texturizer.hasRenderTexture() || (hasRenderUpdates >= 3)) {
                    // Switch to default shader for building up the render texture.
                    renderState.setShader(renderState.defaultShader, this);

                    prevRenderTextureInfo = renderState.renderTextureInfo;

                    renderTextureInfo = {
                        nativeTexture: null,
                        offset: 0,  // Set by CoreRenderState.
                        w: this._w,
                        h: this._h,
                        empty: true,
                        cleared: false,
                        ignore: false,
                        cache: false
                    };

                    if (this._texturizer.hasResultTexture() || (!renderState.isCachingTexturizer && (hasRenderUpdates < 3))) {
                        /**
                         * We don't always cache render textures.
                         *
                         * The rule is, that caching for a specific render texture is only enabled if:
                         * - There is a result texture to be updated.
                         * - There were no render updates -within the contents- since last frame (ElementCore.hasRenderUpdates < 3)
                         * - AND there are no ancestors that are being cached during this frame (CoreRenderState.isCachingTexturizer)
                         *   If an ancestor is cached anyway, it's probably not necessary to keep deeper caches. If the top level is to
                         *   change while a lower one is not, that lower level will be cached instead.
                         *
                         * In case of the fast blur element, this prevents having to cache all blur levels and stages, saving a huge amount
                         * of GPU memory!
                         *
                         * Especially when using multiple stacked layers of the same dimensions that are RTT this will have a very
                         * noticable effect on performance as less render textures need to be allocated.
                         */
                        renderTextureInfo.cache = true;
                        renderState.isCachingTexturizer = true;
                    }

                    if (!this._texturizer.hasResultTexture()) {
                        // We can already release the current texture to the pool, as it will be rebuild anyway.
                        // In case of multiple layers of 'filtering', this may save us from having to create one
                        //  render-to-texture layer.
                        // Notice that we don't do this when there is a result texture, as any other element may rely on
                        //  that result texture being filled.
                        this._texturizer.releaseRenderTexture();
                    }

                    renderState.setRenderTextureInfo(renderTextureInfo);
                    renderState.setScissor(null);

                    if (this._displayedTextureSource) {
                        let r = this._renderContext;

                        // Use an identity context for drawing the displayed texture to the render texture.
                        this._renderContext = ElementCoreContext.IDENTITY;

                        // Add displayed texture source in local coordinates.
                        this.renderState.addQuad(this);

                        this._renderContext = r;
                    }
                } else {
                    mustRenderChildren = false;
                }
            } else {
                if ((this._outOfBounds === 0) && this._displayedTextureSource) {
                    renderState.setShader(this.activeShader, this._shaderOwner);
                    renderState.setScissor(this._scissor);
                    this.renderState.addQuad(this);
                }
            }

            // Also add children to the VBO.
            if (mustRenderChildren && this._children) {
                if (this._zContextUsage) {
                    for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
                        this._zIndexedChildren[i].render();
                    }
                } else {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        if (this._children[i]._zIndex === 0) {
                            // If zIndex is set, this item already belongs to a zIndexedChildren array in one of the ancestors.
                            this._children[i].render();
                        }
                    }
                }
            }

            if (this._useRenderToTexture) {
                let updateResultTexture = false;
                if (mustRenderChildren) {
                    // Finished refreshing renderTexture.
                    renderState.finishedRenderTexture();

                    // If nothing was rendered, we store a flag in the texturizer and prevent unnecessary
                    //  render-to-texture and filtering.
                    this._texturizer.empty = renderTextureInfo.empty;

                    if (renderTextureInfo.empty) {
                        // We ignore empty render textures and do not draw the final quad.

                        // The following cleans up memory and enforces that the result texture is also cleared.
                        this._texturizer.releaseRenderTexture();
                    } else if (renderTextureInfo.nativeTexture) {
                        // If nativeTexture is set, we can reuse that directly instead of creating a new render texture.
                        this._texturizer.reuseTextureAsRenderTexture(renderTextureInfo.nativeTexture);

                        renderTextureInfo.ignore = true;
                    } else {
                        if (this._texturizer.renderTextureReused) {
                            // Quad operations must be written to a render texture actually owned.
                            this._texturizer.releaseRenderTexture();
                        }
                        // Just create the render texture.
                        renderTextureInfo.nativeTexture = this._texturizer.getRenderTexture();
                    }

                    // Restore the parent's render texture.
                    renderState.setRenderTextureInfo(prevRenderTextureInfo);

                    updateResultTexture = true;
                }

                if (!this._texturizer.empty) {
                    let resultTexture = this._texturizer.getResultTexture();
                    if (updateResultTexture) {
                        if (resultTexture) {
                            // Logging the update frame can be handy for userland.
                            resultTexture.update = renderState.stage.frameCounter;
                        }
                        this._texturizer.updateResultTexture();
                    }

                    if (!this._texturizer.renderOffscreen) {
                        // Render result texture to the actual render target.
                        renderState.setShader(this.activeShader, this._shaderOwner);
                        renderState.setScissor(this._scissor);

                        // If no render texture info is set, the cache can be reused.
                        const cache = !renderTextureInfo || renderTextureInfo.cache;

                        renderState.setTexturizer(this._texturizer, cache);
                        this._stashTexCoords();
                        if (!this._texturizer.colorize) this._stashColors();
                        this.renderState.addQuad(this, true);
                        if (!this._texturizer.colorize) this._unstashColors();
                        this._unstashTexCoords();
                        renderState.setTexturizer(null);
                    }
                }
            }

            if (renderTextureInfo && renderTextureInfo.cache) {
                // Allow siblings to cache.
                renderState.isCachingTexturizer = false;
            }
        }
    }

    get zSort() {
        return this._zSort;
    }

    sortZIndexedChildren() {
        /**
         * We want to avoid resorting everything. Instead, we do a single pass of the full array:
         * - filtering out elements with a different zParent than this (were removed)
         * - filtering out, but also gathering (in a temporary array) the elements that have zIndexResort flag
         * - then, finally, we merge-sort both the new array and the 'old' one
         * - element may have been added 'double', so when merge-sorting also check for doubles.
         * - if the old one is larger (in size) than it should be, splice off the end of the array.
         */

        const n = this._zIndexedChildren.length;
        let ptr = 0;
        const a = this._zIndexedChildren;

        // Notice that items may occur multiple times due to z-index changing.
        const b = [];
        for (let i = 0; i < n; i++) {
            if (a[i]._zParent === this) {
                if (a[i]._zIndexResort) {
                    b.push(a[i]);
                } else {
                    if (ptr !== i) {
                        a[ptr] = a[i];
                    }
                    ptr++;
                }
            }
        }

        const m = b.length;
        if (m) {
            for (let j = 0; j < m; j++) {
                b[j]._zIndexResort = false;
            }

            b.sort(ElementCore.sortZIndexedChildren);
            const n = ptr;
            if (!n) {
                ptr = 0;
                let j = 0;
                do {
                    a[ptr++] = b[j++];
                } while (j < m);

                if (a.length > ptr) {
                    // Slice old (unnecessary) part off array.
                    a.splice(ptr);
                }
            } else {
                // Merge-sort arrays;
                ptr = 0;
                let i = 0;
                let j = 0;
                const mergeResult = [];
                do {
                    const v = (a[i]._zIndex === b[j]._zIndex ? a[i]._updateTreeOrder - b[j]._updateTreeOrder : a[i]._zIndex - b[j]._zIndex);

                    const add = v > 0 ? b[j++] : a[i++];

                    if (ptr === 0 || (mergeResult[ptr - 1] !== add)) {
                        mergeResult[ptr++] = add;
                    }

                    if (i >= n) {
                        do {
                            const add = b[j++];
                            if (ptr === 0 || (mergeResult[ptr - 1] !== add)) {
                                mergeResult[ptr++] = add;
                            }
                        } while (j < m);
                        break;
                    } else if (j >= m) {
                        do {
                            const add = a[i++];
                            if (ptr === 0 || (mergeResult[ptr - 1] !== add)) {
                                mergeResult[ptr++] = add;
                            }
                        } while (i < n);
                        break;
                    }
                } while (true);

                this._zIndexedChildren = mergeResult;
            }
        } else {
            if (a.length > ptr) {
                // Slice old (unnecessary) part off array.
                a.splice(ptr);
            }
        }

        this._zSort = false;
    };

    get localTa() {
        return this._localTa;
    };

    get localTb() {
        return this._localTb;
    };

    get localTc() {
        return this._localTc;
    };

    get localTd() {
        return this._localTd;
    };

    get element() {
        return this._element;
    }

    get renderUpdates() {
        return this._hasRenderUpdates;
    }

    get texturizer() {
        if (!this._texturizer) {
            this._texturizer = new _ElementTexturizer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this);
        }
        return this._texturizer;
    }

    getCornerPoints() {
        let w = this._worldContext;

        return [
            w.px,
            w.py,
            w.px + this._w * w.ta,
            w.py + this._w * w.tc,
            w.px + this._w * w.ta + this._h * w.tb,
            w.py + this._w * w.tc + this._h * w.td,
            w.px + this._h * w.tb,
            w.py + this._h * w.td
        ];
    };

    getRenderTextureCoords(relX, relY) {
        let r = this._renderContext;
        return [
            r.px + r.ta * relX + r.tb * relY,
            r.py + r.tc * relX + r.td * relY
        ];
    }

    getAbsoluteCoords(relX, relY) {
        let w = this._renderContext;
        return [
            w.px + w.ta * relX + w.tb * relY,
            w.py + w.tc * relX + w.td * relY
        ];
    }

    collectAtCoord(x, y, children) {
        // return when branch is hidden
        if (this._renderContext.alpha === 0) {
            return;
        }

        if (this.inBound(x, y)) {
            if (this._scissor) {
                if (this.inScissor()) {
                    children.push(this);
                }
            } else {
                children.push(this);
            }
        }

        if (this._children) {
            const j = this._children.length;
            for (let i = 0; i < j; i++) {
                this._children[i].collectAtCoord(x, y, children);
            }
        }

        return children.sort(ElementCore.sortZIndexedChildren);
    }

    inBound(tx, ty) {
        const c = this.getCornerPoints();
        return tx > c[0] && tx < c[2] && ty > c[1] && ty < c[7];
    }

    inScissor() {
        const sc = this._scissor;
        const c = this.getCornerPoints();

        return c[2] >= sc[0] && c[0] <= sc[0] + sc[2] && c[7] >= sc[1] && c[1] <= sc[1] + sc[3];
    }

    get layout() {
        this._ensureLayout();
        return this._layout;
    }

    get flex() {
        return this._layout ? this._layout.flex : null;
    }

    set flex(v) {
        this.layout.flex = v;
    }

    get flexItem() {
        return this._layout ? this._layout.flexItem : null;
    }

    set flexItem(v) {
        this.layout.flexItem = v;
    }

    isFlexItem() {
        return !!this._layout && this._layout.isFlexItemEnabled();
    }

    isFlexContainer() {
        return !!this._layout && this._layout.isFlexEnabled();
    }

    enableFlexLayout() {
        this._ensureLayout();
    }

    _ensureLayout() {
        if (!this._layout) {
            this._layout = new _flex_FlexTarget_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this);
        }
    }

    disableFlexLayout() {
        this._triggerRecalcTranslate();
    }

    hasFlexLayout() {
        return (this._layout && this._layout.isEnabled());
    }

    setLayout(x, y, w, h) {
        this.x = x;
        this.y = y;
        this._updateDimensions(w, h);
    }

    triggerLayout() {
        this._setRecalc(256);
    }

    _triggerRecalcTranslate() {
        this._setRecalc(2);
    }

}

class ElementCoreContext {

    constructor() {
        this.alpha = 1;

        this.px = 0;
        this.py = 0;

        this.ta = 1;
        this.tb = 0;
        this.tc = 0;
        this.td = 1;
    }

    isIdentity() {
        return this.alpha === 1 &&
            this.px === 0 &&
            this.py === 0 &&
            this.ta === 1 &&
            this.tb === 0 &&
            this.tc === 0 &&
            this.td === 1;
    }

    isSquare() {
        return this.tb === 0 && this.tc === 0;
    }

}

ElementCoreContext.IDENTITY = new ElementCoreContext();
ElementCore.sortZIndexedChildren = function (a, b) {
    return (a._zIndex === b._zIndex ? a._updateTreeOrder - b._updateTreeOrder : a._zIndex - b._zIndex);
};





/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/ElementTexturizer.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/ElementTexturizer.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementTexturizer)
/* harmony export */ });
/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../TextureSource.mjs */ "./node_modules/@lightningjs/core/src/tree/TextureSource.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ElementTexturizer {

    constructor(elementCore) {

        this._element = elementCore.element;
        this._core = elementCore;

        this.ctx = this._core.ctx;

        this._enabled = false;
        this.lazy = false;
        this._colorize = false;

        this._renderTexture = null;

        this._renderTextureReused = false;

        this._resultTextureSource = null;

        this._renderOffscreen = false;

        this.empty = false;
    }

    get enabled() {
        return this._enabled;
    }

    set enabled(v) {
        this._enabled = v;
        this._core.updateRenderToTextureEnabled();
    }

    get renderOffscreen() {
        return this._renderOffscreen;
    }

    set renderOffscreen(v) {
        this._renderOffscreen = v;
        this._core.setHasRenderUpdates(1);

        // This enforces rechecking the 'within bounds'.
        this._core._setRecalc(6);
    }

    get colorize() {
        return this._colorize;
    }

    set colorize(v) {
        if (this._colorize !== v) {
            this._colorize = v;

            // Only affects the finally drawn quad.
            this._core.setHasRenderUpdates(1);
        }
    }

    _getTextureSource() {
        if (!this._resultTextureSource) {
            this._resultTextureSource = new _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this._element.stage.textureManager);
            this.updateResultTexture();
        }
        return this._resultTextureSource;
    }

    hasResultTexture() {
        return !!this._resultTextureSource;
    }

    resultTextureInUse() {
        return this._resultTextureSource && this._resultTextureSource.hasEnabledElements();
    }

    updateResultTexture() {
        let resultTexture = this.getResultTexture();
        if (this._resultTextureSource) {
            if (this._resultTextureSource.nativeTexture !== resultTexture) {
                let w = resultTexture ? resultTexture.w : 0;
                let h = resultTexture ? resultTexture.h : 0;
                this._resultTextureSource.replaceNativeTexture(resultTexture, w, h);
            }

            // Texture will be updated: all elements using the source need to be updated as well.
            this._resultTextureSource.forEachEnabledElement(element => {
                element._updateDimensions();
                element.core.setHasRenderUpdates(3);
            });
        }
    }

    mustRenderToTexture() {
        // Check if we must really render as texture.
        if (this._enabled && !this.lazy) {
            return true;
        } else if (this._enabled && this.lazy && this._core._hasRenderUpdates < 3) {
            // Static-only: if renderToTexture did not need to update during last drawn frame, generate it as a cache.
            return true;
        }
        return false;
    }

    deactivate() {
        this.release();
    }

    get renderTextureReused() {
        return this._renderTextureReused;
    }

    release() {
        this.releaseRenderTexture();
    }

    releaseRenderTexture() {
        if (this._renderTexture) {
            if (!this._renderTextureReused) {
                this.ctx.releaseRenderTexture(this._renderTexture);
            }
            this._renderTexture = null;
            this._renderTextureReused = false;
            this.updateResultTexture();
        }
    }

    // Reuses the specified texture as the render texture (in ancestor).
    reuseTextureAsRenderTexture(nativeTexture) {
        if (this._renderTexture !== nativeTexture) {
            this.releaseRenderTexture();
            this._renderTexture = nativeTexture;
            this._renderTextureReused = true;
        }
    }

    hasRenderTexture() {
        return !!this._renderTexture;
    }

    getRenderTexture() {
        if (!this._renderTexture) {
            this._renderTexture = this.ctx.allocateRenderTexture(this._core._w, this._core._h);
            this._renderTextureReused = false;
        }
        return this._renderTexture;
    }

    getResultTexture() {
        return this._renderTexture;
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/sdk/package.json":
/*!****************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/package.json ***!
  \****************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"@lightningjs/sdk","version":"4.8.1","license":"Apache-2.0","scripts":{"postinstall":"node ./scripts/postinstall.js","lint":"eslint \'**/*.js\'","release":"npm publish --access public"},"lint-staged":{"*.js":["eslint --fix"],"src/startApp.js":["rollup -c ./rollup.config.js"]},"husky":{"hooks":{"pre-commit":"lint-staged"}},"dependencies":{"@babel/polyfill":"^7.11.5","@lightningjs/core":"*","@michieljs/execute-as-promise":"^1.0.0","deepmerge":"^4.2.2","localCookie":"github:WebPlatformForEmbedded/localCookie","shelljs":"^0.8.4","url-polyfill":"^1.1.10","whatwg-fetch":"^3.0.0"},"devDependencies":{"@babel/core":"^7.11.6","@babel/plugin-transform-parameters":"^7.10.5 ","@babel/plugin-transform-spread":"^7.11.0","@babel/preset-env":"^7.11.5","babel-eslint":"^10.1.0","eslint":"^7.10.0","eslint-config-prettier":"^6.12.0","eslint-plugin-prettier":"^3.1.4","husky":"^4.3.0","lint-staged":"^10.4.0","prettier":"^1.19.1","rollup":"^1.32.1","rollup-plugin-babel":"^4.4.0"},"repository":{"type":"git","url":"git@github.com:rdkcentral/Lightning-SDK.git"},"bugs":{"url":"https://github.com/rdkcentral/Lightning-SDK/issues"}}');

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"pt3-firebolt_hello_world-mock","version":"1.0.0","description":"","scripts":{"build":"webpack","dev":"cross-env NODE_ENV=development webpack serve"},"dependencies":{"@firebolt-js/sdk":"^0.6.0","@lightningjs/sdk":"^4.6.1"},"devDependencies":{"@babel/core":"^7.14.5","@babel/preset-env":"^7.14.5","copy-webpack-plugin":"^10.2.4","cross-env":"^7.0.3","html-webpack-plugin":"^5.5.0","pug":">=3.0.1","pug-loader":"^2.4.0","webpack":"^5.68.0","webpack-cli":"^4.9.2","webpack-dev-server":"^4.7.4"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*************************!*\
  !*** ./public/index.js ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lightningjs/sdk */ "./node_modules/@lightningjs/sdk/index.js");
/* harmony import */ var _src_App__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/App */ "./src/App.js");
/* harmony import */ var _src_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/settings */ "./src/settings.js");
/*
* Copyright 2021 Comcast Cable Communications Management, LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* SPDX-License-Identifier: Apache-2.0
*/






// launch the application with custom settings
const app = (0,_lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Launch)(_src_App__WEBPACK_IMPORTED_MODULE_1__.App, _src_settings__WEBPACK_IMPORTED_MODULE_2__.appSettings, _src_settings__WEBPACK_IMPORTED_MODULE_2__.platformSettings, _src_settings__WEBPACK_IMPORTED_MODULE_2__.appData);

// append the canvas to the dom
document.body.appendChild(app.stage.getCanvas());

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxnQ0FBZ0M7QUFDaEMsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7Ozs7QUFJQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBLHFEQUFxRCxlQUFlO0FBQ3BFOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDs7OztBQUlBO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7O0FBRUE7QUFDQSxvREFBb0QsVUFBVTtBQUM5RDs7QUFFQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEOztBQUVBO0FBQ0EsK0NBQStDLDRCQUE0QjtBQUMzRTs7QUFFQTtBQUNBLDhDQUE4Qyw4Q0FBOEM7QUFDNUY7O0FBRUE7QUFDQSx1REFBdUQsVUFBVTtBQUNqRTs7QUFFQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEOztBQUVBO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7O0FBRUE7QUFDQSxtREFBbUQsVUFBVTtBQUM3RDs7QUFFQTtBQUNBLHFEQUFxRCxVQUFVO0FBQy9EOztBQUVBO0FBQ0Esc0RBQXNELG9CQUFvQjtBQUMxRTs7QUFFQTtBQUNBLHFEQUFxRCxrQkFBa0I7QUFDdkU7O0FBRUE7QUFDQSxvREFBb0Qsb0JBQW9CO0FBQ3hFOztBQUVBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RTs7QUFFQTtBQUNBLDZEQUE2RCwyQ0FBMkM7QUFDeEc7O0FBRUE7QUFDQSxtREFBbUQsVUFBVTtBQUM3RDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLElBQUk7QUFDOUcsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLHlFQUF5RSxJQUFJO0FBQzdFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsSUFBSTtBQUMzRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdURBQXVELE1BQU07QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gsSUFBSTtBQUNwSCxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsK0VBQStFLElBQUk7QUFDbkYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxJQUFJO0FBQ2pGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2REFBNkQsTUFBTTtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsMENBQTBDO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QscUNBQXFDO0FBQ3pGOztBQUVBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7O0FBRUE7QUFDQSxpREFBaUQsZUFBZTtBQUNoRTs7OztBQUlBO0FBQ0Esc0RBQXNELGNBQWM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBOzs7O0FBSUE7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBLCtDQUErQyxlQUFlO0FBQzlEOztBQUVBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7O0FBRUE7QUFDQSxrREFBa0QsU0FBUztBQUMzRDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOzs7O0FBSUE7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBOztBQUVBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOzs7O0FBSUE7QUFDQSx5REFBeUQ7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU0sa0RBQVM7QUFDZjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWU7QUFDZjtBQUNBO0FBQ0EsR0FBRztBQUNILDRCQUE0QjtBQUM1QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QUFXO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7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QSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFEOztBQUV0Qyw4QkFBOEIsa0VBQVM7O0FBRXREO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxzQkFBc0Isc0NBQXNDO0FBQzVELHdCQUF3QiwyQkFBMkI7QUFDbkQseUJBQXlCLDJCQUEyQjtBQUNwRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUZBQWE7O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRDs7QUFFdEMsNEJBQTRCLGtFQUFTOztBQUVwRDtBQUNBOztBQUVBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHNFQUFvQjtBQUM3QyxvQkFBb0Isc0VBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixzRUFBb0I7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0Qiw2Q0FBNkM7QUFDekUsNEJBQTRCLHNFQUFvQjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULDRCQUE0Qiw2Q0FBNkM7QUFDekUsNEJBQTRCLHNFQUFvQjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxzRUFBb0I7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksdUVBQXFCO0FBQ2pDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFK0Q7QUFDL0Qsd0JBQXdCLG9FQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRXNDOzs7Ozs7Ozs7Ozs7Ozs7O0FDaGdCdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRDs7QUFFdEMsbUNBQW1DLGtFQUFTOztBQUUzRDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsYUFBYTtBQUNiLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1EQUFtRDtBQUM5RTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLDRCQUE0QjtBQUMxRCx3QkFBd0I7QUFDeEIsYUFBYTs7QUFFYixnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0M7QUFDUzs7QUFFOUI7OztBQUdmO0FBQ0E7O0FBRUEsMkJBQTJCLDhEQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtFQUFnQjtBQUN4Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9DO0FBQ0k7QUFDUTs7QUFFakM7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGdCQUFnQiw4RUFBaUM7QUFDakQsaUVBQWlFLDJFQUE4QjtBQUMvRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtFQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHFFQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdFQUEyQjtBQUNuQzs7QUFFQTtBQUNBLGdCQUFnQixxRUFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3RUFBMkI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxxRUFBd0I7QUFDdkM7O0FBRUE7QUFDQSxlQUFlLHFFQUF3QjtBQUN2Qzs7QUFFQTtBQUNBLGVBQWUsd0VBQTJCO0FBQzFDOztBQUVBO0FBQ0EsZUFBZSx1RUFBMEI7QUFDekM7O0FBRUE7QUFDQSxlQUFlLHVFQUEwQjtBQUN6Qzs7QUFFQTtBQUNBLGVBQWUsdUVBQTBCO0FBQ3pDOztBQUVBO0FBQ0EsZUFBZSx3RUFBMkI7QUFDMUM7O0FBRUE7QUFDQSxlQUFlLGlFQUFvQjtBQUNuQzs7QUFFQTtBQUNBLGVBQWUsaUVBQW9CO0FBQ25DOztBQUVBO0FBQ0EsZUFBZSxzRUFBeUI7QUFDeEM7O0FBRUE7QUFDQSxlQUFlLHNFQUF5QjtBQUN4Qzs7QUFFQTtBQUNBLGVBQWUscUVBQXdCO0FBQ3ZDOztBQUVBO0FBQ0EsZUFBZSxxRUFBd0I7QUFDdkM7O0FBRUE7QUFDQSxlQUFlLHNFQUF5QjtBQUN4Qzs7QUFFQTtBQUNBLGVBQWUsc0VBQXlCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixxRUFBd0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7QUFDVjtBQUNFOztBQUV4QztBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QiwwREFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVE7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1GQUFzQztBQUN6RTtBQUNBO0FBQ0EsbUNBQW1DLG1GQUFzQztBQUN6RTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3BlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RDs7QUFFekM7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSwrQkFBK0I7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFVO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsMEJBQTBCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlEOztBQUUxQzs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwrQkFBK0I7O0FBRTlDOztBQUVBO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUseUVBQTRCO0FBQzNDOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEM7QUFDSjtBQUNRO0FBQ047O0FBRTdCOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix1REFBVTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIseURBQVk7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLDJEQUFjO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsd0RBQVc7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0Msb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwQkFBMEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDBCQUEwQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUQ7QUFDSDs7QUFFckMsNEJBQTRCLGdFQUFhOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0VBQVc7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRDs7QUFFdkMsMEJBQTBCLDhEQUFXOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFtQixzRUFBZTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxZQUFZLDhEQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQix1RUFBcUI7QUFDaEQsNEJBQTRCLHVFQUFxQjs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsNEVBQTBCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxPQUFPO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEQ7QUFDZjs7QUFFNUIsMEJBQTBCLHdEQUFNOztBQUUvQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0RBQWtCOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ2U7O0FBRWY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ2UsNEJBQTRCLDBEQUFhOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRDO0FBQ0k7O0FBRWpDLGlDQUFpQywwREFBYTs7QUFFN0Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOERBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDalFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkM7O0FBRTlCLDRCQUE0Qix3REFBVzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEQ7QUFDZDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ2UsOEJBQThCLDBEQUFhOztBQUUxRDtBQUNBOztBQUVBLGlDQUFpQyxrRUFBWTs7QUFFN0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsWUFBWTs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDs7QUFFakMsNEJBQTRCLDBEQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7O0FBRWpDLHlCQUF5QiwwREFBYTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsNkVBQWdDOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDs7QUFFakMsOEJBQThCLDBEQUFhOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDs7QUFFakMsNEJBQTRCLDBEQUFhOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzNRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEOztBQUVqQywrQkFBK0IsMERBQWE7O0FBRTNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEOztBQUVqQyw4QkFBOEIsMERBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkVBQWdDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRDtBQUNOOztBQUVqQyw0QkFBNEIsMERBQWE7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qix3RkFBc0M7QUFDOUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLFlBQVk7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEOztBQUVqQyxnQ0FBZ0MsMERBQWE7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDZSw2QkFBNkIsMERBQWE7O0FBRXpEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEOztBQUVqQyxpQ0FBaUMsMERBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7QUFDTTs7QUFFdkMsbUNBQW1DLDBEQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix3RkFBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyx3RkFBc0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEO0FBQ007O0FBRXZDLHFDQUFxQywwREFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isd0ZBQXNDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDtBQUNLOztBQUV0Qyw0QkFBNEIsMERBQWE7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3RkFBc0M7QUFDekYsNkRBQTZELHdGQUFzQztBQUNuRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLDZFQUFnQzs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7QUFDTTs7QUFFdkMsNkJBQTZCLDBEQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix3RkFBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7O0FBRWpDLDZCQUE2QiwwREFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQ0FBK0M7QUFDM0YsMkNBQTJDLCtDQUErQztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxpQkFBaUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQy81QmpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtFQUFxQjtBQUNsQztBQUNBLFVBQVU7QUFDVjtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGdCQUFnQiw2REFBZ0I7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRWdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUUwQztBQUNPO0FBQ25COztBQUVFO0FBQ2U7QUFDYjs7QUFFbkI7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQiw2REFBVzs7QUFFckM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyREFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0IsWUFBWSw2REFBZ0I7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZDQUE2QyxJQUFJOztBQUVqRDtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFxQjtBQUNyQztBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQscUNBQXFDLFNBQVMsR0FBRyxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQywwR0FBMEc7QUFDMUcsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLDBDQUEwQztBQUMxQyx1SEFBdUg7QUFDdkg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDZEQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw2REFBZ0I7QUFDNUI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksNkRBQWdCO0FBQzVCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrRUFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQixrRUFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FDclJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix1REFBdUQ7QUFDM0UsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsNkRBQWdCO0FBQ3hCOztBQUVBOztBQUVBOztBQUVBOztBQUU4Qjs7Ozs7Ozs7Ozs7Ozs7OztBQ2xuQjlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7O0FBRWpDOztBQUVmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBEQUFhOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxPQUFPO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHlEQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRWdDOzs7Ozs7Ozs7Ozs7Ozs7QUN6WWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3BNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdlOztBQUVmO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2U7O0FBRWY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdlOztBQUVmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlOztBQUVmO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUVBQXVFLE9BQU87QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtRDs7QUFFcEM7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDZEQUFnQjtBQUM1QjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw2REFBZ0I7QUFDNUI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsT0FBTztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0QsT0FBTztBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUNBO0FBQ0EsK0JBQStCLDREQUFVO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0Q7QUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7QUNudUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlEOztBQUVsQzs7QUFFZjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsMERBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUMzS0E7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxXQUFXO1dBQzVDO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEM7O0FBRVQ7QUFDd0M7O0FBRXpFO0FBQ0EsWUFBWSx3REFBTSxDQUFDLHlDQUFHLEVBQUUsc0RBQVcsRUFBRSwyREFBZ0IsRUFBRSxrREFBTzs7QUFFOUQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BmaXJlYm9sdC1qcy9zZGsvZGlzdC9maXJlYm9sdC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL0Fkcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9BcHBsaWNhdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9BdWRpb1BsYXllci9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Db2xvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvQ29sb3JzL3V0aWxzLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL0Zwc0NvdW50ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvSW1nL1NjYWxlZEltYWdlVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9JbWcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvS2V5Ym9hcmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvTGFuZ3VhZ2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvTGF1bmNoL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL0xpZ2h0bmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Mb2NhbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvTG9nL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL01lZGlhUGxheWVyL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL01ldGFkYXRhL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL01ldHJpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUGluL2RpYWxvZy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9QaW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUHJvZmlsZS9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Qcm9maWxlL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUHJvZmlsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9QdXJjaGFzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9SZWdpc3RyeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvYmFzZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUm91dGVyL21vZGVsL1JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUm91dGVyL21vZGVsL1JvdXRlLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci90cmFuc2l0aW9ucy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvY29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvZW1pdC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvaGVscGVycy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvaGlzdG9yeS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvbG9hZGVyLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci91dGlscy9wcm92aWRlci5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvcmVnZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUm91dGVyL3V0aWxzL3JlZ2lzdGVyLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci91dGlscy9yb3V0ZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvcm91dGVyLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci91dGlscy90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci91dGlscy93aWRnZXRzLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1NldHRpbmdzL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1N0b3JhZ2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVFYvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVFYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVmVyc2lvbkxhYmVsL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1ZpZGVvUGxheWVyL1ZpZGVvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9WaWRlb1BsYXllci9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVmlkZW9QbGF5ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvaGVscGVycy9hdXRvU2V0dXBNaXhpbi5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9oZWxwZXJzL2Vhc2VFeGVjdXRpb24uanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvaGVscGVycy9zZXF1ZW5jZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbWljaGllbGpzL2V4ZWN1dGUtYXMtcHJvbWlzZS9zcmMvZXhlY3V0ZS1hcy1wcm9taXNlLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS9kaXN0L2Nqcy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9sb2NhbENvb2tpZS9tb2R1bGUvbG9jYWxDb29raWUuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9zcmMvQXBwLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vc3JjL0JsYWNrQWRhbS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL3NyYy9NeUJ1dHRvbi5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL3NyYy9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvRXZlbnRFbWl0dGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvYW5pbWF0aW9uL0FuaW1hdGlvbi5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2FuaW1hdGlvbi9BbmltYXRpb25BY3Rpb25TZXR0aW5ncy5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2FuaW1hdGlvbi9BbmltYXRpb25NYW5hZ2VyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvYW5pbWF0aW9uL0FuaW1hdGlvblNldHRpbmdzLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvYW5pbWF0aW9uL1RyYW5zaXRpb24ubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9hbmltYXRpb24vVHJhbnNpdGlvbk1hbmFnZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9hbmltYXRpb24vVHJhbnNpdGlvblNldHRpbmdzLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvYXBwbGljYXRpb24vQXBwbGljYXRpb24ubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9hcHBsaWNhdGlvbi9Db21wb25lbnQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9hcHBsaWNhdGlvbi9TdGF0ZU1hY2hpbmUubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9jb21wb25lbnRzL0Jsb29tQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvY29tcG9uZW50cy9Cb3JkZXJDb21wb25lbnQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9jb21wb25lbnRzL0Zhc3RCbHVyQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvY29tcG9uZW50cy9MaXN0Q29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvY29tcG9uZW50cy9TbW9vdGhTY2FsZUNvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvRmxleENvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvRmxleEl0ZW0ubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9mbGV4L0ZsZXhUYXJnZXQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9mbGV4L0ZsZXhVdGlscy5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvbGF5b3V0L0NvbnRlbnRBbGlnbmVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9sYXlvdXQvRmxleExheW91dC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvbGF5b3V0L0l0ZW1Db29yZGluYXRlc1VwZGF0ZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9mbGV4L2xheW91dC9MaW5lTGF5b3V0ZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9mbGV4L2xheW91dC9TcGFjaW5nQ2FsY3VsYXRvci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvbGF5b3V0L2xpbmUvSXRlbUFsaWduZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9mbGV4L2xheW91dC9saW5lL0l0ZW1Qb3NpdGlvbmVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9sYXlvdXQvbGluZS9MaW5lTGF5b3V0Lm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9sYXlvdXQvbGluZS9TaXplR3Jvd2VyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9sYXlvdXQvbGluZS9TaXplU2hyaW5rZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9saWdodG5pbmcubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9wbGF0Zm9ybXMvUGxhdGZvcm1Mb2FkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9wbGF0Zm9ybXMvYnJvd3Nlci9JbWFnZVdvcmtlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3BsYXRmb3Jtcy9icm93c2VyL1dlYlBsYXRmb3JtLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvUmVuZGVyZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9jMmQvQzJkQ29yZVF1YWRMaXN0Lm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvYzJkL0MyZENvcmVRdWFkT3BlcmF0aW9uLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvYzJkL0MyZENvcmVSZW5kZXJFeGVjdXRvci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL2MyZC9DMmRSZW5kZXJlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL2MyZC9DMmRTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9jMmQvQzJkVGV4dHVyZVRpbnRNYW5hZ2VyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvYzJkL3NoYWRlcnMvQmx1clNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL2MyZC9zaGFkZXJzL0RlZmF1bHRTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9jb21tb24vc2hhZGVycy9HcmF5c2NhbGVTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9zcGFyay9TcGFya1JlbmRlcmVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvc3Bhcmsvc2hhZGVycy9TcGFya1NoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL1dlYkdMQ29yZVF1YWRMaXN0Lm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvV2ViR0xDb3JlUXVhZE9wZXJhdGlvbi5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL1dlYkdMQ29yZVJlbmRlckV4ZWN1dG9yLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvV2ViR0xSZW5kZXJlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL1dlYkdMU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvV2ViR0xTaGFkZXJQcm9ncmFtLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9Cb3hCbHVyU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9DaXJjdWxhclB1c2hTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0RlZmF1bHRTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0RpdGhlcmluZ1NoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvRmFkZU91dFNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvSG9sZVNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvSW52ZXJzaW9uU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9MaWdodDNkU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9MaW5lYXJCbHVyU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9NYWduaWZpZXJTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL091dGxpbmVTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1BlcnNwZWN0aXZlU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9QaXhlbGF0ZVNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvUmFkaWFsRmlsdGVyU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9SYWRpYWxHcmFkaWVudFNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvUm91bmRlZFJlY3RhbmdsZVNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvU3Bpbm5lclNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvU3Bpbm5lclNoYWRlcjIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1ZpZ25ldHRlU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdGV4dHVyZXMvSHRtbFRleHR1cmUubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90ZXh0dXJlcy9JbWFnZVRleHR1cmUubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90ZXh0dXJlcy9Ob2lzZVRleHR1cmUubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90ZXh0dXJlcy9SZWN0YW5nbGVUZXh0dXJlLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdGV4dHVyZXMvU291cmNlVGV4dHVyZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RleHR1cmVzL1N0YXRpY0NhbnZhc1RleHR1cmUubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90ZXh0dXJlcy9TdGF0aWNUZXh0dXJlLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdGV4dHVyZXMvVGV4dFRleHR1cmUubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90ZXh0dXJlcy9UZXh0VGV4dHVyZVJlbmRlcmVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdGV4dHVyZXMvVGV4dFRleHR1cmVSZW5kZXJlckFkdmFuY2VkLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdG9vbHMvTXVsdGlTcGxpbmUubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90b29scy9PYmpNZXJnZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90b29scy9PYmplY3RMaXN0UHJveHkubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90b29scy9PYmplY3RMaXN0V3JhcHBlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3Rvb2xzL1Rvb2xzLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdG9vbHMvV2ViR0xTdGF0ZU1hbmFnZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL0Jhc2UubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL0VsZW1lbnQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL0VsZW1lbnRDaGlsZExpc3QubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL09iamVjdExpc3QubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL1NoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvU3RhZ2UubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL1N0YWdlVXRpbHMubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL1RleHR1cmUubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL1RleHR1cmVNYW5hZ2VyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9UZXh0dXJlU291cmNlLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9UZXh0dXJlVGhyb3R0bGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9VdGlscy5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvY29yZS9Db3JlQ29udGV4dC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvY29yZS9Db3JlUXVhZExpc3QubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL2NvcmUvQ29yZVF1YWRPcGVyYXRpb24ubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL2NvcmUvQ29yZVJlbmRlckV4ZWN1dG9yLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9jb3JlL0NvcmVSZW5kZXJTdGF0ZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvY29yZS9FbGVtZW50Q29yZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvY29yZS9FbGVtZW50VGV4dHVyaXplci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL3B1YmxpYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqLyAvLyBUaGUgcmVxdWlyZSBzY29wZVxuLyoqKioqKi8gdmFyIF9fd2VicGFja19yZXF1aXJlX18gPSB7fTtcbi8qKioqKiovIFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBcInlxXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBY2Nlc3NpYmlsaXR5KSxcbiAgXCJtUlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWNjb3VudCksXG4gIFwiWkxcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFkdmVydGlzaW5nKSxcbiAgXCJWeVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQXV0aGVudGljYXRpb24pLFxuICBcIkFTXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEZXZpY2UpLFxuICBcIlBHXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEaXNjb3ZlcnkpLFxuICBcInpXXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFdmVudHMpLFxuICBcIk4xXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBLZXlib2FyZCksXG4gIFwiRndcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIExpZmVjeWNsZSksXG4gIFwiV0hcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIExvY2FsaXphdGlvbiksXG4gIFwiWmJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIExvZyksXG4gIFwiQzNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1ldHJpY3MpLFxuICBcImFFXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQYXJhbWV0ZXJzKSxcbiAgXCJ0NFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGxhdGZvcm0pLFxuICBcIk5aXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQcm9maWxlKSxcbiAgXCJfRlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU2Vjb25kU2NyZWVuKSxcbiAgXCJaclwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU2V0dGluZ3MpXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1Byb3AvTW9ja1Byb3BzLmpzXG5cblxuY29uc3QgbW9ja3MgPSB7fVxuXG5mdW5jdGlvbiBtb2NrKG1vZHVsZSwgbWV0aG9kLCBhcmdzLCBkZWYpIHtcbiAgY29uc3QgZnVsbE1ldGhvZCA9IGAke21vZHVsZX0uJHttZXRob2R9YFxuICBpZiAoKGFyZ3MgPT0gbnVsbCkgfHwgKGFyZ3MubGVuZ3RoID09PSAwKSkge1xuICAgIC8vIGdldFxuICAgIGNvbnN0IHJ2ID0gbW9ja3NbZnVsbE1ldGhvZF0gJiYgbW9ja3NbZnVsbE1ldGhvZF0udmFsdWUgPyBtb2Nrc1tmdWxsTWV0aG9kXS52YWx1ZSA6IGRlZlxuICAgIHJldHVybiBydlxuICB9IGVsc2Uge1xuICAgIC8vIHNldFxuICAgIGxldCBtb2NrTWV0aG9kID0gbW9ja3NbZnVsbE1ldGhvZF1cbiAgICBpZiAobW9ja01ldGhvZCA9PSBudWxsKSB7XG4gICAgICBtb2NrTWV0aG9kID0ge1xuICAgICAgICBzdWJzY3JpYmVyczogW11cbiAgICAgIH1cbiAgICB9XG4gICAgbW9ja3NbZnVsbE1ldGhvZF0gPSBtb2NrTWV0aG9kXG4gICAgbW9ja01ldGhvZC52YWx1ZSA9IGFyZ3NbMF0udmFsdWVcbiAgICBUcmFuc3BvcnRfbW9jay5ldmVudChtb2R1bGUsIG1ldGhvZCArICdDaGFuZ2VkJywge1xuICAgICAgdmFsdWU6IGFyZ3NbMF0udmFsdWVcbiAgICB9KVxuICAgIHJldHVybiB7fVxuICB9XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTW9ja1Byb3BzID0gKHtcbiAgbW9jazogbW9ja1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvQWNjZXNzaWJpbGl0eS9kZWZhdWx0cy5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgZGVmYXVsdHMgPSAoe1xuXG4gICAgY2xvc2VkQ2FwdGlvbnM6IHtcbiAgXCJlbmFibGVkXCI6IHRydWUsXG4gIFwic3R5bGVzXCI6IHtcbiAgICBcImZvbnRGYW1pbHlcIjogXCJNb25vc3BhY2Ugc2Fucy1zZXJpZlwiLFxuICAgIFwiZm9udFNpemVcIjogMSxcbiAgICBcImZvbnRDb2xvclwiOiBcIiNmZmZmZmZcIixcbiAgICBcImZvbnRFZGdlXCI6IFwibm9uZVwiLFxuICAgIFwiZm9udEVkZ2VDb2xvclwiOiBcIiM3RjdGN0ZcIixcbiAgICBcImZvbnRPcGFjaXR5XCI6IDEwMCxcbiAgICBcImJhY2tncm91bmRDb2xvclwiOiBcIiMwMDAwMDBcIixcbiAgICBcImJhY2tncm91bmRPcGFjaXR5XCI6IDEwMCxcbiAgICBcInRleHRBbGlnblwiOiBcImNlbnRlclwiLFxuICAgIFwidGV4dEFsaWduVmVydGljYWxcIjogXCJtaWRkbGVcIlxuICB9XG59LFxuXG4gICAgY2xvc2VkQ2FwdGlvbnNTZXR0aW5nczogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2FjY2Vzc2liaWxpdHknLCAnY2xvc2VkQ2FwdGlvbnNTZXR0aW5ncycsIGFyZ3VtZW50cywge1xuICBcImVuYWJsZWRcIjogdHJ1ZSxcbiAgXCJzdHlsZXNcIjoge1xuICAgIFwiZm9udEZhbWlseVwiOiBcIk1vbm9zcGFjZSBzYW5zLXNlcmlmXCIsXG4gICAgXCJmb250U2l6ZVwiOiAxLFxuICAgIFwiZm9udENvbG9yXCI6IFwiI2ZmZmZmZlwiLFxuICAgIFwiZm9udEVkZ2VcIjogXCJub25lXCIsXG4gICAgXCJmb250RWRnZUNvbG9yXCI6IFwiIzdGN0Y3RlwiLFxuICAgIFwiZm9udE9wYWNpdHlcIjogMTAwLFxuICAgIFwiYmFja2dyb3VuZENvbG9yXCI6IFwiIzAwMDAwMFwiLFxuICAgIFwiYmFja2dyb3VuZE9wYWNpdHlcIjogMTAwLFxuICAgIFwidGV4dEFsaWduXCI6IFwiY2VudGVyXCIsXG4gICAgXCJ0ZXh0QWxpZ25WZXJ0aWNhbFwiOiBcIm1pZGRsZVwiXG4gIH1cbn0pIH0sXG5cbiAgICB2b2ljZUd1aWRhbmNlOiB7XG4gIFwiZW5hYmxlZFwiOiB0cnVlLFxuICBcInNwZWVkXCI6IDVcbn0sXG5cbiAgICB2b2ljZUd1aWRhbmNlU2V0dGluZ3M6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdhY2Nlc3NpYmlsaXR5JywgJ3ZvaWNlR3VpZGFuY2VTZXR0aW5ncycsIGFyZ3VtZW50cywge1xuICBcImVuYWJsZWRcIjogdHJ1ZSxcbiAgXCJzcGVlZFwiOiA1XG59KSB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9BY2NvdW50L2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBY2NvdW50X2RlZmF1bHRzID0gKHtcblxuICAgIGlkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnYWNjb3VudCcsICdpZCcsIGFyZ3VtZW50cywgXCIxMjNcIikgfSxcblxuICAgIHVpZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2FjY291bnQnLCAndWlkJywgYXJndW1lbnRzLCBcImVlNjcyM2I4LTdhYjMtNDYyYy04ZDkzLWRiZjYxMjI3OTk4ZVwiKSB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9BZHZlcnRpc2luZy9kZWZhdWx0cy5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQWR2ZXJ0aXNpbmdfZGVmYXVsdHMgPSAoe1xuXG4gICAgY29uZmlnOiB7XG4gIFwiYWRTZXJ2ZXJVcmxcIjogXCJodHRwOi8vZGVtby52LmZ3bXJtLm5ldC9hZC9wLzFcIixcbiAgXCJhZFNlcnZlclVybFRlbXBsYXRlXCI6IFwiaHR0cDovL2RlbW8udi5md21ybS5uZXQvYWQvcC8xP2ZsYWc9K3NsdHArZXh2dCtzbGNiK2VtY3IrYW1jYithZXRpJnByb2Y9MTIzNDU6Y2FmX2FsbGlub25lX3Byb2ZpbGUgJm53PTEyMzQ1Jm1vZGU9bGl2ZSZ2ZHVyPTEyMyZjYWlkPWExMTA1MjMwMTgmYXNudz0zNzI0NjQmY3NpZD1nbW90dF9pb3NfdGFibGV0X3dhdGNoX2xpdmVfRVNQTlUmc3Nudz0zNzI0NjQmdmlwPTE5OC4yMDUuOTIuMSZyZXNwPXZtYXAxJm1ldHI9MTAzMSZwdnJuPTEyMzQ1JnZwcm49MTIzNDUmdmNpZD0xWDBDZTdMM3hSV2xUZU5oYzdicjhRJTNEJTNEXCIsXG4gIFwiYWROZXR3b3JrSWRcIjogXCI1MTkxNzhcIixcbiAgXCJhZFByb2ZpbGVJZFwiOiBcIjEyMzQ1OmNhZl9hbGxpbm9uZV9wcm9maWxlXCIsXG4gIFwiYWRTaXRlU2VjdGlvbklkXCI6IFwiY2FmX2FsbGlub25lX3Byb2ZpbGVfc2VjdGlvblwiLFxuICBcImFkT3B0T3V0XCI6IHRydWUsXG4gIFwicHJpdmFjeURhdGFcIjogXCJldzBLSUNBaWNHUjBJam9nSW1ka2NEcDJNU0lzRFFvZ0lDSjFjMTl3Y21sMllXTjVJam9nSWpFdFRpMGlMQTBLSUNBaWJHMTBJam9nSWpFaUlBMEtmUTBLXCIsXG4gIFwiaWZhVmFsdWVcIjogXCIwMTIzNDU2Ny04OUFCLUNERUYtR0gwMS0yMzQ1Njc4OUFCQ0RcIixcbiAgXCJpZmFcIjogXCJld29nSUNKMllXeDFaU0k2SUNJd01USXpORFUyTnkwNE9VRkNMVU5FUlVZdFIwZ3dNUzB5TXpRMU5qYzRPVUZDUTBRaUxBb2dJQ0pwWm1GZmRIbHdaU0k2SUNKemMzQnBaQ0lzQ2lBZ0lteHRkQ0k2SUNJd0lncDlDZz09XCIsXG4gIFwiYXBwTmFtZVwiOiBcIkZ1dHVyZVRvZGF5XCIsXG4gIFwiYXBwQnVuZGxlSWRcIjogXCJGdXR1cmVUb2RheS5jb21jYXN0XCIsXG4gIFwiZGlzdHJpYnV0b3JBcHBJZFwiOiBcIjEwMDFcIixcbiAgXCJkZXZpY2VBZEF0dHJpYnV0ZXNcIjogXCJld29nSUNKaWIwRjBkSEpwWW5WMFpYTkdiM0pTWlhaVGFHRnlaVWxrSWpvZ0lqRXlNelFpQ24wPVwiLFxuICBcImNvcHBhXCI6IDAsXG4gIFwiYXV0aGVudGljYXRpb25FbnRpdHlcIjogXCI2MGY3MjQ3NTI4MWNmYmEzODUyNDEzYmQ1M2U5NTdmNlwiXG59LFxuXG4gICAgcG9saWN5OiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnYWR2ZXJ0aXNpbmcnLCAncG9saWN5JywgYXJndW1lbnRzLCB7XG4gIFwic2tpcFJlc3RyaWN0aW9uXCI6IFwiYWRzVW53YXRjaGVkXCIsXG4gIFwibGltaXRBZFRyYWNraW5nXCI6IGZhbHNlXG59KSB9LFxuXG4gICAgYWR2ZXJ0aXNpbmdJZDoge1xuICBcImlmYVwiOiBcIjAxMjM0NTY3LTg5QUItQ0RFRi1HSDAxLTIzNDU2Nzg5QUJDRFwiLFxuICBcImlmYV90eXBlXCI6IFwiaWRmYVwiLFxuICBcImxtdFwiOiBcIjBcIlxufSxcblxuICAgIGRldmljZUF0dHJpYnV0ZXM6IHt9LFxuXG4gICAgYXBwQnVuZGxlSWQ6IFwib3BlcmF0b3IuYXBwXCJcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0F1dGhlbnRpY2F0aW9uL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBdXRoZW50aWNhdGlvbl9kZWZhdWx0cyA9ICh7XG5cbiAgICB0b2tlbjoge1xuICBcInZhbHVlXCI6IFwiZXlKaGJHY2lPaUpJVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SnpkV0lpT2lJeE1qTTBOVFkzT0Rrd0lpd2libUZ0WlNJNklrcHZhRzRnUkc5bElpd2lhV0YwSWpveE5URTJNak01TURJeWZRLlNmbEt4d1JKU01lS0tGMlFUNGZ3cE1lSmYzNlBPazZ5SlZfYWRRc3N3NWNcIixcbiAgXCJleHBpcmVzXCI6IFwiMjAyMi0wNC0yM1QxODoyNTo0My41MTFaXCIsXG4gIFwidHlwZVwiOiBcInBsYXRmb3JtXCJcbn1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0RldmljZS9kZWZhdWx0cy5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRGV2aWNlX2RlZmF1bHRzID0gKHtcblxuICAgIGlkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ2lkJywgYXJndW1lbnRzLCBcIjEyM1wiKSB9LFxuXG4gICAgZGlzdHJpYnV0b3I6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkZXZpY2UnLCAnZGlzdHJpYnV0b3InLCBhcmd1bWVudHMsIFwiQ29tcGFueVwiKSB9LFxuXG4gICAgcGxhdGZvcm06IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkZXZpY2UnLCAncGxhdGZvcm0nLCBhcmd1bWVudHMsIFwiV1BFXCIpIH0sXG5cbiAgICB1aWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkZXZpY2UnLCAndWlkJywgYXJndW1lbnRzLCBcImVlNjcyM2I4LTdhYjMtNDYyYy04ZDkzLWRiZjYxMjI3OTk4ZVwiKSB9LFxuXG4gICAgdHlwZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICd0eXBlJywgYXJndW1lbnRzLCBcIlNUQlwiKSB9LFxuXG4gICAgbW9kZWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkZXZpY2UnLCAnbW9kZWwnLCBhcmd1bWVudHMsIFwieGk2XCIpIH0sXG5cbiAgICBza3U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkZXZpY2UnLCAnc2t1JywgYXJndW1lbnRzLCBcIkFYMDYxQUVJXCIpIH0sXG5cbiAgICBtYWtlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ21ha2UnLCBhcmd1bWVudHMsIFwiQXJyaXNcIikgfSxcblxuICAgIHZlcnNpb246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkZXZpY2UnLCAndmVyc2lvbicsIGFyZ3VtZW50cywge1xuICBcInNka1wiOiB7XG4gICAgXCJtYWpvclwiOiAwLFxuICAgIFwibWlub3JcIjogNSxcbiAgICBcInBhdGNoXCI6IDAsXG4gICAgXCJyZWFkYWJsZVwiOiBcIkZpcmVib2x0IEpTIFNESyB2MC41LjBcIlxuICB9LFxuICBcIm9zXCI6IHtcbiAgICBcIm1ham9yXCI6IDAsXG4gICAgXCJtaW5vclwiOiAxLFxuICAgIFwicGF0Y2hcIjogMCxcbiAgICBcInJlYWRhYmxlXCI6IFwiRmlyZWJvbHQgT1MgdjAuMS4wXCJcbiAgfSxcbiAgXCJkZWJ1Z1wiOiBcIlwiXG59KSB9LFxuXG4gICAgaGRjcDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICdoZGNwJywgYXJndW1lbnRzLCB7XG4gIFwiaGRjcDEuNFwiOiB0cnVlLFxuICBcImhkY3AyLjJcIjogdHJ1ZVxufSkgfSxcblxuICAgIGhkcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICdoZHInLCBhcmd1bWVudHMsIHtcbiAgXCJoZHIxMFwiOiB0cnVlLFxuICBcImhkcjEwUGx1c1wiOiB0cnVlLFxuICBcImRvbGJ5VmlzaW9uXCI6IHRydWUsXG4gIFwiaGxnXCI6IHRydWVcbn0pIH0sXG5cbiAgICBhdWRpbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICdhdWRpbycsIGFyZ3VtZW50cywge1xuICBcInN0ZXJlb1wiOiB0cnVlLFxuICBcImRvbGJ5RGlnaXRhbDUuMVwiOiB0cnVlLFxuICBcImRvbGJ5RGlnaXRhbDUuMStcIjogdHJ1ZSxcbiAgXCJkb2xieUF0bW9zXCI6IHRydWVcbn0pIH0sXG5cbiAgICBzY3JlZW5SZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ3NjcmVlblJlc29sdXRpb24nLCBhcmd1bWVudHMsIFtcbiAgMTkyMCxcbiAgMTA4MFxuXSkgfSxcblxuICAgIHZpZGVvUmVzb2x1dGlvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICd2aWRlb1Jlc29sdXRpb24nLCBhcmd1bWVudHMsIFtcbiAgMTkyMCxcbiAgMTA4MFxuXSkgfSxcblxuICAgIG5hbWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkZXZpY2UnLCAnbmFtZScsIGFyZ3VtZW50cywgXCJMaXZpbmcgUm9vbVwiKSB9LFxuXG4gICAgbmV0d29yazogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICduZXR3b3JrJywgYXJndW1lbnRzLCB7XG4gIFwic3RhdGVcIjogXCJjb25uZWN0ZWRcIixcbiAgXCJ0eXBlXCI6IFwid2lmaVwiXG59KSB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9EaXNjb3ZlcnkvZGVmYXVsdHMuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IERpc2NvdmVyeV9kZWZhdWx0cyA9ICh7XG5cbiAgICBwb2xpY3k6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkaXNjb3ZlcnknLCAncG9saWN5JywgYXJndW1lbnRzLCB7XG4gIFwiZW5hYmxlUmVjb21tZW5kYXRpb25zXCI6IHRydWUsXG4gIFwic2hhcmVXYXRjaEhpc3RvcnlcIjogdHJ1ZSxcbiAgXCJyZW1lbWJlcldhdGNoZWRQcm9ncmFtc1wiOiB0cnVlXG59KSB9LFxuXG4gICAgZW50aXR5SW5mbzogdHJ1ZSxcblxuICAgIHB1cmNoYXNlZENvbnRlbnQ6IHRydWUsXG5cbiAgICB3YXRjaGVkOiB0cnVlLFxuXG4gICAgd2F0Y2hOZXh0OiB0cnVlLFxuXG4gICAgZW50aXRsZW1lbnRzOiB0cnVlLFxuXG4gICAgbGF1bmNoOiB0cnVlLFxuXG4gICAgc2lnbkluOiB0cnVlLFxuXG4gICAgc2lnbk91dDogdHJ1ZVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvS2V5Ym9hcmQvZGVmYXVsdHMuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEtleWJvYXJkX2RlZmF1bHRzID0gKHtcblxuICAgIGVtYWlsOiBcInVzZXJAZG9tYWluLmNvbVwiLFxuXG4gICAgcGFzc3dvcmQ6IFwiYWJjMTIzXCIsXG5cbiAgICBzdGFuZGFyZDogXCJMaXZpbmcgUm9vbVwiXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9UcmFuc3BvcnQvZ2xvYmFsLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmxldCBnXG5cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ZyA9IHNlbGY7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdGcgPSB3aW5kb3c7XG59IGVsc2Uge1xuXHRnID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn0gXG5cbmNvbnN0IGdsb2JhbCA9IGdcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUcmFuc3BvcnRfZ2xvYmFsID0gKGdsb2JhbCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvTGlmZWN5Y2xlL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxubGV0IGluYWN0aXZlID0ge1wic3RhdGVcIjpcImluYWN0aXZlXCIsXCJwcmV2aW91c1wiOlwiaW5pdGlhbGl6aW5nXCJ9XG5sZXQgZm9yZWdyb3VuZCA9IHtcInN0YXRlXCI6XCJmb3JlZ3JvdW5kXCIsXCJwcmV2aW91c1wiOlwiaW5hY3RpdmVcIn1cbmxldCBiYWNrZ3JvdW5kID0ge1wic3RhdGVcIjpcImJhY2tncm91bmRcIixcInByZXZpb3VzXCI6XCJmb3JlZ3JvdW5kXCJ9XG5sZXQgc3VzcGVuZGVkID0ge1wic3RhdGVcIjpcInN1c3BlbmRlZFwiLFwicHJldmlvdXNcIjpcImluYWN0aXZlXCJ9XG5sZXQgdW5sb2FkaW5nID0ge1wic3RhdGVcIjpcInVubG9hZGluZ1wiLFwicHJldmlvdXNcIjpcImluYWN0aXZlXCJ9XG5cbmNvbnN0IGVtaXQgPSAodmFsdWUpID0+IHtcbiAgdmFsdWUucHJldmlvdXMgPSBMaWZlY3ljbGUuc3RhdGUoKVxuICBUcmFuc3BvcnRfbW9jay5ldmVudCgnTGlmZWN5Y2xlJywgdmFsdWUuc3RhdGUsIHZhbHVlKVxufVxuXG5jb25zdCBhdXRvbWF0aW9uID0gVHJhbnNwb3J0X2dsb2JhbCAmJiBUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQgPyAhIVRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdC5hdXRvbWF0aW9uIDogZmFsc2VcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMaWZlY3ljbGVfZGVmYXVsdHMgPSAoe1xuICByZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgaW5hY3RpdmUucHJldmlvdXMgPSAnaW5pdGlhbGl6aW5nJ1xuICAgIHNldFRpbWVvdXQoKCkgPT4gZW1pdChpbmFjdGl2ZSksIGF1dG9tYXRpb24gPyAxIDogNTAwKVxuICAgIGZvcmVncm91bmQucHJldmlvdXMgPSAnaW5hY3RpdmUnXG4gICAgc2V0VGltZW91dCgoKSA9PiBlbWl0KGZvcmVncm91bmQpLCBhdXRvbWF0aW9uID8gMiA6IDEwMDApXG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIGxldCByZWFzb24gPSBwYXJhbXMucmVhc29uXG4gICAgaWYgKHJlYXNvbiA9PT0gTGlmZWN5Y2xlLkNsb3NlUmVhc29uLlJFTU9URV9CVVRUT04pIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gZW1pdChpbmFjdGl2ZSksIGF1dG9tYXRpb24gPyAxIDogNTAwKVxuICAgIH1cbiAgICBlbHNlIGlmIChPYmplY3QudmFsdWVzKExpZmVjeWNsZS5DbG9zZVJlYXNvbikuaW5jbHVkZXMocmVhc29uKSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBlbWl0KGluYWN0aXZlKSwgYXV0b21hdGlvbiA/IDEgOiA1MDApXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGVtaXQodW5sb2FkaW5nKSwgYXV0b21hdGlvbiA/IDIgOiAxMDAwKVxuICAgICAgc2V0VGltZW91dCgoKSA9PiBMaWZlY3ljbGUuZmluaXNoZWQoKSwgYXV0b21hdGlvbiA/IDM6IDMwMDApXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgXCJJbnZhbGlkIGNsb3NlIHJlYXNvblwiXG4gICAgfVxuICB9LFxuXG4gIGZpbmlzaGVkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoVHJhbnNwb3J0X2dsb2JhbC5sb2NhdGlvbilcbiAgICAgIFRyYW5zcG9ydF9nbG9iYWwubG9jYXRpb24uaHJlZiA9IFwiYWJvdXQ6YmxhbmtcIlxuICB9LFxufSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9Mb2NhbGl6YXRpb24vZGVmYXVsdHMuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExvY2FsaXphdGlvbl9kZWZhdWx0cyA9ICh7XG5cbiAgICBsb2NhbGl0eTogXCJQaGlsYWRlbHBoaWFcIixcblxuICAgIHBvc3RhbENvZGU6IFwiMTkxMDNcIixcblxuICAgIGNvdW50cnlDb2RlOiBcIlVTXCIsXG5cbiAgICBsYW5ndWFnZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2xvY2FsaXphdGlvbicsICdsYW5ndWFnZScsIGFyZ3VtZW50cywgXCJlblwiKSB9LFxuXG4gICAgbG9jYWxlOiBcImVuLVVTXCIsXG5cbiAgICBsYXRsb246IFtcbiAgMzkuOTU0OSxcbiAgNzUuMTY5OVxuXSxcblxuICAgIGFkZGl0aW9uYWxJbmZvOiB7fVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvTWV0cmljcy9kZWZhdWx0cy5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTWV0cmljc19kZWZhdWx0cyA9ICh7XG5cbiAgICByZWFkeTogdHJ1ZSxcblxuICAgIHNpZ25JbjogdHJ1ZSxcblxuICAgIHNpZ25PdXQ6IHRydWUsXG5cbiAgICBzdGFydENvbnRlbnQ6IHRydWUsXG5cbiAgICBzdG9wQ29udGVudDogdHJ1ZSxcblxuICAgIHBhZ2U6IHRydWUsXG5cbiAgICBhY3Rpb246IHRydWUsXG5cbiAgICBlcnJvcjogdHJ1ZSxcblxuICAgIG1lZGlhTG9hZFN0YXJ0OiB0cnVlLFxuXG4gICAgbWVkaWFQbGF5OiB0cnVlLFxuXG4gICAgbWVkaWFQbGF5aW5nOiB0cnVlLFxuXG4gICAgbWVkaWFQYXVzZTogdHJ1ZSxcblxuICAgIG1lZGlhV2FpdGluZzogdHJ1ZSxcblxuICAgIG1lZGlhUHJvZ3Jlc3M6IHRydWUsXG5cbiAgICBtZWRpYVNlZWtpbmc6IHRydWUsXG5cbiAgICBtZWRpYVNlZWtlZDogdHJ1ZSxcblxuICAgIG1lZGlhUmF0ZUNoYW5nZTogdHJ1ZSxcblxuICAgIG1lZGlhUmVuZGl0aW9uQ2hhbmdlOiB0cnVlLFxuXG4gICAgbWVkaWFFbmRlZDogdHJ1ZVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvUGFyYW1ldGVycy9kZWZhdWx0cy5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUGFyYW1ldGVyc19kZWZhdWx0cyA9ICh7XG5cbiAgICBpbml0aWFsaXphdGlvbjoge1xuICBcImxtdFwiOiAwLFxuICBcInVzX3ByaXZhY3lcIjogXCIxLVktXCIsXG4gIFwiZGlzY292ZXJ5XCI6IHtcbiAgICBcIm5hdmlnYXRlVG9cIjoge1xuICAgICAgXCJhY3Rpb25cIjogXCJlbnRpdHlcIixcbiAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgIFwiZW50aXR5SWRcIjogXCJhYmNcIixcbiAgICAgICAgXCJlbnRpdHlUeXBlXCI6IFwicHJvZ3JhbVwiLFxuICAgICAgICBcInByb2dyYW1UeXBlXCI6IFwibW92aWVcIlxuICAgICAgfSxcbiAgICAgIFwiY29udGV4dFwiOiB7XG4gICAgICAgIFwic291cmNlXCI6IFwidm9pY2VcIlxuICAgICAgfVxuICAgIH1cbiAgfVxufVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvUHJvZmlsZS9kZWZhdWx0cy5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUHJvZmlsZV9kZWZhdWx0cyA9ICh7XG5cbiAgICBhcHByb3ZlQ29udGVudFJhdGluZzogZmFsc2UsXG5cbiAgICBhcHByb3ZlUHVyY2hhc2U6IGZhbHNlLFxuXG4gICAgZmxhZ3M6IHtcbiAgXCJ1c2VyRXhwZXJpZW5jZVwiOiBcIjEwMDBcIlxufVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvU2Vjb25kU2NyZWVuL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTZWNvbmRTY3JlZW5fZGVmYXVsdHMgPSAoe1xuXG4gICAgcHJvdG9jb2xzOiB7XG4gIFwiZGlhbDEuN1wiOiB0cnVlXG59LFxuXG4gICAgZGV2aWNlOiBcImRldmljZS1pZFwiLFxuXG4gICAgZnJpZW5kbHlOYW1lOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnc2Vjb25kc2NyZWVuJywgJ2ZyaWVuZGx5TmFtZScsIGFyZ3VtZW50cywgXCJMaXZpbmcgUm9vbVwiKSB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9QbGF0Zm9ybS9kZWZhdWx0cy5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUGxhdGZvcm1fZGVmYXVsdHMgPSAoe1xuICBsb2NhbGl6YXRpb246IExvY2FsaXphdGlvbl9kZWZhdWx0cyxcbiAgZGV2aWNlOiBEZXZpY2VfZGVmYXVsdHMsXG4gIGFjY2Vzc2liaWxpdHk6IGRlZmF1bHRzLFxufSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9UcmFuc3BvcnQvbW9jay5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5sZXQgbGlzdGVuZXJcbmNvbnN0IHNldE1vY2tMaXN0ZW5lciA9IGZ1bmMgPT4geyBsaXN0ZW5lciA9IGZ1bmMgfVxuXG5sZXQgbW9ja19tb2NrID0ge1xuICBhY2Nlc3NpYmlsaXR5OiBkZWZhdWx0cyxcbiAgYWNjb3VudDogQWNjb3VudF9kZWZhdWx0cyxcbiAgYWR2ZXJ0aXNpbmc6IEFkdmVydGlzaW5nX2RlZmF1bHRzLFxuICBhdXRoZW50aWNhdGlvbjogQXV0aGVudGljYXRpb25fZGVmYXVsdHMsXG4gIGRldmljZTogRGV2aWNlX2RlZmF1bHRzLFxuICBkaXNjb3Zlcnk6IERpc2NvdmVyeV9kZWZhdWx0cyxcbiAga2V5Ym9hcmQ6IEtleWJvYXJkX2RlZmF1bHRzLFxuICBsaWZlY3ljbGU6IExpZmVjeWNsZV9kZWZhdWx0cyxcbiAgbG9jYWxpemF0aW9uOiBMb2NhbGl6YXRpb25fZGVmYXVsdHMsXG4gIG1ldHJpY3M6IE1ldHJpY3NfZGVmYXVsdHMsXG4gIHBhcmFtZXRlcnM6IFBhcmFtZXRlcnNfZGVmYXVsdHMsXG4gIHByb2ZpbGU6IFByb2ZpbGVfZGVmYXVsdHMsXG4gIHNlY29uZHNjcmVlbjogU2Vjb25kU2NyZWVuX2RlZmF1bHRzLFxuICBwbGF0Zm9ybTogUGxhdGZvcm1fZGVmYXVsdHMsXG59XG5cbmxldCBjYWxsYmFja1xubGV0IHRlc3RIYXJuZXNzXG5cbmlmIChUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQgJiYgVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LnRlc3RIYXJuZXNzKSB7XG4gIHRlc3RIYXJuZXNzID0gVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LnRlc3RIYXJuZXNzXG59XG5cbmZ1bmN0aW9uIHNlbmQobWVzc2FnZSkge1xuICBsZXQganNvbiA9IEpTT04ucGFyc2UobWVzc2FnZSlcbiAgbGV0IFttb2R1bGUsIG1ldGhvZF0gPSBqc29uLm1ldGhvZC5zcGxpdCgnLicpXG5cbiAgaWYgKHRlc3RIYXJuZXNzICYmIHRlc3RIYXJuZXNzLm9uU2VuZCkge1xuICAgIHRlc3RIYXJuZXNzLm9uU2VuZChtb2R1bGUsIG1ldGhvZCwganNvbi5wYXJhbXMsIGpzb24uaWQpXG4gIH1cblxuICAvLyBzdG9yZSB0aGUgSUQgb2YgdGhlIGZpcnN0IGxpc3RlbiBmb3IgZWFjaCBldmVudFxuICAvLyBUT0RPOiB3aGF0IGFib3V0IHdpbGQgY2FyZHM/XG4gIGxldCByZXN1bHRcbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBnZXRSZXN1bHQoanNvbi5tZXRob2QsIGpzb24ucGFyYW1zKVxuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkoeyBcbiAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgZXJyb3I6IHtcbiAgICAgICAgY29kZTogLTMyNjAyLFxuICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgcGFyYW1zICh0aGlzIGlzIGEgbW9jayBlcnJvciBmcm9tIHRoZSBtb2NrIHRyYW5zcG9ydCBsYXllcilcIlxuICAgICAgfSxcbiAgICAgIGlkOiBqc29uLmlkXG4gICAgfSkpKVxuICB9XG5cbiAgc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeSh7IFxuICAgIGpzb25ycGM6ICcyLjAnLFxuICAgIHJlc3VsdDogcmVzdWx0LFxuICAgIGlkOiBqc29uLmlkXG4gIH0pKSlcbn1cblxuZnVuY3Rpb24gcmVjZWl2ZShfY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBfY2FsbGJhY2tcblxuICBpZiAodGVzdEhhcm5lc3MgJiYgKHR5cGVvZiB0ZXN0SGFybmVzcy5pbml0aWFsaXplID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHRlc3RIYXJuZXNzLmluaXRpYWxpemUoe1xuICAgICAgZW1pdDogbW9ja19ldmVudCxcbiAgICAgIGxpc3RlbjogZnVuY3Rpb24oLi4uYXJncykgeyBsaXN0ZW5lciguLi5hcmdzKSB9LFxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ja19ldmVudChtb2R1bGUsIGV2ZW50LCB2YWx1ZSkge1xuICBjb25zdCBsaXN0ZW5lciA9IE9iamVjdC5lbnRyaWVzKFRyYW5zcG9ydC5nZXRFdmVudE1hcCgpKS5maW5kKChbaywgdl0pID0+IHYudG9Mb3dlckNhc2UoKSA9PT0gbW9kdWxlLnRvTG93ZXJDYXNlKCkgKyAnLicgKyBldmVudC50b0xvd2VyQ2FzZSgpKVxuICBpZiAobGlzdGVuZXIpIHtcbiAgICBsZXQgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgaWQ6IGxpc3RlbmVyWzBdLFxuICAgICAgcmVzdWx0OiB2YWx1ZVxuICAgIH0pXG4gICAgY2FsbGJhY2sobWVzc2FnZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBkb3RHcmFiKG9iaiA9IHt9LCBrZXkpIHtcbiAgY29uc3Qga2V5cyA9IGtleS5zcGxpdCgnLicpXG4gIGxldCByZWYgPSBvYmpcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVmID0gcmVmW2tleXNbaV1dIHx8IHt9XG4gIH1cbiAgcmV0dXJuIHJlZlxufVxuXG5mdW5jdGlvbiBnZXRSZXN1bHQobWV0aG9kLCBwYXJhbXMpIHtcbiAgbGV0IGFwaSA9IGRvdEdyYWIobW9ja19tb2NrLCBtZXRob2QpXG5cbiAgaWYgKG1ldGhvZC5tYXRjaCgvXlthLXpBLVpdK1xcLm9uW0EtWmEtel0rJC8pKSB7XG4gICAgYXBpID0ge1xuICAgICAgZXZlbnQ6IG1ldGhvZCxcbiAgICAgIGxpc3RlbmluZzogdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgYXBpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHBhcmFtcyA9PSBudWxsID8gYXBpKCkgOiBhcGkocGFyYW1zKVxuICB9IGVsc2UgcmV0dXJuIGFwaVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRyYW5zcG9ydF9tb2NrID0gKHtcbiAgc2VuZDogc2VuZCxcbiAgcmVjZWl2ZTogcmVjZWl2ZSxcbiAgZXZlbnQ6IG1vY2tfZXZlbnRcbn0pO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9UcmFuc3BvcnQvcXVldWUuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuY2xhc3MgUXVldWUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsXG4gICAgdGhpcy5fcXVldWUgPSBbXVxuICB9XG5cbiAgc2VuZCAoanNvbikge1xuICAgIHRoaXMuX3F1ZXVlLnB1c2goanNvbilcbiAgfVxuXG4gIHJlY2VpdmUgKF9jYWxsYmFjaykge1xuICAgIHRoaXMuX2NhbGxiYWNrID0gX2NhbGxiYWNrXG4gIH1cblxuICBmbHVzaCAodHJhbnNwb3J0KSB7XG4gICAgdHJhbnNwb3J0LnJlY2VpdmUodGhpcy5fY2FsbGJhY2spXG4gICAgdGhpcy5fcXVldWUuZm9yRWFjaChpdGVtID0+IHRyYW5zcG9ydC5zZW5kKGl0ZW0pKVxuICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9TZXR0aW5ncy9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5jb25zdCBzZXR0aW5ncyA9IHt9XG5jb25zdCBzdWJzY3JpYmVycyA9IHt9XG5cbmNvbnN0IGluaXRTZXR0aW5ncyA9IChhcHBTZXR0aW5ncywgcGxhdGZvcm1TZXR0aW5ncykgPT4ge1xuICBzZXR0aW5nc1snYXBwJ10gPSBhcHBTZXR0aW5nc1xuICBzZXR0aW5nc1sncGxhdGZvcm0nXSA9IHtcbiAgICBsb2dMZXZlbDogJ1dBUk4nLFxuICAgIC4uLnBsYXRmb3JtU2V0dGluZ3NcbiAgfVxuICBzZXR0aW5nc1sndXNlciddID0ge31cbn1cblxuY29uc3QgcHVibGlzaCA9IChrZXksIHZhbHVlKSA9PiB7XG4gIHN1YnNjcmliZXJzW2tleV0gJiYgc3Vic2NyaWJlcnNba2V5XS5mb3JFYWNoKHN1YnNjcmliZXIgPT4gc3Vic2NyaWJlcih2YWx1ZSkpXG59XG5cbmNvbnN0IFNldHRpbmdzX2RvdEdyYWIgPSAob2JqID0ge30sIGtleSkgPT4ge1xuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgb2JqID0gb2JqW2tleXNbaV1dID0gb2JqW2tleXNbaV1dICE9PSB1bmRlZmluZWQgPyBvYmpba2V5c1tpXV0gOiB7fVxuICB9XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyA/IChPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA/IG9iaiA6IHVuZGVmaW5lZCkgOiBvYmpcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTZXR0aW5ncyA9ICh7XG4gIGdldCh0eXBlLCBrZXksIGZhbGxiYWNrID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgdmFsID0gU2V0dGluZ3NfZG90R3JhYihzZXR0aW5nc1t0eXBlXSwga2V5KVxuICAgIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/IHZhbCA6IGZhbGxiYWNrXG4gIH0sXG4gIGhhcyh0eXBlLCBrZXkpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldCh0eXBlLCBrZXkpXG4gIH0sXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgc2V0dGluZ3NbJ3VzZXInXVtrZXldID0gdmFsdWVcbiAgICBwdWJsaXNoKGtleSwgdmFsdWUpXG4gIH0sXG4gIHN1YnNjcmliZShrZXksIGNhbGxiYWNrKSB7XG4gICAgc3Vic2NyaWJlcnNba2V5XSA9IHN1YnNjcmliZXJzW2tleV0gfHwgW11cbiAgICBzdWJzY3JpYmVyc1trZXldLnB1c2goY2FsbGJhY2spXG4gIH0sXG4gIHVuc3Vic2NyaWJlKGtleSwgY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gc3Vic2NyaWJlcnNba2V5XSAmJiBzdWJzY3JpYmVyc1trZXldLmZpbmRJbmRleChjYiA9PiBjYiA9PT0gY2FsbGJhY2spXG4gICAgICBpbmRleCA+IC0xICYmIHN1YnNjcmliZXJzW2tleV0uc3BsaWNlKGluZGV4LCAxKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5IGluIHN1YnNjcmliZXJzKSB7XG4gICAgICAgIHN1YnNjcmliZXJzW2tleV0gPSBbXVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2xlYXJTdWJzY3JpYmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdWJzY3JpYmVycykpIHtcbiAgICAgIGRlbGV0ZSBzdWJzY3JpYmVyc1trZXldXG4gICAgfVxuICB9LFxuICBzZXRMb2dMZXZlbCAobG9nTGV2ZWwpIHtcbiAgICBzZXR0aW5ncy5wbGF0Zm9ybS5sb2dMZXZlbCA9IGxvZ0xldmVsXG4gIH0sXG4gIGdldExvZ0xldmVsICgpIHtcbiAgICByZXR1cm4gc2V0dGluZ3MucGxhdGZvcm0ubG9nTGV2ZWxcbiAgfVxufSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9UcmFuc3BvcnQvTGVnYWN5VHJhbnNwb3J0LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmNsYXNzIExlZ2FjeVRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yIChicmlkZ2UpIHtcbiAgICB0aGlzLmJyaWRnZSA9IGJyaWRnZVxuICB9XG5cbiAgc2VuZCAobXNnKSB7XG4gICAgdGhpcy5icmlkZ2UuSlNNZXNzYWdlQ2hhbmdlZChtc2csICgpID0+IHt9KVxuICB9XG5cbiAgcmVjZWl2ZSAoY2FsbGJhY2spIHtcbiAgICB3aW5kb3cuJGJhZGdlciA9IHdpbmRvdy4kYmFkZ2VyIHx8IHt9XG4gICAgLyoqIEhvbGQgb24gdG8gcmVhbCAkYmFkZ2VyIGNhbGxiYWNrIGFuZCBldmVudCBtZXRob2RzIHNvIHRoZXkgY2FuIGJlIGNhbGxlZCBmb3Igbm9uLWpzb25ycGMgbWVzc2FnZXMgKi9cbiAgICBjb25zdCBiYWRnZXJDYWxsYmFjayA9IHdpbmRvdy4kYmFkZ2VyLmNhbGxiYWNrID8gd2luZG93LiRiYWRnZXIuY2FsbGJhY2suYmluZCh3aW5kb3cuJGJhZGdlcikgOiBudWxsXG4gICAgY29uc3QgYmFkZ2VyRXZlbnQgPSB3aW5kb3cuJGJhZGdlci5ldmVudCA/IHdpbmRvdy4kYmFkZ2VyLmV2ZW50LmJpbmQod2luZG93LiRiYWRnZXIpIDogbnVsbFxuICAgIHdpbmRvdy4kYmFkZ2VyLmNhbGxiYWNrID0gKHBpZCwgc3VjY2VzcywganNvbikgPT4ge1xuICAgICAgaWYgKGpzb24uanNvbnJwYykge1xuICAgICAgICBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShqc29uKSlcbiAgICAgIH0gZWxzZSBpZiAoYmFkZ2VyQ2FsbGJhY2spIHtcbiAgICAgICAgYmFkZ2VyQ2FsbGJhY2socGlkLCBzdWNjZXNzLCBqc29uKVxuICAgICAgfVxuICAgIH1cbiAgICB3aW5kb3cuJGJhZGdlci5ldmVudCA9IChoYW5kbGVySWQsIGpzb24pID0+IHtcbiAgICAgIGlmIChqc29uLmpzb25ycGMpIHtcbiAgICAgICAgY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkoanNvbikpXG4gICAgICB9IGVsc2UgaWYgKGJhZGdlckV2ZW50KSB7XG4gICAgICAgIGJhZGdlckV2ZW50KGhhbmRsZXJJZCwganNvbilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgaXNMZWdhY3kgKHRyYW5zcG9ydCkge1xuICAgIHJldHVybiBMZWdhY3lUcmFuc3BvcnQuaXNYUkVQcm94eSh0cmFuc3BvcnQpIHx8ICgodHJhbnNwb3J0LnNlbmQgPT09IHVuZGVmaW5lZCkgJiYgKHRyYW5zcG9ydC5KU01lc3NhZ2VDaGFuZ2VkKSlcbiAgfVxuXG4gIHN0YXRpYyBpc1hSRVByb3h5ICh0cmFuc3BvcnQpIHtcbiAgICAvKiogU2V0IHRvcCBib3hlcyBydW5uaW5nIFhSRSBoYXMgYSBcIlByb3h5XCIgdHJhbnNwb3J0XG4gICAgICogbmF0aXZlIG9iamVjdCB0aGF0IGludGVyY2VwdHMgQUxMIG1ldGhvZCBjYWxscywgc28gd2VcbiAgICAgKiBjYW5ub3QgdGVzdCBmb3IgdHJhbnNwb3J0LnNlbmQgZXhpc3RlbmNlIGJlY2F1c2UgaXQgd2lsbCByZXR1cm4gdHJ1ZVxuICAgICAqIGV2ZW4gdGhvdWdoIGl0IGFjdHVhbGx5IGlzIG5vdCBzdXBwb3J0ZWQuIENoZWNrIGlmIHNvbWUgb2JzY3VyZSBtZXRob2RcbiAgICAgKiBuYW1lIGxpa2UgXCJwcm94eU9iamVjdFRlc3RcIiBpcyBkZWZpbmVkLiBJZiBpdCBpcyB0aGVuIHdlIGtub3cgd2UgYXJlIHVzaW5nIGFcbiAgICAgKiBQcm94eSBvYmplY3QgYW5kIHRodXMgaXMgbGVnYWN5IHRyYW5zcG9ydC5cbiAgICAgKi9cbiAgICByZXR1cm4gdHJhbnNwb3J0LnByb3h5T2JqZWN0VGVzdCAhPT0gdW5kZWZpbmVkXG4gIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1RyYW5zcG9ydC9XZWJzb2NrZXRUcmFuc3BvcnQuanNcbmNvbnN0IE1BWF9RVUVVRURfTUVTU0FHRVMgPSAxMDBcblxuY2xhc3MgV2Vic29ja2V0VHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3IgKGVuZHBvaW50KSB7XG4gICAgdGhpcy5fZW5kcG9pbnQgPSBlbmRwb2ludFxuICAgIHRoaXMuX3dzID0gbnVsbFxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhpcy5fcXVldWUgPSBbXVxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdXG4gIH1cblxuICBzZW5kIChtc2cpIHtcbiAgICB0aGlzLl9jb25uZWN0KClcblxuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuX3dzLnNlbmQobXNnKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoIDwgTUFYX1FVRVVFRF9NRVNTQUdFUykge1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKG1zZylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZWNlaXZlIChjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHJldHVyblxuICAgIHRoaXMuX2Nvbm5lY3QoKVxuICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKVxuICB9XG5cbiAgX25vdGlmeUNhbGxiYWNrcyAobWVzc2FnZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX2NhbGxiYWNrc1tpXShtZXNzYWdlKSwgMSlcbiAgICB9XG4gIH1cblxuICBfY29ubmVjdCAoKSB7XG4gICAgaWYgKHRoaXMuX3dzKSByZXR1cm5cbiAgICB0aGlzLl93cyA9IG5ldyBXZWJTb2NrZXQodGhpcy5fZW5kcG9pbnQpXG4gICAgdGhpcy5fd3MuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG1lc3NhZ2UgPT4ge1xuICAgICAgdGhpcy5fbm90aWZ5Q2FsbGJhY2tzKG1lc3NhZ2UuZGF0YSlcbiAgICB9KVxuICAgIHRoaXMuX3dzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbWVzc2FnZSA9PiB7XG4gICAgfSlcbiAgICB0aGlzLl93cy5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIG1lc3NhZ2UgPT4ge1xuICAgICAgdGhpcy5fd3MgPSBudWxsXG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZVxuICAgIH0pXG4gICAgdGhpcy5fd3MuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIG1lc3NhZ2UgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl93cy5zZW5kKHRoaXMuX3F1ZXVlW2ldKVxuICAgICAgfVxuICAgICAgdGhpcy5fcXVldWUgPSBbXVxuICAgIH0pXG4gIH1cbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9UcmFuc3BvcnQvaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5cblxuXG5jb25zdCBMRUdBQ1lfVFJBTlNQT1JUX1NFUlZJQ0VfTkFNRSA9ICdjb20uY29tY2FzdC5CcmlkZ2VPYmplY3RfMSdcbmxldCBtb2R1bGVJbnN0YW5jZSA9IG51bGxcblxuY29uc3QgaXNFdmVudFN1Y2Nlc3MgPSB4ID0+IHggJiYgKHR5cGVvZiB4LmV2ZW50ID09PSAnc3RyaW5nJykgJiYgKHR5cGVvZiB4Lmxpc3RlbmluZyA9PT0gJ2Jvb2xlYW4nKVxuXG5jbGFzcyBUcmFuc3BvcnQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fcHJvbWlzZXMgPSBbXVxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGxcbiAgICB0aGlzLl9pZCA9IDFcbiAgICB0aGlzLl9ldmVudEVtaXR0ZXJzID0gW11cbiAgICB0aGlzLl9ldmVudE1hcCA9IHt9XG4gICAgdGhpcy5fcXVldWUgPSBuZXcgUXVldWUoKVxuICAgIHRoaXMuX2RlcHJlY2F0ZWQgPSB7fVxuICAgIHRoaXMuaXNNb2NrID0gZmFsc2VcbiAgfVxuXG4gIHN0YXRpYyBhZGRFdmVudEVtaXR0ZXIgKGVtaXR0ZXIpIHtcbiAgICBUcmFuc3BvcnQuZ2V0KCkuX2V2ZW50RW1pdHRlcnMucHVzaChlbWl0dGVyKVxuICB9XG5cbiAgc3RhdGljIHJlZ2lzdGVyRGVwcmVjYXRlZE1ldGhvZCAobW9kdWxlLCBtZXRob2QsIGFsdGVybmF0aXZlKSB7XG4gICAgVHJhbnNwb3J0LmdldCgpLl9kZXByZWNhdGVkW21vZHVsZS50b0xvd2VyQ2FzZSgpICsgJy4nICsgbWV0aG9kLnRvTG93ZXJDYXNlKCldID0ge1xuICAgICAgYWx0ZXJuYXRpdmU6IGFsdGVybmF0aXZlIHx8ICcnXG4gICAgfVxuICB9XG5cbiAgX2VuZHBvaW50ICgpIHtcbiAgICBpZiAoVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0ICYmIFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdC5lbmRwb2ludCkge1xuICAgICAgcmV0dXJuIFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdC5lbmRwb2ludFxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3RydWN0VHJhbnNwb3J0TGF5ZXIgKCkge1xuICAgIGxldCB0cmFuc3BvcnRcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2VuZHBvaW50KClcbiAgICBpZiAoZW5kcG9pbnQgJiYgKGVuZHBvaW50LnN0YXJ0c1dpdGgoJ3dzOi8vJykgfHwgZW5kcG9pbnQuc3RhcnRzV2l0aCgnd3NzOi8vJykpKSB7XG4gICAgICB0cmFuc3BvcnQgPSBuZXcgV2Vic29ja2V0VHJhbnNwb3J0KGVuZHBvaW50KVxuICAgICAgdHJhbnNwb3J0LnJlY2VpdmUodGhpcy5yZWNlaXZlSGFuZGxlci5iaW5kKHRoaXMpKVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0eXBlb2YgVHJhbnNwb3J0X2dsb2JhbC5TZXJ2aWNlTWFuYWdlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIFRyYW5zcG9ydF9nbG9iYWwuU2VydmljZU1hbmFnZXIgJiZcbiAgICAgIFRyYW5zcG9ydF9nbG9iYWwuU2VydmljZU1hbmFnZXIudmVyc2lvblxuICAgICkge1xuICAgICAgLy8gV2lyZSB1cCB0aGUgcXVldWVcbiAgICAgIHRyYW5zcG9ydCA9IHRoaXMuX3F1ZXVlXG4gICAgICAvLyBnZXQgdGhlIGRlZmF1bHQgYnJpZGdlIHNlcnZpY2UsIGFuZCBmbHVzaCB0aGUgcXVldWVcbiAgICAgIFRyYW5zcG9ydF9nbG9iYWwuU2VydmljZU1hbmFnZXIuZ2V0U2VydmljZUZvckphdmFTY3JpcHQoTEVHQUNZX1RSQU5TUE9SVF9TRVJWSUNFX05BTUUsIHNlcnZpY2UgPT4ge1xuICAgICAgICBpZiAoTGVnYWN5VHJhbnNwb3J0LmlzTGVnYWN5KHNlcnZpY2UpKSB7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbmV3IExlZ2FjeVRyYW5zcG9ydChzZXJ2aWNlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYW5zcG9ydCA9IHNlcnZpY2VcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFRyYW5zcG9ydExheWVyKHRyYW5zcG9ydClcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNNb2NrID0gdHJ1ZVxuICAgICAgdHJhbnNwb3J0ID0gVHJhbnNwb3J0X21vY2tcbiAgICAgIHRyYW5zcG9ydC5yZWNlaXZlKHRoaXMucmVjZWl2ZUhhbmRsZXIuYmluZCh0aGlzKSlcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zcG9ydFxuICB9XG5cbiAgc2V0VHJhbnNwb3J0TGF5ZXIgKHRsKSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdGxcbiAgICB0aGlzLl9xdWV1ZS5mbHVzaCh0bClcbiAgfVxuXG4gIHN0YXRpYyBzZW5kIChtb2R1bGUsIG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgLyoqIFRyYW5zcG9ydCBzaW5nbGV0b24gYWNyb3NzIGFsbCBTREtzIHRvIGtlZXAgc2luZ2xlIGlkIG1hcCAqL1xuICAgIHJldHVybiBUcmFuc3BvcnQuZ2V0KCkuX3NlbmQobW9kdWxlLCBtZXRob2QsIHBhcmFtcylcbiAgfVxuXG4gIF9zZW5kIChtb2R1bGUsIG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3Byb21pc2VzW3RoaXMuX2lkXSA9IHt9XG4gICAgICB0aGlzLl9wcm9taXNlc1t0aGlzLl9pZF0ucHJvbWlzZSA9IHRoaXNcbiAgICAgIHRoaXMuX3Byb21pc2VzW3RoaXMuX2lkXS5yZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgdGhpcy5fcHJvbWlzZXNbdGhpcy5faWRdLnJlamVjdCA9IHJlamVjdFxuXG4gICAgICBjb25zdCBkZXByZWNhdGVkID0gdGhpcy5fZGVwcmVjYXRlZFttb2R1bGUudG9Mb3dlckNhc2UoKSArICcuJyArIG1ldGhvZC50b0xvd2VyQ2FzZSgpXVxuICAgICAgaWYgKGRlcHJlY2F0ZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBXQVJOSU5HOiAke21vZHVsZX0uJHttZXRob2R9KCkgaXMgZGVwcmVjYXRlZC4gYCArIGRlcHJlY2F0ZWQuYWx0ZXJuYXRpdmUpXG4gICAgICB9XG5cbiAgICAgIC8vIHN0b3JlIHRoZSBJRCBvZiB0aGUgZmlyc3QgbGlzdGVuIGZvciBlYWNoIGV2ZW50XG4gICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHdpbGQgY2FyZHM/XG4gICAgICBpZiAobWV0aG9kLm1hdGNoKC9eb25bQS1aXS8pKSB7XG4gICAgICAgIGlmIChwYXJhbXMubGlzdGVuKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRNYXBbdGhpcy5faWRdID0gbW9kdWxlLnRvTG93ZXJDYXNlKCkgKyAnLicgKyBtZXRob2RbMl0udG9Mb3dlckNhc2UoKSArIG1ldGhvZC5zdWJzdHIoMylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9ldmVudE1hcCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50TWFwW2tleV0gPT09IG1vZHVsZS50b0xvd2VyQ2FzZSgpICsgJy4nICsgbWV0aG9kWzJdLnRvTG93ZXJDYXNlKCkgKyBtZXRob2Quc3Vic3RyKDMpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcFtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBqc29uID0geyBqc29ucnBjOiAnMi4wJywgbWV0aG9kOiBtb2R1bGUgKyAnLicgKyBtZXRob2QsIHBhcmFtczogcGFyYW1zLCBpZDogdGhpcy5faWQgfVxuICAgIHRoaXMuX2lkKytcblxuICAgIGNvbnN0IG1zZyA9IEpTT04uc3RyaW5naWZ5KGpzb24pXG4gICAgaWYgKFNldHRpbmdzLmdldExvZ0xldmVsKCkgPT09ICdERUJVRycpIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoJ1NlbmRpbmcgbWVzc2FnZSB0byB0cmFuc3BvcnQ6ICcgKyBtc2cpXG4gICAgfVxuICAgIHRoaXMuX3RyYW5zcG9ydC5zZW5kKG1zZylcblxuICAgIHJldHVybiBwXG4gIH1cblxuICBzdGF0aWMgZ2V0RXZlbnRNYXAgKCkge1xuICAgIHJldHVybiBUcmFuc3BvcnQuZ2V0KCkuX2V2ZW50TWFwXG4gIH1cblxuICAvKipcbiAgICogSWYgd2UgaGF2ZSBhIGdsb2JhbCB0cmFuc3BvcnQsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHVzZSB0aGUgbW9kdWxlLXNjb3BlZCB0cmFuc3BvcnQgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtUcmFuc3BvcnR9XG4gICAqL1xuICBzdGF0aWMgZ2V0ICgpIHtcbiAgICByZXR1cm4gVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LnRyYW5zcG9ydCA/IFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdC50cmFuc3BvcnQgOiBtb2R1bGVJbnN0YW5jZVxuICB9XG5cbiAgcmVjZWl2ZUhhbmRsZXIgKG1lc3NhZ2UpIHtcbiAgICBpZiAoU2V0dGluZ3MuZ2V0TG9nTGV2ZWwoKSA9PT0gJ0RFQlVHJykge1xuICAgICAgY29uc29sZS5kZWJ1ZygnUmVjZWl2ZWQgbWVzc2FnZSBmcm9tIHRyYW5zcG9ydDogJyArIG1lc3NhZ2UpXG4gICAgfVxuICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKG1lc3NhZ2UpXG4gICAgY29uc3QgcCA9IHRoaXMuX3Byb21pc2VzW2pzb24uaWRdXG5cbiAgICBpZiAocCkge1xuICAgICAgaWYgKGpzb24uZXJyb3IpIHAucmVqZWN0KGpzb24uZXJyb3IpXG4gICAgICBlbHNlIHtcbiAgICAgICAgcC5yZXNvbHZlKGpzb24ucmVzdWx0KVxuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuX3Byb21pc2VzW2pzb24uaWRdXG4gICAgfVxuXG4gICAgLy8gZXZlbnQgcmVzcG9uc2VzIG5lZWQgdG8gYmUgZW1pdHRlZCwgZXZlbiBhZnRlciB0aGUgbGlzdGVuIGNhbGwgaXMgcmVzb2x2ZWRcbiAgICBpZiAodGhpcy5fZXZlbnRNYXBbanNvbi5pZF0gJiYgIWlzRXZlbnRTdWNjZXNzKGpzb24ucmVzdWx0KSkge1xuICAgICAgY29uc3QgbW9kdWxlZXZlbnQgPSB0aGlzLl9ldmVudE1hcFtqc29uLmlkXVxuICAgICAgaWYgKG1vZHVsZWV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlcnMuZm9yRWFjaChlbWl0ID0+IHtcbiAgICAgICAgICBlbWl0KG1vZHVsZWV2ZW50LnNwbGl0KCcuJylbMF0sIG1vZHVsZWV2ZW50LnNwbGl0KCcuJylbMV0sIGpzb24ucmVzdWx0KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluaXQgKCkge1xuICAgIGluaXRTZXR0aW5ncyh7fSwgeyBsb2c6IHRydWUgfSlcbiAgICB0aGlzLl9xdWV1ZS5yZWNlaXZlKHRoaXMucmVjZWl2ZUhhbmRsZXIuYmluZCh0aGlzKSlcbiAgICBpZiAoVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0KSB7XG4gICAgICBpZiAoVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0Lm1vY2tUcmFuc3BvcnRMYXllciA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmlzTW9jayA9IHRydWVcbiAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnRMYXllcihUcmFuc3BvcnRfbW9jaylcbiAgICAgIH0gZWxzZSBpZiAoVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LmdldFRyYW5zcG9ydExheWVyKSB7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0TGF5ZXIoVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LmdldFRyYW5zcG9ydExheWVyKCkpXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl90cmFuc3BvcnQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gdGhpcy5jb25zdHJ1Y3RUcmFuc3BvcnRMYXllcigpXG4gICAgfVxuICB9XG59XG5cbi8qKiBTZXQgdXAgc2luZ2xldG9uIGFuZCBpbml0aWFsaXplIGl0ICovXG5UcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQgPSBUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQgfHwge31cbmlmICgoVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LnRyYW5zcG9ydCA9PSBudWxsKSAmJiAobW9kdWxlSW5zdGFuY2UgPT0gbnVsbCkpIHtcbiAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydCgpXG4gIHRyYW5zcG9ydC5pbml0KClcbiAgaWYgKHRyYW5zcG9ydC5pc01vY2spIHtcbiAgICAvKiogV2Ugc2hvdWxkIHVzZSB0aGUgbW9jayB0cmFuc3BvcnQgYnVpbHQgd2l0aCB0aGUgU0RLLCBub3QgYSBnbG9iYWwgKi9cbiAgICBtb2R1bGVJbnN0YW5jZSA9IHRyYW5zcG9ydFxuICB9IGVsc2Uge1xuICAgIFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdCA9IFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdCB8fCB7fVxuICAgIFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdC50cmFuc3BvcnQgPSB0cmFuc3BvcnRcbiAgfVxuICBUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQuc2V0VHJhbnNwb3J0TGF5ZXIgPSB0cmFuc3BvcnQuc2V0VHJhbnNwb3J0TGF5ZXIuYmluZCh0cmFuc3BvcnQpXG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9FdmVudHMvaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxubGV0IGxpc3RlbmVySWQgPSAwXG5cbi8vIGhvbGRzIGEgbWFwIG9mICR7bW9kdWxlfS4ke2V2ZW50fSA9PiBsaXN0ZW5lcklkLCBlLmcuIGNhbGxiYWNrIG1ldGhvZCBpZFxuLy8gbm90ZSB0aGF0IG9uZSBjYWxsYmFjayBjYW4gbGlzdGVuIHRvIG11bHRpcGxlIGV2ZW50cywgZS5nLiAnZGlzY292ZXJ5LionXG5jb25zdCBsaXN0ZW5lcnMgPSB7fVxuXG4vLyBob2xkcyBhIG1hcCBvZiAke21vZHVsZX0uJHtldmVudH0gPT4gVHJhbnNwb3J0LnNlbmQgY2FsbHMgKG9ubHkgY2FsbGVkIG9uY2UgcGVyIGV2ZW50KVxuLy8gbm90ZSB0aGF0IHRoZSBrZXlzIGhlcmUgTVVTVCBOT1QgY29udGFpbiB3aWxkIGNhcmRzXG5jb25zdCBlbmFibGVkRXZlbnRzID0ge31cblxuY29uc3Qgb25jZXJzID0gW11cbmNvbnN0IHZhbGlkRXZlbnRzID0ge31cbmxldCB0cmFuc3BvcnRJbml0aWFsaXplZCA9IGZhbHNlXG5cbmNvbnN0IEV2ZW50c19lbWl0ID0gKG1vZHVsZSwgZXZlbnQsIHZhbHVlKSA9PiB7XG4gIGNhbGxDYWxsYmFja3MobGlzdGVuZXJzW21vZHVsZSArICcuKiddLCBbZXZlbnQsIHZhbHVlXSlcbiAgY2FsbENhbGxiYWNrcyhsaXN0ZW5lcnNbbW9kdWxlICsgJy4nICsgZXZlbnRdLCBbdmFsdWVdKVxufVxuXG5jb25zdCByZWdpc3RlckV2ZW50cyA9IChtb2R1bGUsIGV2ZW50cykgPT4ge1xuICB2YWxpZEV2ZW50c1ttb2R1bGUudG9Mb3dlckNhc2UoKV0gPSBldmVudHMuY29uY2F0KClcbn1cblxuY29uc3QgY2FsbENhbGxiYWNrcyA9IChjYnMsIGFyZ3MpID0+IHtcbiAgY2JzICYmXG4gICAgT2JqZWN0LmtleXMoY2JzKS5mb3JFYWNoKGxpc3RlbmVySWQgPT4ge1xuICAgICAgbGV0IGNhbGxiYWNrID0gY2JzW2xpc3RlbmVySWRdXG4gICAgICBpZiAob25jZXJzLmluZGV4T2YocGFyc2VJbnQobGlzdGVuZXJJZCkpID49IDApIHtcbiAgICAgICAgb25jZXJzLnNwbGljZShvbmNlcnMuaW5kZXhPZihwYXJzZUludChsaXN0ZW5lcklkKSksIDEpXG4gICAgICAgIGRlbGV0ZSBjYnNbbGlzdGVuZXJJZF1cbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgfSlcbn1cblxuY29uc3QgZG9MaXN0ZW4gPSBmdW5jdGlvbihtb2R1bGUsIGV2ZW50LCBjYWxsYmFjaywgb25jZSkge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdObyB2YWxpZCBjYWxsYmFjayBmdW5jdGlvbiBwcm92aWRlZC4nKVxuICB9IGVsc2Uge1xuICAgIGlmIChtb2R1bGUgPT09ICcqJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdObyB2YWxpZCBtb2R1bGUgbmFtZSBwcm92aWRlZCcpXG4gICAgfVxuXG4gICAgbGV0IGV2ZW50cyA9IChldmVudCA9PT0gJyonID8gdmFsaWRFdmVudHNbbW9kdWxlXSA6IFtldmVudF0pIC8vIGV4cGxvZGVzIHdpbGRjYXJkcyBpbnRvIGFuIGFycmF5XG4gICAgbGV0IHByb21pc2VzID0gW11cbiAgICBjb25zdCBrZXkgPSBtb2R1bGUgKyAnLicgKyBldmVudCAvLyB0aGlzIG1pZ2h0IGJlIGEgd2lsZGNhcmQsIGUuZy4gJ2xpZmVjeWNsZS4qJ1xuICAgIGxpc3RlbmVySWQrK1xuICAgIGxpc3RlbmVyc1trZXldID0gbGlzdGVuZXJzW2tleV0gfHwge31cbiAgICBsaXN0ZW5lcnNba2V5XVsnJytsaXN0ZW5lcklkXSA9IGNhbGxiYWNrXG5cbiAgICBpZiAob25jZSkge1xuICAgICAgb25jZXJzLnB1c2gobGlzdGVuZXJJZClcbiAgICB9XG5cbiAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAvLyBDaGVjayBlYWNoIGV2ZW50LCBhbmQgb25seSB0dXJuIG9uIGV2ZW50cyAobm90IHdpbGRjYXJkcykgdGhhdCBhcmUgb2ZmXG4gICAgICBpZiAoIWVuYWJsZWRFdmVudHNbbW9kdWxlICsgJy4nICsgZXZlbnRdKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgVHJhbnNwb3J0LnNlbmQobW9kdWxlLCAnb24nICsgZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnN1YnN0cigxKSwgeyBsaXN0ZW46IHRydWUgfSlcbiAgICAgICAgKVxuICAgICAgICBlbmFibGVkRXZlbnRzW21vZHVsZSArICcuJyArIGV2ZW50XSA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgbGV0IHJlc29sdmUsIHJlamVjdFxuICAgIGxldCBwID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICByZXNvbHZlID0gcmVzXG4gICAgICByZWplY3QgPSByZWpcbiAgICB9KVxuXG4gICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4ocmVzcG9uc2VzID0+IHtcbiAgICAgICAgcmVzb2x2ZShsaXN0ZW5lcklkKVxuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAvLyBQcm9taXNlLmFsbCByZWplY3RzIGlmIGF0IGxlYXN0IG9uZSBwcm9taXNlIHJlamVjdHMuLi4gd2UgZG9uJ3Qgd2FudCB0aGF0IGJlaGF2aW9yIGhlcmVcbiAgICAgICAgLy8gVE9ETzogRG8gc29tZXRoaW5nIGJldHRlciB0aGFuIGZhaWwgc2lsZW50bHlcbiAgICAgICAgaWYgKGV2ZW50ID09PSAnKicpIHtcbiAgICAgICAgICByZXNvbHZlKGxpc3RlbmVySWQpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlc29sdmUobGlzdGVuZXJJZClcbiAgICB9XG5cbiAgICByZXR1cm4gcFxuICB9XG59XG5cbmNvbnN0IGdldExpc3RlbkFyZ3MgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gIGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKVxuICBjb25zdCBtb2R1bGUgPSBhcmdzWzBdLnRvTG93ZXJDYXNlKCkgfHwgJyonXG4gIGNvbnN0IGV2ZW50ID0gYXJnc1sxXSB8fCAnKidcbiAgcmV0dXJuIFttb2R1bGUsIGV2ZW50LCBjYWxsYmFja11cbn1cblxuY29uc3Qgb25jZSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgY29uc3QgW21vZHVsZSwgZXZlbnQsIGNhbGxiYWNrXSA9IGdldExpc3RlbkFyZ3MoLi4uYXJncylcbiAgcmV0dXJuIGRvTGlzdGVuKG1vZHVsZSwgZXZlbnQsIGNhbGxiYWNrLCB0cnVlKVxufVxuXG5jb25zdCBsaXN0ZW4gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gIGluaXQoKVxuICBjb25zdCBbbW9kdWxlLCBldmVudCwgY2FsbGJhY2tdID0gZ2V0TGlzdGVuQXJncyguLi5hcmdzKVxuICByZXR1cm4gZG9MaXN0ZW4obW9kdWxlLCBldmVudCwgY2FsbGJhY2ssIGZhbHNlKVxufVxuXG5jb25zdCBpbml0ID0gKCkgPT4ge1xuICBpZiAoIXRyYW5zcG9ydEluaXRpYWxpemVkKSB7XG4gICAgVHJhbnNwb3J0LmFkZEV2ZW50RW1pdHRlcihFdmVudHNfZW1pdClcbiAgICBzZXRNb2NrTGlzdGVuZXIobGlzdGVuKVxuICAgIHRyYW5zcG9ydEluaXRpYWxpemVkID0gdHJ1ZVxuICB9XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRXZlbnRzID0gKHtcbiAgbGlzdGVuOiBsaXN0ZW4sXG4gIG9uY2U6IG9uY2UsXG4gIC8vIFRPRE86IGNsZWFyIG5lZWRzIHRvIGdvIHRocm91Z2ggVHJhbnNwb3J0IExheWVyXG4gIGNsZWFyKG1vZHVsZU9ySWQgPSBmYWxzZSwgZXZlbnQgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlT3JJZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IHNlYXJjaElkID0gbW9kdWxlT3JJZC50b1N0cmluZygpXG4gICAgICBPYmplY3Qua2V5cyhsaXN0ZW5lcnMpLmV2ZXJ5KGtleSA9PiB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnNba2V5XVtzZWFyY2hJZF0pIHtcbiAgICAgICAgICAvLyBkZWxldGUgY2FsbGJhY2tcbiAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2tleV1bc2VhcmNoSWRdXG4gICAgICAgICAgLy8gZGVsZXRlIHRoZSB3aG9sZSBuYW1lc3BhY2UgaWYgaXQgd2FzIHRoZSBvbmx5IGNhbGxiYWNrXG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxpc3RlbmVyc1trZXldKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNba2V5XVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFtb2R1bGVPcklkICYmICFldmVudCkge1xuICAgICAgICBPYmplY3Qua2V5cyhsaXN0ZW5lcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2tleV1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoIWV2ZW50KSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGxpc3RlbmVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihtb2R1bGVPcklkLnRvTG93ZXJDYXNlKCkpID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2tleV1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW21vZHVsZU9ySWQgKyAnLicgKyBldmVudF1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJyb2FkY2FzdChldmVudCwgdmFsdWUpIHtcbiAgICBFdmVudHNfZW1pdCgnYXBwJywgZXZlbnQsIHZhbHVlKVxuICB9LFxufSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9Qcm9wL2luZGV4LmpzXG5cblxuXG5mdW5jdGlvbiBwcm9wKG1vZHVsZU5hbWUsIGtleSwgYXJncywgaW1tdXRhYmxlLCByZWFkb25seSkge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBnZXR0ZXJcbiAgICByZXR1cm4gVHJhbnNwb3J0LnNlbmQobW9kdWxlTmFtZSwga2V5KVxuICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gc3Vic2NyaWJlXG4gICAgaWYgKGltbXV0YWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3Vic2NyaWJlIHRvIGFuIGltbXV0YWJsZSBwcm9wZXJ0eScpXG4gICAgfVxuICAgIHJldHVybiBFdmVudHMubGlzdGVuKG1vZHVsZU5hbWUsIGtleSArICdDaGFuZ2VkJywgYXJnc1swXSlcbiAgfSBlbHNlIHtcbiAgICAvLyBzZXR0ZXJcbiAgICBpZiAoaW1tdXRhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgYSB2YWx1ZSB0byBhbiBpbW11dGFibGUgcHJvcGVydHknKVxuICAgIH1cbiAgICBpZiAocmVhZG9ubHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBhIHZhbHVlIHRvIGEgcmVhZG9ubHkgcHJvcGVydHknKVxuICAgIH1cbiAgICByZXR1cm4gVHJhbnNwb3J0LnNlbmQobW9kdWxlTmFtZSwga2V5LCB7XG4gICAgICB2YWx1ZTogYXJnc1swXVxuICAgIH0pXG4gIH1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQcm9wID0gKHtcbiAgcHJvcDogcHJvcFxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvQWNjZXNzaWJpbGl0eS9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuXG5yZWdpc3RlckV2ZW50cygnQWNjZXNzaWJpbGl0eScsIE9iamVjdC52YWx1ZXMoW1wiY2xvc2VkQ2FwdGlvbnNTZXR0aW5nc0NoYW5nZWRcIixcInZvaWNlR3VpZGFuY2VTZXR0aW5nc0NoYW5nZWRcIl0pKVxuXG5UcmFuc3BvcnQucmVnaXN0ZXJEZXByZWNhdGVkTWV0aG9kKCdBY2Nlc3NpYmlsaXR5JywgJ2Nsb3NlZENhcHRpb25zJywgJ1VzZSBBY2Nlc3NpYmlsaXR5LmNsb3NlZENhcHRpb25zU2V0dGluZ3MoKSBpbnN0ZWFkLicpXG5UcmFuc3BvcnQucmVnaXN0ZXJEZXByZWNhdGVkTWV0aG9kKCdBY2Nlc3NpYmlsaXR5JywgJ3ZvaWNlR3VpZGFuY2UnLCAnVXNlIEFjY2Vzc2liaWxpdHkudm9pY2VHdWlkYW5jZVNldHRpbmdzKCkgaW5zdGVhZC4nKVxuXG5cbmZ1bmN0aW9uIGNsb3NlZENhcHRpb25zKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2FjY2Vzc2liaWxpdHknLCAnY2xvc2VkQ2FwdGlvbnMnLCB7ICB9KVxufVxuZnVuY3Rpb24gY2xvc2VkQ2FwdGlvbnNTZXR0aW5ncygpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnYWNjZXNzaWJpbGl0eScsICAnY2xvc2VkQ2FwdGlvbnNTZXR0aW5ncycsIGFyZ3VtZW50cywgZmFsc2UsIHRydWUpXG59XG5cbmZ1bmN0aW9uIHZvaWNlR3VpZGFuY2UoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnYWNjZXNzaWJpbGl0eScsICd2b2ljZUd1aWRhbmNlJywgeyAgfSlcbn1cbmZ1bmN0aW9uIHZvaWNlR3VpZGFuY2VTZXR0aW5ncygpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnYWNjZXNzaWJpbGl0eScsICAndm9pY2VHdWlkYW5jZVNldHRpbmdzJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gQWNjZXNzaWJpbGl0eV9saXN0ZW4oLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmxpc3RlbignYWNjZXNzaWJpbGl0eScsIC4uLmFyZ3MpXG59IFxuXG5mdW5jdGlvbiBBY2Nlc3NpYmlsaXR5X29uY2UoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLm9uY2UoJ2FjY2Vzc2liaWxpdHknLCAuLi5hcmdzKVxufVxuXG5mdW5jdGlvbiBjbGVhciguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMuY2xlYXIoJ2FjY2Vzc2liaWxpdHknLCAuLi5hcmdzKVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFjY2Vzc2liaWxpdHkgPSAoe1xuXG4gIGV2ZW50czoge1xuICAgIGNsb3NlZENhcHRpb25zU2V0dGluZ3NDaGFuZ2VkOidjbG9zZWRDYXB0aW9uc1NldHRpbmdzQ2hhbmdlZCcsXG4gICAgdm9pY2VHdWlkYW5jZVNldHRpbmdzQ2hhbmdlZDondm9pY2VHdWlkYW5jZVNldHRpbmdzQ2hhbmdlZCdcbiAgfSxcbmNsb3NlZENhcHRpb25zLFxuICBjbG9zZWRDYXB0aW9uc1NldHRpbmdzLFxuICB2b2ljZUd1aWRhbmNlLFxuICB2b2ljZUd1aWRhbmNlU2V0dGluZ3MsXG4gIGxpc3RlbjogQWNjZXNzaWJpbGl0eV9saXN0ZW4sXG4gIG9uY2U6IEFjY2Vzc2liaWxpdHlfb25jZSxcbiAgY2xlYXJcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0FjY291bnQvaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGlkKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdhY2NvdW50JywgICdpZCcsIGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIHVpZCgpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnYWNjb3VudCcsICAndWlkJywgYXJndW1lbnRzLCB0cnVlLCB0cnVlKVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFjY291bnQgPSAoe1xuXG5pZCxcbiAgdWlkXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9BZHZlcnRpc2luZy9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuXG5yZWdpc3RlckV2ZW50cygnQWR2ZXJ0aXNpbmcnLCBPYmplY3QudmFsdWVzKFtcInBvbGljeUNoYW5nZWRcIl0pKVxuXG5cblxuZnVuY3Rpb24gY29uZmlnKG9wdGlvbnMpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdhZHZlcnRpc2luZycsICdjb25maWcnLCB7IG9wdGlvbnMgfSlcbn1cbmZ1bmN0aW9uIHBvbGljeSgpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnYWR2ZXJ0aXNpbmcnLCAgJ3BvbGljeScsIGFyZ3VtZW50cywgZmFsc2UsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGFkdmVydGlzaW5nSWQoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnYWR2ZXJ0aXNpbmcnLCAnYWR2ZXJ0aXNpbmdJZCcsIHsgIH0pXG59XG5cbmZ1bmN0aW9uIGRldmljZUF0dHJpYnV0ZXMoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnYWR2ZXJ0aXNpbmcnLCAnZGV2aWNlQXR0cmlidXRlcycsIHsgIH0pXG59XG5cbmZ1bmN0aW9uIGFwcEJ1bmRsZUlkKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2FkdmVydGlzaW5nJywgJ2FwcEJ1bmRsZUlkJywgeyAgfSlcbn1cblxuZnVuY3Rpb24gQWR2ZXJ0aXNpbmdfbGlzdGVuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5saXN0ZW4oJ2FkdmVydGlzaW5nJywgLi4uYXJncylcbn0gXG5cbmZ1bmN0aW9uIEFkdmVydGlzaW5nX29uY2UoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLm9uY2UoJ2FkdmVydGlzaW5nJywgLi4uYXJncylcbn1cblxuZnVuY3Rpb24gQWR2ZXJ0aXNpbmdfY2xlYXIoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmNsZWFyKCdhZHZlcnRpc2luZycsIC4uLmFyZ3MpXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQWR2ZXJ0aXNpbmcgPSAoe1xuXG4gIGV2ZW50czoge1xuICAgIHBvbGljeUNoYW5nZWQ6J3BvbGljeUNoYW5nZWQnXG4gIH0sXG5cbiAgU2tpcFJlc3RyaWN0aW9uOiB7XG4gICAgTk9ORTogJ25vbmUnLFxuICAgIEFEU19VTldBVENIRUQ6ICdhZHNVbndhdGNoZWQnLFxuICAgIEFEU19BTEw6ICdhZHNBbGwnLFxuICAgIEFMTDogJ2FsbCdcbiAgfSxcblxuY29uZmlnLFxuICBwb2xpY3ksXG4gIGFkdmVydGlzaW5nSWQsXG4gIGRldmljZUF0dHJpYnV0ZXMsXG4gIGFwcEJ1bmRsZUlkLFxuICBsaXN0ZW46IEFkdmVydGlzaW5nX2xpc3RlbixcbiAgb25jZTogQWR2ZXJ0aXNpbmdfb25jZSxcbiAgY2xlYXI6IEFkdmVydGlzaW5nX2NsZWFyXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9BdXRoZW50aWNhdGlvbi9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuZnVuY3Rpb24gdG9rZW4odHlwZSwgb3B0aW9ucykge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2F1dGhlbnRpY2F0aW9uJywgJ3Rva2VuJywgeyB0eXBlLCBvcHRpb25zIH0pXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQXV0aGVudGljYXRpb24gPSAoe1xuXG5cbiAgVG9rZW5UeXBlOiB7XG4gICAgUExBVEZPUk06ICdwbGF0Zm9ybScsXG4gICAgREVWSUNFOiAnZGV2aWNlJyxcbiAgICBESVNUUklCVVRPUjogJ2Rpc3RyaWJ1dG9yJ1xuICB9LFxuXG50b2tlblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvRGV2aWNlL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cbnJlZ2lzdGVyRXZlbnRzKCdEZXZpY2UnLCBPYmplY3QudmFsdWVzKFtcImRldmljZU5hbWVDaGFuZ2VkXCIsXCJoZGNwQ2hhbmdlZFwiLFwiaGRyQ2hhbmdlZFwiLFwiYXVkaW9DaGFuZ2VkXCIsXCJzY3JlZW5SZXNvbHV0aW9uQ2hhbmdlZFwiLFwidmlkZW9SZXNvbHV0aW9uQ2hhbmdlZFwiLFwibmFtZUNoYW5nZWRcIixcIm5ldHdvcmtDaGFuZ2VkXCJdKSlcblxuVHJhbnNwb3J0LnJlZ2lzdGVyRGVwcmVjYXRlZE1ldGhvZCgnRGV2aWNlJywgJ29uRGV2aWNlTmFtZUNoYW5nZWQnLCAnVXNlIERldmljZS5uYW1lKCkgaW5zdGVhZC4nKVxuXG5mdW5jdGlvbiB2ZXJzaW9uKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIFRyYW5zcG9ydC5zZW5kKCdkZXZpY2UnLCAndmVyc2lvbicpLnRoZW4oIHYgPT4ge1xuICAgICAgICAgIHYgPSB2IHx8IHt9XG4gICAgICAgICAgdi5zZGsgPSB2LnNkayB8fCB7fVxuICAgICAgICAgIHYuc2RrLm1ham9yID0gcGFyc2VJbnQoJzAnKVxuICAgICAgICAgIHYuc2RrLm1pbm9yID0gcGFyc2VJbnQoJzYnKVxuICAgICAgICAgIHYuc2RrLnBhdGNoID0gcGFyc2VJbnQoJzAnKVxuICAgICAgICAgIHYuc2RrLnJlYWRhYmxlID0gJ1RoZSBGaXJlYm9sdCBKUyBTREsnXG4gICAgICAgICAgcmVzb2x2ZSh2KSAgICBcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBEZXZpY2VfaWQoKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAnaWQnLCBhcmd1bWVudHMsIHRydWUsIHRydWUpXG59XG5mdW5jdGlvbiBkaXN0cmlidXRvcigpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnZGV2aWNlJywgICdkaXN0cmlidXRvcicsIGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIHBsYXRmb3JtKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ3BsYXRmb3JtJywgYXJndW1lbnRzLCB0cnVlLCB0cnVlKVxufVxuZnVuY3Rpb24gRGV2aWNlX3VpZCgpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnZGV2aWNlJywgICd1aWQnLCBhcmd1bWVudHMsIHRydWUsIHRydWUpXG59XG5mdW5jdGlvbiB0eXBlKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ3R5cGUnLCBhcmd1bWVudHMsIHRydWUsIHRydWUpXG59XG5mdW5jdGlvbiBtb2RlbCgpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnZGV2aWNlJywgICdtb2RlbCcsIGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIHNrdSgpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnZGV2aWNlJywgICdza3UnLCBhcmd1bWVudHMsIHRydWUsIHRydWUpXG59XG5mdW5jdGlvbiBtYWtlKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ21ha2UnLCBhcmd1bWVudHMsIHRydWUsIHRydWUpXG59XG5mdW5jdGlvbiBoZGNwKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ2hkY3AnLCBhcmd1bWVudHMsIGZhbHNlLCB0cnVlKVxufVxuZnVuY3Rpb24gaGRyKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ2hkcicsIGFyZ3VtZW50cywgZmFsc2UsIHRydWUpXG59XG5mdW5jdGlvbiBhdWRpbygpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnZGV2aWNlJywgICdhdWRpbycsIGFyZ3VtZW50cywgZmFsc2UsIHRydWUpXG59XG5mdW5jdGlvbiBzY3JlZW5SZXNvbHV0aW9uKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ3NjcmVlblJlc29sdXRpb24nLCBhcmd1bWVudHMsIGZhbHNlLCB0cnVlKVxufVxuZnVuY3Rpb24gdmlkZW9SZXNvbHV0aW9uKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ3ZpZGVvUmVzb2x1dGlvbicsIGFyZ3VtZW50cywgZmFsc2UsIHRydWUpXG59XG5mdW5jdGlvbiBEZXZpY2VfbmFtZSgpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnZGV2aWNlJywgICduYW1lJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIG5ldHdvcmsoKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAnbmV0d29yaycsIGFyZ3VtZW50cywgZmFsc2UsIHRydWUpXG59XG5cbmZ1bmN0aW9uIERldmljZV9saXN0ZW4oLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmxpc3RlbignZGV2aWNlJywgLi4uYXJncylcbn0gXG5cbmZ1bmN0aW9uIERldmljZV9vbmNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5vbmNlKCdkZXZpY2UnLCAuLi5hcmdzKVxufVxuXG5mdW5jdGlvbiBEZXZpY2VfY2xlYXIoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmNsZWFyKCdkZXZpY2UnLCAuLi5hcmdzKVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IERldmljZSA9ICh7XG5cbiAgZXZlbnRzOiB7XG4gICAgZGV2aWNlTmFtZUNoYW5nZWQ6J2RldmljZU5hbWVDaGFuZ2VkJyxcbiAgICBoZGNwQ2hhbmdlZDonaGRjcENoYW5nZWQnLFxuICAgIGhkckNoYW5nZWQ6J2hkckNoYW5nZWQnLFxuICAgIGF1ZGlvQ2hhbmdlZDonYXVkaW9DaGFuZ2VkJyxcbiAgICBzY3JlZW5SZXNvbHV0aW9uQ2hhbmdlZDonc2NyZWVuUmVzb2x1dGlvbkNoYW5nZWQnLFxuICAgIHZpZGVvUmVzb2x1dGlvbkNoYW5nZWQ6J3ZpZGVvUmVzb2x1dGlvbkNoYW5nZWQnLFxuICAgIG5hbWVDaGFuZ2VkOiduYW1lQ2hhbmdlZCcsXG4gICAgbmV0d29ya0NoYW5nZWQ6J25ldHdvcmtDaGFuZ2VkJ1xuICB9LFxuXG4gIE5ldHdvcmtUeXBlOiB7XG4gICAgV0lGSTogJ3dpZmknLFxuICAgIEVUSEVSTkVUOiAnZXRoZXJuZXQnLFxuICAgIEhZQlJJRDogJ2h5YnJpZCdcbiAgfSxcblxuXG4gIE5ldHdvcmtTdGF0ZToge1xuICAgIENPTk5FQ1RFRDogJ2Nvbm5lY3RlZCcsXG4gICAgRElTQ09OTkVDVEVEOiAnZGlzY29ubmVjdGVkJ1xuICB9LFxuXG5cbiAgQXVkaW9Qcm9maWxlOiB7XG4gICAgU1RFUkVPOiAnc3RlcmVvJyxcbiAgICBET0xCWV9ESUdJVEFMXzVfMTogJ2RvbGJ5RGlnaXRhbDUuMScsXG4gICAgRE9MQllfRElHSVRBTF83XzE6ICdkb2xieURpZ2l0YWw3LjEnLFxuICAgIERPTEJZX0RJR0lUQUxfNV8xX1BMVVM6ICdkb2xieURpZ2l0YWw1LjErJyxcbiAgICBET0xCWV9ESUdJVEFMXzdfMV9QTFVTOiAnZG9sYnlEaWdpdGFsNy4xKycsXG4gICAgRE9MQllfQVRNT1M6ICdkb2xieUF0bW9zJ1xuICB9LFxuXG5cbiAgdmVyc2lvbixcbmlkOiBEZXZpY2VfaWQsXG4gIGRpc3RyaWJ1dG9yLFxuICBwbGF0Zm9ybSxcbiAgdWlkOiBEZXZpY2VfdWlkLFxuICB0eXBlLFxuICBtb2RlbCxcbiAgc2t1LFxuICBtYWtlLFxuICBoZGNwLFxuICBoZHIsXG4gIGF1ZGlvLFxuICBzY3JlZW5SZXNvbHV0aW9uLFxuICB2aWRlb1Jlc29sdXRpb24sXG4gIG5hbWU6IERldmljZV9uYW1lLFxuICBuZXR3b3JrLFxuICBsaXN0ZW46IERldmljZV9saXN0ZW4sXG4gIG9uY2U6IERldmljZV9vbmNlLFxuICBjbGVhcjogRGV2aWNlX2NsZWFyXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL01ldHJpY3MvaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5cbmZ1bmN0aW9uIHJlYWR5KCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAncmVhZHknLCB7fSlcbn1cblxuZnVuY3Rpb24gc2lnbkluKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnc2lnbkluJywge30pXG59XG5cbmZ1bmN0aW9uIHNpZ25PdXQoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdzaWduT3V0Jywge30pXG59XG5cblxuXG5mdW5jdGlvbiBzdGFydENvbnRlbnQoZW50aXR5SWQpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ3N0YXJ0Q29udGVudCcsIHsgZW50aXR5SWQgfSlcbn1cblxuZnVuY3Rpb24gc3RvcENvbnRlbnQoZW50aXR5SWQpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ3N0b3BDb250ZW50JywgeyBlbnRpdHlJZCB9KVxufVxuXG5mdW5jdGlvbiBwYWdlKHBhZ2VJZCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAncGFnZScsIHsgcGFnZUlkIH0pXG59XG5cbmZ1bmN0aW9uIGFjdGlvbihjYXRlZ29yeSwgdHlwZSwgcGFyYW1ldGVycykge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnYWN0aW9uJywgeyBjYXRlZ29yeSwgdHlwZSwgcGFyYW1ldGVycyB9KVxufVxuXG5mdW5jdGlvbiBlcnJvcih0eXBlLCBjb2RlLCBkZXNjcmlwdGlvbiwgdmlzaWJsZSwgcGFyYW1ldGVycykge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnZXJyb3InLCB7IHR5cGUsIGNvZGUsIGRlc2NyaXB0aW9uLCB2aXNpYmxlLCBwYXJhbWV0ZXJzIH0pXG59XG5cbmZ1bmN0aW9uIG1lZGlhTG9hZFN0YXJ0KGVudGl0eUlkKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdtZWRpYUxvYWRTdGFydCcsIHsgZW50aXR5SWQgfSlcbn1cblxuZnVuY3Rpb24gbWVkaWFQbGF5KGVudGl0eUlkKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdtZWRpYVBsYXknLCB7IGVudGl0eUlkIH0pXG59XG5cbmZ1bmN0aW9uIG1lZGlhUGxheWluZyhlbnRpdHlJZCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnbWVkaWFQbGF5aW5nJywgeyBlbnRpdHlJZCB9KVxufVxuXG5mdW5jdGlvbiBtZWRpYVBhdXNlKGVudGl0eUlkKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdtZWRpYVBhdXNlJywgeyBlbnRpdHlJZCB9KVxufVxuXG5mdW5jdGlvbiBtZWRpYVdhaXRpbmcoZW50aXR5SWQpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ21lZGlhV2FpdGluZycsIHsgZW50aXR5SWQgfSlcbn1cblxuZnVuY3Rpb24gbWVkaWFQcm9ncmVzcyhlbnRpdHlJZCwgcHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ21lZGlhUHJvZ3Jlc3MnLCB7IGVudGl0eUlkLCBwcm9ncmVzcyB9KVxufVxuXG5mdW5jdGlvbiBtZWRpYVNlZWtpbmcoZW50aXR5SWQsIHRhcmdldCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnbWVkaWFTZWVraW5nJywgeyBlbnRpdHlJZCwgdGFyZ2V0IH0pXG59XG5cbmZ1bmN0aW9uIG1lZGlhU2Vla2VkKGVudGl0eUlkLCBwb3NpdGlvbikge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnbWVkaWFTZWVrZWQnLCB7IGVudGl0eUlkLCBwb3NpdGlvbiB9KVxufVxuXG5mdW5jdGlvbiBtZWRpYVJhdGVDaGFuZ2UoZW50aXR5SWQsIHJhdGUpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ21lZGlhUmF0ZUNoYW5nZScsIHsgZW50aXR5SWQsIHJhdGUgfSlcbn1cblxuZnVuY3Rpb24gbWVkaWFSZW5kaXRpb25DaGFuZ2UoZW50aXR5SWQsIGJpdHJhdGUsIHdpZHRoLCBoZWlnaHQsIHByb2ZpbGUpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ21lZGlhUmVuZGl0aW9uQ2hhbmdlJywgeyBlbnRpdHlJZCwgYml0cmF0ZSwgd2lkdGgsIGhlaWdodCwgcHJvZmlsZSB9KVxufVxuXG5mdW5jdGlvbiBtZWRpYUVuZGVkKGVudGl0eUlkKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdtZWRpYUVuZGVkJywgeyBlbnRpdHlJZCB9KVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IE1ldHJpY3MgPSAoe1xuXG5cbiAgRXJyb3JUeXBlOiB7XG4gICAgTkVUV09SSzogJ25ldHdvcmsnLFxuICAgIE1FRElBOiAnbWVkaWEnLFxuICAgIFJFU1RSSUNUSU9OOiAncmVzdHJpY3Rpb24nLFxuICAgIEVOVElUTEVNRU5UOiAnZW50aXRsZW1lbnQnLFxuICAgIE9USEVSOiAnb3RoZXInXG4gIH0sXG5cbnN0YXJ0Q29udGVudCxcbiAgc3RvcENvbnRlbnQsXG4gIHBhZ2UsXG4gIGFjdGlvbixcbiAgZXJyb3IsXG4gIG1lZGlhTG9hZFN0YXJ0LFxuICBtZWRpYVBsYXksXG4gIG1lZGlhUGxheWluZyxcbiAgbWVkaWFQYXVzZSxcbiAgbWVkaWFXYWl0aW5nLFxuICBtZWRpYVByb2dyZXNzLFxuICBtZWRpYVNlZWtpbmcsXG4gIG1lZGlhU2Vla2VkLFxuICBtZWRpYVJhdGVDaGFuZ2UsXG4gIG1lZGlhUmVuZGl0aW9uQ2hhbmdlLFxuICBtZWRpYUVuZGVkXG59KTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvRGlzY292ZXJ5L2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cbnJlZ2lzdGVyRXZlbnRzKCdEaXNjb3ZlcnknLCBPYmplY3QudmFsdWVzKFtcIm5hdmlnYXRlVG9cIixcInBvbGljeUNoYW5nZWRcIl0pKVxuXG5cbmZ1bmN0aW9uIERpc2NvdmVyeV9wb2xpY3koKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2Rpc2NvdmVyeScsICAncG9saWN5JywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cblxubGV0IGVudGl0eUluZm9IYXNDYWxsYmFjayA9IGZhbHNlXG5cbmZ1bmN0aW9uIGVudGl0eUluZm8gKGRhdGEpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChlbnRpdHlJbmZvSGFzQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2Fubm90IHJlZ2lzdGVyIG1vcmUgdGhhbiBvbmUgZW50aXR5SW5mbyBoYW5kbGVyLicpXG4gICAgfVxuXG4gICAgY29uc3QgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF1cbiAgICBlbnRpdHlJbmZvSGFzQ2FsbGJhY2sgPSB0cnVlXG4gICAgcmV0dXJuIEV2ZW50cy5saXN0ZW4oJ2Rpc2NvdmVyeScsICdwdWxsRW50aXR5SW5mbycsIChyZXF1ZXN0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdib29sZWFuJykgcmV0dXJuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKHJlcXVlc3QucGFyYW1ldGVycykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IHJlcXVlc3QuY29ycmVsYXRpb25JZCxcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgfVxuICAgICAgICAgIFRyYW5zcG9ydC5zZW5kKCdkaXNjb3ZlcnknLCAnZW50aXR5SW5mbycsIHBhcmFtcykuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJyA/IGVycm9yIDogZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBFcnJvcidcbiAgICAgICAgICAgIEludGVybmFsTWV0cmljcy5zZGsuZXJyb3IoYEZhaWxlZCB0byBzZW5kIGVudGl0eUluZm8gcHVsbCByZXNwb25zZSB0aHJvdWdoIFRyYW5zcG9ydCBMYXllcjogJHttc2d9YCwgcGFyc2VJbnQoZXJyb3IuY29kZSkgfHwgNTAwLCBmYWxzZSwgcmVxdWVzdC5wYXJhbWV0ZXJzKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBjb25zdCBtc2cgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyb3IgOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIEVycm9yJ1xuICAgICAgICAgIEludGVybmFsTWV0cmljcy5zZGsuZXJyb3IoYEFwcCAnZW50aXR5SW5mbycgY2FsbGJhY2sgZmFpbGVkOiAke21zZ31gLCBwYXJzZUludChlcnJvci5jb2RlKSB8fCA1MDAsIGZhbHNlLCByZXF1ZXN0LnBhcmFtZXRlcnMpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbXNnID0gdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJyA/IGVycm9yIDogZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBFcnJvcidcbiAgICAgICAgSW50ZXJuYWxNZXRyaWNzLnNkay5lcnJvcihgQXBwICdlbnRpdHlJbmZvJyBjYWxsYmFjayBmYWlsZWQ6ICR7bXNnfWAsIHBhcnNlSW50KGVycm9yLmNvZGUpIHx8IDUwMCwgZmFsc2UsIHJlcXVlc3QucGFyYW1ldGVycylcbiAgICB9XG4gICAgfSlcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICdlbnRpdHlJbmZvJywgeyBkYXRhIH0pXG4gIH1cbn1cblxubGV0IHB1cmNoYXNlZENvbnRlbnRIYXNDYWxsYmFjayA9IGZhbHNlXG5cbmZ1bmN0aW9uIHB1cmNoYXNlZENvbnRlbnQgKGRhdGEpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwdXJjaGFzZWRDb250ZW50SGFzQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2Fubm90IHJlZ2lzdGVyIG1vcmUgdGhhbiBvbmUgcHVyY2hhc2VkQ29udGVudCBoYW5kbGVyLicpXG4gICAgfVxuXG4gICAgY29uc3QgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF1cbiAgICBwdXJjaGFzZWRDb250ZW50SGFzQ2FsbGJhY2sgPSB0cnVlXG4gICAgcmV0dXJuIEV2ZW50cy5saXN0ZW4oJ2Rpc2NvdmVyeScsICdwdWxsUHVyY2hhc2VkQ29udGVudCcsIChyZXF1ZXN0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdib29sZWFuJykgcmV0dXJuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKHJlcXVlc3QucGFyYW1ldGVycykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IHJlcXVlc3QuY29ycmVsYXRpb25JZCxcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgfVxuICAgICAgICAgIFRyYW5zcG9ydC5zZW5kKCdkaXNjb3ZlcnknLCAncHVyY2hhc2VkQ29udGVudCcsIHBhcmFtcykuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJyA/IGVycm9yIDogZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBFcnJvcidcbiAgICAgICAgICAgIEludGVybmFsTWV0cmljcy5zZGsuZXJyb3IoYEZhaWxlZCB0byBzZW5kIHB1cmNoYXNlZENvbnRlbnQgcHVsbCByZXNwb25zZSB0aHJvdWdoIFRyYW5zcG9ydCBMYXllcjogJHttc2d9YCwgcGFyc2VJbnQoZXJyb3IuY29kZSkgfHwgNTAwLCBmYWxzZSwgcmVxdWVzdC5wYXJhbWV0ZXJzKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBjb25zdCBtc2cgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyb3IgOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIEVycm9yJ1xuICAgICAgICAgIEludGVybmFsTWV0cmljcy5zZGsuZXJyb3IoYEFwcCAncHVyY2hhc2VkQ29udGVudCcgY2FsbGJhY2sgZmFpbGVkOiAke21zZ31gLCBwYXJzZUludChlcnJvci5jb2RlKSB8fCA1MDAsIGZhbHNlLCByZXF1ZXN0LnBhcmFtZXRlcnMpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbXNnID0gdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJyA/IGVycm9yIDogZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBFcnJvcidcbiAgICAgICAgSW50ZXJuYWxNZXRyaWNzLnNkay5lcnJvcihgQXBwICdwdXJjaGFzZWRDb250ZW50JyBjYWxsYmFjayBmYWlsZWQ6ICR7bXNnfWAsIHBhcnNlSW50KGVycm9yLmNvZGUpIHx8IDUwMCwgZmFsc2UsIHJlcXVlc3QucGFyYW1ldGVycylcbiAgICB9XG4gICAgfSlcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICdwdXJjaGFzZWRDb250ZW50JywgeyBkYXRhIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gd2F0Y2hlZChlbnRpdHlJZCwgcHJvZ3Jlc3MsIGNvbXBsZXRlZCwgd2F0Y2hlZE9uKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnZGlzY292ZXJ5JywgJ3dhdGNoZWQnLCBhcmd1bWVudHNbMF0pXG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdkaXNjb3ZlcnknLCAnd2F0Y2hlZCcsIHsgZW50aXR5SWQsIHByb2dyZXNzLCBjb21wbGV0ZWQsIHdhdGNoZWRPbiB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhdGNoTmV4dCh0aXRsZSwgaWRlbnRpZmllcnMsIGV4cGlyZXMsIGltYWdlcykge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICd3YXRjaE5leHQnLCB7IHRpdGxlLCBpZGVudGlmaWVycywgZXhwaXJlcywgaW1hZ2VzIH0pXG59XG5cbmZ1bmN0aW9uIGVudGl0bGVtZW50cyhlbnRpdGxlbWVudHMpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdkaXNjb3ZlcnknLCAnZW50aXRsZW1lbnRzJywgeyBlbnRpdGxlbWVudHMgfSlcbn1cblxuZnVuY3Rpb24gbGF1bmNoKGFwcElkLCBpbnRlbnQpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdkaXNjb3ZlcnknLCAnbGF1bmNoJywgeyBhcHBJZCwgaW50ZW50IH0pXG59XG5cblxuXG5mdW5jdGlvbiBEaXNjb3Zlcnlfc2lnbkluKGVudGl0bGVtZW50cykge1xuICAgIGNvbnN0IHAgPSBUcmFuc3BvcnQuc2VuZCgnZGlzY292ZXJ5JywgJ3NpZ25JbicsIHsgZW50aXRsZW1lbnRzIH0pXG4gICAgXG4gICAgcC50aGVuKF8gPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KF8gPT4ge1xuICAgICAgICAgICAgc2lnbkluKGVudGl0bGVtZW50cylcbiAgICAgICAgfSkgICAgXG4gICAgfSlcblxuICAgIHJldHVybiBwXG59XG5cblxuXG5mdW5jdGlvbiBEaXNjb3Zlcnlfc2lnbk91dCgpIHtcbiAgICBjb25zdCBwID0gVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICdzaWduT3V0JywgeyAgfSlcbiAgICBcbiAgICBwLnRoZW4oXyA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoXyA9PiB7XG4gICAgICAgICAgICBzaWduT3V0KClcbiAgICAgICAgfSkgICAgXG4gICAgfSlcblxuICAgIHJldHVybiBwXG59XG5cbmZ1bmN0aW9uIERpc2NvdmVyeV9saXN0ZW4oLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmxpc3RlbignZGlzY292ZXJ5JywgLi4uYXJncylcbn0gXG5cbmZ1bmN0aW9uIERpc2NvdmVyeV9vbmNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5vbmNlKCdkaXNjb3ZlcnknLCAuLi5hcmdzKVxufVxuXG5mdW5jdGlvbiBEaXNjb3ZlcnlfY2xlYXIoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmNsZWFyKCdkaXNjb3ZlcnknLCAuLi5hcmdzKVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IERpc2NvdmVyeSA9ICh7XG5cbiAgZXZlbnRzOiB7XG4gICAgbmF2aWdhdGVUbzonbmF2aWdhdGVUbycsXG4gICAgcG9saWN5Q2hhbmdlZDoncG9saWN5Q2hhbmdlZCdcbiAgfSxcbnBvbGljeTogRGlzY292ZXJ5X3BvbGljeSxcbiAgZW50aXR5SW5mbyxcbiAgcHVyY2hhc2VkQ29udGVudCxcbiAgd2F0Y2hlZCxcbiAgd2F0Y2hOZXh0LFxuICBlbnRpdGxlbWVudHMsXG4gIGxhdW5jaCxcbiAgc2lnbkluOiBEaXNjb3Zlcnlfc2lnbkluLFxuICBzaWduT3V0OiBEaXNjb3Zlcnlfc2lnbk91dCxcbiAgbGlzdGVuOiBEaXNjb3ZlcnlfbGlzdGVuLFxuICBvbmNlOiBEaXNjb3Zlcnlfb25jZSxcbiAgY2xlYXI6IERpc2NvdmVyeV9jbGVhclxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvS2V5Ym9hcmQvaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGVtYWlsKHR5cGUsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdrZXlib2FyZCcsICdlbWFpbCcsIHsgdHlwZSwgbWVzc2FnZSB9KVxufVxuXG5mdW5jdGlvbiBLZXlib2FyZF9wYXNzd29yZChtZXNzYWdlKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgna2V5Ym9hcmQnLCAncGFzc3dvcmQnLCB7IG1lc3NhZ2UgfSlcbn1cblxuZnVuY3Rpb24gc3RhbmRhcmQobWVzc2FnZSkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2tleWJvYXJkJywgJ3N0YW5kYXJkJywgeyBtZXNzYWdlIH0pXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgS2V5Ym9hcmQgPSAoe1xuXG5cbiAgRW1haWxVc2FnZToge1xuICAgIFNJR05fSU46ICdzaWduSW4nLFxuICAgIFNJR05fVVA6ICdzaWduVXAnXG4gIH0sXG5cbmVtYWlsLFxuICBwYXNzd29yZDogS2V5Ym9hcmRfcGFzc3dvcmQsXG4gIHN0YW5kYXJkXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9MaWZlY3ljbGUvaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5cbnJlZ2lzdGVyRXZlbnRzKCdMaWZlY3ljbGUnLCBPYmplY3QudmFsdWVzKFtcImluYWN0aXZlXCIsXCJmb3JlZ3JvdW5kXCIsXCJiYWNrZ3JvdW5kXCIsXCJzdXNwZW5kZWRcIixcInVubG9hZGluZ1wiXSkpXG5cblxuY29uc3Qgc3RvcmUgPSB7XG4gIF9jdXJyZW50OiAnaW5pdGlhbGl6aW5nJyxcbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRcbiAgfVxufVxuXG5FdmVudHMubGlzdGVuKCdMaWZlY3ljbGUnLCAoZXZlbnQsIHZhbHVlKSA9PiB7XG4gIHN0b3JlLl9jdXJyZW50ID0gZXZlbnRcbn0pXG5cblxuO1xuXG5mdW5jdGlvbiBMaWZlY3ljbGVfcmVhZHkoKSB7XG4gICAgY29uc3QgcCA9IFRyYW5zcG9ydC5zZW5kKCdsaWZlY3ljbGUnLCAncmVhZHknLCB7ICB9KVxuICAgIFxuICAgIHAudGhlbihfID0+IHtcbiAgICAgICAgc2V0VGltZW91dChfID0+IHtcbiAgICAgICAgICAgIHJlYWR5KClcbiAgICAgICAgfSkgICAgXG4gICAgfSlcblxuICAgIHJldHVybiBwXG59XG5cbmZ1bmN0aW9uIExpZmVjeWNsZV9jbG9zZShyZWFzb24pIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdsaWZlY3ljbGUnLCAnY2xvc2UnLCB7IHJlYXNvbiB9KVxufVxuXG5mdW5jdGlvbiBMaWZlY3ljbGVfbGlzdGVuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5saXN0ZW4oJ2xpZmVjeWNsZScsIC4uLmFyZ3MpXG59IFxuXG5mdW5jdGlvbiBMaWZlY3ljbGVfb25jZSguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMub25jZSgnbGlmZWN5Y2xlJywgLi4uYXJncylcbn1cblxuZnVuY3Rpb24gTGlmZWN5Y2xlX2NsZWFyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5jbGVhcignbGlmZWN5Y2xlJywgLi4uYXJncylcbn1cblxuZnVuY3Rpb24gc3RhdGUoKSB7XG4gIHJldHVybiBzdG9yZS5jdXJyZW50XG59XG5cbmZ1bmN0aW9uIGZpbmlzaGVkKCkge1xuICBpZiAoc3RvcmUuY3VycmVudCA9PT0gJ3VubG9hZGluZycpIHtcbiAgICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2xpZmVjeWNsZScsICdmaW5pc2hlZCcpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgJ0Nhbm5vdCBjYWxsIGZpbmlzaGVkKCkgZXhjZXB0IHdoZW4gaW4gdGhlIHVubG9hZGluZyB0cmFuc2l0aW9uJ1xuICB9XG59XG5cbi8vIHB1YmxpYyBBUElcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTGlmZWN5Y2xlID0gKHtcblxuICBldmVudHM6IHtcbiAgICBpbmFjdGl2ZTonaW5hY3RpdmUnLFxuICAgIGZvcmVncm91bmQ6J2ZvcmVncm91bmQnLFxuICAgIGJhY2tncm91bmQ6J2JhY2tncm91bmQnLFxuICAgIHN1c3BlbmRlZDonc3VzcGVuZGVkJyxcbiAgICB1bmxvYWRpbmc6J3VubG9hZGluZydcbiAgfSxcblxuXG4gIExpZmVjeWNsZVN0YXRlOiB7XG4gICAgSU5JVElBTElaSU5HOiAnaW5pdGlhbGl6aW5nJyxcbiAgICBJTkFDVElWRTogJ2luYWN0aXZlJyxcbiAgICBCQUNLR1JPVU5EOiAnYmFja2dyb3VuZCcsXG4gICAgRk9SRUdST1VORDogJ2ZvcmVncm91bmQnLFxuICAgIFNVU1BFTkRFRDogJ3N1c3BlbmRlZCcsXG4gICAgVU5MT0FESU5HOiAndW5sb2FkaW5nJ1xuICB9LFxuXG5cbiAgQ2xvc2VSZWFzb246IHtcbiAgICBSRU1PVEVfQlVUVE9OOiAncmVtb3RlQnV0dG9uJyxcbiAgICBVU0VSX0VYSVQ6ICd1c2VyRXhpdCcsXG4gICAgRVJST1I6ICdlcnJvcidcbiAgfSxcblxuXG4gIHN0YXRlLFxuICBmaW5pc2hlZCxcblxucmVhZHk6IExpZmVjeWNsZV9yZWFkeSxcbiAgY2xvc2U6IExpZmVjeWNsZV9jbG9zZSxcbiAgbGlzdGVuOiBMaWZlY3ljbGVfbGlzdGVuLFxuICBvbmNlOiBMaWZlY3ljbGVfb25jZSxcbiAgY2xlYXI6IExpZmVjeWNsZV9jbGVhciAgXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0xvY2FsaXphdGlvbi9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuXG5yZWdpc3RlckV2ZW50cygnTG9jYWxpemF0aW9uJywgT2JqZWN0LnZhbHVlcyhbXCJsYW5ndWFnZUNoYW5nZWRcIl0pKVxuXG5cblxuZnVuY3Rpb24gbG9jYWxpdHkoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbG9jYWxpemF0aW9uJywgJ2xvY2FsaXR5JywgeyAgfSlcbn1cblxuZnVuY3Rpb24gcG9zdGFsQ29kZSgpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdsb2NhbGl6YXRpb24nLCAncG9zdGFsQ29kZScsIHsgIH0pXG59XG5cbmZ1bmN0aW9uIGNvdW50cnlDb2RlKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2xvY2FsaXphdGlvbicsICdjb3VudHJ5Q29kZScsIHsgIH0pXG59XG5mdW5jdGlvbiBsYW5ndWFnZSgpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnbG9jYWxpemF0aW9uJywgICdsYW5ndWFnZScsIGFyZ3VtZW50cywgZmFsc2UsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGxvY2FsZSgpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdsb2NhbGl6YXRpb24nLCAnbG9jYWxlJywgeyAgfSlcbn1cblxuZnVuY3Rpb24gbGF0bG9uKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2xvY2FsaXphdGlvbicsICdsYXRsb24nLCB7ICB9KVxufVxuXG5mdW5jdGlvbiBhZGRpdGlvbmFsSW5mbygpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdsb2NhbGl6YXRpb24nLCAnYWRkaXRpb25hbEluZm8nLCB7ICB9KVxufVxuXG5mdW5jdGlvbiBMb2NhbGl6YXRpb25fbGlzdGVuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5saXN0ZW4oJ2xvY2FsaXphdGlvbicsIC4uLmFyZ3MpXG59IFxuXG5mdW5jdGlvbiBMb2NhbGl6YXRpb25fb25jZSguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMub25jZSgnbG9jYWxpemF0aW9uJywgLi4uYXJncylcbn1cblxuZnVuY3Rpb24gTG9jYWxpemF0aW9uX2NsZWFyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5jbGVhcignbG9jYWxpemF0aW9uJywgLi4uYXJncylcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMb2NhbGl6YXRpb24gPSAoe1xuXG4gIGV2ZW50czoge1xuICAgIGxhbmd1YWdlQ2hhbmdlZDonbGFuZ3VhZ2VDaGFuZ2VkJ1xuICB9LFxubG9jYWxpdHksXG4gIHBvc3RhbENvZGUsXG4gIGNvdW50cnlDb2RlLFxuICBsYW5ndWFnZSxcbiAgbG9jYWxlLFxuICBsYXRsb24sXG4gIGFkZGl0aW9uYWxJbmZvLFxuICBsaXN0ZW46IExvY2FsaXphdGlvbl9saXN0ZW4sXG4gIG9uY2U6IExvY2FsaXphdGlvbl9vbmNlLFxuICBjbGVhcjogTG9jYWxpemF0aW9uX2NsZWFyXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9QYXJhbWV0ZXJzL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5mdW5jdGlvbiBpbml0aWFsaXphdGlvbigpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdwYXJhbWV0ZXJzJywgJ2luaXRpYWxpemF0aW9uJywgeyAgfSlcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQYXJhbWV0ZXJzID0gKHtcblxuaW5pdGlhbGl6YXRpb25cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1Byb2ZpbGUvaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGFwcHJvdmVDb250ZW50UmF0aW5nKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ3Byb2ZpbGUnLCAnYXBwcm92ZUNvbnRlbnRSYXRpbmcnLCB7ICB9KVxufVxuXG5mdW5jdGlvbiBhcHByb3ZlUHVyY2hhc2UoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgncHJvZmlsZScsICdhcHByb3ZlUHVyY2hhc2UnLCB7ICB9KVxufVxuXG5mdW5jdGlvbiBmbGFncygpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdwcm9maWxlJywgJ2ZsYWdzJywgeyAgfSlcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQcm9maWxlID0gKHtcblxuYXBwcm92ZUNvbnRlbnRSYXRpbmcsXG4gIGFwcHJvdmVQdXJjaGFzZSxcbiAgZmxhZ3Ncbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1NlY29uZFNjcmVlbi9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuXG5yZWdpc3RlckV2ZW50cygnU2Vjb25kU2NyZWVuJywgT2JqZWN0LnZhbHVlcyhbXCJsYXVuY2hSZXF1ZXN0XCIsXCJjbG9zZVJlcXVlc3RcIixcImZyaWVuZGx5TmFtZUNoYW5nZWRcIl0pKVxuXG5cblxuZnVuY3Rpb24gcHJvdG9jb2xzKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ3NlY29uZHNjcmVlbicsICdwcm90b2NvbHMnLCB7ICB9KVxufVxuXG5mdW5jdGlvbiBkZXZpY2UodHlwZSkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ3NlY29uZHNjcmVlbicsICdkZXZpY2UnLCB7IHR5cGUgfSlcbn1cbmZ1bmN0aW9uIGZyaWVuZGx5TmFtZSgpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnc2Vjb25kc2NyZWVuJywgICdmcmllbmRseU5hbWUnLCBhcmd1bWVudHMsIGZhbHNlLCB0cnVlKVxufVxuXG5mdW5jdGlvbiBTZWNvbmRTY3JlZW5fbGlzdGVuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5saXN0ZW4oJ3NlY29uZHNjcmVlbicsIC4uLmFyZ3MpXG59IFxuXG5mdW5jdGlvbiBTZWNvbmRTY3JlZW5fb25jZSguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMub25jZSgnc2Vjb25kc2NyZWVuJywgLi4uYXJncylcbn1cblxuZnVuY3Rpb24gU2Vjb25kU2NyZWVuX2NsZWFyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5jbGVhcignc2Vjb25kc2NyZWVuJywgLi4uYXJncylcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTZWNvbmRTY3JlZW4gPSAoe1xuXG4gIGV2ZW50czoge1xuICAgIGxhdW5jaFJlcXVlc3Q6J2xhdW5jaFJlcXVlc3QnLFxuICAgIGNsb3NlUmVxdWVzdDonY2xvc2VSZXF1ZXN0JyxcbiAgICBmcmllbmRseU5hbWVDaGFuZ2VkOidmcmllbmRseU5hbWVDaGFuZ2VkJ1xuICB9LFxucHJvdG9jb2xzLFxuICBkZXZpY2UsXG4gIGZyaWVuZGx5TmFtZSxcbiAgbGlzdGVuOiBTZWNvbmRTY3JlZW5fbGlzdGVuLFxuICBvbmNlOiBTZWNvbmRTY3JlZW5fb25jZSxcbiAgY2xlYXI6IFNlY29uZFNjcmVlbl9jbGVhclxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvUGxhdGZvcm0vaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5cbi8vIHB1YmxpYyBBUElcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUGxhdGZvcm0gPSAoe1xuICBMb2NhbGl6YXRpb246IExvY2FsaXphdGlvbixcbiAgRGV2aWNlOiBEZXZpY2UsXG4gIEFjY2Vzc2liaWxpdHk6IEFjY2Vzc2liaWxpdHksXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0xvZy9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuY29uc3QgcHJlcExvZyA9ICh0eXBlLCBhcmdzKSA9PiB7XG4gIGNvbnN0IGNvbG9ycyA9IHtcbiAgICBJbmZvOiAnZ3JlZW4nLFxuICAgIERlYnVnOiAnZ3JheScsXG4gICAgV2FybjogJ29yYW5nZScsXG4gICAgRXJyb3I6ICdyZWQnLFxuICB9XG5cbiAgYXJncyA9IEFycmF5LmZyb20oYXJncylcbiAgcmV0dXJuIFtcbiAgICAnJWMnICsgKGFyZ3MubGVuZ3RoID4gMSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgPyBhcmdzLnNoaWZ0KCkgOiB0eXBlKSxcbiAgICAnYmFja2dyb3VuZC1jb2xvcjogJyArIGNvbG9yc1t0eXBlXSArICc7IGNvbG9yOiB3aGl0ZTsgcGFkZGluZzogMnB4IDRweDsgYm9yZGVyLXJhZGl1czogMnB4JyxcbiAgICBhcmdzLFxuICBdXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTG9nID0gKHtcbiAgaW5mbygpIHtcbiAgICBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ2xvZycpICYmIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIHByZXBMb2coJ0luZm8nLCBhcmd1bWVudHMpKVxuICB9LFxuICBkZWJ1ZygpIHtcbiAgICBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ2xvZycpICYmIGNvbnNvbGUuZGVidWcuYXBwbHkoY29uc29sZSwgcHJlcExvZygnRGVidWcnLCBhcmd1bWVudHMpKVxuICB9LFxuICBlcnJvcigpIHtcbiAgICBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ2xvZycpICYmIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgcHJlcExvZygnRXJyb3InLCBhcmd1bWVudHMpKVxuICB9LFxuICB3YXJuKCkge1xuICAgIFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnbG9nJykgJiYgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIHByZXBMb2coJ1dhcm4nLCBhcmd1bWVudHMpKVxuICB9LFxufSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0FjY2Vzc2liaWxpdHkgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnlxO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BY2NvdW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5tUjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWR2ZXJ0aXNpbmcgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlpMO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BdXRoZW50aWNhdGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uVnk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0RldmljZSA9IF9fd2VicGFja19leHBvcnRzX18uQVM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Rpc2NvdmVyeSA9IF9fd2VicGFja19leHBvcnRzX18uUEc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0V2ZW50cyA9IF9fd2VicGFja19leHBvcnRzX18uelc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0tleWJvYXJkID0gX193ZWJwYWNrX2V4cG9ydHNfXy5OMTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTGlmZWN5Y2xlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5GdztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTG9jYWxpemF0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5XSDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTG9nID0gX193ZWJwYWNrX2V4cG9ydHNfXy5aYjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTWV0cmljcyA9IF9fd2VicGFja19leHBvcnRzX18uQzM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BhcmFtZXRlcnMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmFFO1xudmFyIF9fd2VicGFja19leHBvcnRzX19QbGF0Zm9ybSA9IF9fd2VicGFja19leHBvcnRzX18udDQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Byb2ZpbGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk5aO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TZWNvbmRTY3JlZW4gPSBfX3dlYnBhY2tfZXhwb3J0c19fLl9GO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TZXR0aW5ncyA9IF9fd2VicGFja19leHBvcnRzX18uWnI7XG5leHBvcnQgeyBfX3dlYnBhY2tfZXhwb3J0c19fQWNjZXNzaWJpbGl0eSBhcyBBY2Nlc3NpYmlsaXR5LCBfX3dlYnBhY2tfZXhwb3J0c19fQWNjb3VudCBhcyBBY2NvdW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQWR2ZXJ0aXNpbmcgYXMgQWR2ZXJ0aXNpbmcsIF9fd2VicGFja19leHBvcnRzX19BdXRoZW50aWNhdGlvbiBhcyBBdXRoZW50aWNhdGlvbiwgX193ZWJwYWNrX2V4cG9ydHNfX0RldmljZSBhcyBEZXZpY2UsIF9fd2VicGFja19leHBvcnRzX19EaXNjb3ZlcnkgYXMgRGlzY292ZXJ5LCBfX3dlYnBhY2tfZXhwb3J0c19fRXZlbnRzIGFzIEV2ZW50cywgX193ZWJwYWNrX2V4cG9ydHNfX0tleWJvYXJkIGFzIEtleWJvYXJkLCBfX3dlYnBhY2tfZXhwb3J0c19fTGlmZWN5Y2xlIGFzIExpZmVjeWNsZSwgX193ZWJwYWNrX2V4cG9ydHNfX0xvY2FsaXphdGlvbiBhcyBMb2NhbGl6YXRpb24sIF9fd2VicGFja19leHBvcnRzX19Mb2cgYXMgTG9nLCBfX3dlYnBhY2tfZXhwb3J0c19fTWV0cmljcyBhcyBNZXRyaWNzLCBfX3dlYnBhY2tfZXhwb3J0c19fUGFyYW1ldGVycyBhcyBQYXJhbWV0ZXJzLCBfX3dlYnBhY2tfZXhwb3J0c19fUGxhdGZvcm0gYXMgUGxhdGZvcm0sIF9fd2VicGFja19leHBvcnRzX19Qcm9maWxlIGFzIFByb2ZpbGUsIF9fd2VicGFja19leHBvcnRzX19TZWNvbmRTY3JlZW4gYXMgU2Vjb25kU2NyZWVuLCBfX3dlYnBhY2tfZXhwb3J0c19fU2V0dGluZ3MgYXMgU2V0dGluZ3MgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlyZWJvbHQuanMubWFwIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IGxuZyBmcm9tICcuL3NyYy9saWdodG5pbmcubWpzJztcbmV4cG9ydCBkZWZhdWx0IGxuZztcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgQWRzIH0gZnJvbSAnLi9zcmMvQWRzJ1xuZXhwb3J0IHsgQXBwRGF0YSB9IGZyb20gJy4vc3JjL0FwcGxpY2F0aW9uJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBcHBsaWNhdGlvbiB9IGZyb20gJy4vc3JjL0FwcGxpY2F0aW9uJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBdWRpb1BsYXllciB9IGZyb20gJy4vc3JjL0F1ZGlvUGxheWVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb2xvcnMgfSBmcm9tICcuL3NyYy9Db2xvcnMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIEltZyB9IGZyb20gJy4vc3JjL0ltZydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgS2V5Ym9hcmQgfSBmcm9tICcuL3NyYy9LZXlib2FyZCdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGF1bmNoIH0gZnJvbSAnLi9zcmMvTGF1bmNoJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaWdodG5pbmcgfSBmcm9tICcuL3NyYy9MaWdodG5pbmcnXG5leHBvcnQgeyBkZWZhdWx0IGFzIExvY2FsZSB9IGZyb20gJy4vc3JjL0xvY2FsZSdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGFuZ3VhZ2UgfSBmcm9tICcuL3NyYy9MYW5ndWFnZSdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTG9nIH0gZnJvbSAnLi9zcmMvTG9nJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNZWRpYVBsYXllciB9IGZyb20gJy4vc3JjL01lZGlhUGxheWVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNZXRyaWNzIH0gZnJvbSAnLi9zcmMvTWV0cmljcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGluIH0gZnJvbSAnLi9zcmMvUGluJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQcm9maWxlIH0gZnJvbSAnLi9zcmMvUHJvZmlsZSdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHVyY2hhc2UgfSBmcm9tICcuL3NyYy9QdXJjaGFzZSdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmVnaXN0cnkgfSBmcm9tICcuL3NyYy9SZWdpc3RyeSdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUm91dGVyIH0gZnJvbSAnLi9zcmMvUm91dGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZXR0aW5ncyB9IGZyb20gJy4vc3JjL1NldHRpbmdzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdG9yYWdlIH0gZnJvbSAnLi9zcmMvU3RvcmFnZSdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVFYgfSBmcm9tICcuL3NyYy9UVidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVXRpbHMgfSBmcm9tICcuL3NyYy9VdGlscydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVmlkZW9QbGF5ZXIgfSBmcm9tICcuL3NyYy9WaWRlb1BsYXllcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWV0YWRhdGEgfSBmcm9tICcuL3NyYy9NZXRhZGF0YSdcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBMb2cgZnJvbSAnLi4vTG9nJ1xuaW1wb3J0IHsgbWVkaWFVcmwgfSBmcm9tICcuLi9WaWRlb1BsYXllcidcblxubGV0IGNvbnN1bWVyXG5cbmxldCBnZXRBZHMgPSAoKSA9PiB7XG4gIC8vIHRvZG86IGVuYWJsZSBzb21lIGRlZmF1bHQgYWRzIGR1cmluZyBkZXZlbG9wbWVudCwgbWF5YmUgZnJvbSB0aGUgc2V0dGluZ3MuanNvblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICBwcmVyb2xsczogW10sXG4gICAgbWlkcm9sbHM6IFtdLFxuICAgIHBvc3Ryb2xsczogW10sXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBpbml0QWRzID0gY29uZmlnID0+IHtcbiAgaWYgKGNvbmZpZy5nZXRBZHMpIHtcbiAgICBnZXRBZHMgPSBjb25maWcuZ2V0QWRzXG4gIH1cbn1cblxuY29uc3Qgc3RhdGUgPSB7XG4gIGFjdGl2ZTogZmFsc2UsXG59XG5cbmNvbnN0IHBsYXlTbG90ID0gKHNsb3QgPSBbXSkgPT4ge1xuICByZXR1cm4gc2xvdC5yZWR1Y2UoKHByb21pc2UsIGFkKSA9PiB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gcGxheUFkKGFkKVxuICAgIH0pXG4gIH0sIFByb21pc2UucmVzb2x2ZShudWxsKSlcbn1cblxuY29uc3QgcGxheUFkID0gYWQgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgaWYgKHN0YXRlLmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgIExvZy5pbmZvKCdBZCcsICdTa2lwcGluZyBhZGQgZHVlIHRvIGluYWN0aXZlIHN0YXRlJylcbiAgICAgIHJldHVybiByZXNvbHZlKClcbiAgICB9XG4gICAgLy8gaXMgaXQgc2FmZSB0byByZWx5IG9uIHZpZGVvcGxheWVyIHBsdWdpbiBhbHJlYWR5IGNyZWF0ZWQgdGhlIHZpZGVvIHRhZz9cbiAgICBjb25zdCB2aWRlb0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJylbMF1cbiAgICB2aWRlb0VsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgdmlkZW9FbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgdmlkZW9FbC5zcmMgPSBtZWRpYVVybChhZC51cmwpXG4gICAgdmlkZW9FbC5sb2FkKClcblxuICAgIGxldCB0aW1lRXZlbnRzID0gbnVsbFxuICAgIGxldCB0aW1lb3V0XG5cbiAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgLy8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnNcbiAgICAgIE9iamVjdC5rZXlzKGhhbmRsZXJzKS5mb3JFYWNoKGhhbmRsZXIgPT5cbiAgICAgICAgdmlkZW9FbC5yZW1vdmVFdmVudExpc3RlbmVyKGhhbmRsZXIsIGhhbmRsZXJzW2hhbmRsZXJdKVxuICAgICAgKVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgcGxheSgpIHtcbiAgICAgICAgTG9nLmluZm8oJ0FkJywgJ1BsYXkgYWQnLCBhZC51cmwpXG4gICAgICAgIGZpcmVPbkNvbnN1bWVyKCdQbGF5JywgYWQpXG4gICAgICAgIHNlbmRCZWFjb24oYWQuY2FsbGJhY2tzLCAnZGVmYXVsdEltcHJlc3Npb24nKVxuICAgICAgfSxcbiAgICAgIGVuZGVkKCkge1xuICAgICAgICBmaXJlT25Db25zdW1lcignRW5kZWQnLCBhZClcbiAgICAgICAgc2VuZEJlYWNvbihhZC5jYWxsYmFja3MsICdjb21wbGV0ZScpXG4gICAgICAgIGNsZWFudXAoKVxuICAgICAgfSxcbiAgICAgIHRpbWV1cGRhdGUoKSB7XG4gICAgICAgIGlmICghdGltZUV2ZW50cyAmJiB2aWRlb0VsLmR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHdoZW4gdG8gZmlyZSB0aGUgdGltZSBiYXNlZCBldmVudHMgKG5vdyB0aGF0IGR1cmF0aW9uIGlzIGtub3duKVxuICAgICAgICAgIHRpbWVFdmVudHMgPSB7XG4gICAgICAgICAgICBmaXJzdFF1YXJ0aWxlOiB2aWRlb0VsLmR1cmF0aW9uIC8gNCxcbiAgICAgICAgICAgIG1pZFBvaW50OiB2aWRlb0VsLmR1cmF0aW9uIC8gMixcbiAgICAgICAgICAgIHRoaXJkUXVhcnRpbGU6ICh2aWRlb0VsLmR1cmF0aW9uIC8gNCkgKiAzLFxuICAgICAgICAgIH1cbiAgICAgICAgICBMb2cuaW5mbygnQWQnLCAnQ2FsY3VsYXRlZCBxdWFydGlsZXMgdGltZXMnLCB7IHRpbWVFdmVudHMgfSlcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGltZUV2ZW50cyAmJlxuICAgICAgICAgIHRpbWVFdmVudHMuZmlyc3RRdWFydGlsZSAmJlxuICAgICAgICAgIHZpZGVvRWwuY3VycmVudFRpbWUgPj0gdGltZUV2ZW50cy5maXJzdFF1YXJ0aWxlXG4gICAgICAgICkge1xuICAgICAgICAgIGZpcmVPbkNvbnN1bWVyKCdGaXJzdFF1YXJ0aWxlJywgYWQpXG4gICAgICAgICAgZGVsZXRlIHRpbWVFdmVudHMuZmlyc3RRdWFydGlsZVxuICAgICAgICAgIHNlbmRCZWFjb24oYWQuY2FsbGJhY2tzLCAnZmlyc3RRdWFydGlsZScpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVFdmVudHMgJiYgdGltZUV2ZW50cy5taWRQb2ludCAmJiB2aWRlb0VsLmN1cnJlbnRUaW1lID49IHRpbWVFdmVudHMubWlkUG9pbnQpIHtcbiAgICAgICAgICBmaXJlT25Db25zdW1lcignTWlkUG9pbnQnLCBhZClcbiAgICAgICAgICBkZWxldGUgdGltZUV2ZW50cy5taWRQb2ludFxuICAgICAgICAgIHNlbmRCZWFjb24oYWQuY2FsbGJhY2tzLCAnbWlkUG9pbnQnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aW1lRXZlbnRzICYmXG4gICAgICAgICAgdGltZUV2ZW50cy50aGlyZFF1YXJ0aWxlICYmXG4gICAgICAgICAgdmlkZW9FbC5jdXJyZW50VGltZSA+PSB0aW1lRXZlbnRzLnRoaXJkUXVhcnRpbGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ1RoaXJkUXVhcnRpbGUnLCBhZClcbiAgICAgICAgICBkZWxldGUgdGltZUV2ZW50cy50aGlyZFF1YXJ0aWxlXG4gICAgICAgICAgc2VuZEJlYWNvbihhZC5jYWxsYmFja3MsICd0aGlyZFF1YXJ0aWxlJylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0YWxsZWQoKSB7XG4gICAgICAgIGZpcmVPbkNvbnN1bWVyKCdTdGFsbGVkJywgYWQpXG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjbGVhbnVwKClcbiAgICAgICAgfSwgNTAwMCkgLy8gbWFrZSB0aW1lb3V0IGNvbmZpZ3VyYWJsZVxuICAgICAgfSxcbiAgICAgIGNhbnBsYXkoKSB7XG4gICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICB9LFxuICAgICAgZXJyb3IoKSB7XG4gICAgICAgIGZpcmVPbkNvbnN1bWVyKCdFcnJvcicsIGFkKVxuICAgICAgICBjbGVhbnVwKClcbiAgICAgIH0sXG4gICAgICAvLyB0aGlzIGRvZXNuJ3Qgd29yayByZWxpYWJseSBvbiBza3kgYm94LCBtb3ZlZCBsb2dpYyB0byB0aW1lVXBkYXRlIGV2ZW50XG4gICAgICAvLyBsb2FkZWRtZXRhZGF0YSgpIHtcbiAgICAgIC8vICAgLy8gY2FsY3VsYXRlIHdoZW4gdG8gZmlyZSB0aGUgdGltZSBiYXNlZCBldmVudHMgKG5vdyB0aGF0IGR1cmF0aW9uIGlzIGtub3duKVxuICAgICAgLy8gICB0aW1lRXZlbnRzID0ge1xuICAgICAgLy8gICAgIGZpcnN0UXVhcnRpbGU6IHZpZGVvRWwuZHVyYXRpb24gLyA0LFxuICAgICAgLy8gICAgIG1pZFBvaW50OiB2aWRlb0VsLmR1cmF0aW9uIC8gMixcbiAgICAgIC8vICAgICB0aGlyZFF1YXJ0aWxlOiAodmlkZW9FbC5kdXJhdGlvbiAvIDQpICogMyxcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfSxcbiAgICAgIGFib3J0KCkge1xuICAgICAgICBjbGVhbnVwKClcbiAgICAgIH0sXG4gICAgICAvLyB0b2RvOiBwYXVzZSwgcmVzdW1lLCBtdXRlLCB1bm11dGUgYmVhY29uc1xuICAgIH1cbiAgICAvLyBhZGQgYWxsIGxpc3RlbmVyc1xuICAgIE9iamVjdC5rZXlzKGhhbmRsZXJzKS5mb3JFYWNoKGhhbmRsZXIgPT4gdmlkZW9FbC5hZGRFdmVudExpc3RlbmVyKGhhbmRsZXIsIGhhbmRsZXJzW2hhbmRsZXJdKSlcblxuICAgIHZpZGVvRWwucGxheSgpXG4gIH0pXG59XG5cbmNvbnN0IHNlbmRCZWFjb24gPSAoY2FsbGJhY2tzLCBldmVudCkgPT4ge1xuICBpZiAoY2FsbGJhY2tzICYmIGNhbGxiYWNrc1tldmVudF0pIHtcbiAgICBMb2cuaW5mbygnQWQnLCAnU2VuZGluZyBiZWFjb24nLCBldmVudCwgY2FsbGJhY2tzW2V2ZW50XSlcbiAgICByZXR1cm4gY2FsbGJhY2tzW2V2ZW50XS5yZWR1Y2UoKHByb21pc2UsIHVybCkgPT4ge1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoKSA9PlxuICAgICAgICBmZXRjaCh1cmwpXG4gICAgICAgICAgLy8gYWx3YXlzIHJlc29sdmUsIGFsc28gaW4gY2FzZSBvZiBhIGZldGNoIGVycm9yIChzbyB3ZSBkb24ndCBibG9jayBmaXJpbmcgdGhlIHJlc3Qgb2YgdGhlIGJlYWNvbnMgZm9yIHRoaXMgZXZlbnQpXG4gICAgICAgICAgLy8gbm90ZTogZm9yIGZldGNoIGZhaWxlZCBodHRwIHJlc3BvbnNlcyBkb24ndCB0aHJvdyBhbiBFcnJvciA6KVxuICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICBmaXJlT25Db25zdW1lcignQmVhY29uJyArIGV2ZW50ICsgJ1NlbnQnKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ0JlYWNvbicgKyBldmVudCArICdGYWlsZWQnICsgcmVzcG9uc2Uuc3RhdHVzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpXG4gICAgICAgICAgfSlcbiAgICAgIClcbiAgICB9LCBQcm9taXNlLnJlc29sdmUobnVsbCkpXG4gIH0gZWxzZSB7XG4gICAgTG9nLmluZm8oJ0FkJywgJ05vIGNhbGxiYWNrIGZvdW5kIGZvciAnICsgZXZlbnQpXG4gIH1cbn1cblxuY29uc3QgZmlyZU9uQ29uc3VtZXIgPSAoZXZlbnQsIGFyZ3MpID0+IHtcbiAgaWYgKGNvbnN1bWVyKSB7XG4gICAgY29uc3VtZXIuZmlyZSgnJGFkJyArIGV2ZW50LCBhcmdzKVxuICAgIGNvbnN1bWVyLmZpcmUoJyRhZEV2ZW50JywgZXZlbnQsIGFyZ3MpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXQoY29uZmlnLCB2aWRlb1BsYXllckNvbnN1bWVyKSB7XG4gICAgaWYgKGNvbmZpZy5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHByZXJvbGxzKCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9XG4gICAgY29uc3VtZXIgPSB2aWRlb1BsYXllckNvbnN1bWVyXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBMb2cuaW5mbygnQWQnLCAnU3RhcnRpbmcgc2Vzc2lvbicpXG4gICAgICBnZXRBZHMoY29uZmlnKS50aGVuKGFkcyA9PiB7XG4gICAgICAgIExvZy5pbmZvKCdBZCcsICdBUEkgcmVzdWx0JywgYWRzKVxuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBwcmVyb2xscygpIHtcbiAgICAgICAgICAgIGlmIChhZHMucHJlcm9sbCkge1xuICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmUgPSB0cnVlXG4gICAgICAgICAgICAgIGZpcmVPbkNvbnN1bWVyKCdQcmVyb2xsU2xvdEltcHJlc3Npb24nLCBhZHMpXG4gICAgICAgICAgICAgIHNlbmRCZWFjb24oYWRzLnByZXJvbGwuY2FsbGJhY2tzLCAnc2xvdEltcHJlc3Npb24nKVxuICAgICAgICAgICAgICByZXR1cm4gcGxheVNsb3QoYWRzLnByZXJvbGwuYWRzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBmaXJlT25Db25zdW1lcignUHJlcm9sbFNsb3RFbmQnLCBhZHMpXG4gICAgICAgICAgICAgICAgc2VuZEJlYWNvbihhZHMucHJlcm9sbC5jYWxsYmFja3MsICdzbG90RW5kJylcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmUgPSBmYWxzZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtaWRyb2xscygpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9zdHJvbGxzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcbiAgY2FuY2VsKCkge1xuICAgIExvZy5pbmZvKCdBZCcsICdDYW5jZWwgQWQnKVxuICAgIHN0YXRlLmFjdGl2ZSA9IGZhbHNlXG4gIH0sXG4gIHN0b3AoKSB7XG4gICAgTG9nLmluZm8oJ0FkJywgJ1N0b3AgQWQnKVxuICAgIHN0YXRlLmFjdGl2ZSA9IGZhbHNlXG4gICAgLy8gZml4bWU6IGR1cGxpY2F0aW9uXG4gICAgY29uc3QgdmlkZW9FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd2aWRlbycpWzBdXG4gICAgdmlkZW9FbC5wYXVzZSgpXG4gICAgdmlkZW9FbC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpXG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVlcG1lcmdlIGZyb20gJ2RlZXBtZXJnZSdcbmltcG9ydCBMaWdodG5pbmcgZnJvbSAnLi4vTGlnaHRuaW5nJ1xuaW1wb3J0IExvY2FsZSBmcm9tICcuLi9Mb2NhbGUnXG5pbXBvcnQgTWV0cmljcyBmcm9tICcuLi9NZXRyaWNzJ1xuaW1wb3J0IFZlcnNpb25MYWJlbCBmcm9tICcuLi9WZXJzaW9uTGFiZWwnXG5pbXBvcnQgRnBzQ291bnRlciBmcm9tICcuLi9GcHNDb3VudGVyJ1xuaW1wb3J0IExvZyBmcm9tICcuLi9Mb2cnXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5pbXBvcnQgeyBpbml0TGFuZ3VhZ2UgfSBmcm9tICcuLi9MYW5ndWFnZSdcbmltcG9ydCBVdGlscyBmcm9tICcuLi9VdGlscydcbmltcG9ydCBSZWdpc3RyeSBmcm9tICcuLi9SZWdpc3RyeSdcbmltcG9ydCB7IGluaXRDb2xvcnMgfSBmcm9tICcuLi9Db2xvcnMnXG5cbmltcG9ydCBwYWNrYWdlSW5mbyBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nXG5cbmV4cG9ydCBsZXQgQXBwSW5zdGFuY2VcbmV4cG9ydCBsZXQgQXBwRGF0YVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgc3RhZ2U6IHsgdzogMTkyMCwgaDogMTA4MCwgY2xlYXJDb2xvcjogMHgwMDAwMDAwMCwgY2FudmFzMmQ6IGZhbHNlIH0sXG4gIGRlYnVnOiBmYWxzZSxcbiAgZGVmYXVsdEZvbnRGYWNlOiAnUm9ib3RvUmVndWxhcicsXG4gIGtleXM6IHtcbiAgICA4OiAnQmFjaycsXG4gICAgMTM6ICdFbnRlcicsXG4gICAgMjc6ICdNZW51JyxcbiAgICAzNzogJ0xlZnQnLFxuICAgIDM4OiAnVXAnLFxuICAgIDM5OiAnUmlnaHQnLFxuICAgIDQwOiAnRG93bicsXG4gICAgMTc0OiAnQ2hhbm5lbERvd24nLFxuICAgIDE3NTogJ0NoYW5uZWxVcCcsXG4gICAgMTc4OiAnU3RvcCcsXG4gICAgMjUwOiAnUGxheVBhdXNlJyxcbiAgICAxOTE6ICdTZWFyY2gnLCAvLyBVc2UgXCIvXCIgZm9yIGtleWJvYXJkXG4gICAgNDA5OiAnU2VhcmNoJyxcbiAgfSxcbn1cblxuY29uc3QgY3VzdG9tRm9udEZhY2VzID0gW11cblxuY29uc3QgZm9udExvYWRlciA9IChmb250cywgc3RvcmUpID0+XG4gIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmb250c1xuICAgICAgLm1hcCgoeyBmYW1pbHksIHVybCwgdXJscywgZGVzY3JpcHRvcnMgfSkgPT4gKCkgPT4ge1xuICAgICAgICBjb25zdCBzcmMgPSB1cmxzXG4gICAgICAgICAgPyB1cmxzLm1hcCh1cmwgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gJ3VybCgnICsgdXJsICsgJyknXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogJ3VybCgnICsgdXJsICsgJyknXG4gICAgICAgIGNvbnN0IGZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKGZhbWlseSwgc3JjLCBkZXNjcmlwdG9ycyB8fCB7fSlcbiAgICAgICAgc3RvcmUucHVzaChmb250RmFjZSlcbiAgICAgICAgTG9nLmluZm8oJ0xvYWRpbmcgZm9udCcsIGZhbWlseSlcbiAgICAgICAgZG9jdW1lbnQuZm9udHMuYWRkKGZvbnRGYWNlKVxuICAgICAgICByZXR1cm4gZm9udEZhY2UubG9hZCgpXG4gICAgICB9KVxuICAgICAgLnJlZHVjZSgocHJvbWlzZSwgbWV0aG9kKSA9PiB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKCkgPT4gbWV0aG9kKCkpXG4gICAgICB9LCBQcm9taXNlLnJlc29sdmUobnVsbCkpXG4gICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgLmNhdGNoKHJlamVjdClcbiAgfSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oQXBwLCBhcHBEYXRhLCBwbGF0Zm9ybVNldHRpbmdzKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcGxhdGZvcm1TZXR0aW5nc1xuXG4gIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5zdGFnZVsndyddID0gd2lkdGhcbiAgICBkZWZhdWx0T3B0aW9ucy5zdGFnZVsnaCddID0gaGVpZ2h0XG4gICAgZGVmYXVsdE9wdGlvbnMuc3RhZ2VbJ3ByZWNpc2lvbiddID0gd2lkdGggLyAxOTIwXG4gIH1cblxuICAvLyBzdXBwb3J0IGZvciA3MjBwIGJyb3dzZXJcbiAgaWYgKCF3aWR0aCAmJiAhaGVpZ2h0ICYmIHdpbmRvdy5pbm5lckhlaWdodCA9PT0gNzIwKSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuc3RhZ2VbJ3cnXSA9IDEyODBcbiAgICBkZWZhdWx0T3B0aW9ucy5zdGFnZVsnaCddID0gNzIwXG4gICAgZGVmYXVsdE9wdGlvbnMuc3RhZ2VbJ3ByZWNpc2lvbiddID0gMTI4MCAvIDE5MjBcbiAgfVxuXG4gIHJldHVybiBjbGFzcyBBcHBsaWNhdGlvbiBleHRlbmRzIExpZ2h0bmluZy5BcHBsaWNhdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgY29uc3QgY29uZmlnID0gRGVlcG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuICAgICAgLy8gRGVlcG1lcmdlIGJyZWFrcyBIVE1MQ2FudmFzRWxlbWVudCwgc28gcmVzdG9yZSB0aGUgcGFzc2VkIGluIGNhbnZhcy5cbiAgICAgIGlmIChvcHRpb25zLnN0YWdlLmNhbnZhcykge1xuICAgICAgICBjb25maWcuc3RhZ2UuY2FudmFzID0gb3B0aW9ucy5zdGFnZS5jYW52YXNcbiAgICAgIH1cbiAgICAgIHN1cGVyKGNvbmZpZylcbiAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnXG4gICAgfVxuXG4gICAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHc6IDE5MjAsXG4gICAgICAgIGg6IDEwODAsXG4gICAgICB9XG4gICAgfVxuXG4gICAgX3NldHVwKCkge1xuICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLmxvYWRGb250cygoQXBwLmNvbmZpZyAmJiBBcHAuY29uZmlnLmZvbnRzKSB8fCAoQXBwLmdldEZvbnRzICYmIEFwcC5nZXRGb250cygpKSB8fCBbXSksXG4gICAgICAgIC8vIHRvIGJlIGRlcHJlY2F0ZWRcbiAgICAgICAgTG9jYWxlLmxvYWQoKEFwcC5jb25maWcgJiYgQXBwLmNvbmZpZy5sb2NhbGUpIHx8IChBcHAuZ2V0TG9jYWxlICYmIEFwcC5nZXRMb2NhbGUoKSkpLFxuICAgICAgICBBcHAubGFuZ3VhZ2UgJiYgdGhpcy5sb2FkTGFuZ3VhZ2UoQXBwLmxhbmd1YWdlKCkpLFxuICAgICAgICBBcHAuY29sb3JzICYmIHRoaXMubG9hZENvbG9ycyhBcHAuY29sb3JzKCkpLFxuICAgICAgXSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIE1ldHJpY3MuYXBwLmxvYWRlZCgpXG5cbiAgICAgICAgICBBcHBEYXRhID0gYXBwRGF0YVxuXG4gICAgICAgICAgQXBwSW5zdGFuY2UgPSB0aGlzLnN0YWdlLmMoe1xuICAgICAgICAgICAgcmVmOiAnQXBwJyxcbiAgICAgICAgICAgIHR5cGU6IEFwcCxcbiAgICAgICAgICAgIHpJbmRleDogMSxcbiAgICAgICAgICAgIGZvcmNlWkluZGV4Q29udGV4dDogISFwbGF0Zm9ybVNldHRpbmdzLnNob3dWZXJzaW9uIHx8ICEhcGxhdGZvcm1TZXR0aW5ncy5zaG93RnBzLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICB0aGlzLmNoaWxkTGlzdC5hKEFwcEluc3RhbmNlKVxuXG4gICAgICAgICAgdGhpcy5fcmVmb2N1cygpXG5cbiAgICAgICAgICBMb2cuaW5mbygnQXBwIHZlcnNpb24nLCB0aGlzLmNvbmZpZy52ZXJzaW9uKVxuICAgICAgICAgIExvZy5pbmZvKCdTREsgdmVyc2lvbicsIHBhY2thZ2VJbmZvLnZlcnNpb24pXG5cbiAgICAgICAgICBpZiAocGxhdGZvcm1TZXR0aW5ncy5zaG93VmVyc2lvbikge1xuICAgICAgICAgICAgdGhpcy5jaGlsZExpc3QuYSh7XG4gICAgICAgICAgICAgIHJlZjogJ1ZlcnNpb25MYWJlbCcsXG4gICAgICAgICAgICAgIHR5cGU6IFZlcnNpb25MYWJlbCxcbiAgICAgICAgICAgICAgdmVyc2lvbjogdGhpcy5jb25maWcudmVyc2lvbixcbiAgICAgICAgICAgICAgc2RrVmVyc2lvbjogcGFja2FnZUluZm8udmVyc2lvbixcbiAgICAgICAgICAgICAgekluZGV4OiAxLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGxhdGZvcm1TZXR0aW5ncy5zaG93RnBzKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkTGlzdC5hKHtcbiAgICAgICAgICAgICAgcmVmOiAnRnBzQ291bnRlcicsXG4gICAgICAgICAgICAgIHR5cGU6IEZwc0NvdW50ZXIsXG4gICAgICAgICAgICAgIHpJbmRleDogMSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3VwZXIuX3NldHVwKClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpXG4gICAgfVxuXG4gICAgX2hhbmRsZUJhY2soKSB7XG4gICAgICB0aGlzLmNsb3NlQXBwKClcbiAgICB9XG5cbiAgICBfaGFuZGxlRXhpdCgpIHtcbiAgICAgIHRoaXMuY2xvc2VBcHAoKVxuICAgIH1cblxuICAgIGNsb3NlQXBwKCkge1xuICAgICAgTG9nLmluZm8oJ1NpZ25hbGluZyBBcHAgQ2xvc2UnKVxuXG4gICAgICBpZiAocGxhdGZvcm1TZXR0aW5ncy5vbkNsb3NlICYmIHR5cGVvZiBwbGF0Zm9ybVNldHRpbmdzLm9uQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGxhdGZvcm1TZXR0aW5ncy5vbkNsb3NlKC4uLmFyZ3VtZW50cylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgTG9nLmluZm8oJ0Nsb3NpbmcgQXBwJylcblxuICAgICAgU2V0dGluZ3MuY2xlYXJTdWJzY3JpYmVycygpXG4gICAgICBSZWdpc3RyeS5jbGVhcigpXG5cbiAgICAgIHRoaXMuY2hpbGRMaXN0LnJlbW92ZSh0aGlzLnRhZygnQXBwJykpXG4gICAgICB0aGlzLmNsZWFudXBGb250cygpXG4gICAgICAvLyBmb3JjZSB0ZXh0dXJlIGdhcmJhZ2UgY29sbGVjdFxuICAgICAgdGhpcy5zdGFnZS5nYygpXG4gICAgICB0aGlzLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIGxvYWRGb250cyhmb250cykge1xuICAgICAgcmV0dXJuIHBsYXRmb3JtU2V0dGluZ3MuZm9udExvYWRlciAmJiB0eXBlb2YgcGxhdGZvcm1TZXR0aW5ncy5mb250TG9hZGVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGxhdGZvcm1TZXR0aW5ncy5mb250TG9hZGVyKGZvbnRzLCBjdXN0b21Gb250RmFjZXMpXG4gICAgICAgIDogZm9udExvYWRlcihmb250cywgY3VzdG9tRm9udEZhY2VzKVxuICAgIH1cblxuICAgIGNsZWFudXBGb250cygpIHtcbiAgICAgIGlmICgnZGVsZXRlJyBpbiBkb2N1bWVudC5mb250cykge1xuICAgICAgICBjdXN0b21Gb250RmFjZXMuZm9yRWFjaChmb250RmFjZSA9PiB7XG4gICAgICAgICAgTG9nLmluZm8oJ1JlbW92aW5nIGZvbnQnLCBmb250RmFjZS5mYW1pbHkpXG4gICAgICAgICAgZG9jdW1lbnQuZm9udHMuZGVsZXRlKGZvbnRGYWNlKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTG9nLmluZm8oJ05vIHN1cHBvcnQgZm9yIHJlbW92aW5nIG1hbnVhbGx5LWFkZGVkIGZvbnRzJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsb2FkTGFuZ3VhZ2UoY29uZmlnKSB7XG4gICAgICBsZXQgZmlsZSA9IFV0aWxzLmFzc2V0KCd0cmFuc2xhdGlvbnMuanNvbicpXG4gICAgICBsZXQgbGFuZ3VhZ2UgPSBjb25maWdcblxuICAgICAgaWYgKHR5cGVvZiBsYW5ndWFnZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbGFuZ3VhZ2UgPSBjb25maWcubGFuZ3VhZ2UgfHwgbnVsbFxuICAgICAgICBmaWxlID0gY29uZmlnLmZpbGUgfHwgZmlsZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5pdExhbmd1YWdlKGZpbGUsIGxhbmd1YWdlKVxuICAgIH1cblxuICAgIGxvYWRDb2xvcnMoY29uZmlnKSB7XG4gICAgICBsZXQgZmlsZSA9IFV0aWxzLmFzc2V0KCdjb2xvcnMuanNvbicpXG4gICAgICBpZiAoY29uZmlnICYmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgZmlsZSA9IGNvbmZpZ1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluaXRDb2xvcnMoZmlsZSlcbiAgICB9XG5cbiAgICBzZXQgZm9jdXModikge1xuICAgICAgdGhpcy5fZm9jdXNzZWQgPSB2XG4gICAgICB0aGlzLl9yZWZvY3VzKClcbiAgICB9XG5cbiAgICBfZ2V0Rm9jdXNlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mb2N1c3NlZCB8fCB0aGlzLnRhZygnQXBwJylcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1ZGlvUGxheWVyIHt9XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcbmltcG9ydCB7IG1lcmdlQ29sb3JzLCBjYWxjdWxhdGVBbHBoYSwgaXNPYmplY3QsIGlzU3RyaW5nLCBhcmdiVG9IU0xBLCBoc2xhVG9BUkdCIH0gZnJvbSAnLi91dGlscy5qcydcblxubGV0IGNvbG9ycyA9IHtcbiAgd2hpdGU6ICcjZmZmZmZmJyxcbiAgYmxhY2s6ICcjMDAwMDAwJyxcbiAgcmVkOiAnI2ZmMDAwMCcsXG4gIGdyZWVuOiAnIzAwZmYwMCcsXG4gIGJsdWU6ICcjMDAwMGZmJyxcbiAgeWVsbG93OiAnI2ZlZmYwMCcsXG4gIGN5YW46ICcjMDBmZWZmJyxcbiAgbWFnZW50YTogJyNmZjAwZmYnLFxufVxuXG5jb25zdCBub3JtYWxpemVkQ29sb3JzID0ge1xuICAvL3N0b3JlIGZvciBub3JtYWxpemVkIGNvbG9yc1xufVxuXG5jb25zdCBhZGRDb2xvcnMgPSAoY29sb3JzVG9BZGQsIHZhbHVlKSA9PiB7XG4gIGlmIChpc09iamVjdChjb2xvcnNUb0FkZCkpIHtcbiAgICAvLyBjbGVhbiB1cCBub3JtYWxpemVkQ29sb3JzIGlmIHRoZXkgZXhpc3QgaW4gdGhlIHRvIGJlIGFkZGVkIGNvbG9yc1xuICAgIE9iamVjdC5rZXlzKGNvbG9yc1RvQWRkKS5mb3JFYWNoKGNvbG9yID0+IGNsZWFuVXBOb3JtYWxpemVkQ29sb3JzKGNvbG9yKSlcbiAgICBjb2xvcnMgPSBPYmplY3QuYXNzaWduKHt9LCBjb2xvcnMsIGNvbG9yc1RvQWRkKVxuICB9IGVsc2UgaWYgKGlzU3RyaW5nKGNvbG9yc1RvQWRkKSAmJiB2YWx1ZSkge1xuICAgIGNsZWFuVXBOb3JtYWxpemVkQ29sb3JzKGNvbG9yc1RvQWRkKVxuICAgIGNvbG9yc1tjb2xvcnNUb0FkZF0gPSB2YWx1ZVxuICB9XG59XG5cbmNvbnN0IGNsZWFuVXBOb3JtYWxpemVkQ29sb3JzID0gY29sb3IgPT4ge1xuICBmb3IgKGxldCBjIGluIG5vcm1hbGl6ZWRDb2xvcnMpIHtcbiAgICBpZiAoYy5pbmRleE9mKGNvbG9yKSA+IC0xKSB7XG4gICAgICBkZWxldGUgbm9ybWFsaXplZENvbG9yc1tjXVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaW5pdENvbG9ycyA9IGZpbGUgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGFkZENvbG9ycyhmaWxlKVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuICAgIGZldGNoKGZpbGUpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAudGhlbihqc29uID0+IHtcbiAgICAgICAgYWRkQ29sb3JzKGpzb24pXG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gJ0NvbG9ycyBmaWxlICcgKyBmaWxlICsgJyBub3QgZm91bmQnXG4gICAgICAgIExvZy5lcnJvcihlcnJvcilcbiAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgfSlcbiAgfSlcbn1cblxuY29uc3Qgbm9ybWFsaXplQ29sb3JUb0FSR0IgPSBjb2xvciA9PiB7XG4gIGxldCB0YXJnZXRDb2xvciA9IG5vcm1hbGl6ZWRDb2xvcnNbY29sb3JdIHx8IGNvbG9yc1tjb2xvcl0gfHwgY29sb3JcbiAgaWYgKCF0YXJnZXRDb2xvcikge1xuICAgIHRhcmdldENvbG9yID0gY29sb3JcbiAgfVxuICBjb25zdCBjaGVjayA9IC9eIyhbMC05QS1GXXszfXxbMC05QS1GXXs2fSkkL2lcbiAgaWYgKGlzU3RyaW5nKHRhcmdldENvbG9yKSAmJiBjaGVjay50ZXN0KHRhcmdldENvbG9yKSkge1xuICAgIGxldCBoZXggPSBjaGVjay5leGVjKHRhcmdldENvbG9yKVsxXVxuICAgIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XG4gICAgICBoZXggPSBoZXhcbiAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAubWFwKHZhbHVlID0+IHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgKyB2YWx1ZVxuICAgICAgICB9KVxuICAgICAgICAuam9pbignJylcbiAgICB9XG4gICAgdGFyZ2V0Q29sb3IgPSBgMHhmZiR7aGV4fWAgKiAxXG4gIH1cbiAgaWYgKCFub3JtYWxpemVkQ29sb3JzW2NvbG9yXSkge1xuICAgIG5vcm1hbGl6ZWRDb2xvcnNbY29sb3JdID0gdGFyZ2V0Q29sb3JcbiAgfVxuICByZXR1cm4gdGFyZ2V0Q29sb3IgfHwgMHhmZmZmZmZmZlxufVxuXG5leHBvcnQgZGVmYXVsdCBjb2xvciA9PiB7XG4gIHJldHVybiBDb2xvci5nZW5lcmF0ZShjb2xvcilcbn1cblxuY29uc3QgQ29sb3IgPSB7XG4gIGNvbG9yOiBudWxsLFxuICBnZW5lcmF0ZTogZnVuY3Rpb24odmFsdWUgPSB0aGlzLmNvbG9yKSB7XG4gICAgaWYgKG5vcm1hbGl6ZWRDb2xvcnNbdmFsdWVdKSB7XG4gICAgICB0aGlzLmNvbG9yID0gbm9ybWFsaXplZENvbG9yc1t2YWx1ZV1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2xvciA9IG5vcm1hbGl6ZUNvbG9yVG9BUkdCKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JcbiAgfSxcbiAgYWxwaGE6IGZ1bmN0aW9uKHBlcmNlbnRhZ2UpIHtcbiAgICB0aGlzLmNvbG9yID0gY2FsY3VsYXRlQWxwaGEodGhpcy5jb2xvciwgTWF0aC5hYnMocGVyY2VudGFnZSkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbiAgZGFya2VyKHBlcmNlbnRhZ2UpIHtcbiAgICBjb25zdCBoc2wgPSBhcmdiVG9IU0xBKHRoaXMuY29sb3IpXG4gICAgaHNsLmwgPSBoc2wubCAqICgxIC0gcGVyY2VudGFnZSlcbiAgICB0aGlzLmNvbG9yID0gaHNsYVRvQVJHQihoc2wpXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbiAgbGlnaHRlcihwZXJjZW50YWdlKSB7XG4gICAgY29uc3QgaHNsID0gYXJnYlRvSFNMQSh0aGlzLmNvbG9yKVxuICAgIGhzbC5sID0gaHNsLmwgKyAoMSAtIGhzbC5sKSAqIHBlcmNlbnRhZ2VcbiAgICB0aGlzLmNvbG9yID0gaHNsYVRvQVJHQihoc2wpXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbiAgc2F0dXJhdGlvbihwZXJjZW50YWdlKSB7XG4gICAgY29uc3QgaHNsID0gYXJnYlRvSFNMQSh0aGlzLmNvbG9yKVxuICAgIGhzbC5zID0gcGVyY2VudGFnZVxuICAgIHRoaXMuY29sb3IgPSBoc2xhVG9BUkdCKGhzbClcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICBsaWdodG5lc3MocGVyY2VudGFnZSkge1xuICAgIGNvbnN0IGhzbCA9IGFyZ2JUb0hTTEEodGhpcy5jb2xvcilcbiAgICBoc2wubCA9IHBlcmNlbnRhZ2VcbiAgICB0aGlzLmNvbG9yID0gaHNsYVRvQVJHQihoc2wpXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbiAgaHVlKGRlZ3JlZXMpIHtcbiAgICBjb25zdCBoc2wgPSBhcmdiVG9IU0xBKHRoaXMuY29sb3IpXG4gICAgaHNsLmggPSBkZWdyZWVzXG4gICAgdGhpcy5jb2xvciA9IGhzbGFUb0FSR0IoaHNsKVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIG1peChhcmdiLCBwKSB7XG4gICAgdGhpcy5jb2xvciA9IG1lcmdlQ29sb3JzKHRoaXMuY29sb3IsIGFyZ2IsIHApXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBpc09iamVjdCA9IHYgPT4ge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGxcbn1cblxuZXhwb3J0IGNvbnN0IGlzU3RyaW5nID0gdiA9PiB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZydcbn1cblxuZXhwb3J0IGNvbnN0IGdldFJnYmFDb21wb25lbnRzID0gYXJnYiA9PiB7XG4gIHJldHVybiB7XG4gICAgcjogKChhcmdiIC8gNjU1MzYpIHwgMCkgJSAyNTYsXG4gICAgZzogKChhcmdiIC8gMjU2KSB8IDApICUgMjU2LFxuICAgIGI6IChhcmdiICogMSkgJSAyNTYsXG4gICAgYTogKGFyZ2IgLyAxNjc3NzIxNikgfCAwLFxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBsaW1pdFdpdGhpblJhbmdlID0gKG51bSwgbWluLCBtYXgpID0+IHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG51bSwgbWluKSwgbWF4KVxufVxuXG5leHBvcnQgY29uc3QgbWVyZ2VDb2xvcnMgPSAoYzEsIGMyLCBwKSA9PiB7XG4gIGxldCByMSA9ICgoYzEgLyA2NTUzNikgfCAwKSAlIDI1NlxuICBsZXQgZzEgPSAoKGMxIC8gMjU2KSB8IDApICUgMjU2XG4gIGxldCBiMSA9IGMxICUgMjU2XG4gIGxldCBhMSA9IChjMSAvIDE2Nzc3MjE2KSB8IDBcbiAgbGV0IHIyID0gKChjMiAvIDY1NTM2KSB8IDApICUgMjU2XG4gIGxldCBnMiA9ICgoYzIgLyAyNTYpIHwgMCkgJSAyNTZcbiAgbGV0IGIyID0gYzIgJSAyNTZcbiAgbGV0IGEyID0gKGMyIC8gMTY3NzcyMTYpIHwgMFxuICBsZXQgciA9IHIxICogcCArIHIyICogKDEgLSBwKVxuICBsZXQgZyA9IGcxICogcCArIGcyICogKDEgLSBwKVxuICBsZXQgYiA9IGIxICogcCArIGIyICogKDEgLSBwKVxuICBsZXQgYSA9IGExICogcCArIGEyICogKDEgLSBwKVxuICByZXR1cm4gTWF0aC5yb3VuZChhKSAqIDE2Nzc3MjE2ICsgTWF0aC5yb3VuZChyKSAqIDY1NTM2ICsgTWF0aC5yb3VuZChnKSAqIDI1NiArIE1hdGgucm91bmQoYilcbn1cblxuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZUFscGhhID0gKGFyZ2IsIHApID0+IHtcbiAgaWYgKHAgPiAxKSB7XG4gICAgcCAvPSAxMDBcbiAgfSBlbHNlIGlmIChwIDwgMCkge1xuICAgIHAgPSAwXG4gIH1cbiAgbGV0IHIgPSAoKGFyZ2IgLyA2NTUzNikgfCAwKSAlIDI1NlxuICBsZXQgZyA9ICgoYXJnYiAvIDI1NikgfCAwKSAlIDI1NlxuICBsZXQgYiA9IGFyZ2IgJSAyNTZcbiAgcmV0dXJuIChyIDw8IDE2KSArIChnIDw8IDgpICsgYiArICgocCAqIDI1NSkgfCAwKSAqIDE2Nzc3MjE2XG59XG5cbmV4cG9ydCBjb25zdCBtZXJnZUNvbG9yQWxwaGEgPSAoYywgYWxwaGEpID0+IHtcbiAgbGV0IGEgPSAoKChjIC8gMTY3NzcyMTYpIHwgMCkgKiBhbHBoYSkgfCAwXG4gIHJldHVybiAoXG4gICAgKCgoKChjID4+IDE2KSAmIDB4ZmYpICogYSkgLyAyNTUpICYgMHhmZikgK1xuICAgICgoKChjICYgMHhmZjAwKSAqIGEpIC8gMjU1KSAmIDB4ZmYwMCkgK1xuICAgICgoKCgoYyAmIDB4ZmYpIDw8IDE2KSAqIGEpIC8gMjU1KSAmIDB4ZmYwMDAwKSArXG4gICAgKGEgPDwgMjQpXG4gIClcbn1cblxuY29uc3QgZ2V0QXJnYk51bWJlciA9IHJnYmEgPT4ge1xuICByZ2JhWzBdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2JhWzBdKSlcbiAgcmdiYVsxXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiYVsxXSkpXG4gIHJnYmFbMl0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYmFbMl0pKVxuICByZ2JhWzNdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2JhWzNdKSlcbiAgbGV0IHYgPSAoKHJnYmFbM10gfCAwKSA8PCAyNCkgKyAoKHJnYmFbMF0gfCAwKSA8PCAxNikgKyAoKHJnYmFbMV0gfCAwKSA8PCA4KSArIChyZ2JhWzJdIHwgMClcbiAgaWYgKHYgPCAwKSB7XG4gICAgdiA9IDB4ZmZmZmZmZmYgKyB2ICsgMVxuICB9XG4gIHJldHVybiB2XG59XG5cbmV4cG9ydCBjb25zdCBhcmdiVG9Ic3ZhID0gYXJnYiA9PiB7XG4gIGNvbnN0IGNvbG9yID0gZ2V0UmdiYUNvbXBvbmVudHMoYXJnYilcbiAgbGV0IHIgPSBjb2xvci5yIC8gMjU1XG4gIGxldCBnID0gY29sb3IuZyAvIDI1NVxuICBsZXQgYiA9IGNvbG9yLmIgLyAyNTVcbiAgbGV0IGggPSAwXG4gIGxldCBzID0gMFxuXG4gIGNvbnN0IGNNYXggPSBNYXRoLm1heChyLCBnLCBiKVxuICBjb25zdCBjTWluID0gTWF0aC5taW4ociwgZywgYilcbiAgY29uc3QgZGVsdGEgPSBjTWF4IC0gY01pblxuXG4gIC8vY2FsY3VsYXRlIGh1ZVxuICBpZiAoZGVsdGEgPCAwLjAwMDAxKSB7XG4gICAgaCA9IDBcbiAgfSBlbHNlIGlmIChjTWF4ICE9PSAwIHx8IGNNaW4gIT09IDApIHtcbiAgICBpZiAociA9PT0gY01heCkge1xuICAgICAgaCA9ICg2MCAqICgoZyAtIGIpIC8gZGVsdGEpICsgMzYwKSAlIDM2MFxuICAgIH0gZWxzZSBpZiAoZyA9PT0gY01heCkge1xuICAgICAgaCA9ICg2MCAqICgoYiAtIHIpIC8gZGVsdGEpICsgMTIwKSAlIDM2MFxuICAgIH0gZWxzZSBpZiAoYiA9PT0gY01heCkge1xuICAgICAgaCA9ICg2MCAqICgociAtIGcpIC8gZGVsdGEpICsgMjQwKSAlIDM2MFxuICAgIH1cbiAgfVxuXG4gIC8vY2FsYyBzYXR1cmF0aW9uXG4gIGlmIChjTWF4ID4gMCkge1xuICAgIHMgPSBkZWx0YSAvIGNNYXhcbiAgfVxuICByZXR1cm4ge1xuICAgIGgsXG4gICAgcyxcbiAgICB2OiBjTWF4LFxuICAgIGE6IGNvbG9yLmEgLyAyNTUsXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGhzdmFUb0FyZ2IgPSBjb2xvciA9PiB7XG4gIGNvbnN0IGggPSBjb2xvci5oXG4gIGNvbnN0IGMgPSBjb2xvci52ICogY29sb3Iuc1xuICBjb25zdCBtID0gY29sb3IudiAtIGNcbiAgY29uc3QgeCA9IGMgKiAoMS4wIC0gTWF0aC5hYnMoKChoIC8gNjApICUgMikgLSAxKSlcbiAgbGV0IHIgPSAwXG4gIGxldCBnID0gMFxuICBsZXQgYiA9IDBcblxuICBpZiAoMCA8PSBoICYmIGggPCA2MCkge1xuICAgIHIgPSBjXG4gICAgZyA9IHhcbiAgfSBlbHNlIGlmICg2MCA8PSBoICYmIGggPCAxMjApIHtcbiAgICByID0geFxuICAgIGcgPSBjXG4gIH0gZWxzZSBpZiAoMTIwIDw9IGggJiYgaCA8IDE4MCkge1xuICAgIGcgPSBjXG4gICAgYiA9IHhcbiAgfSBlbHNlIGlmICgxODAgPD0gaCAmJiBoIDwgMjQwKSB7XG4gICAgZyA9IHhcbiAgICBiID0gY1xuICB9IGVsc2UgaWYgKDI0MCA8PSBoICYmIGggPCAzMDApIHtcbiAgICByID0geFxuICAgIGIgPSBjXG4gIH0gZWxzZSBpZiAoMzAwIDw9IGggJiYgaCA8IDM2MCkge1xuICAgIHIgPSBjXG4gICAgYiA9IHhcbiAgfVxuXG4gIHIgPSBNYXRoLnJvdW5kKChyICsgbSkgKiAyNTUuMClcbiAgZyA9IE1hdGgucm91bmQoKGcgKyBtKSAqIDI1NS4wKVxuICBiID0gTWF0aC5yb3VuZCgoYiArIG0pICogMjU1LjApXG4gIHJldHVybiBnZXRBcmdiTnVtYmVyKFtyLCBnLCBiLCBjb2xvci5hICogMjU1XSlcbn1cblxuZXhwb3J0IGNvbnN0IGFyZ2JUb0hTTEEgPSBhcmdiID0+IHtcbiAgY29uc3QgY29sID0gZ2V0UmdiYUNvbXBvbmVudHMoYXJnYilcbiAgY29uc3QgciA9IGNvbC5yIC8gMjU1XG4gIGNvbnN0IGcgPSBjb2wuZyAvIDI1NVxuICBjb25zdCBiID0gY29sLmIgLyAyNTVcblxuICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKVxuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKVxuXG4gIGxldCBoID0gMFxuICBsZXQgcyA9IDBcbiAgY29uc3QgbCA9IChtaW4gKyBtYXgpICogMC41XG4gIGlmIChsID4gMCkge1xuICAgIGNvbnN0IG1heE1pbiA9IG1heCAtIG1pblxuICAgIGlmIChtYXhNaW4gPiAwKSB7XG4gICAgICBjb25zdCByMiA9IChtYXggLSByKSAvIG1heE1pblxuICAgICAgY29uc3QgZzIgPSAobWF4IC0gZykgLyBtYXhNaW5cbiAgICAgIGNvbnN0IGIyID0gKG1heCAtIGIpIC8gbWF4TWluXG4gICAgICBpZiAobCA8IDAuNSkge1xuICAgICAgICBzID0gbWF4ICsgbWluXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gMiAtIG1heCAtIG1pblxuICAgICAgfVxuXG4gICAgICBpZiAociA9PT0gbWF4ICYmIGcgPT09IG1pbikge1xuICAgICAgICBoID0gNS4wICsgYjJcbiAgICAgIH0gZWxzZSBpZiAociA9PT0gbWF4KSB7XG4gICAgICAgIGggPSAxLjAgLSBnMlxuICAgICAgfSBlbHNlIGlmIChnID09PSBtYXggJiYgYiA9PT0gbWluKSB7XG4gICAgICAgIGggPSAxLjAgKyByMlxuICAgICAgfSBlbHNlIGlmIChnID09PSBtYXgpIHtcbiAgICAgICAgaCA9IDMuMCAtIGIyXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IG1heCkge1xuICAgICAgICBoID0gMy4wICsgZzJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSA1LjAgLSByMlxuICAgICAgfVxuICAgICAgaCA9IGggLyA2XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGg6IGggJSAxLCBzLCBsLCBhOiBjb2wuYSB9XG59XG5cbmV4cG9ydCBjb25zdCBoc2xhVG9BUkdCID0gaHNsYSA9PiB7XG4gIGxldCByID0gMVxuICBsZXQgZyA9IDFcbiAgbGV0IGIgPSAxXG5cbiAgbGV0IGggPSBoc2xhLmhcbiAgbGV0IHMgPSBoc2xhLnNcbiAgbGV0IGwgPSBoc2xhLmxcblxuICBpZiAoaCA8IDApIHtcbiAgICBoICs9IDFcbiAgfVxuICBsZXQgbWF4ID0gMFxuICBpZiAobCA8PSAwLjUpIHtcbiAgICBtYXggPSBsICogKDEuMCArIHMpXG4gIH0gZWxzZSB7XG4gICAgbWF4ID0gbCArIHMgLSBsICogc1xuICB9XG5cbiAgaWYgKG1heCA+IDApIHtcbiAgICBoICo9IDYuMFxuICAgIGNvbnN0IG1pbiA9IGwgKyBsIC0gbWF4XG4gICAgY29uc3QgbWluTWF4ID0gKG1heCAtIG1pbikgLyBtYXhcbiAgICBjb25zdCBzZXh0YW50ID0gTWF0aC5mbG9vcihoKVxuICAgIGNvbnN0IGZyYWN0ID0gaCAtIHNleHRhbnRcbiAgICBjb25zdCBtaW5NYXhGcmFjdCA9IG1heCAqIG1pbk1heCAqIGZyYWN0XG4gICAgY29uc3QgbWlkMSA9IG1pbiArIG1pbk1heEZyYWN0XG4gICAgY29uc3QgbWlkMiA9IG1heCAtIG1pbk1heEZyYWN0XG5cbiAgICBpZiAoc2V4dGFudCA9PT0gMCkge1xuICAgICAgciA9IG1heFxuICAgICAgZyA9IG1pZDFcbiAgICAgIGIgPSBtaW5cbiAgICB9XG4gICAgaWYgKHNleHRhbnQgPT09IDEpIHtcbiAgICAgIHIgPSBtaWQyXG4gICAgICBnID0gbWF4XG4gICAgICBiID0gbWluXG4gICAgfVxuICAgIGlmIChzZXh0YW50ID09PSAyKSB7XG4gICAgICByID0gbWluXG4gICAgICBnID0gbWF4XG4gICAgICBiID0gbWlkMVxuICAgIH1cbiAgICBpZiAoc2V4dGFudCA9PT0gMykge1xuICAgICAgciA9IG1pblxuICAgICAgZyA9IG1pZDJcbiAgICAgIGIgPSBtYXhcbiAgICB9XG4gICAgaWYgKHNleHRhbnQgPT09IDQpIHtcbiAgICAgIHIgPSBtaWQxXG4gICAgICBnID0gbWluXG4gICAgICBiID0gbWF4XG4gICAgfVxuICAgIGlmIChzZXh0YW50ID09PSA1KSB7XG4gICAgICByID0gbWF4XG4gICAgICBnID0gbWluXG4gICAgICBiID0gbWlkMlxuICAgIH1cbiAgfVxuICByZXR1cm4gZ2V0QXJnYk51bWJlcihbTWF0aC5mbG9vcihyICogMjU1KSwgTWF0aC5mbG9vcihnICogMjU1KSwgTWF0aC5mbG9vcihiICogMjU1KSwgaHNsYS5hXSlcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBMaWdodG5pbmcgZnJvbSAnLi4vTGlnaHRuaW5nJ1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL1NldHRpbmdzJ1xuaW1wb3J0IExvZyBmcm9tICcuLi9Mb2cnXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGcHNJbmRpY2F0b3IgZXh0ZW5kcyBMaWdodG5pbmcuQ29tcG9uZW50IHtcbiAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjdDogdHJ1ZSxcbiAgICAgIGNvbG9yOiAweGZmZmZmZmZmLFxuICAgICAgdGV4dHVyZTogTGlnaHRuaW5nLlRvb2xzLmdldFJvdW5kUmVjdCg4MCwgODAsIDQwKSxcbiAgICAgIGg6IDgwLFxuICAgICAgdzogODAsXG4gICAgICB4OiAxMDAsXG4gICAgICB5OiAxMDAsXG4gICAgICBtb3VudDogMSxcbiAgICAgIEJhY2tncm91bmQ6IHtcbiAgICAgICAgeDogMyxcbiAgICAgICAgeTogMyxcbiAgICAgICAgdGV4dHVyZTogTGlnaHRuaW5nLlRvb2xzLmdldFJvdW5kUmVjdCg3MiwgNzIsIDM2KSxcbiAgICAgICAgY29sb3I6IDB4ZmYwMDgwMDAsXG4gICAgICB9LFxuICAgICAgQ291bnRlcjoge1xuICAgICAgICB3OiB3ID0+IHcsXG4gICAgICAgIGg6IGggPT4gaCxcbiAgICAgICAgeTogMTAsXG4gICAgICAgIHRleHQ6IHtcbiAgICAgICAgICBmb250U2l6ZTogMzIsXG4gICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBUZXh0OiB7XG4gICAgICAgIHc6IHcgPT4gdyxcbiAgICAgICAgaDogaCA9PiBoLFxuICAgICAgICB5OiA0OCxcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgIGZvbnRTaXplOiAxNSxcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIHRleHQ6ICdGUFMnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9XG4gIH1cblxuICBfc2V0dXAoKSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi57XG4gICAgICAgIGxvZzogZmFsc2UsXG4gICAgICAgIGludGVydmFsOiA1MDAsXG4gICAgICAgIHRocmVzaG9sZDogMSxcbiAgICAgIH0sXG4gICAgICAuLi5TZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ3Nob3dGcHMnKSxcbiAgICB9XG5cbiAgICB0aGlzLmZwcyA9IDBcbiAgICB0aGlzLmxhc3RGcHMgPSB0aGlzLmZwcyAtIHRoaXMuY29uZmlnLnRocmVzaG9sZFxuXG4gICAgY29uc3QgZnBzQ2FsY3VsYXRvciA9ICgpID0+IHtcbiAgICAgIHRoaXMuZnBzID0gfn4oMSAvIHRoaXMuc3RhZ2UuZHQpXG4gICAgfVxuICAgIHRoaXMuc3RhZ2Uub24oJ2ZyYW1lU3RhcnQnLCBmcHNDYWxjdWxhdG9yKVxuICAgIHRoaXMuc3RhZ2Uub2ZmKCdmcmFtZXN0YXJ0JywgZnBzQ2FsY3VsYXRvcilcbiAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy5zaG93RnBzLmJpbmQodGhpcyksIHRoaXMuY29uZmlnLmludGVydmFsKVxuICB9XG5cbiAgX2ZpcnN0QWN0aXZlKCkge1xuICAgIHRoaXMuc2hvd0ZwcygpXG4gIH1cblxuICBfZGV0YWNoKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbClcbiAgfVxuXG4gIHNob3dGcHMoKSB7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMubGFzdEZwcyAtIHRoaXMuZnBzKSA8PSB0aGlzLmNvbmZpZy50aHJlc2hvbGQpIHJldHVyblxuICAgIHRoaXMubGFzdEZwcyA9IHRoaXMuZnBzXG4gICAgLy8gZ3JlZW5cbiAgICBsZXQgYmdDb2xvciA9IDB4ZmYwMDgwMDBcbiAgICAvLyBvcmFuZ2VcbiAgICBpZiAodGhpcy5mcHMgPD0gNDAgJiYgdGhpcy5mcHMgPiAyMCkgYmdDb2xvciA9IDB4ZmZmZmE1MDBcbiAgICAvLyByZWRcbiAgICBlbHNlIGlmICh0aGlzLmZwcyA8PSAyMCkgYmdDb2xvciA9IDB4ZmZmZjAwMDBcblxuICAgIHRoaXMudGFnKCdCYWNrZ3JvdW5kJykuc2V0U21vb3RoKCdjb2xvcicsIGJnQ29sb3IpXG4gICAgdGhpcy50YWcoJ0NvdW50ZXInKS50ZXh0ID0gYCR7dGhpcy5mcHN9YFxuXG4gICAgdGhpcy5jb25maWcubG9nICYmIExvZy5pbmZvKCdGUFMnLCB0aGlzLmZwcylcbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExpZ2h0bmluZyBmcm9tICcuLi9MaWdodG5pbmcnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYWxlZEltYWdlVGV4dHVyZSBleHRlbmRzIExpZ2h0bmluZy50ZXh0dXJlcy5JbWFnZVRleHR1cmUge1xuICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgIHN1cGVyKHN0YWdlKVxuICAgIHRoaXMuX3NjYWxpbmdPcHRpb25zID0gdW5kZWZpbmVkXG4gIH1cblxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5yZXNpemVNb2RlID0gdGhpcy5fc2NhbGluZ09wdGlvbnMgPSBvcHRpb25zXG4gIH1cblxuICBfZ2V0TG9va3VwSWQoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuX3NyY30tJHt0aGlzLl9zY2FsaW5nT3B0aW9ucy50eXBlfS0ke3RoaXMuX3NjYWxpbmdPcHRpb25zLnd9LSR7dGhpcy5fc2NhbGluZ09wdGlvbnMuaH1gXG4gIH1cblxuICBnZXROb25EZWZhdWx0cygpIHtcbiAgICBjb25zdCBvYmogPSBzdXBlci5nZXROb25EZWZhdWx0cygpXG4gICAgaWYgKHRoaXMuX3NyYykge1xuICAgICAgb2JqLnNyYyA9IHRoaXMuX3NyY1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBVdGlscyBmcm9tICcuLi9VdGlscydcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi9TZXR0aW5ncydcbmltcG9ydCBTY2FsZWRJbWFnZVRleHR1cmUgZnJvbSAnLi9TY2FsZWRJbWFnZVRleHR1cmUnXG5cbmV4cG9ydCBkZWZhdWx0IChpbWFnZVVybCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBpbWFnZVNlcnZlclVybCA9IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnaW1hZ2VTZXJ2ZXJVcmwnKVxuXG4gIC8vIG1ha2UgYW5kIHJldHVybiBTY2FsZWRJbWFnZVRleHR1cmVcbiAgY29uc3QgbWFrZSA9IG9wdGlvbnMgPT4ge1xuICAgIC8vIGxvY2FsIGFzc2V0LCB3cmFwIGl0IGluIFV0aWxzLmFzc2V0KClcbiAgICBpZiAoIS9eKD86aHR0cHM/Oik/XFwvXFwvL2kudGVzdChpbWFnZVVybCkpIHtcbiAgICAgIGltYWdlVXJsID0gVXRpbHMuYXNzZXQoaW1hZ2VVcmwpXG4gICAgfVxuXG4gICAgLy8gb25seSBwYXNzIHRvIGltYWdlIHNlcnZlciBpZiBpbWFnZVNlcnZlclVybCBpcyBjb25maWd1cmVkXG4gICAgLy8gYW5kIGlmIHRoZSBhc3NldCBpc24ndCBsb2NhbCB0byB0aGUgYXBwIChpLmUuIGhhcyBzYW1lIG9yaWdpbilcbiAgICBpZiAoaW1hZ2VTZXJ2ZXJVcmwgJiYgaW1hZ2VVcmwuaW5kZXhPZih3aW5kb3cubG9jYXRpb24ub3JpZ2luKSA9PT0gLTEpIHtcbiAgICAgIGltYWdlVXJsID0gVXRpbHMuZW5zdXJlVXJsV2l0aFByb3RvY29sKFxuICAgICAgICBpbWFnZVNlcnZlclVybCArICc/JyArIFV0aWxzLm1ha2VRdWVyeVN0cmluZyhpbWFnZVVybCwgb3B0aW9ucylcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlnaHRuaW5nIHdpbGwgaGFuZGxlIHRoZSByZXNpemluZyBhbmQgaGFzIG9ubHkgMiBmbGF2b3VycyAoY292ZXIgYW5kIGNvbnRhaW4pXG4gICAgICBpZiAob3B0aW9ucy50eXBlID09PSAnY3JvcCcpIG9wdGlvbnMudHlwZSA9ICdjb3ZlcidcbiAgICAgIGVsc2Ugb3B0aW9ucy50eXBlID0gJ2NvbnRhaW4nXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFNjYWxlZEltYWdlVGV4dHVyZSxcbiAgICAgIHNyYzogaW1hZ2VVcmwsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgIH1cbiAgfVxuXG4gIC8vIG1lcmdlIG9wdGlvbnMgd2l0aCBkZWZhdWx0XG4gIGNvbnN0IHNldE9wdGlvbnMgPSBvcHRpb25zID0+IHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgLi4ue1xuICAgICAgICB0eXBlOiAnY29udGFpbicsXG4gICAgICAgIHc6IDAsXG4gICAgICAgIGg6IDAsXG4gICAgICB9LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VRdWFsaXR5ID0gTWF0aC5tYXgoXG4gICAgICAwLjEsXG4gICAgICBNYXRoLm1pbigxLCAocGFyc2VGbG9hdChTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ2ltYWdlLnF1YWxpdHknKSkgfHwgMTAwKSAvIDEwMClcbiAgICApXG5cbiAgICBvcHRpb25zLncgPSBvcHRpb25zLncgKiBpbWFnZVF1YWxpdHlcbiAgICBvcHRpb25zLmggPSBvcHRpb25zLmggKiBpbWFnZVF1YWxpdHlcbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgLy8gaWYgb3B0aW9ucyBhcmUgcGFzc2VkLCByZXR1cm4gc2NhbGVkIGltYWdlIHJpZ2h0IGF3YXlcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbWFrZShzZXRPcHRpb25zKG9wdGlvbnMpKVxuICB9XG5cbiAgLy8gb3RoZXJ3aXNlIHJldHVybiAnY2hhaW5lZCcgZnVuY3Rpb25zXG4gIHJldHVybiB7XG4gICAgLy8gb2ZmaWNpYWwgYXBpXG4gICAgZXhhY3Q6ICh3LCBoKSA9PiBtYWtlKHNldE9wdGlvbnMoeyB0eXBlOiAnZXhhY3QnLCB3LCBoIH0pKSxcbiAgICBsYW5kc2NhcGU6IHcgPT4gbWFrZShzZXRPcHRpb25zKHsgdHlwZTogJ2xhbmRzY2FwZScsIHcgfSkpLFxuICAgIHBvcnRyYWl0OiBoID0+IG1ha2Uoc2V0T3B0aW9ucyh7IHR5cGU6ICdwb3J0cmFpdCcsIGggfSkpLFxuICAgIGNvdmVyOiAodywgaCkgPT4gbWFrZShzZXRPcHRpb25zKHsgdHlwZTogJ2NvdmVyJywgdywgaCB9KSksXG4gICAgY29udGFpbjogKHcsIGgpID0+IG1ha2Uoc2V0T3B0aW9ucyh7IHR5cGU6ICdjb250YWluJywgdywgaCB9KSksXG4gICAgb3JpZ2luYWw6ICgpID0+IG1ha2Uoc2V0T3B0aW9ucyh7IHR5cGU6ICdjb250YWluJyB9KSksXG5cbiAgICAvLyB0b2RvOiBhZGQgcG9zaXRpb25pbmcgLSBpLmUuIHRvcCwgYm90dG9tLCBjZW50ZXIsIGxlZnQgZXRjLlxuICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCB7fVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExvZyBmcm9tICcuLi9Mb2cnXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vVXRpbHMnXG5cbmxldCBtZXRhID0ge31cbmxldCB0cmFuc2xhdGlvbnMgPSB7fVxubGV0IGxhbmd1YWdlID0gbnVsbFxubGV0IGRpY3Rpb25hcnkgPSBudWxsXG5cbmV4cG9ydCBjb25zdCBpbml0TGFuZ3VhZ2UgPSAoZmlsZSwgbGFuZ3VhZ2UgPSBudWxsKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZmV0Y2goZmlsZSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC50aGVuKGpzb24gPT4ge1xuICAgICAgICBzZXRUcmFuc2xhdGlvbnMoanNvbilcbiAgICAgICAgLy8gc2V0IGxhbmd1YWdlIChkaXJlY3RseSBvciBpbiBhIHByb21pc2UpXG4gICAgICAgIHR5cGVvZiBsYW5ndWFnZSA9PT0gJ29iamVjdCcgJiYgJ3RoZW4nIGluIGxhbmd1YWdlICYmIHR5cGVvZiBsYW5ndWFnZS50aGVuID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBsYW5ndWFnZVxuICAgICAgICAgICAgICAudGhlbihsYW5nID0+XG4gICAgICAgICAgICAgICAgc2V0TGFuZ3VhZ2UobGFuZylcbiAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICBMb2cuZXJyb3IoZSlcbiAgICAgICAgICAgICAgICByZWplY3QoZSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IHNldExhbmd1YWdlKGxhbmd1YWdlKVxuICAgICAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gJ0xhbmd1YWdlIGZpbGUgJyArIGZpbGUgKyAnIG5vdCBmb3VuZCdcbiAgICAgICAgTG9nLmVycm9yKGVycm9yKVxuICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICB9KVxuICB9KVxufVxuXG5jb25zdCBzZXRUcmFuc2xhdGlvbnMgPSBvYmogPT4ge1xuICBpZiAoJ21ldGEnIGluIG9iaikge1xuICAgIG1ldGEgPSB7IC4uLm9iai5tZXRhIH1cbiAgICBkZWxldGUgb2JqLm1ldGFcbiAgfVxuICB0cmFuc2xhdGlvbnMgPSBvYmpcbn1cblxuY29uc3QgZ2V0TGFuZ3VhZ2UgPSAoKSA9PiB7XG4gIHJldHVybiBsYW5ndWFnZVxufVxuXG5jb25zdCBzZXRMYW5ndWFnZSA9IGxuZyA9PiB7XG4gIGxhbmd1YWdlID0gbnVsbFxuICBkaWN0aW9uYXJ5ID0gbnVsbFxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKGxuZyBpbiB0cmFuc2xhdGlvbnMpIHtcbiAgICAgIGxhbmd1YWdlID0gbG5nXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgnbWFwJyBpbiBtZXRhICYmIGxuZyBpbiBtZXRhLm1hcCAmJiBtZXRhLm1hcFtsbmddIGluIHRyYW5zbGF0aW9ucykge1xuICAgICAgICBsYW5ndWFnZSA9IG1ldGEubWFwW2xuZ11cbiAgICAgIH0gZWxzZSBpZiAoJ2RlZmF1bHQnIGluIG1ldGEgJiYgbWV0YS5kZWZhdWx0IGluIHRyYW5zbGF0aW9ucykge1xuICAgICAgICBjb25zdCBlcnJvciA9XG4gICAgICAgICAgJ1RyYW5zbGF0aW9ucyBmb3IgTGFuZ3VhZ2UgJyArXG4gICAgICAgICAgbGFuZ3VhZ2UgK1xuICAgICAgICAgICcgbm90IGZvdW5kLiBVc2luZyBkZWZhdWx0IGxhbmd1YWdlICcgK1xuICAgICAgICAgIG1ldGEuZGVmYXVsdFxuICAgICAgICBMb2cud2FybihlcnJvcilcbiAgICAgICAgbGFuZ3VhZ2UgPSBtZXRhLmRlZmF1bHRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gJ1RyYW5zbGF0aW9ucyBmb3IgTGFuZ3VhZ2UgJyArIGxhbmd1YWdlICsgJyBub3QgZm91bmQuJ1xuICAgICAgICBMb2cuZXJyb3IoZXJyb3IpXG4gICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgIExvZy5pbmZvKCdTZXR0aW5nIGxhbmd1YWdlIHRvJywgbGFuZ3VhZ2UpXG5cbiAgICAgIGNvbnN0IHRyYW5zbGF0aW9uc09iaiA9IHRyYW5zbGF0aW9uc1tsYW5ndWFnZV1cbiAgICAgIGlmICh0eXBlb2YgdHJhbnNsYXRpb25zT2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICBkaWN0aW9uYXJ5ID0gdHJhbnNsYXRpb25zT2JqXG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHJhbnNsYXRpb25zT2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCB1cmwgPSBVdGlscy5hc3NldCh0cmFuc2xhdGlvbnNPYmopXG5cbiAgICAgICAgZmV0Y2godXJsKVxuICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgICAudGhlbihqc29uID0+IHtcbiAgICAgICAgICAgIC8vIHNhdmUgdGhlIHRyYW5zbGF0aW9ucyBmb3IgdGhpcyBsYW5ndWFnZSAodG8gcHJldmVudCBsb2FkaW5nIHR3aWNlKVxuICAgICAgICAgICAgdHJhbnNsYXRpb25zW2xhbmd1YWdlXSA9IGpzb25cbiAgICAgICAgICAgIGRpY3Rpb25hcnkgPSBqc29uXG4gICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gJ0Vycm9yIHdoaWxlIGZldGNoaW5nICcgKyB1cmxcbiAgICAgICAgICAgIExvZy5lcnJvcihlcnJvciwgZSlcbiAgICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICB0cmFuc2xhdGUoa2V5KSB7XG4gICAgbGV0IHJlcGxhY2VtZW50cyA9IFsuLi5hcmd1bWVudHNdLnNsaWNlKDEpXG5cbiAgICAvLyBubyByZXBsYWNlbWVudHMgc28ganVzdCB0cmFuc2xhdGVkIHN0cmluZ1xuICAgIGlmIChyZXBsYWNlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gKGRpY3Rpb25hcnkgJiYgZGljdGlvbmFyeVtrZXldKSB8fCBrZXlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlcGxhY2VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHJlcGxhY2VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVwbGFjZW1lbnRzID0gcmVwbGFjZW1lbnRzLnBvcCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhcbiAgICAgICAgLy8gbWFwcyBhcnJheSBpbnB1dCB0byBhbiBvYmplY3QgezA6ICdpdGVtMScsIDE6ICdpdGVtMid9XG4gICAgICAgIEFycmF5LmlzQXJyYXkocmVwbGFjZW1lbnRzKSA/IE9iamVjdC5hc3NpZ24oe30sIHJlcGxhY2VtZW50cykgOiByZXBsYWNlbWVudHNcbiAgICAgICkucmVkdWNlKCh0ZXh0LCByZXBsYWNlbWVudEtleSkgPT4ge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKFxuICAgICAgICAgIG5ldyBSZWdFeHAoJ3tcXFxccz8nICsgcmVwbGFjZW1lbnRLZXkgKyAnXFxcXHM/fScsICdnJyksXG4gICAgICAgICAgcmVwbGFjZW1lbnRzW3JlcGxhY2VtZW50S2V5XVxuICAgICAgICApXG4gICAgICB9LCAoZGljdGlvbmFyeSAmJiBkaWN0aW9uYXJ5W2tleV0pIHx8IGtleSlcbiAgICB9XG4gIH0sXG5cbiAgdHJhbnNsYXRpb25zKG9iaikge1xuICAgIHNldFRyYW5zbGF0aW9ucyhvYmopXG4gIH0sXG5cbiAgc2V0KGxhbmd1YWdlKSB7XG4gICAgcmV0dXJuIHNldExhbmd1YWdlKGxhbmd1YWdlKVxuICB9LFxuXG4gIGdldCgpIHtcbiAgICByZXR1cm4gZ2V0TGFuZ3VhZ2UoKVxuICB9LFxuXG4gIGF2YWlsYWJsZSgpIHtcbiAgICBjb25zdCBsYW5ndWFnZUtleXMgPSBPYmplY3Qua2V5cyh0cmFuc2xhdGlvbnMpXG4gICAgcmV0dXJuIGxhbmd1YWdlS2V5cy5tYXAoa2V5ID0+ICh7IGNvZGU6IGtleSwgbmFtZTogKG1ldGEubmFtZXMgJiYgbWV0YS5uYW1lc1trZXldKSB8fCBrZXkgfSkpXG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBpbml0VXRpbHMgfSBmcm9tICcuLi9VdGlscydcbmltcG9ydCB7IGluaXRQcm9maWxlIH0gZnJvbSAnLi4vUHJvZmlsZSdcbmltcG9ydCB7IGluaXRNZXRyaWNzIH0gZnJvbSAnLi4vTWV0cmljcydcbmltcG9ydCB7IGluaXRTZXR0aW5ncyB9IGZyb20gJy4uL1NldHRpbmdzJ1xuaW1wb3J0IHsgaW5pdE1lZGlhUGxheWVyIH0gZnJvbSAnLi4vTWVkaWFQbGF5ZXInXG5pbXBvcnQgeyBpbml0VmlkZW9QbGF5ZXIgfSBmcm9tICcuLi9WaWRlb1BsYXllcidcbmltcG9ydCB7IGluaXRTdG9yYWdlIH0gZnJvbSAnLi4vU3RvcmFnZSdcbmltcG9ydCB7IGluaXRBZHMgfSBmcm9tICcuLi9BZHMnXG5pbXBvcnQgeyBpbml0Um91dGVyIH0gZnJvbSAnLi4vUm91dGVyJ1xuaW1wb3J0IHsgaW5pdFRWIH0gZnJvbSAnLi4vVFYnXG5pbXBvcnQgeyBpbml0UHVyY2hhc2UgfSBmcm9tICcuLi9QdXJjaGFzZSdcbmltcG9ydCB7IGluaXRQaW4gfSBmcm9tICcuLi9QaW4nXG5pbXBvcnQgeyBpbml0TWV0YWRhdGEgfSBmcm9tICcuLi9NZXRhZGF0YSdcbmltcG9ydCBBcHBsaWNhdGlvbiBmcm9tICcuLi9BcHBsaWNhdGlvbidcblxuZXhwb3J0IGxldCBBcHBsaWNhdGlvbkluc3RhbmNlXG5cbmV4cG9ydCBkZWZhdWx0IChBcHAsIGFwcFNldHRpbmdzLCBwbGF0Zm9ybVNldHRpbmdzLCBhcHBEYXRhKSA9PiB7XG4gIGluaXRTZXR0aW5ncyhhcHBTZXR0aW5ncywgcGxhdGZvcm1TZXR0aW5ncylcbiAgaW5pdE1ldGFkYXRhKGFwcFNldHRpbmdzKVxuXG4gIGluaXRVdGlscyhwbGF0Zm9ybVNldHRpbmdzKVxuICBpbml0U3RvcmFnZSgpXG4gIC8vIEluaXRpYWxpemUgcGx1Z2luc1xuICBpZiAocGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zKSB7XG4gICAgcGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLnByb2ZpbGUgJiYgaW5pdFByb2ZpbGUocGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLnByb2ZpbGUpXG4gICAgcGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLm1ldHJpY3MgJiYgaW5pdE1ldHJpY3MocGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLm1ldHJpY3MpXG4gICAgcGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLm1lZGlhUGxheWVyICYmIGluaXRNZWRpYVBsYXllcihwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMubWVkaWFQbGF5ZXIpXG4gICAgcGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLm1lZGlhUGxheWVyICYmIGluaXRWaWRlb1BsYXllcihwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMubWVkaWFQbGF5ZXIpXG4gICAgcGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLmFkcyAmJiBpbml0QWRzKHBsYXRmb3JtU2V0dGluZ3MucGx1Z2lucy5hZHMpXG4gICAgcGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLnJvdXRlciAmJiBpbml0Um91dGVyKHBsYXRmb3JtU2V0dGluZ3MucGx1Z2lucy5yb3V0ZXIpXG4gICAgcGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLnR2ICYmIGluaXRUVihwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMudHYpXG4gICAgcGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLnB1cmNoYXNlICYmIGluaXRQdXJjaGFzZShwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMucHVyY2hhc2UpXG4gICAgcGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLnBpbiAmJiBpbml0UGluKHBsYXRmb3JtU2V0dGluZ3MucGx1Z2lucy5waW4pXG4gIH1cblxuICBjb25zdCBhcHAgPSBBcHBsaWNhdGlvbihBcHAsIGFwcERhdGEsIHBsYXRmb3JtU2V0dGluZ3MpXG4gIEFwcGxpY2F0aW9uSW5zdGFuY2UgPSBuZXcgYXBwKGFwcFNldHRpbmdzKVxuICByZXR1cm4gQXBwbGljYXRpb25JbnN0YW5jZVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExpZ2h0bmluZyBmcm9tICdAbGlnaHRuaW5nanMvY29yZSdcbmV4cG9ydCBkZWZhdWx0IExpZ2h0bmluZ1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBTaW1wbGUgbW9kdWxlIGZvciBsb2NhbGl6YXRpb24gb2Ygc3RyaW5ncy5cbiAqXG4gKiBIb3cgdG8gdXNlOlxuICogMS4gQ3JlYXRlIGxvY2FsaXphdGlvbiBmaWxlIHdpdGggZm9sbG93aW5nIEpTT04gZm9ybWF0OlxuICoge1xuICogICBcImVuXCIgOntcbiAqICAgICBcImhvd1wiOiBcIkhvdyBkbyB5b3Ugd2FudCB5b3VyIGVnZyB0b2RheT9cIixcbiAqICAgICBcImJvaWxlZEVnZ1wiOiBcIkJvaWxlZCBlZ2dcIixcbiAqICAgICBcInNvZnRCb2lsZWRFZ2dcIjogXCJTb2Z0LWJvaWxlZCBlZ2dcIixcbiAqICAgICBcImNob2ljZVwiOiBcIkhvdyB0byBjaG9vc2UgdGhlIGVnZ1wiLFxuICogICAgIFwiYnV5UXVlc3Rpb25cIjogXCJJJ2QgbGlrZSB0byBidXkgezB9IGVnZ3MsIHsxfSBkb2xsYXJzIGVhY2guXCJcbiAqICAgfSxcbiAqXG4gKiAgIFwiaXRcIjoge1xuICogICAgIFwiaG93XCI6IFwiQ29tZSB2dW9pIGlsIHR1byB1b3ZvIG9nZ2k/XCIsXG4gKiAgICAgXCJib2lsZWRFZ2dcIjogXCJVb3ZvIHNvZG9cIixcbiAqICAgICBcInNvZnRCb2lsZWRFZ2dcIjogXCJVb3ZvIGFsbGEgY29xdWVcIixcbiAqICAgICBcImNob2ljZVwiOiBcIkNvbWUgc2NlZ2xpZXJlIGwndW92b1wiLFxuICogICAgIFwiYnV5UXVlc3Rpb25cIjogXCJNaSBwaWFjZXJlYmJlIGNvbXByYXJlIHswfSB1b3ZhLCB7MX0gZG9sbGFyaSBjaWFzY3VuYS5cIlxuICogICB9XG4gKiB9XG4gKlxuICogMi4gVXNlIExvY2FsZSdzIG1vZHVsZSBsb2FkIG1ldGhvZCwgc3BlY2lmeWluZyBwYXRoIHRvIHlvdXIgbG9jYWxpemF0aW9uIGZpbGUgYW5kIHNldCBjaG9zZW4gbGFuZ3VhZ2UsIGUuZy46XG4gKiAgICA+IExvY2FsZS5sb2FkKCdzdGF0aWMvbG9jYWxlL2xvY2FsZS5qc29uJyk7XG4gKiAgICA+IExvY2FsZS5zZXRMYW5ndWFnZSgnZW4nKTtcbiAqXG4gKiAzLiBVc2UgbG9jYWxpemF0aW9uIHN0cmluZ3M6XG4gKiAgICA+IGNvbnNvbGUubG9nKExvY2FsZS50ci5ob3cpO1xuICogICAgSG93IGRvIHlvdSB3YW50IHlvdXIgZWdnIHRvZGF5P1xuICogICAgPiBjb25zb2xlLmxvZyhMb2NhbGUudHIuYm9pbGVkRWdnKTtcbiAqICAgIEJvaWxlZCBlZ2dcbiAqXG4gKiA0LiBTdHJpbmcgZm9ybWF0dGluZ1xuICogICAgPiBjb25zb2xlLmxvZyhMb2NhbGUudHIuYnV5UXVlc3Rpb24uZm9ybWF0KDEwLCAwLjUpKTtcbiAqICAgIEknZCBsaWtlIHRvIGJ1eSAxMCBlZ2dzLCAwLjUgZG9sbGFycyBlYWNoLlxuICovXG5cbmltcG9ydCBMb2cgZnJvbSAnLi4vTG9nJ1xuXG5sZXQgd2FybmVkID0gZmFsc2VcbmNvbnN0IGRlcHJlY2F0ZWQgPSAoZm9yY2UgPSBmYWxzZSkgPT4ge1xuICBpZiAoZm9yY2UgPT09IHRydWUgfHwgd2FybmVkID09PSBmYWxzZSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFtcbiAgICAgICAgXCJUaGUgJ0xvY2FsZSctcGx1Z2luIGluIHRoZSBMaWdodG5pbmctU0RLIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMuXCIsXG4gICAgICAgIFwiUGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBuZXcgJ0xhbmd1YWdlJy1wbHVnaW4gaW5zdGVhZC5cIixcbiAgICAgICAgJ2h0dHBzOi8vcmRrY2VudHJhbC5naXRodWIuaW8vTGlnaHRuaW5nLVNESy8jL3BsdWdpbnMvbGFuZ3VhZ2UnLFxuICAgICAgXS5qb2luKCdcXG5cXG4nKVxuICAgIClcbiAgfVxuICB3YXJuZWQgPSB0cnVlXG59XG5jbGFzcyBMb2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9fZW5hYmxlZCA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgdHJhbnNsYXRpb24gb2JqZWN0IGZyb20gZXh0ZXJuYWwganNvbiBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBQYXRoIHRvIHJlc291cmNlLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgbG9hZChwYXRoKSB7XG4gICAgaWYgKCF0aGlzLl9fZW5hYmxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXdhaXQgZmV0Y2gocGF0aClcbiAgICAgIC50aGVuKHJlc3AgPT4gcmVzcC5qc29uKCkpXG4gICAgICAudGhlbihyZXNwID0+IHtcbiAgICAgICAgdGhpcy5sb2FkRnJvbU9iamVjdChyZXNwKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGxhbmd1YWdlIHVzZWQgYnkgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGFuZ1xuICAgKi9cbiAgc2V0TGFuZ3VhZ2UobGFuZykge1xuICAgIGRlcHJlY2F0ZWQoKVxuICAgIHRoaXMuX19lbmFibGVkID0gdHJ1ZVxuICAgIHRoaXMubGFuZ3VhZ2UgPSBsYW5nXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyByZWZlcmVuY2UgdG8gdHJhbnNsYXRpb24gb2JqZWN0IGZvciBjdXJyZW50IGxhbmd1YWdlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXQgdHIoKSB7XG4gICAgZGVwcmVjYXRlZCh0cnVlKVxuICAgIHJldHVybiB0aGlzLl9fdHJPYmpbdGhpcy5sYW5ndWFnZV1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0cmFuc2xhdGlvbiBvYmplY3QgZnJvbSBleGlzdGluZyBvYmplY3QgKGJpbmRzIGV4aXN0aW5nIG9iamVjdCkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0ck9ialxuICAgKi9cbiAgbG9hZEZyb21PYmplY3QodHJPYmopIHtcbiAgICBkZXByZWNhdGVkKClcbiAgICBjb25zdCBmYWxsYmFja0xhbmd1YWdlID0gJ2VuJ1xuICAgIGlmIChPYmplY3Qua2V5cyh0ck9iaikuaW5kZXhPZih0aGlzLmxhbmd1YWdlKSA9PT0gLTEpIHtcbiAgICAgIExvZy53YXJuKCdObyB0cmFuc2xhdGlvbnMgZm91bmQgZm9yOiAnICsgdGhpcy5sYW5ndWFnZSlcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0ck9iaikuaW5kZXhPZihmYWxsYmFja0xhbmd1YWdlKSA+IC0xKSB7XG4gICAgICAgIExvZy53YXJuKCdVc2luZyBmYWxsYmFjayBsYW5ndWFnZTogJyArIGZhbGxiYWNrTGFuZ3VhZ2UpXG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBmYWxsYmFja0xhbmd1YWdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlcnJvciA9ICdObyB0cmFuc2xhdGlvbnMgZm91bmQgZm9yIGZhbGxiYWNrIGxhbmd1YWdlOiAnICsgZmFsbGJhY2tMYW5ndWFnZVxuICAgICAgICBMb2cuZXJyb3IoZXJyb3IpXG4gICAgICAgIHRocm93IEVycm9yKGVycm9yKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX190ck9iaiA9IHRyT2JqXG4gICAgZm9yIChjb25zdCBsYW5nIG9mIE9iamVjdC52YWx1ZXModGhpcy5fX3RyT2JqKSkge1xuICAgICAgZm9yIChjb25zdCBzdHIgb2YgT2JqZWN0LmtleXMobGFuZykpIHtcbiAgICAgICAgbGFuZ1tzdHJdID0gbmV3IExvY2FsaXplZFN0cmluZyhsYW5nW3N0cl0pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXh0ZW5kZWQgc3RyaW5nIGNsYXNzIHVzZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqL1xuY2xhc3MgTG9jYWxpemVkU3RyaW5nIGV4dGVuZHMgU3RyaW5nIHtcbiAgLyoqXG4gICAqIFJldHVybnMgZm9ybWF0dGVkIExvY2FsaXplZFN0cmluZy5cbiAgICogUmVwbGFjZXMgZWFjaCBwbGFjZWhvbGRlciB2YWx1ZSAoZS5nLiB7MH0sIHsxfSkgd2l0aCBjb3JyZXNwb25kaW5nIGFyZ3VtZW50LlxuICAgKlxuICAgKiBFLmcuOlxuICAgKiA+IG5ldyBMb2NhbGl6ZWRTdHJpbmcoJ3swfSBhbmQgezF9IGFuZCB7MH0nKS5mb3JtYXQoJ0EnLCAnQicpO1xuICAgKiBBIGFuZCBCIGFuZCBBXG4gICAqXG4gICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBMaXN0IG9mIGFyZ3VtZW50cyBmb3IgcGxhY2Vob2xkZXJzLlxuICAgKi9cbiAgZm9ybWF0KC4uLmFyZ3MpIHtcbiAgICBjb25zdCBzdWIgPSBhcmdzLnJlZHVjZSgoc3RyaW5nLCBhcmcsIGluZGV4KSA9PiBzdHJpbmcuc3BsaXQoYHske2luZGV4fX1gKS5qb2luKGFyZyksIHRoaXMpXG4gICAgcmV0dXJuIG5ldyBMb2NhbGl6ZWRTdHJpbmcoc3ViKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBMb2NhbGUoKVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL1NldHRpbmdzJ1xuXG5jb25zdCBwcmVwTG9nID0gKHR5cGUsIGFyZ3MpID0+IHtcbiAgY29uc3QgY29sb3JzID0ge1xuICAgIEluZm86ICdncmVlbicsXG4gICAgRGVidWc6ICdncmF5JyxcbiAgICBXYXJuOiAnb3JhbmdlJyxcbiAgICBFcnJvcjogJ3JlZCcsXG4gIH1cblxuICBhcmdzID0gQXJyYXkuZnJvbShhcmdzKVxuICByZXR1cm4gW1xuICAgICclYycgKyAoYXJncy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyA/IGFyZ3Muc2hpZnQoKSA6IHR5cGUpLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yOiAnICsgY29sb3JzW3R5cGVdICsgJzsgY29sb3I6IHdoaXRlOyBwYWRkaW5nOiAycHggNHB4OyBib3JkZXItcmFkaXVzOiAycHgnLFxuICAgIGFyZ3MsXG4gIF1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbmZvKCkge1xuICAgIFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnbG9nJykgJiYgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgcHJlcExvZygnSW5mbycsIGFyZ3VtZW50cykpXG4gIH0sXG4gIGRlYnVnKCkge1xuICAgIFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnbG9nJykgJiYgY29uc29sZS5kZWJ1Zy5hcHBseShjb25zb2xlLCBwcmVwTG9nKCdEZWJ1ZycsIGFyZ3VtZW50cykpXG4gIH0sXG4gIGVycm9yKCkge1xuICAgIFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnbG9nJykgJiYgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBwcmVwTG9nKCdFcnJvcicsIGFyZ3VtZW50cykpXG4gIH0sXG4gIHdhcm4oKSB7XG4gICAgU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdsb2cnKSAmJiBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgcHJlcExvZygnV2FybicsIGFyZ3VtZW50cykpXG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTGlnaHRuaW5nIGZyb20gJy4uL0xpZ2h0bmluZydcbmltcG9ydCBNZXRyaWNzIGZyb20gJy4uL01ldHJpY3MnXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcblxuY29uc3QgZXZlbnRzID0gW1xuICAndGltZXVwZGF0ZScsXG4gICdlcnJvcicsXG4gICdlbmRlZCcsXG4gICdsb2FkZWRkYXRhJyxcbiAgJ2NhbnBsYXknLFxuICAncGxheScsXG4gICdwbGF5aW5nJyxcbiAgJ3BhdXNlJyxcbiAgJ2xvYWRzdGFydCcsXG4gICdzZWVraW5nJyxcbiAgJ3NlZWtlZCcsXG4gICdlbmNyeXB0ZWQnLFxuXVxuXG5sZXQgbWVkaWFVcmwgPSB1cmwgPT4gdXJsXG5cbmV4cG9ydCBjb25zdCBpbml0TWVkaWFQbGF5ZXIgPSBjb25maWcgPT4ge1xuICBpZiAoY29uZmlnLm1lZGlhVXJsKSB7XG4gICAgbWVkaWFVcmwgPSBjb25maWcubWVkaWFVcmxcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZWRpYXBsYXllciBleHRlbmRzIExpZ2h0bmluZy5Db21wb25lbnQge1xuICBfY29uc3RydWN0KCkge1xuICAgIHRoaXMuX3NraXBSZW5kZXJUb1RleHR1cmUgPSBmYWxzZVxuICAgIHRoaXMuX21ldHJpY3MgPSBudWxsXG4gICAgdGhpcy5fdGV4dHVyZU1vZGUgPSBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ3RleHR1cmVNb2RlJykgfHwgZmFsc2VcbiAgICBMb2cuaW5mbygnVGV4dHVyZSBtb2RlOiAnICsgdGhpcy5fdGV4dHVyZU1vZGUpXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgW1xuICAgICAgICBcIlRoZSAnTWVkaWFQbGF5ZXInLXBsdWdpbiBpbiB0aGUgTGlnaHRuaW5nLVNESyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzLlwiLFxuICAgICAgICBcIlBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgbmV3ICdWaWRlb1BsYXllcictcGx1Z2luIGluc3RlYWQuXCIsXG4gICAgICAgICdodHRwczovL3Jka2NlbnRyYWwuZ2l0aHViLmlvL0xpZ2h0bmluZy1TREsvIy9wbHVnaW5zL3ZpZGVvcGxheWVyJyxcbiAgICAgIF0uam9pbignXFxuXFxuJylcbiAgICApXG4gIH1cblxuICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBWaWRlbzoge1xuICAgICAgICBWaWRlb1dyYXA6IHtcbiAgICAgICAgICBWaWRlb1RleHR1cmU6IHtcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgcGl2b3Q6IDAuNSxcbiAgICAgICAgICAgIHRleHR1cmU6IHsgdHlwZTogTGlnaHRuaW5nLnRleHR1cmVzLlN0YXRpY1RleHR1cmUsIG9wdGlvbnM6IHt9IH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgc2V0IHNraXBSZW5kZXJUb1RleHR1cmUodikge1xuICAgIHRoaXMuX3NraXBSZW5kZXJUb1RleHR1cmUgPSB2XG4gIH1cblxuICBnZXQgdGV4dHVyZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVNb2RlXG4gIH1cblxuICBnZXQgdmlkZW9WaWV3KCkge1xuICAgIHJldHVybiB0aGlzLnRhZygnVmlkZW8nKVxuICB9XG5cbiAgX2luaXQoKSB7XG4gICAgLy9yZS11c2UgdmlkZW90YWcgaWYgYWxyZWFkeSB0aGVyZVxuICAgIGNvbnN0IHZpZGVvRWxzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJylcbiAgICBpZiAodmlkZW9FbHMgJiYgdmlkZW9FbHMubGVuZ3RoID4gMCkgdGhpcy52aWRlb0VsID0gdmlkZW9FbHNbMF1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMudmlkZW9FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJylcbiAgICAgIHRoaXMudmlkZW9FbC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3ZpZGVvLXBsYXllcicpXG4gICAgICB0aGlzLnZpZGVvRWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgICB0aGlzLnZpZGVvRWwuc3R5bGUuekluZGV4ID0gJzEnXG4gICAgICB0aGlzLnZpZGVvRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgdGhpcy52aWRlb0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTAwJScpXG4gICAgICB0aGlzLnZpZGVvRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMTAwJScpXG5cbiAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS52aXNpYmlsaXR5ID0gdGhpcy50ZXh0dXJlTW9kZSA/ICdoaWRkZW4nIDogJ3Zpc2libGUnXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMudmlkZW9FbClcbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dHVyZU1vZGUgJiYgIXRoaXMuX3NraXBSZW5kZXJUb1RleHR1cmUpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVZpZGVvVGV4dHVyZSgpXG4gICAgfVxuXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW11cbiAgfVxuXG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9tZXRyaWNzICYmIHRoaXMuX21ldHJpY3NbZXZlbnRdICYmIHR5cGVvZiB0aGlzLl9tZXRyaWNzW2V2ZW50XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuX21ldHJpY3NbZXZlbnRdKHsgY3VycmVudFRpbWU6IHRoaXMudmlkZW9FbC5jdXJyZW50VGltZSB9KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyZShldmVudCwgeyB2aWRlb0VsZW1lbnQ6IHRoaXMudmlkZW9FbCwgZXZlbnQ6IGUgfSlcbiAgICAgIH1cbiAgICAgIHRoaXMuZXZlbnRIYW5kbGVycy5wdXNoKGhhbmRsZXIpXG4gICAgICB0aGlzLnZpZGVvRWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcilcbiAgICB9KVxuICB9XG5cbiAgX2RlcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgTG9nLmluZm8oJ0RlcmVnaXN0ZXJpbmcgZXZlbnQgbGlzdGVuZXJzIE1lZGlhUGxheWVyJylcbiAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQsIGluZGV4KSA9PiB7XG4gICAgICB0aGlzLnZpZGVvRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5ldmVudEhhbmRsZXJzW2luZGV4XSlcbiAgICB9KVxuICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdXG4gIH1cblxuICBfYXR0YWNoKCkge1xuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKClcbiAgfVxuXG4gIF9kZXRhY2goKSB7XG4gICAgdGhpcy5fZGVyZWdpc3Rlckxpc3RlbmVycygpXG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cblxuICBfY3JlYXRlVmlkZW9UZXh0dXJlKCkge1xuICAgIGNvbnN0IHN0YWdlID0gdGhpcy5zdGFnZVxuXG4gICAgY29uc3QgZ2wgPSBzdGFnZS5nbFxuICAgIGNvbnN0IGdsVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSlcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKVxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSlcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKVxuXG4gICAgdGhpcy52aWRlb1RleHR1cmUub3B0aW9ucyA9IHsgc291cmNlOiBnbFRleHR1cmUsIHc6IHRoaXMudmlkZW9FbC53aWR0aCwgaDogdGhpcy52aWRlb0VsLmhlaWdodCB9XG4gIH1cblxuICBfc3RhcnRVcGRhdGluZ1ZpZGVvVGV4dHVyZSgpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlTW9kZSAmJiAhdGhpcy5fc2tpcFJlbmRlclRvVGV4dHVyZSkge1xuICAgICAgY29uc3Qgc3RhZ2UgPSB0aGlzLnN0YWdlXG4gICAgICBpZiAoIXRoaXMuX3VwZGF0ZVZpZGVvVGV4dHVyZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVWaWRlb1RleHR1cmUgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMuc291cmNlICYmIHRoaXMudmlkZW9FbC52aWRlb1dpZHRoICYmIHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0YWdlLmdsXG5cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKClcblxuICAgICAgICAgICAgLy8gV2hlbiBCUjJfUEFDS0FHRV9HU1QxX1BMVUdJTlNfQkFEX1BMVUdJTl9ERUJVR1VUSUxTIGlzIG5vdCBzZXQgaW4gV1BFLCB3ZWJraXREZWNvZGVkRnJhbWVDb3VudCB3aWxsIG5vdCBiZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAvLyBXZSdsbCBmYWxsYmFjayB0byBmaXhlZCAzMGZwcyBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICBjb25zdCBmcmFtZUNvdW50ID0gdGhpcy52aWRlb0VsLndlYmtpdERlY29kZWRGcmFtZUNvdW50XG5cbiAgICAgICAgICAgIGNvbnN0IG11c3RVcGRhdGUgPSBmcmFtZUNvdW50XG4gICAgICAgICAgICAgID8gdGhpcy5fbGFzdEZyYW1lICE9PSBmcmFtZUNvdW50XG4gICAgICAgICAgICAgIDogdGhpcy5fbGFzdFRpbWUgPCBjdXJyZW50VGltZSAtIDMwXG5cbiAgICAgICAgICAgIGlmIChtdXN0VXBkYXRlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xhc3RUaW1lID0gY3VycmVudFRpbWVcbiAgICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gZnJhbWVDb3VudFxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMuc291cmNlKVxuICAgICAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnZpZGVvRWwpXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gdGhpcy52aWRlb0VsLndlYmtpdERlY29kZWRGcmFtZUNvdW50XG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmVWaWV3LnZpc2libGUgPSB0cnVlXG5cbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZS5vcHRpb25zLncgPSB0aGlzLnZpZGVvRWwudmlkZW9XaWR0aFxuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMuaCA9IHRoaXMudmlkZW9FbC52aWRlb0hlaWdodFxuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkQXNwZWN0UmF0aW8gPSB0aGlzLnZpZGVvVGV4dHVyZVZpZXcudyAvIHRoaXMudmlkZW9UZXh0dXJlVmlldy5oXG4gICAgICAgICAgICAgICAgY29uc3QgcmVhbEFzcGVjdFJhdGlvID0gdGhpcy52aWRlb0VsLnZpZGVvV2lkdGggLyB0aGlzLnZpZGVvRWwudmlkZW9IZWlnaHRcbiAgICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWRBc3BlY3RSYXRpbyA+IHJlYWxBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmVWaWV3LnNjYWxlWCA9IHJlYWxBc3BlY3RSYXRpbyAvIGV4cGVjdGVkQXNwZWN0UmF0aW9cbiAgICAgICAgICAgICAgICAgIHRoaXMudmlkZW9UZXh0dXJlVmlldy5zY2FsZVkgPSAxXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudmlkZW9UZXh0dXJlVmlldy5zY2FsZVkgPSBleHBlY3RlZEFzcGVjdFJhdGlvIC8gcmVhbEFzcGVjdFJhdGlvXG4gICAgICAgICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZVZpZXcuc2NhbGVYID0gMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIExvZy5lcnJvcigndGV4SW1hZ2UyZCB2aWRlbycsIGUpXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcFVwZGF0aW5nVmlkZW9UZXh0dXJlKClcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZVZpZXcudmlzaWJsZSA9IGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmUuc291cmNlLmZvcmNlUmVuZGVyVXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fdXBkYXRpbmdWaWRlb1RleHR1cmUpIHtcbiAgICAgICAgc3RhZ2Uub24oJ2ZyYW1lU3RhcnQnLCB0aGlzLl91cGRhdGVWaWRlb1RleHR1cmUpXG4gICAgICAgIHRoaXMuX3VwZGF0aW5nVmlkZW9UZXh0dXJlID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9zdG9wVXBkYXRpbmdWaWRlb1RleHR1cmUoKSB7XG4gICAgaWYgKHRoaXMudGV4dHVyZU1vZGUpIHtcbiAgICAgIGNvbnN0IHN0YWdlID0gdGhpcy5zdGFnZVxuICAgICAgc3RhZ2UucmVtb3ZlTGlzdGVuZXIoJ2ZyYW1lU3RhcnQnLCB0aGlzLl91cGRhdGVWaWRlb1RleHR1cmUpXG4gICAgICB0aGlzLl91cGRhdGluZ1ZpZGVvVGV4dHVyZSA9IGZhbHNlXG4gICAgICB0aGlzLnZpZGVvVGV4dHVyZVZpZXcudmlzaWJsZSA9IGZhbHNlXG5cbiAgICAgIGlmICh0aGlzLnZpZGVvVGV4dHVyZS5vcHRpb25zLnNvdXJjZSkge1xuICAgICAgICBjb25zdCBnbCA9IHN0YWdlLmdsXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMuc291cmNlKVxuICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDEpXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU2V0dGluZ3Moc2V0dGluZ3MgPSB7fSkge1xuICAgIC8vIFRoZSBDb21wb25lbnQgdGhhdCAnY29uc3VtZXMnIHRoZSBtZWRpYSBwbGF5ZXIuXG4gICAgdGhpcy5fY29uc3VtZXIgPSBzZXR0aW5ncy5jb25zdW1lclxuXG4gICAgaWYgKHRoaXMuX2NvbnN1bWVyICYmIHRoaXMuX2NvbnN1bWVyLmdldE1lZGlhcGxheWVyU2V0dGluZ3MpIHtcbiAgICAgIC8vIEFsbG93IGNvbnN1bWVyIHRvIGFkZCBzZXR0aW5ncy5cbiAgICAgIHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgdGhpcy5fY29uc3VtZXIuZ2V0TWVkaWFwbGF5ZXJTZXR0aW5ncygpKVxuICAgIH1cblxuICAgIGlmICghTGlnaHRuaW5nLlV0aWxzLmVxdWFsVmFsdWVzKHRoaXMuX3N0cmVhbSwgc2V0dGluZ3Muc3RyZWFtKSkge1xuICAgICAgaWYgKHNldHRpbmdzLnN0cmVhbSAmJiBzZXR0aW5ncy5zdHJlYW0ua2V5U3lzdGVtKSB7XG4gICAgICAgIG5hdmlnYXRvclxuICAgICAgICAgIC5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MoXG4gICAgICAgICAgICBzZXR0aW5ncy5zdHJlYW0ua2V5U3lzdGVtLmlkLFxuICAgICAgICAgICAgc2V0dGluZ3Muc3RyZWFtLmtleVN5c3RlbS5jb25maWdcbiAgICAgICAgICApXG4gICAgICAgICAgLnRoZW4oa2V5U3lzdGVtQWNjZXNzID0+IHtcbiAgICAgICAgICAgIHJldHVybiBrZXlTeXN0ZW1BY2Nlc3MuY3JlYXRlTWVkaWFLZXlzKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKGNyZWF0ZWRNZWRpYUtleXMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9FbC5zZXRNZWRpYUtleXMoY3JlYXRlZE1lZGlhS2V5cylcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zdHJlYW0gJiYgc2V0dGluZ3Muc3RyZWFtLnNyYykgdGhpcy5vcGVuKHNldHRpbmdzLnN0cmVhbS5zcmMpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNldCB1cCBNZWRpYUtleXMnKVxuICAgICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnN0cmVhbSAmJiBzZXR0aW5ncy5zdHJlYW0uc3JjKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaGVyZSB0byBiZSBiYWNrd2FyZHMgY29tcGF0aWJsZSwgd2lsbCBiZSByZW1vdmVkXG4gICAgICAgIC8vIGluIGZ1dHVyZSBzZGsgcmVsZWFzZVxuICAgICAgICBpZiAoU2V0dGluZ3MuZ2V0KCdhcHAnLCAnaGxzJykpIHtcbiAgICAgICAgICBpZiAoIXdpbmRvdy5IbHMpIHtcbiAgICAgICAgICAgIHdpbmRvdy5IbHMgPSBjbGFzcyBIbHMge1xuICAgICAgICAgICAgICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdobHMtbGlnaHQgbm90IGluY2x1ZGVkJylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2luZG93Lkhscy5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hscykgdGhpcy5faGxzID0gbmV3IHdpbmRvdy5IbHMoeyBsaXZlRHVyYXRpb25JbmZpbml0eTogdHJ1ZSB9KVxuICAgICAgICAgICAgdGhpcy5faGxzLmxvYWRTb3VyY2Uoc2V0dGluZ3Muc3RyZWFtLnNyYylcbiAgICAgICAgICAgIHRoaXMuX2hscy5hdHRhY2hNZWRpYSh0aGlzLnZpZGVvRWwpXG4gICAgICAgICAgICB0aGlzLnZpZGVvRWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vcGVuKHNldHRpbmdzLnN0cmVhbS5zcmMpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgfVxuICAgICAgdGhpcy5fc3RyZWFtID0gc2V0dGluZ3Muc3RyZWFtXG4gICAgfVxuXG4gICAgdGhpcy5fc2V0SGlkZShzZXR0aW5ncy5oaWRlKVxuICAgIHRoaXMuX3NldFZpZGVvQXJlYShzZXR0aW5ncy52aWRlb1BvcylcbiAgfVxuXG4gIF9zZXRIaWRlKGhpZGUpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlTW9kZSkge1xuICAgICAgdGhpcy50YWcoJ1ZpZGVvJykuc2V0U21vb3RoKCdhbHBoYScsIGhpZGUgPyAwIDogMSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRlID8gJ2hpZGRlbicgOiAndmlzaWJsZSdcbiAgICB9XG4gIH1cblxuICBvcGVuKHVybCwgc2V0dGluZ3MgPSB7IGhpZGU6IGZhbHNlLCB2aWRlb1Bvc2l0aW9uOiBudWxsIH0pIHtcbiAgICAvLyBwcmVwIHRoZSBtZWRpYSB1cmwgdG8gcGxheSBkZXBlbmRpbmcgb24gcGxhdGZvcm0gKG1lZGlhUGxheWVycGx1Z2luKVxuICAgIHVybCA9IG1lZGlhVXJsKHVybClcbiAgICB0aGlzLl9tZXRyaWNzID0gTWV0cmljcy5tZWRpYSh1cmwpXG4gICAgTG9nLmluZm8oJ1BsYXlpbmcgc3RyZWFtJywgdXJsKVxuICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uLm5vVmlkZW8pIHtcbiAgICAgIExvZy5pbmZvKCdub1ZpZGVvIG9wdGlvbiBzZXQsIHNvIGlnbm9yaW5nOiAnICsgdXJsKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIGNsb3NlIHRoZSB2aWRlbyB3aGVuIG9wZW5pbmcgc2FtZSB1cmwgYXMgY3VycmVudCAoZWZmZWN0aXZlbHkgcmVsb2FkaW5nKVxuICAgIGlmICh0aGlzLnZpZGVvRWwuZ2V0QXR0cmlidXRlKCdzcmMnKSA9PT0gdXJsKSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9XG4gICAgdGhpcy52aWRlb0VsLnNldEF0dHJpYnV0ZSgnc3JjJywgdXJsKVxuXG4gICAgLy8gZm9yY2UgaGlkZSwgdGhlbiBmb3JjZSBzaG93IChpbiBuZXh0IHRpY2shKVxuICAgIC8vIChmaXhlcyBjb21jYXN0IHBsYXliYWNrIHJvbGxvdmVyIGlzc3VlKVxuICAgIHRoaXMudmlkZW9FbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICB0aGlzLnZpZGVvRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnZpZGVvRWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgfSlcblxuICAgIHRoaXMuX3NldEhpZGUoc2V0dGluZ3MuaGlkZSlcbiAgICB0aGlzLl9zZXRWaWRlb0FyZWEoc2V0dGluZ3MudmlkZW9Qb3NpdGlvbiB8fCBbMCwgMCwgMTkyMCwgMTA4MF0pXG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICAvLyBXZSBuZWVkIHRvIHBhdXNlIGZpcnN0IGluIG9yZGVyIHRvIHN0b3Agc291bmQuXG4gICAgdGhpcy52aWRlb0VsLnBhdXNlKClcbiAgICB0aGlzLnZpZGVvRWwucmVtb3ZlQXR0cmlidXRlKCdzcmMnKVxuXG4gICAgLy8gZm9yY2UgbG9hZCB0byByZXNldCBldmVyeXRoaW5nIHdpdGhvdXQgZXJyb3JzXG4gICAgdGhpcy52aWRlb0VsLmxvYWQoKVxuXG4gICAgdGhpcy5fY2xlYXJTcmMoKVxuXG4gICAgdGhpcy52aWRlb0VsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgfVxuXG4gIHBsYXlQYXVzZSgpIHtcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcoKSkge1xuICAgICAgdGhpcy5kb1BhdXNlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb1BsYXkoKVxuICAgIH1cbiAgfVxuXG4gIGdldCBtdXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWRlb0VsLm11dGVkXG4gIH1cblxuICBzZXQgbXV0ZWQodikge1xuICAgIHRoaXMudmlkZW9FbC5tdXRlZCA9IHZcbiAgfVxuXG4gIGdldCBsb29wKCkge1xuICAgIHJldHVybiB0aGlzLnZpZGVvRWwubG9vcFxuICB9XG5cbiAgc2V0IGxvb3Aodikge1xuICAgIHRoaXMudmlkZW9FbC5sb29wID0gdlxuICB9XG5cbiAgaXNQbGF5aW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGF0ZSgpID09PSAnUGxheWluZydcbiAgfVxuXG4gIGRvUGxheSgpIHtcbiAgICB0aGlzLnZpZGVvRWwucGxheSgpXG4gIH1cblxuICBkb1BhdXNlKCkge1xuICAgIHRoaXMudmlkZW9FbC5wYXVzZSgpXG4gIH1cblxuICByZWxvYWQoKSB7XG4gICAgdmFyIHVybCA9IHRoaXMudmlkZW9FbC5nZXRBdHRyaWJ1dGUoJ3NyYycpXG4gICAgdGhpcy5jbG9zZSgpXG4gICAgdGhpcy52aWRlb0VsLnNyYyA9IHVybFxuICB9XG5cbiAgZ2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnZpZGVvRWwuY3VycmVudFRpbWUpXG4gIH1cblxuICBzZXRQb3NpdGlvbihwb3MpIHtcbiAgICB0aGlzLnZpZGVvRWwuY3VycmVudFRpbWUgPSBwb3NcbiAgfVxuXG4gIGdldER1cmF0aW9uKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy52aWRlb0VsLmR1cmF0aW9uKVxuICB9XG5cbiAgc2Vlayh0aW1lLCBhYnNvbHV0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKGFic29sdXRlKSB7XG4gICAgICB0aGlzLnZpZGVvRWwuY3VycmVudFRpbWUgPSB0aW1lXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmlkZW9FbC5jdXJyZW50VGltZSArPSB0aW1lXG4gICAgfVxuICB9XG5cbiAgZ2V0IHZpZGVvVGV4dHVyZVZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnKCdWaWRlbycpLnRhZygnVmlkZW9UZXh0dXJlJylcbiAgfVxuXG4gIGdldCB2aWRlb1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlkZW9UZXh0dXJlVmlldy50ZXh0dXJlXG4gIH1cblxuICBfc2V0VmlkZW9BcmVhKHZpZGVvUG9zKSB7XG4gICAgaWYgKExpZ2h0bmluZy5VdGlscy5lcXVhbFZhbHVlcyh0aGlzLl92aWRlb1BvcywgdmlkZW9Qb3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl92aWRlb1BvcyA9IHZpZGVvUG9zXG5cbiAgICBpZiAodGhpcy50ZXh0dXJlTW9kZSkge1xuICAgICAgdGhpcy52aWRlb1RleHR1cmVWaWV3LnBhdGNoKHtcbiAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgeDogdmlkZW9Qb3NbMF0sXG4gICAgICAgICAgeTogdmlkZW9Qb3NbMV0sXG4gICAgICAgICAgdzogdmlkZW9Qb3NbMl0gLSB2aWRlb1Bvc1swXSxcbiAgICAgICAgICBoOiB2aWRlb1Bvc1szXSAtIHZpZGVvUG9zWzFdLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJlY2lzaW9uID0gdGhpcy5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKVxuICAgICAgdGhpcy52aWRlb0VsLnN0eWxlLmxlZnQgPSBNYXRoLnJvdW5kKHZpZGVvUG9zWzBdICogcHJlY2lzaW9uKSArICdweCdcbiAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS50b3AgPSBNYXRoLnJvdW5kKHZpZGVvUG9zWzFdICogcHJlY2lzaW9uKSArICdweCdcbiAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS53aWR0aCA9IE1hdGgucm91bmQoKHZpZGVvUG9zWzJdIC0gdmlkZW9Qb3NbMF0pICogcHJlY2lzaW9uKSArICdweCdcbiAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS5oZWlnaHQgPSBNYXRoLnJvdW5kKCh2aWRlb1Bvc1szXSAtIHZpZGVvUG9zWzFdKSAqIHByZWNpc2lvbikgKyAncHgnXG4gICAgfVxuICB9XG5cbiAgX2ZpcmVDb25zdW1lcihldmVudCwgYXJncykge1xuICAgIGlmICh0aGlzLl9jb25zdW1lcikge1xuICAgICAgdGhpcy5fY29uc3VtZXIuZmlyZShldmVudCwgYXJncylcbiAgICB9XG4gIH1cblxuICBfZXF1YWxJbml0RGF0YShidWYxLCBidWYyKSB7XG4gICAgaWYgKCFidWYxIHx8ICFidWYyKSByZXR1cm4gZmFsc2VcbiAgICBpZiAoYnVmMS5ieXRlTGVuZ3RoICE9IGJ1ZjIuYnl0ZUxlbmd0aCkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgZHYxID0gbmV3IEludDhBcnJheShidWYxKVxuICAgIGNvbnN0IGR2MiA9IG5ldyBJbnQ4QXJyYXkoYnVmMilcbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPSBidWYxLmJ5dGVMZW5ndGg7IGkrKykgaWYgKGR2MVtpXSAhPSBkdjJbaV0pIHJldHVybiBmYWxzZVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBlcnJvcihhcmdzKSB7XG4gICAgdGhpcy5fZmlyZUNvbnN1bWVyKCckbWVkaWFwbGF5ZXJFcnJvcicsIGFyZ3MpXG4gICAgdGhpcy5fc2V0U3RhdGUoJycpXG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBsb2FkZWRkYXRhKGFyZ3MpIHtcbiAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllckxvYWRlZERhdGEnLCBhcmdzKVxuICB9XG5cbiAgcGxheShhcmdzKSB7XG4gICAgdGhpcy5fZmlyZUNvbnN1bWVyKCckbWVkaWFwbGF5ZXJQbGF5JywgYXJncylcbiAgfVxuXG4gIHBsYXlpbmcoYXJncykge1xuICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyUGxheWluZycsIGFyZ3MpXG4gICAgdGhpcy5fc2V0U3RhdGUoJ1BsYXlpbmcnKVxuICB9XG5cbiAgY2FucGxheShhcmdzKSB7XG4gICAgdGhpcy52aWRlb0VsLnBsYXkoKVxuICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyU3RhcnQnLCBhcmdzKVxuICB9XG5cbiAgbG9hZHN0YXJ0KGFyZ3MpIHtcbiAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllckxvYWQnLCBhcmdzKVxuICB9XG5cbiAgc2Vla2VkKCkge1xuICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyU2Vla2VkJywge1xuICAgICAgY3VycmVudFRpbWU6IHRoaXMudmlkZW9FbC5jdXJyZW50VGltZSxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLnZpZGVvRWwuZHVyYXRpb24gfHwgMSxcbiAgICB9KVxuICB9XG5cbiAgc2Vla2luZygpIHtcbiAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllclNlZWtpbmcnLCB7XG4gICAgICBjdXJyZW50VGltZTogdGhpcy52aWRlb0VsLmN1cnJlbnRUaW1lLFxuICAgICAgZHVyYXRpb246IHRoaXMudmlkZW9FbC5kdXJhdGlvbiB8fCAxLFxuICAgIH0pXG4gIH1cblxuICBkdXJhdGlvbmNoYW5nZShhcmdzKSB7XG4gICAgdGhpcy5fZmlyZUNvbnN1bWVyKCckbWVkaWFwbGF5ZXJEdXJhdGlvbkNoYW5nZScsIGFyZ3MpXG4gIH1cblxuICBlbmNyeXB0ZWQoYXJncykge1xuICAgIGNvbnN0IHZpZGVvID0gYXJncy52aWRlb0VsZW1lbnRcbiAgICBjb25zdCBldmVudCA9IGFyZ3MuZXZlbnRcbiAgICAvLyBGSVhNRTogRG91YmxlIGVuY3J5cHRlZCBldmVudHMgbmVlZCB0byBiZSBwcm9wZXJseSBmaWx0ZXJlZCBieSBHc3RyZWFtZXJcbiAgICBpZiAodmlkZW8ubWVkaWFLZXlzICYmICF0aGlzLl9lcXVhbEluaXREYXRhKHRoaXMuX3ByZXZpb3VzSW5pdERhdGEsIGV2ZW50LmluaXREYXRhKSkge1xuICAgICAgdGhpcy5fcHJldmlvdXNJbml0RGF0YSA9IGV2ZW50LmluaXREYXRhXG4gICAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllckVuY3J5cHRlZCcsIGFyZ3MpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIF9zdGF0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGNsYXNzIFBsYXlpbmcgZXh0ZW5kcyB0aGlzIHtcbiAgICAgICAgJGVudGVyKCkge1xuICAgICAgICAgIHRoaXMuX3N0YXJ0VXBkYXRpbmdWaWRlb1RleHR1cmUoKVxuICAgICAgICB9XG4gICAgICAgICRleGl0KCkge1xuICAgICAgICAgIHRoaXMuX3N0b3BVcGRhdGluZ1ZpZGVvVGV4dHVyZSgpXG4gICAgICAgIH1cbiAgICAgICAgdGltZXVwZGF0ZSgpIHtcbiAgICAgICAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllclByb2dyZXNzJywge1xuICAgICAgICAgICAgY3VycmVudFRpbWU6IHRoaXMudmlkZW9FbC5jdXJyZW50VGltZSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLnZpZGVvRWwuZHVyYXRpb24gfHwgMSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGVuZGVkKGFyZ3MpIHtcbiAgICAgICAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllckVuZGVkJywgYXJncylcbiAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnJylcbiAgICAgICAgfVxuICAgICAgICBwYXVzZShhcmdzKSB7XG4gICAgICAgICAgdGhpcy5fZmlyZUNvbnN1bWVyKCckbWVkaWFwbGF5ZXJQYXVzZScsIGFyZ3MpXG4gICAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ1BsYXlpbmcuUGF1c2VkJylcbiAgICAgICAgfVxuICAgICAgICBfY2xlYXJTcmMoKSB7XG4gICAgICAgICAgdGhpcy5fZmlyZUNvbnN1bWVyKCckbWVkaWFwbGF5ZXJTdG9wJywge30pXG4gICAgICAgICAgdGhpcy5fc2V0U3RhdGUoJycpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIF9zdGF0ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIFtjbGFzcyBQYXVzZWQgZXh0ZW5kcyB0aGlzIHt9XVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIF1cbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmxldCBtZXRhZGF0YSA9IHt9XG5cbmV4cG9ydCBjb25zdCBpbml0TWV0YWRhdGEgPSBtZXRhZGF0YU9iaiA9PiB7XG4gIG1ldGFkYXRhID0gbWV0YWRhdGFPYmpcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXQoa2V5LCBmYWxsYmFjayA9IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBrZXkgaW4gbWV0YWRhdGEgPyBtZXRhZGF0YVtrZXldIDogZmFsbGJhY2tcbiAgfSxcbiAgYXBwSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdpZCcpXG4gIH0sXG4gIHNhZmVBcHBJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2lkJykucmVwbGFjZSgvW14wLTlhLXpBLVpfJF0vZywgJ18nKVxuICB9LFxuICBhcHBOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnbmFtZScpXG4gIH0sXG4gIGFwcFZlcnNpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLmdldCgndmVyc2lvbicpIHx8ICcnKS5zcGxpdCgnLScpLnNoaWZ0KClcbiAgfSxcbiAgYXBwSWNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2ljb24nKVxuICB9LFxuICAvLyBWZXJzaW9uIGZyb20gYXBwIHN0b3JlICh3aXRoIGNvbW1pdCBoYXNoKVxuICBhcHBGdWxsVmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3ZlcnNpb24nKVxuICB9LFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExvZyBmcm9tICcuLi9Mb2cnXG5cbmxldCBzZW5kTWV0cmljID0gKHR5cGUsIGV2ZW50LCBwYXJhbXMpID0+IHtcbiAgTG9nLmluZm8oJ1NlbmRpbmcgbWV0cmljJywgdHlwZSwgZXZlbnQsIHBhcmFtcylcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRNZXRyaWNzID0gY29uZmlnID0+IHtcbiAgc2VuZE1ldHJpYyA9IGNvbmZpZy5zZW5kTWV0cmljXG59XG5cbi8vIGF2YWlsYWJsZSBtZXRyaWMgcGVyIGNhdGVnb3J5XG5jb25zdCBtZXRyaWNzID0ge1xuICBhcHA6IFsnbGF1bmNoJywgJ2xvYWRlZCcsICdyZWFkeScsICdjbG9zZSddLFxuICBwYWdlOiBbJ3ZpZXcnLCAnbGVhdmUnXSxcbiAgdXNlcjogWydjbGljaycsICdpbnB1dCddLFxuICBtZWRpYTogW1xuICAgICdhYm9ydCcsXG4gICAgJ2NhbnBsYXknLFxuICAgICdlbmRlZCcsXG4gICAgJ3BhdXNlJyxcbiAgICAncGxheScsXG4gICAgLy8gd2l0aCBzb21lIHZpZGVvcyB0aGVyZSBvY2N1ciBhbG1vc3QgY29uc3RhbnQgc3VzcGVuZCBldmVudHMgLi4uIHNob3VsZCBpbnZlc3RpZ2F0ZVxuICAgIC8vICdzdXNwZW5kJyxcbiAgICAndm9sdW1lY2hhbmdlJyxcbiAgICAnd2FpdGluZycsXG4gICAgJ3NlZWtpbmcnLFxuICAgICdzZWVrZWQnLFxuICBdLFxufVxuXG4vLyBlcnJvciBtZXRyaWMgZnVuY3Rpb24gKGFkZGVkIHRvIGVhY2ggY2F0ZWdvcnkpXG5jb25zdCBlcnJvck1ldHJpYyA9ICh0eXBlLCBtZXNzYWdlLCBjb2RlLCB2aXNpYmxlLCBwYXJhbXMgPSB7fSkgPT4ge1xuICBwYXJhbXMgPSB7IHBhcmFtcywgLi4ueyBtZXNzYWdlLCBjb2RlLCB2aXNpYmxlIH0gfVxuICBzZW5kTWV0cmljKHR5cGUsICdlcnJvcicsIHBhcmFtcylcbn1cblxuY29uc3QgTWV0cmljID0gKHR5cGUsIGV2ZW50cywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIHJldHVybiBldmVudHMucmVkdWNlKFxuICAgIChvYmosIGV2ZW50KSA9PiB7XG4gICAgICBvYmpbZXZlbnRdID0gKG5hbWUsIHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgIHBhcmFtcyA9IHsgLi4ub3B0aW9ucywgLi4uKG5hbWUgPyB7IG5hbWUgfSA6IHt9KSwgLi4ucGFyYW1zIH1cbiAgICAgICAgc2VuZE1ldHJpYyh0eXBlLCBldmVudCwgcGFyYW1zKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialxuICAgIH0sXG4gICAge1xuICAgICAgZXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIGVycm9yTWV0cmljKHR5cGUsIG1lc3NhZ2UsIGNvZGUsIHBhcmFtcylcbiAgICAgIH0sXG4gICAgICBldmVudChuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgc2VuZE1ldHJpYyh0eXBlLCBuYW1lLCBwYXJhbXMpXG4gICAgICB9LFxuICAgIH1cbiAgKVxufVxuXG5jb25zdCBNZXRyaWNzID0gdHlwZXMgPT4ge1xuICByZXR1cm4gT2JqZWN0LmtleXModHlwZXMpLnJlZHVjZShcbiAgICAob2JqLCB0eXBlKSA9PiB7XG4gICAgICAvLyBtZWRpYSBtZXRyaWMgd29ya3MgYSBiaXQgZGlmZmVyZW50IVxuICAgICAgLy8gaXQncyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHVybCBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgYXZhaWxhYmxlIG1ldHJpY3NcbiAgICAgIC8vIHVybCBpcyBhdXRvbWF0aWNhbGx5IHBhc3NlZCBhcyBhIHBhcmFtIGluIGV2ZXJ5IG1ldHJpY1xuICAgICAgdHlwZSA9PT0gJ21lZGlhJ1xuICAgICAgICA/IChvYmpbdHlwZV0gPSB1cmwgPT4gTWV0cmljKHR5cGUsIHR5cGVzW3R5cGVdLCB7IHVybCB9KSlcbiAgICAgICAgOiAob2JqW3R5cGVdID0gTWV0cmljKHR5cGUsIHR5cGVzW3R5cGVdKSlcbiAgICAgIHJldHVybiBvYmpcbiAgICB9LFxuICAgIHsgZXJyb3I6IGVycm9yTWV0cmljLCBldmVudDogc2VuZE1ldHJpYyB9XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgTWV0cmljcyhtZXRyaWNzKVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExpZ2h0bmluZyBmcm9tICcuLi9MaWdodG5pbmcnXG5pbXBvcnQgUGluIGZyb20gJy4uL1BpbidcblxuY2xhc3MgUGluSW5wdXQgZXh0ZW5kcyBMaWdodG5pbmcuQ29tcG9uZW50IHtcbiAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdzogMTIwLFxuICAgICAgaDogMTUwLFxuICAgICAgcmVjdDogdHJ1ZSxcbiAgICAgIGNvbG9yOiAweGZmOTQ5MzkzLFxuICAgICAgYWxwaGE6IDAuNSxcbiAgICAgIHNoYWRlcjogeyB0eXBlOiBMaWdodG5pbmcuc2hhZGVycy5Sb3VuZGVkUmVjdGFuZ2xlLCByYWRpdXM6IDEwIH0sXG4gICAgICBOcjoge1xuICAgICAgICB3OiB3ID0+IHcsXG4gICAgICAgIHk6IDI0LFxuICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgdGV4dENvbG9yOiAweGZmMzMzMzMzLFxuICAgICAgICAgIGZvbnRTaXplOiA4MCxcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9XG4gIH1cblxuICBzZXQgaW5kZXgodikge1xuICAgIHRoaXMueCA9IHYgKiAoMTIwICsgMjQpXG4gIH1cblxuICBzZXQgbnIodikge1xuICAgIHRoaXMuX3RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpXG5cbiAgICBpZiAodikge1xuICAgICAgdGhpcy5zZXRTbW9vdGgoJ2FscGhhJywgMSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRTbW9vdGgoJ2FscGhhJywgMC41KVxuICAgIH1cblxuICAgIHRoaXMudGFnKCdOcicpLnBhdGNoKHtcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgdGV4dDogKHYgJiYgdi50b1N0cmluZygpKSB8fCAnJyxcbiAgICAgICAgZm9udFNpemU6IHYgPT09ICcqJyA/IDEyMCA6IDgwLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgaWYgKHYgJiYgdiAhPT0gJyonKSB7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsXG4gICAgICAgIHRoaXMubnIgPSAnKidcbiAgICAgIH0sIDc1MClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGluRGlhbG9nIGV4dGVuZHMgTGlnaHRuaW5nLkNvbXBvbmVudCB7XG4gIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHpJbmRleDogMSxcbiAgICAgIHc6IHcgPT4gdyxcbiAgICAgIGg6IGggPT4gaCxcbiAgICAgIHJlY3Q6IHRydWUsXG4gICAgICBjb2xvcjogMHhkZDAwMDAwMCxcbiAgICAgIGFscGhhOiAwLjAwMDAwMSxcbiAgICAgIERpYWxvZzoge1xuICAgICAgICB3OiA2NDgsXG4gICAgICAgIGg6IDMyMCxcbiAgICAgICAgeTogaCA9PiAoaCAtIDMyMCkgLyAyLFxuICAgICAgICB4OiB3ID0+ICh3IC0gNjQ4KSAvIDIsXG4gICAgICAgIHJlY3Q6IHRydWUsXG4gICAgICAgIGNvbG9yOiAweGRkMzMzMzMzLFxuICAgICAgICBzaGFkZXI6IHsgdHlwZTogTGlnaHRuaW5nLnNoYWRlcnMuUm91bmRlZFJlY3RhbmdsZSwgcmFkaXVzOiAxMCB9LFxuICAgICAgICBJbmZvOiB7XG4gICAgICAgICAgeTogMjQsXG4gICAgICAgICAgeDogNDgsXG4gICAgICAgICAgdGV4dDogeyB0ZXh0OiAnUGxlYXNlIGVudGVyIHlvdXIgUElOJywgZm9udFNpemU6IDMyIH0sXG4gICAgICAgIH0sXG4gICAgICAgIE1zZzoge1xuICAgICAgICAgIHk6IDI2MCxcbiAgICAgICAgICB4OiA0OCxcbiAgICAgICAgICB0ZXh0OiB7IHRleHQ6ICcnLCBmb250U2l6ZTogMjgsIHRleHRDb2xvcjogMHhmZmZmZmZmZiB9LFxuICAgICAgICB9LFxuICAgICAgICBDb2RlOiB7XG4gICAgICAgICAgeDogNDgsXG4gICAgICAgICAgeTogOTYsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIF9pbml0KCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgIHR5cGU6IFBpbklucHV0LFxuICAgICAgICBpbmRleDogaSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy50YWcoJ0NvZGUnKS5jaGlsZHJlbiA9IGNoaWxkcmVuXG4gIH1cblxuICBnZXQgcGluKCkge1xuICAgIGlmICghdGhpcy5fcGluKSB0aGlzLl9waW4gPSAnJ1xuICAgIHJldHVybiB0aGlzLl9waW5cbiAgfVxuXG4gIHNldCBwaW4odikge1xuICAgIGlmICh2Lmxlbmd0aCA8PSA0KSB7XG4gICAgICBjb25zdCBtYXNrZWRQaW4gPSBuZXcgQXJyYXkoTWF0aC5tYXgodi5sZW5ndGggLSAxLCAwKSkuZmlsbCgnKicsIDAsIHYubGVuZ3RoIC0gMSlcbiAgICAgIHYubGVuZ3RoICYmIG1hc2tlZFBpbi5wdXNoKHYubGVuZ3RoID4gdGhpcy5fcGluLmxlbmd0aCA/IHYuc2xpY2UoLTEpIDogJyonKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgdGhpcy50YWcoJ0NvZGUnKS5jaGlsZHJlbltpXS5uciA9IG1hc2tlZFBpbltpXSB8fCAnJ1xuICAgICAgfVxuICAgICAgdGhpcy5fcGluID0gdlxuICAgIH1cbiAgfVxuXG4gIGdldCBtc2coKSB7XG4gICAgaWYgKCF0aGlzLl9tc2cpIHRoaXMuX21zZyA9ICcnXG4gICAgcmV0dXJuIHRoaXMuX21zZ1xuICB9XG5cbiAgc2V0IG1zZyh2KSB7XG4gICAgdGhpcy5fdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dClcblxuICAgIHRoaXMuX21zZyA9IHZcbiAgICBpZiAodGhpcy5fbXNnKSB7XG4gICAgICB0aGlzLnRhZygnTXNnJykudGV4dCA9IHRoaXMuX21zZ1xuICAgICAgdGhpcy50YWcoJ0luZm8nKS5zZXRTbW9vdGgoJ2FscGhhJywgMC41KVxuICAgICAgdGhpcy50YWcoJ0NvZGUnKS5zZXRTbW9vdGgoJ2FscGhhJywgMC41KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZygnTXNnJykudGV4dCA9ICcnXG4gICAgICB0aGlzLnRhZygnSW5mbycpLnNldFNtb290aCgnYWxwaGEnLCAxKVxuICAgICAgdGhpcy50YWcoJ0NvZGUnKS5zZXRTbW9vdGgoJ2FscGhhJywgMSlcbiAgICB9XG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5tc2cgPSAnJ1xuICAgIH0sIDIwMDApXG4gIH1cblxuICBfZmlyc3RBY3RpdmUoKSB7XG4gICAgdGhpcy5zZXRTbW9vdGgoJ2FscGhhJywgMSlcbiAgfVxuXG4gIF9oYW5kbGVLZXkoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5tc2cpIHtcbiAgICAgIHRoaXMubXNnID0gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VJbnQoZXZlbnQua2V5KVxuICAgICAgaWYgKHZhbCA+IC0xKSB7XG4gICAgICAgIHRoaXMucGluICs9IHZhbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVCYWNrKCkge1xuICAgIGlmICh0aGlzLm1zZykge1xuICAgICAgdGhpcy5tc2cgPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5waW4ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucGluID0gdGhpcy5waW4uc2xpY2UoMCwgdGhpcy5waW4ubGVuZ3RoIC0gMSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFBpbi5oaWRlKClcbiAgICAgICAgdGhpcy5yZXNvbHZlKGZhbHNlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVFbnRlcigpIHtcbiAgICBpZiAodGhpcy5tc2cpIHtcbiAgICAgIHRoaXMubXNnID0gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgUGluLnN1Ym1pdCh0aGlzLnBpbilcbiAgICAgICAgLnRoZW4odmFsID0+IHtcbiAgICAgICAgICB0aGlzLm1zZyA9ICdVbmxvY2tpbmcgLi4uJ1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgUGluLmhpZGUoKVxuICAgICAgICAgIH0sIDEwMDApXG4gICAgICAgICAgdGhpcy5yZXNvbHZlKHZhbClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgIHRoaXMubXNnID0gZVxuICAgICAgICAgIHRoaXMucmVqZWN0KGUpXG4gICAgICAgIH0pXG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5pbXBvcnQgUGluRGlhbG9nIGZyb20gJy4vZGlhbG9nJ1xuaW1wb3J0IHsgQXBwbGljYXRpb25JbnN0YW5jZSB9IGZyb20gJy4uL0xhdW5jaCdcbmltcG9ydCB7IExvZyB9IGZyb20gJy4uLy4uL2luZGV4J1xuXG4vLyBvbmx5IHVzZWQgZHVyaW5nIGxvY2FsIGRldmVsb3BtZW50XG5sZXQgdW5sb2NrZWQgPSBmYWxzZVxuY29uc3QgY29udGV4dEl0ZW1zID0gWydwdXJjaGFzZScsICdwYXJlbnRhbCddXG5cbmxldCBzdWJtaXQgPSAocGluLCBjb250ZXh0KSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKHBpbi50b1N0cmluZygpID09PSBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ3BpbicsICcwMDAwJykudG9TdHJpbmcoKSkge1xuICAgICAgdW5sb2NrZWQgPSB0cnVlXG4gICAgICByZXNvbHZlKHVubG9ja2VkKVxuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3QoJ0luY29ycmVjdCBwaW4nKVxuICAgIH1cbiAgfSlcbn1cblxubGV0IGNoZWNrID0gY29udGV4dCA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICByZXNvbHZlKHVubG9ja2VkKVxuICB9KVxufVxuXG5leHBvcnQgY29uc3QgaW5pdFBpbiA9IGNvbmZpZyA9PiB7XG4gIGlmIChjb25maWcuc3VibWl0ICYmIHR5cGVvZiBjb25maWcuc3VibWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3VibWl0ID0gY29uZmlnLnN1Ym1pdFxuICB9XG4gIGlmIChjb25maWcuY2hlY2sgJiYgdHlwZW9mIGNvbmZpZy5jaGVjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoZWNrID0gY29uZmlnLmNoZWNrXG4gIH1cbn1cblxubGV0IHBpbkRpYWxvZyA9IG51bGxcblxuY29uc3QgY29udGV4dENoZWNrID0gY29udGV4dCA9PiB7XG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICBMb2cuaW5mbygnUGxlYXNlIHByb3ZpZGUgY29udGV4dCBleHBsaWNpdGx5JylcbiAgICByZXR1cm4gY29udGV4dEl0ZW1zWzBdXG4gIH0gZWxzZSBpZiAoIWNvbnRleHRJdGVtcy5pbmNsdWRlcyhjb250ZXh0KSkge1xuICAgIExvZy53YXJuKCdJbmNvcnJlY3QgY29udGV4dCBwcm92aWRlZCcpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIGNvbnRleHRcbn1cblxuLy8gUHVibGljIEFQSVxuZXhwb3J0IGRlZmF1bHQge1xuICBzaG93KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBwaW5EaWFsb2cgPSBBcHBsaWNhdGlvbkluc3RhbmNlLnN0YWdlLmMoe1xuICAgICAgICByZWY6ICdQaW5EaWFsb2cnLFxuICAgICAgICB0eXBlOiBQaW5EaWFsb2csXG4gICAgICAgIHJlc29sdmUsXG4gICAgICAgIHJlamVjdCxcbiAgICAgIH0pXG4gICAgICBBcHBsaWNhdGlvbkluc3RhbmNlLmNoaWxkTGlzdC5hKHBpbkRpYWxvZylcbiAgICAgIEFwcGxpY2F0aW9uSW5zdGFuY2UuZm9jdXMgPSBwaW5EaWFsb2dcbiAgICB9KVxuICB9LFxuICBoaWRlKCkge1xuICAgIEFwcGxpY2F0aW9uSW5zdGFuY2UuZm9jdXMgPSBudWxsXG4gICAgQXBwbGljYXRpb25JbnN0YW5jZS5jaGlsZHJlbiA9IEFwcGxpY2F0aW9uSW5zdGFuY2UuY2hpbGRyZW4ubWFwKFxuICAgICAgY2hpbGQgPT4gY2hpbGQgIT09IHBpbkRpYWxvZyAmJiBjaGlsZFxuICAgIClcbiAgICBwaW5EaWFsb2cgPSBudWxsXG4gIH0sXG4gIHN1Ym1pdChwaW4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHRDaGVjayhjb250ZXh0KVxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIHN1Ym1pdChwaW4sIGNvbnRleHQpXG4gICAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoJ0luY29ycmVjdCBDb250ZXh0IHByb3ZpZGVkJylcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICB1bmxvY2tlZChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0Q2hlY2soY29udGV4dClcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICBjaGVjayhjb250ZXh0KVxuICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KCdJbmNvcnJlY3QgQ29udGV4dCBwcm92aWRlZCcpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgbG9ja2VkKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHRDaGVjayhjb250ZXh0KVxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGNoZWNrKGNvbnRleHQpXG4gICAgICAgICAgICAudGhlbih1bmxvY2tlZCA9PiByZXNvbHZlKCEhIXVubG9ja2VkKSlcbiAgICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KCdJbmNvcnJlY3QgQ29udGV4dCBwcm92aWRlZCcpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGdldExvY2FsZSwgZ2V0TGFuZ3VhZ2UsIGdldENvdW50cnlDb2RlLCBnZXRMYXRMb24gfSBmcm9tICcuL2hlbHBlcnMnXG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UHJvZmlsZSA9IHtcbiAgYWdlUmF0aW5nOiAnYWR1bHQnLFxuICBjaXR5OiAnTmV3IFlvcmsnLFxuICB6aXBDb2RlOiAnMjc1MDUnLFxuICBjb3VudHJ5Q29kZTogKCkgPT4gZ2V0Q291bnRyeUNvZGUoJ1VTJyksXG4gIGlwOiAnMTI3LjAuMC4xJyxcbiAgaG91c2Vob2xkOiAnYjIyNDRlOWQ0YzA0ODI2Y2NkNWE3YjJjMmE1MGU3ZDQnLFxuICBsYW5ndWFnZTogKCkgPT4gZ2V0TGFuZ3VhZ2UoJ2VuJyksXG4gIGxhdGxvbjogKCkgPT4gZ2V0TGF0TG9uKFs0MC43MTI4LCA3NC4wMDZdKSxcbiAgbG9jYWxlOiAoKSA9PiBnZXRMb2NhbGUoJ2VuLVVTJyksXG4gIG1hYzogJzAwOjAwOjAwOjAwOjAwOjAwJyxcbiAgb3BlcmF0b3I6ICdtZXRyb2xvZ2ljYWwnLFxuICBwbGF0Zm9ybTogJ21ldHJvbG9naWNhbCcsXG4gIHBhY2thZ2VzOiBbXSxcbiAgdWlkOiAnZWU2NzIzYjgtN2FiMy00NjJjLThkOTMtZGJmNjEyMjc5OThlJyxcbiAgc3RiVHlwZTogJ21ldHJvbG9naWNhbCcsXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5cbmNvbnN0IGZvcm1hdExvY2FsZSA9IGxvY2FsZSA9PiB7XG4gIGlmIChsb2NhbGUgJiYgbG9jYWxlLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBgJHtsb2NhbGUudG9Mb3dlckNhc2UoKX0tJHtsb2NhbGUudG9VcHBlckNhc2UoKX1gXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxvY2FsZVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRMb2NhbGUgPSBkZWZhdWx0VmFsdWUgPT4ge1xuICBpZiAoJ2xhbmd1YWdlJyBpbiBuYXZpZ2F0b3IpIHtcbiAgICBjb25zdCBsb2NhbGUgPSBmb3JtYXRMb2NhbGUobmF2aWdhdG9yLmxhbmd1YWdlKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobG9jYWxlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVmYXVsdFZhbHVlKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRMYW5ndWFnZSA9IGRlZmF1bHRWYWx1ZSA9PiB7XG4gIGlmICgnbGFuZ3VhZ2UnIGluIG5hdmlnYXRvcikge1xuICAgIGNvbnN0IGxhbmd1YWdlID0gZm9ybWF0TG9jYWxlKG5hdmlnYXRvci5sYW5ndWFnZSkuc2xpY2UoMCwgMilcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxhbmd1YWdlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVmYXVsdFZhbHVlKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRDb3VudHJ5Q29kZSA9IGRlZmF1bHRWYWx1ZSA9PiB7XG4gIGlmICgnbGFuZ3VhZ2UnIGluIG5hdmlnYXRvcikge1xuICAgIGNvbnN0IGNvdW50cnlDb2RlID0gZm9ybWF0TG9jYWxlKG5hdmlnYXRvci5sYW5ndWFnZSkuc2xpY2UoMywgNSlcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvdW50cnlDb2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVmYXVsdFZhbHVlKVxuICB9XG59XG5cbmNvbnN0IGhhc09yQXNrRm9yR2VvTG9jYXRpb25QZXJtaXNzaW9uID0gKCkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgLy8gZm9yY2UgdG8gcHJvbXB0IGZvciBsb2NhdGlvbiBwZXJtaXNzaW9uXG4gICAgaWYgKFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnZm9yY2VCcm93c2VyR2VvbG9jYXRpb24nKSA9PT0gdHJ1ZSkgcmVzb2x2ZSh0cnVlKVxuICAgIGlmICgncGVybWlzc2lvbnMnIGluIG5hdmlnYXRvciAmJiB0eXBlb2YgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkoeyBuYW1lOiAnZ2VvbG9jYXRpb24nIH0pLnRoZW4oc3RhdHVzID0+IHtcbiAgICAgICAgcmVzb2x2ZShzdGF0dXMuc3RhdGUgPT09ICdncmFudGVkJyB8fCBzdGF0dXMuc3RhdHVzID09PSAnZ3JhbnRlZCcpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKGZhbHNlKVxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldExhdExvbiA9IGRlZmF1bHRWYWx1ZSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBoYXNPckFza0Zvckdlb0xvY2F0aW9uUGVybWlzc2lvbigpLnRoZW4oZ3JhbnRlZCA9PiB7XG4gICAgICBpZiAoZ3JhbnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpIHtcbiAgICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKFxuICAgICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICAgICAgcmVzdWx0ID0+XG4gICAgICAgICAgICAgIHJlc3VsdCAmJiByZXN1bHQuY29vcmRzICYmIHJlc29sdmUoW3Jlc3VsdC5jb29yZHMubGF0aXR1ZGUsIHJlc3VsdC5jb29yZHMubG9uZ2l0dWRlXSksXG4gICAgICAgICAgICAvLyBlcnJvclxuICAgICAgICAgICAgKCkgPT4gcmVzb2x2ZShkZWZhdWx0VmFsdWUpLFxuICAgICAgICAgICAgLy8gb3B0aW9uc1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlbmFibGVIaWdoQWNjdXJhY3k6IHRydWUsXG4gICAgICAgICAgICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAgICAgICAgICAgIG1heGltdW1BZ2U6IDAsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBxdWVyeUZvckxhdExvbigpLnRoZW4ocmVzdWx0ID0+IHJlc29sdmUocmVzdWx0IHx8IGRlZmF1bHRWYWx1ZSkpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBxdWVyeUZvckxhdExvbigpLnRoZW4ocmVzdWx0ID0+IHJlc29sdmUocmVzdWx0IHx8IGRlZmF1bHRWYWx1ZSkpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cblxuY29uc3QgcXVlcnlGb3JMYXRMb24gPSAoKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBmZXRjaCgnaHR0cHM6Ly9nZW9sb2NhdGlvbi1kYi5jb20vanNvbi8nKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgLnRoZW4oKHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSB9KSA9PlxuICAgICAgICBsYXRpdHVkZSAmJiBsb25naXR1ZGUgPyByZXNvbHZlKFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSkgOiByZXNvbHZlKGZhbHNlKVxuICAgICAgKVxuICAgICAgLmNhdGNoKCgpID0+IHJlc29sdmUoZmFsc2UpKVxuICB9KVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL1NldHRpbmdzJ1xuaW1wb3J0IHsgZGVmYXVsdFByb2ZpbGUgfSBmcm9tICcuL2RlZmF1bHRzJ1xuXG5sZXQgZ2V0SW5mbyA9IGtleSA9PiB7XG4gIGNvbnN0IHByb2ZpbGUgPSB7IC4uLmRlZmF1bHRQcm9maWxlLCAuLi5TZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ3Byb2ZpbGUnKSB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUodHlwZW9mIHByb2ZpbGVba2V5XSA9PT0gJ2Z1bmN0aW9uJyA/IHByb2ZpbGVba2V5XSgpIDogcHJvZmlsZVtrZXldKVxufVxuXG5sZXQgc2V0SW5mbyA9IChrZXksIHBhcmFtcykgPT4ge1xuICBpZiAoa2V5IGluIGRlZmF1bHRQcm9maWxlKSBkZWZhdWx0UHJvZmlsZVtrZXldID0gcGFyYW1zXG59XG5cbmV4cG9ydCBjb25zdCBpbml0UHJvZmlsZSA9IGNvbmZpZyA9PiB7XG4gIGdldEluZm8gPSBjb25maWcuZ2V0SW5mb1xuICBzZXRJbmZvID0gY29uZmlnLnNldEluZm9cbn1cblxuY29uc3QgZ2V0T3JTZXQgPSAoa2V5LCBwYXJhbXMpID0+IChwYXJhbXMgPyBzZXRJbmZvKGtleSwgcGFyYW1zKSA6IGdldEluZm8oa2V5KSlcblxuLy8gcHVibGljIEFQSVxuZXhwb3J0IGRlZmF1bHQge1xuICBhZ2VSYXRpbmcocGFyYW1zKSB7XG4gICAgcmV0dXJuIGdldE9yU2V0KCdhZ2VSYXRpbmcnLCBwYXJhbXMpXG4gIH0sXG4gIGNpdHkocGFyYW1zKSB7XG4gICAgcmV0dXJuIGdldE9yU2V0KCdjaXR5JywgcGFyYW1zKVxuICB9LFxuICB6aXBDb2RlKHBhcmFtcykge1xuICAgIHJldHVybiBnZXRPclNldCgnemlwQ29kZScsIHBhcmFtcylcbiAgfSxcbiAgY291bnRyeUNvZGUocGFyYW1zKSB7XG4gICAgcmV0dXJuIGdldE9yU2V0KCdjb3VudHJ5Q29kZScsIHBhcmFtcylcbiAgfSxcbiAgaXAocGFyYW1zKSB7XG4gICAgcmV0dXJuIGdldE9yU2V0KCdpcCcsIHBhcmFtcylcbiAgfSxcbiAgaG91c2Vob2xkKHBhcmFtcykge1xuICAgIHJldHVybiBnZXRPclNldCgnaG91c2Vob2xkJywgcGFyYW1zKVxuICB9LFxuICBsYW5ndWFnZShwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ2xhbmd1YWdlJywgcGFyYW1zKVxuICB9LFxuICBsYXRsb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuIGdldE9yU2V0KCdsYXRsb24nLCBwYXJhbXMpXG4gIH0sXG4gIGxvY2FsZShwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ2xvY2FsZScsIHBhcmFtcylcbiAgfSxcbiAgbWFjKHBhcmFtcykge1xuICAgIHJldHVybiBnZXRPclNldCgnbWFjJywgcGFyYW1zKVxuICB9LFxuICBvcGVyYXRvcihwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ29wZXJhdG9yJywgcGFyYW1zKVxuICB9LFxuICBwbGF0Zm9ybShwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ3BsYXRmb3JtJywgcGFyYW1zKVxuICB9LFxuICBwYWNrYWdlcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ3BhY2thZ2VzJywgcGFyYW1zKVxuICB9LFxuICB1aWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGdldE9yU2V0KCd1aWQnLCBwYXJhbXMpXG4gIH0sXG4gIHN0YlR5cGUocGFyYW1zKSB7XG4gICAgcmV0dXJuIGdldE9yU2V0KCdzdGJUeXBlJywgcGFyYW1zKVxuICB9LFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFByb2ZpbGUgZnJvbSAnLi4vUHJvZmlsZSdcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi9TZXR0aW5ncydcbmltcG9ydCBzZXF1ZW5jZSBmcm9tICcuLi9oZWxwZXJzL3NlcXVlbmNlJ1xuXG5sZXQgY3NwVXJsID0gJ2h0dHA6Ly9wYXltZW50LWNzcC1leGFtcGxlLm1ldHJvbG9naWNhbC5jb206ODA4MC8nXG5sZXQgYmlsbGluZ1VybCA9ICdodHRwczovL3BheW1lbnQtc2RrLm1ldHJvbG9naWNhbC5jb20vJ1xuXG5sZXQgY3NwRW5kcG9pbnRzID0ge1xuICBhc3NldHM6IHtcbiAgICB1cmk6ICcvYXNzZXRzJyxcbiAgICBtZXRob2Q6ICdHRVQnLFxuICB9LFxuICBhc3NldDoge1xuICAgIHVyaTogJy9hc3NldHMvOmlkJyxcbiAgICBtZXRob2Q6ICdHRVQnLFxuICB9LFxuICBzaWduYXR1cmU6IHtcbiAgICB1cmk6ICcvYXNzZXRzLzppZC9zaWduYXR1cmUnLFxuICAgIG1ldGhvZDogJ1BPU1QnLFxuICB9LFxuICBzdWJzY3JpYmU6IHtcbiAgICB1cmk6ICcvYXNzZXRzLzppZC9zdWJzY3JpYmUnLFxuICAgIG1ldGhvZDogJ1BPU1QnLFxuICB9LFxuICB1bnN1YnNjcmliZToge1xuICAgIHVyaTogJy9hc3NldHMvOmlkL3Vuc3Vic2NyaWJlJyxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgfSxcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRQdXJjaGFzZSA9IGNvbmZpZyA9PiB7XG4gIGlmIChjb25maWcuYmlsbGluZ1VybCkgYmlsbGluZ1VybCA9IGNvbmZpZy5iaWxsaW5nVXJsXG59XG5cbmNvbnN0IGNyZWF0ZVVybCA9ICh1cmksIGJhc2VVcmwsIHBhcmFtcyA9IHt9KSA9PiB7XG4gIHJldHVybiBuZXcgVVJMKFxuICAgIC8vIHNwcmlua2xlIGluIHRoZSBwYXJhbXNcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpXG4gICAgICAucmVkdWNlKChyZXMsIGtleSkgPT4gcmVzLnJlcGxhY2UobmV3IFJlZ0V4cCgnOicgKyBrZXksICdnJyksIHBhcmFtc1trZXldKSwgdXJpKVxuICAgICAgLy8gcmVtb3ZlIGFueSBsZWFkaW5nIHNsYXNoIGZyb20gdXJpXG4gICAgICAucmVwbGFjZSgvXlxcLy8sICcnKSxcbiAgICAvLyBtYWtlIHN1cmUgYmFzZVVybCBhbHdheXMgaGFzIGEgdHJhaWxpbmcgc2xhc2hcbiAgICAvXFwvJC8udGVzdChiYXNlVXJsKSA/IGJhc2VVcmwgOiBiYXNlVXJsLnJlcGxhY2UoLyQvLCAnLycpXG4gIClcbn1cblxuY29uc3QgcmVxdWVzdCA9ICh1cmwsIG1ldGhvZCA9ICdHRVQnLCBkYXRhLCBoZWFkZXJzID0ge30pID0+IHtcbiAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcgJiYgZGF0YSkge1xuICAgIHVybC5zZWFyY2ggPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGRhdGEpXG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZldGNoKHVybCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi57XG4gICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgIH0sXG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIGJvZHk6IG1ldGhvZCAhPT0gJ0dFVCcgJiYgZGF0YSA/IEpTT04uc3RyaW5naWZ5KGRhdGEpIDogbnVsbCxcbiAgICB9KVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gKHJlc3BvbnNlLm9rID8gcmVzb2x2ZShyZXNwb25zZS5qc29uKCkpIDogcmVqZWN0KHJlc3BvbnNlLnN0YXR1c1RleHQpKSlcbiAgICAgIC5jYXRjaChyZWplY3QpXG4gIH0pXG59XG5cbmNvbnN0IGNzcFJlcXVlc3QgPSAodHlwZSwgZGF0YSA9IG51bGwsIHBhcmFtcyA9IHt9KSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSBjc3BFbmRwb2ludHNbdHlwZV1cblxuICAgIGlmICghZW5kcG9pbnQpIHtcbiAgICAgIHJlamVjdCgnTm8gZW5kcG9pbnQgZm91bmQgZm9yIFwiJyArIHR5cGUgKyAnXCIgY2FsbCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbmRwb2ludC5jYWxsYmFjayAmJiB0eXBlb2YgZW5kcG9pbnQuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW5kcG9pbnRcbiAgICAgICAgICAuY2FsbGJhY2soZGF0YSwgcGFyYW1zKVxuICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3QoXG4gICAgICAgICAgY3JlYXRlVXJsKGVuZHBvaW50LnVyaSwgY3NwVXJsLCBwYXJhbXMpLFxuICAgICAgICAgIGVuZHBvaW50Lm1ldGhvZCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi4oZW5kcG9pbnQuZGF0YSB8fCB7fSksXG4gICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5kcG9pbnQuaGVhZGVycyB8fCB7fVxuICAgICAgICApXG4gICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuY29uc3QgYmlsbGluZ1JlcXVlc3QgPSAodXJpLCBkYXRhLCBtZXRob2QgPSAnUE9TVCcpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXF1ZXN0KGNyZWF0ZVVybCh1cmksIGJpbGxpbmdVcmwpLCBtZXRob2QsIGRhdGEpXG4gICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgLmNhdGNoKHJlamVjdClcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBzZXR1cChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnLmNzcFVybCkgY3NwVXJsID0gY29uZmlnLmNzcFVybFxuICAgIGlmIChjb25maWcuZW5kcG9pbnRzKSBjc3BFbmRwb2ludHMgPSB7IGNzcEVuZHBvaW50cywgLi4uY29uZmlnLmVuZHBvaW50cyB9XG4gIH0sXG4gIGFzc2V0cygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgUHJvZmlsZS5ob3VzZWhvbGQoKS50aGVuKGhvdXNlaG9sZCA9PiB7XG4gICAgICAgIGNzcFJlcXVlc3QoJ2Fzc2V0cycsIHsgaG91c2Vob2xkIH0pXG4gICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuICBhc3NldChpZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBQcm9maWxlLmhvdXNlaG9sZCgpLnRoZW4oaG91c2Vob2xkID0+IHtcbiAgICAgICAgY3NwUmVxdWVzdCgnYXNzZXQnLCB7IGhvdXNlaG9sZCB9LCB7IGlkIH0pXG4gICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuICBzaWduYXR1cmUoaWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgUHJvbWlzZS5hbGwoW1Byb2ZpbGUuaG91c2Vob2xkKCldKS50aGVuKChbaG91c2Vob2xkXSkgPT4ge1xuICAgICAgICBjc3BSZXF1ZXN0KCdzaWduYXR1cmUnLCB7IGhvdXNlaG9sZCB9LCB7IGlkIH0pXG4gICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuICBzdWJzY3JpYmUoaWQsIHRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNzcFJlcXVlc3QoJ3N1YnNjcmliZScsIHsgLi4udHJhbnNhY3Rpb24gfSwgeyBpZCB9KVxuICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgIH0pXG4gIH0sXG4gIHVuc3Vic2NyaWJlKGlkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIFByb2ZpbGUuaG91c2Vob2xkKCkudGhlbihob3VzZWhvbGQgPT4ge1xuICAgICAgICBjc3BSZXF1ZXN0KCd1bnN1YnNjcmliZScsIHsgaG91c2Vob2xkIH0sIHsgaWQgfSlcbiAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG4gIHBheW1lbnQoc2lnbmF0dXJlID0ge30sIHR5cGUgPSAnaW4tYXBwJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIFByb2ZpbGUuaG91c2Vob2xkKCksXG4gICAgICAgIFByb2ZpbGUuY291bnRyeUNvZGUoKSxcbiAgICAgICAgUHJvZmlsZS5vcGVyYXRvcigpLFxuICAgICAgICBQcm9maWxlLm1hYygpLFxuICAgICAgICBQcm9maWxlLnVpZCgpLFxuICAgICAgXSlcbiAgICAgICAgLnRoZW4oKFtob3VzZWhvbGQsIGNvdW50cnksIG9wZXJhdG9yLCBtYWMsIHVpZF0pID0+IHtcbiAgICAgICAgICBiaWxsaW5nUmVxdWVzdCgnLycsIHtcbiAgICAgICAgICAgIHB1cmNoYXNlOiBzaWduYXR1cmUsXG4gICAgICAgICAgICBpZGVudGlmaWVyOiBTZXR0aW5ncy5nZXQoJ2FwcCcsICdpZCcpLFxuICAgICAgICAgICAgbmFtZTogU2V0dGluZ3MuZ2V0KCdhcHAnLCAnaWQnKSxcbiAgICAgICAgICAgIGhvdXNlaG9sZCxcbiAgICAgICAgICAgIGNvdW50cnksXG4gICAgICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgICAgIG1hYyxcbiAgICAgICAgICAgIHVpZCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgIH0pXG4gIH0sXG4gIGNvbmZpcm0odHJhbnNhY3Rpb25JZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBiaWxsaW5nUmVxdWVzdCgnL2NvbmZpcm0nLCB7XG4gICAgICAgIHRyYW5zYWN0aW9uSWQsXG4gICAgICB9KVxuICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgIH0pXG4gIH0sXG4gIGJ1eShhc3NldElkLCB0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCB0cmFuc2FjdGlvbklkXG4gICAgICBzZXF1ZW5jZShbXG4gICAgICAgICgpID0+IHRoaXMuc2lnbmF0dXJlKGFzc2V0SWQpLFxuICAgICAgICBzaWduYXR1cmUgPT4gdGhpcy5wYXltZW50KHNpZ25hdHVyZSwgdHlwZSksXG4gICAgICAgIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgICB0cmFuc2FjdGlvbklkID0gdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25JZFxuICAgICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZShhc3NldElkLCB0cmFuc2FjdGlvbilcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gdGhpcy5jb25maXJtKHRyYW5zYWN0aW9uSWQpLFxuICAgICAgXSlcbiAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICB9KVxuICB9LFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExvZyBmcm9tICcuLi9Mb2cnXG5cbmNvbnN0IHJlZ2lzdHJ5ID0ge1xuICBldmVudExpc3RlbmVyczogW10sXG4gIHRpbWVvdXRzOiBbXSxcbiAgaW50ZXJ2YWxzOiBbXSxcbiAgdGFyZ2V0czogW10sXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLy8gVGltZW91dHNcbiAgc2V0VGltZW91dChjYiwgdGltZW91dCwgLi4ucGFyYW1zKSB7XG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgcmVnaXN0cnkudGltZW91dHMgPSByZWdpc3RyeS50aW1lb3V0cy5maWx0ZXIoaWQgPT4gaWQgIT09IHRpbWVvdXRJZClcbiAgICAgICAgY2IuYXBwbHkobnVsbCwgcGFyYW1zKVxuICAgICAgfSxcbiAgICAgIHRpbWVvdXQsXG4gICAgICBwYXJhbXNcbiAgICApXG4gICAgTG9nLmluZm8oJ1NldCBUaW1lb3V0JywgJ0lEOiAnICsgdGltZW91dElkKVxuICAgIHJlZ2lzdHJ5LnRpbWVvdXRzLnB1c2godGltZW91dElkKVxuICAgIHJldHVybiB0aW1lb3V0SWRcbiAgfSxcblxuICBjbGVhclRpbWVvdXQodGltZW91dElkKSB7XG4gICAgaWYgKHJlZ2lzdHJ5LnRpbWVvdXRzLmluZGV4T2YodGltZW91dElkKSA+IC0xKSB7XG4gICAgICByZWdpc3RyeS50aW1lb3V0cyA9IHJlZ2lzdHJ5LnRpbWVvdXRzLmZpbHRlcihpZCA9PiBpZCAhPT0gdGltZW91dElkKVxuICAgICAgTG9nLmluZm8oJ0NsZWFyIFRpbWVvdXQnLCAnSUQ6ICcgKyB0aW1lb3V0SWQpXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuICAgIH0gZWxzZSB7XG4gICAgICBMb2cuZXJyb3IoJ0NsZWFyIFRpbWVvdXQnLCAnSUQgJyArIHRpbWVvdXRJZCArICcgbm90IGZvdW5kJylcbiAgICB9XG4gIH0sXG5cbiAgY2xlYXJUaW1lb3V0cygpIHtcbiAgICByZWdpc3RyeS50aW1lb3V0cy5mb3JFYWNoKHRpbWVvdXRJZCA9PiB7XG4gICAgICB0aGlzLmNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgfSlcbiAgfSxcblxuICAvLyBJbnRlcnZhbHNcbiAgc2V0SW50ZXJ2YWwoY2IsIGludGVydmFsLCAuLi5wYXJhbXMpIHtcbiAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHJlZ2lzdHJ5LmludGVydmFscy5maWx0ZXIoaWQgPT4gaWQgIT09IGludGVydmFsSWQpXG4gICAgICAgIGNiLmFwcGx5KG51bGwsIHBhcmFtcylcbiAgICAgIH0sXG4gICAgICBpbnRlcnZhbCxcbiAgICAgIHBhcmFtc1xuICAgIClcbiAgICBMb2cuaW5mbygnU2V0IEludGVydmFsJywgJ0lEOiAnICsgaW50ZXJ2YWxJZClcbiAgICByZWdpc3RyeS5pbnRlcnZhbHMucHVzaChpbnRlcnZhbElkKVxuICAgIHJldHVybiBpbnRlcnZhbElkXG4gIH0sXG5cbiAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKSB7XG4gICAgaWYgKHJlZ2lzdHJ5LmludGVydmFscy5pbmRleE9mKGludGVydmFsSWQpID4gLTEpIHtcbiAgICAgIHJlZ2lzdHJ5LmludGVydmFscyA9IHJlZ2lzdHJ5LmludGVydmFscy5maWx0ZXIoaWQgPT4gaWQgIT09IGludGVydmFsSWQpXG4gICAgICBMb2cuaW5mbygnQ2xlYXIgSW50ZXJ2YWwnLCAnSUQ6ICcgKyBpbnRlcnZhbElkKVxuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKVxuICAgIH0gZWxzZSB7XG4gICAgICBMb2cuZXJyb3IoJ0NsZWFyIEludGVydmFsJywgJ0lEICcgKyBpbnRlcnZhbElkICsgJyBub3QgZm91bmQnKVxuICAgIH1cbiAgfSxcblxuICBjbGVhckludGVydmFscygpIHtcbiAgICByZWdpc3RyeS5pbnRlcnZhbHMuZm9yRWFjaChpbnRlcnZhbElkID0+IHtcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKVxuICAgIH0pXG4gIH0sXG5cbiAgLy8gRXZlbnQgbGlzdGVuZXJzXG4gIGFkZEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudCwgaGFuZGxlcikge1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKVxuICAgIGNvbnN0IHRhcmdldEluZGV4ID1cbiAgICAgIHJlZ2lzdHJ5LnRhcmdldHMuaW5kZXhPZih0YXJnZXQpID4gLTFcbiAgICAgICAgPyByZWdpc3RyeS50YXJnZXRzLmluZGV4T2YodGFyZ2V0KVxuICAgICAgICA6IHJlZ2lzdHJ5LnRhcmdldHMucHVzaCh0YXJnZXQpIC0gMVxuXG4gICAgcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnNbdGFyZ2V0SW5kZXhdID0gcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnNbdGFyZ2V0SW5kZXhdIHx8IHt9XG4gICAgcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnNbdGFyZ2V0SW5kZXhdW2V2ZW50XSA9IHJlZ2lzdHJ5LmV2ZW50TGlzdGVuZXJzW3RhcmdldEluZGV4XVtldmVudF0gfHwgW11cbiAgICByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF1bZXZlbnRdLnB1c2goaGFuZGxlcilcbiAgICBMb2cuaW5mbyhcbiAgICAgICdBZGQgZXZlbnRMaXN0ZW5lcicsXG4gICAgICAnVGFyZ2V0OicsXG4gICAgICB0YXJnZXQsXG4gICAgICAnRXZlbnQ6ICcgKyBldmVudCxcbiAgICAgICdIYW5kbGVyOicsXG4gICAgICBoYW5kbGVyLnRvU3RyaW5nKClcbiAgICApXG4gIH0sXG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSByZWdpc3RyeS50YXJnZXRzLmluZGV4T2YodGFyZ2V0KVxuICAgIGlmIChcbiAgICAgIHRhcmdldEluZGV4ID4gLTEgJiZcbiAgICAgIHJlZ2lzdHJ5LmV2ZW50TGlzdGVuZXJzW3RhcmdldEluZGV4XSAmJlxuICAgICAgcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnNbdGFyZ2V0SW5kZXhdW2V2ZW50XSAmJlxuICAgICAgcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnNbdGFyZ2V0SW5kZXhdW2V2ZW50XS5pbmRleE9mKGhhbmRsZXIpID4gLTFcbiAgICApIHtcbiAgICAgIHJlZ2lzdHJ5LmV2ZW50TGlzdGVuZXJzW3RhcmdldEluZGV4XVtldmVudF0gPSByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF1bXG4gICAgICAgIGV2ZW50XG4gICAgICBdLmZpbHRlcihmbiA9PiBmbiAhPT0gaGFuZGxlcilcbiAgICAgIExvZy5pbmZvKFxuICAgICAgICAnUmVtb3ZlIGV2ZW50TGlzdGVuZXInLFxuICAgICAgICAnVGFyZ2V0OicsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgJ0V2ZW50OiAnICsgZXZlbnQsXG4gICAgICAgICdIYW5kbGVyOicsXG4gICAgICAgIGhhbmRsZXIudG9TdHJpbmcoKVxuICAgICAgKVxuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIExvZy5lcnJvcihcbiAgICAgICAgJ1JlbW92ZSBldmVudExpc3RlbmVyJyxcbiAgICAgICAgJ05vdCBmb3VuZCcsXG4gICAgICAgICdUYXJnZXQnLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgICdFdmVudDogJyArIGV2ZW50LFxuICAgICAgICAnSGFuZGxlcicsXG4gICAgICAgIGhhbmRsZXIudG9TdHJpbmcoKVxuICAgICAgKVxuICAgIH1cbiAgfSxcblxuICAvLyBpZiBgZXZlbnRgIGlzIG9taXR0ZWQsIHJlbW92ZXMgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIGZvciB0YXJnZXRcbiAgLy8gaWYgYHRhcmdldGAgaXMgYWxzbyBvbWl0dGVkLCByZW1vdmVzIGFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVyc1xuICByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIGV2ZW50KSB7XG4gICAgaWYgKHRhcmdldCAmJiBldmVudCkge1xuICAgICAgY29uc3QgdGFyZ2V0SW5kZXggPSByZWdpc3RyeS50YXJnZXRzLmluZGV4T2YodGFyZ2V0KVxuICAgICAgaWYgKHRhcmdldEluZGV4ID4gLTEpIHtcbiAgICAgICAgcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnNbdGFyZ2V0SW5kZXhdW2V2ZW50XS5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50LCBoYW5kbGVyKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGFyZ2V0KSB7XG4gICAgICBjb25zdCB0YXJnZXRJbmRleCA9IHJlZ2lzdHJ5LnRhcmdldHMuaW5kZXhPZih0YXJnZXQpXG4gICAgICBpZiAodGFyZ2V0SW5kZXggPiAtMSkge1xuICAgICAgICBPYmplY3Qua2V5cyhyZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF0pLmZvckVhY2goX2V2ZW50ID0+IHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgX2V2ZW50KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3Qua2V5cyhyZWdpc3RyeS5ldmVudExpc3RlbmVycykuZm9yRWFjaCh0YXJnZXRJbmRleCA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnMocmVnaXN0cnkudGFyZ2V0c1t0YXJnZXRJbmRleF0pXG4gICAgICB9KVxuICAgIH1cbiAgfSxcblxuICAvLyBDbGVhciBldmVyeXRoaW5nICh0byBiZSBjYWxsZWQgdXBvbiBhcHAgY2xvc2UgZm9yIHByb3BlciBjbGVhbnVwKVxuICBjbGVhcigpIHtcbiAgICB0aGlzLmNsZWFyVGltZW91dHMoKVxuICAgIHRoaXMuY2xlYXJJbnRlcnZhbHMoKVxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKVxuICAgIHJlZ2lzdHJ5LmV2ZW50TGlzdGVuZXJzID0gW11cbiAgICByZWdpc3RyeS50aW1lb3V0cyA9IFtdXG4gICAgcmVnaXN0cnkuaW50ZXJ2YWxzID0gW11cbiAgICByZWdpc3RyeS50YXJnZXRzID0gW11cbiAgfSxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBMaWdodG5pbmcgZnJvbSAnLi4vTGlnaHRuaW5nJ1xuaW1wb3J0IHsgZGVmYXVsdCBhcyBSb3V0ZXIgfSBmcm9tICcuL2luZGV4J1xuaW1wb3J0IHsgcm91dGVyQ29uZmlnIH0gZnJvbSAnLi91dGlscy9yb3V0ZXIuanMnXG5pbXBvcnQgeyBpc0Jvb2xlYW4gfSBmcm9tICcuL3V0aWxzL2hlbHBlcnMnXG5cbmV4cG9ydCBjbGFzcyBSb3V0ZWRBcHAgZXh0ZW5kcyBMaWdodG5pbmcuQ29tcG9uZW50IHtcbiAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgUGFnZXM6IHtcbiAgICAgICAgZm9yY2VaSW5kZXhDb250ZXh0OiB0cnVlLFxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBpcyBhIGRlZmF1bHQgTG9hZGluZyBwYWdlIHRoYXQgd2lsbCBiZSBtYWRlIHZpc2libGVcbiAgICAgICAqIGR1cmluZyBkYXRhLXByb3ZpZGVyIG9uKCkgeW91IENBTiBvdmVycmlkZSBpbiBjaGlsZC1jbGFzc1xuICAgICAgICovXG4gICAgICBMb2FkaW5nOiB7XG4gICAgICAgIHJlY3Q6IHRydWUsXG4gICAgICAgIHc6IDE5MjAsXG4gICAgICAgIGg6IDEwODAsXG4gICAgICAgIGNvbG9yOiAweGZmMDAwMDAwLFxuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgekluZGV4OiA5OSxcbiAgICAgICAgTGFiZWw6IHtcbiAgICAgICAgICBtb3VudDogMC41LFxuICAgICAgICAgIHg6IDk2MCxcbiAgICAgICAgICB5OiA1NDAsXG4gICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgdGV4dDogJ0xvYWRpbmcuLicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIF9zdGF0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGNsYXNzIExvYWRpbmcgZXh0ZW5kcyB0aGlzIHtcbiAgICAgICAgJGVudGVyKCkge1xuICAgICAgICAgIHRoaXMudGFnKCdMb2FkaW5nJykudmlzaWJsZSA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgICRleGl0KCkge1xuICAgICAgICAgIHRoaXMudGFnKCdMb2FkaW5nJykudmlzaWJsZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbGFzcyBXaWRnZXRzIGV4dGVuZHMgdGhpcyB7XG4gICAgICAgICRlbnRlcihhcmdzLCB3aWRnZXQpIHtcbiAgICAgICAgICAvLyBzdG9yZSB3aWRnZXQgcmVmZXJlbmNlXG4gICAgICAgICAgdGhpcy5fd2lkZ2V0ID0gd2lkZ2V0XG5cbiAgICAgICAgICAvLyBzaW5jZSBpdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBiZWhhdmlvdXJcbiAgICAgICAgICAvLyBpcyBub24tcmVtb3RlIGRyaXZlbiB3ZSBmb3JjZSBhIHJlY2FsY3VsYXRpb25cbiAgICAgICAgICAvLyBvZiB0aGUgZm9jdXNwYXRoXG4gICAgICAgICAgdGhpcy5fcmVmb2N1cygpXG4gICAgICAgIH1cblxuICAgICAgICBfZ2V0Rm9jdXNlZCgpIHtcbiAgICAgICAgICAvLyB3ZSBkZWxlZ2F0ZSBmb2N1cyB0byBzZWxlY3RlZCB3aWRnZXRcbiAgICAgICAgICAvLyBzbyBpdCBjYW4gY29uc3VtZSByZW1vdGVjb250cm9sIHByZXNzZXNcbiAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkZ2V0XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSB3YW50IHRvIHdpZGdldCB0byB3aWRnZXQgZm9jdXMgZGVsZWdhdGlvblxuICAgICAgICByZWxvYWQod2lkZ2V0KSB7XG4gICAgICAgICAgdGhpcy5fd2lkZ2V0ID0gd2lkZ2V0XG4gICAgICAgICAgdGhpcy5fcmVmb2N1cygpXG4gICAgICAgIH1cblxuICAgICAgICBfaGFuZGxlS2V5KCkge1xuICAgICAgICAgIGNvbnN0IHJlc3RvcmVGb2N1cyA9IHJvdXRlckNvbmZpZy5nZXQoJ2F1dG9SZXN0b3JlUmVtb3RlJylcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgUm91dGVyIHVzZWQgdG8gZGVsZWdhdGUgZm9jdXMgYmFjayB0byB0aGUgcGFnZSBpbnN0YW5jZSBvblxuICAgICAgICAgICAqIGV2ZXJ5IHVuaGFuZGxlZCBrZXkuIFRoaXMgaXMgYmFyZWx5IHVzZWZ1bGwgaW4gYW55IHNpdHVhdGlvblxuICAgICAgICAgICAqIHNvIGZvciBub3cgd2Ugb2ZmZXIgdGhlIG9wdGlvbiB0byBleHBsaWNpdHkgdHVybiB0aGF0IGJlaGF2aW91ciBvZmZcbiAgICAgICAgICAgKiBzbyB3ZSBkb24ndCBkb24ndCBpbnRyb2R1Y2UgYSBicmVha2luZyBjaGFuZ2UuXG4gICAgICAgICAgICovXG4gICAgICAgICAgaWYgKCFpc0Jvb2xlYW4ocmVzdG9yZUZvY3VzKSB8fCByZXN0b3JlRm9jdXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIFJvdXRlci5mb2N1c1BhZ2UoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICBdXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGxvY2F0aW9uIHdoZXJlIHBhZ2VzIG5lZWQgdG8gYmUgc3RvcmVkXG4gICAqL1xuICBnZXQgcGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnKCdQYWdlcycpXG4gIH1cblxuICAvKipcbiAgICogVGVsbCByb3V0ZXIgd2hlcmUgd2lkZ2V0cyBhcmUgc3RvcmVkXG4gICAqL1xuICBnZXQgd2lkZ2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy50YWcoJ1dpZGdldHMnKVxuICB9XG5cbiAgLyoqXG4gICAqIHdlIE1VU1QgcmVnaXN0ZXIgX2hhbmRsZUJhY2sgbWV0aG9kIHNvIHRoZSBSb3V0ZXJcbiAgICogY2FuIG92ZXJyaWRlIGl0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlQmFjaygpIHt9XG5cbiAgLyoqXG4gICAqIFdlIE1VU1QgcmV0dXJuIFJvdXRlci5hY3RpdmVQYWdlKCkgc28gdGhlIG5ldyBQYWdlXG4gICAqIGNhbiBsaXN0ZW4gdG8gdGhlIHJlbW90ZS1jb250cm9sLlxuICAgKi9cbiAgX2dldEZvY3VzZWQoKSB7XG4gICAgcmV0dXJuIFJvdXRlci5nZXRBY3RpdmVQYWdlKClcbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgaXNGdW5jdGlvbixcbiAgaXNQYWdlLFxuICBpc09iamVjdCxcbiAgaXNCb29sZWFuLFxuICBpc1N0cmluZyxcbiAgZ2V0UXVlcnlTdHJpbmdQYXJhbXMsXG4gIHN5bWJvbHMsXG4gIGNsZWFuSGFzaCxcbn0gZnJvbSAnLi91dGlscy9oZWxwZXJzJ1xuXG5pbXBvcnQge1xuICBib290Um91dGVyLFxuICByb3V0ZUV4aXN0cyxcbiAgZ2V0Um9vdEhhc2gsXG4gIGdldEJvb3RSZXF1ZXN0LFxuICBtdXN0VXBkYXRlTG9jYXRpb25IYXNoLFxuICBnZXRDb21wb25lbnQsXG4gIHN0b3JlQ29tcG9uZW50LFxuICBzdGFnZSxcbiAgYXBwLFxuICByb3V0ZXJDb25maWcsXG4gIHNldExhc3RIYXNoLFxuICBnZXRBY3RpdmVQYWdlLFxuICBiZWZvcmVFYWNoUm91dGUsXG4gIGdldEFjdGl2ZUhhc2gsXG4gIGdldEFjdGl2ZVJvdXRlLFxufSBmcm9tICcuL3V0aWxzL3JvdXRlcidcblxuaW1wb3J0IHsgZm9jdXNXaWRnZXQsIGdldEFjdGl2ZVdpZGdldCwgcmVzdG9yZUZvY3VzIH0gZnJvbSAnLi91dGlscy93aWRnZXRzJ1xuaW1wb3J0IHsgZ2V0SGlzdG9yeSwgc2V0SGlzdG9yeSwgZ2V0SGlzdG9yeVN0YXRlLCByZXBsYWNlSGlzdG9yeVN0YXRlIH0gZnJvbSAnLi91dGlscy9oaXN0b3J5J1xuaW1wb3J0IHtcbiAgY3JlYXRlUmVxdWVzdCxcbiAgZ2V0Um91dGVCeUhhc2gsXG4gIGdldFZhbHVlc0Zyb21IYXNoLFxuICBnZXRGbG9vcixcbiAgZ2V0SGFzaEJ5TmFtZSxcbiAga2VlcEFjdGl2ZVBhZ2VBbGl2ZSxcbn0gZnJvbSAnLi91dGlscy9yb3V0ZSdcbmltcG9ydCB7IGxvYWQgfSBmcm9tICcuL3V0aWxzL2xvYWRlcidcbmltcG9ydCB7IHN0cmlwUmVnZXgsIGlzV2lsZGNhcmQgfSBmcm9tICcuL3V0aWxzL3JlZ2V4J1xuaW1wb3J0IHsgUm91dGVkQXBwIH0gZnJvbSAnLi9iYXNlJ1xuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uL1JlZ2lzdHJ5J1xuXG4vKlxucm91VGhvciA9PVt4XVxuICovXG5leHBvcnQgbGV0IG5hdmlnYXRlUXVldWUgPSBuZXcgTWFwKClcbmxldCBmb3JjZWRIYXNoID0gJydcbmxldCByZXN1bWVIYXNoID0gJydcblxuLyoqXG4gKiBTdGFydCByb3V0aW5nIHRoZSBhcHBcbiAqIEBwYXJhbSBjb25maWcgLSByb3V0ZSBjb25maWcgb2JqZWN0XG4gKiBAcGFyYW0gaW5zdGFuY2UgLSBpbnN0YW5jZSBvZiB0aGUgYXBwXG4gKi9cbmNvbnN0IHN0YXJ0Um91dGVyID0gKGNvbmZpZywgaW5zdGFuY2UpID0+IHtcbiAgYm9vdFJvdXRlcihjb25maWcsIGluc3RhbmNlKVxuICByZWdpc3Rlckxpc3RlbmVyKClcbiAgc3RhcnQoKVxufVxuXG4vLyBzdGFydCB0cmFuc2xhdGluZyB1cmxcbmNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICBsZXQgaGFzaCA9IChnZXRIYXNoKCkgfHwgJycpLnJlcGxhY2UoL14jLywgJycpXG4gIGNvbnN0IGJvb3RLZXkgPSAnJCdcbiAgY29uc3QgcGFyYW1zID0gZ2V0UXVlcnlTdHJpbmdQYXJhbXMoaGFzaClcbiAgY29uc3QgYm9vdFJlcXVlc3QgPSBnZXRCb290UmVxdWVzdCgpXG4gIGNvbnN0IHJvb3RIYXNoID0gZ2V0Um9vdEhhc2goKVxuICBjb25zdCBpc0RpcmVjdExvYWQgPSBoYXNoLmluZGV4T2YoYm9vdEtleSkgIT09IC0xXG5cbiAgLy8gcHJldmVudCBkaXJlY3QgcmVsb2FkIG9mIHdpbGRjYXJkIHJvdXRlc1xuICAvLyBleHBlY3QgYm9vdENvbXBvbmVudFxuICBpZiAoaXNXaWxkY2FyZC50ZXN0KGhhc2gpICYmIGhhc2ggIT09IGJvb3RLZXkpIHtcbiAgICBoYXNoID0gJydcbiAgfVxuXG4gIC8vIHN0b3JlIHJlc3VtZSBwb2ludCBmb3IgbWFudWFsIHJlc3VtZVxuICByZXN1bWVIYXNoID0gaXNEaXJlY3RMb2FkID8gcm9vdEhhc2ggOiBoYXNoIHx8IHJvb3RIYXNoXG5cbiAgY29uc3QgcmVhZHkgPSAoKSA9PiB7XG4gICAgaWYgKCFoYXNoICYmIHJvb3RIYXNoKSB7XG4gICAgICBpZiAoaXNTdHJpbmcocm9vdEhhc2gpKSB7XG4gICAgICAgIG5hdmlnYXRlKHJvb3RIYXNoKVxuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHJvb3RIYXNoKSkge1xuICAgICAgICByb290SGFzaCgpLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICAgICAgbmF2aWdhdGUocmVzLnBhdGgsIHJlcy5wYXJhbXMpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hdmlnYXRlKHJlcylcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlKGhhc2gpXG4gICAgICBoYW5kbGVIYXNoQ2hhbmdlKClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGFwcC5fcmVmb2N1cygpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKHJvdXRlRXhpc3RzKGJvb3RLZXkpKSB7XG4gICAgaWYgKGhhc2ggJiYgIWlzRGlyZWN0TG9hZCkge1xuICAgICAgaWYgKCFnZXRSb3V0ZUJ5SGFzaChoYXNoKSkge1xuICAgICAgICBuYXZpZ2F0ZSgnKicsIHsgZmFpbGVkSGFzaDogaGFzaCB9KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgbmF2aWdhdGUoXG4gICAgICBib290S2V5LFxuICAgICAge1xuICAgICAgICByZXN1bWU6IHJlc3VtZUhhc2gsXG4gICAgICAgIHJlbG9hZDogYm9vdEtleSA9PT0gaGFzaCxcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgIClcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGJvb3RSZXF1ZXN0KSkge1xuICAgIGJvb3RSZXF1ZXN0KHBhcmFtcylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmVhZHkoKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgaGFuZGxlQm9vdEVycm9yKGUpXG4gICAgICB9KVxuICB9IGVsc2Uge1xuICAgIHJlYWR5KClcbiAgfVxufVxuXG5jb25zdCBoYW5kbGVCb290RXJyb3IgPSBlID0+IHtcbiAgaWYgKHJvdXRlRXhpc3RzKCchJykpIHtcbiAgICBuYXZpZ2F0ZSgnIScsIHsgcmVxdWVzdDogeyBlcnJvcjogZSB9IH0pXG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihlKVxuICB9XG59XG5cbi8qKlxuICogc3RhcnQgYSBuZXcgcmVxdWVzdFxuICogQHBhcmFtIHVybFxuICogQHBhcmFtIGFyZ3NcbiAqIEBwYXJhbSBzdG9yZVxuICovXG5leHBvcnQgY29uc3QgbmF2aWdhdGUgPSAodXJsLCBhcmdzID0ge30sIHN0b3JlKSA9PiB7XG4gIGlmIChpc09iamVjdCh1cmwpKSB7XG4gICAgdXJsID0gZ2V0SGFzaEJ5TmFtZSh1cmwpXG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIGxldCBoYXNoID0gZ2V0SGFzaCgpXG4gIGlmICghbXVzdFVwZGF0ZUxvY2F0aW9uSGFzaCgpICYmIGZvcmNlZEhhc2gpIHtcbiAgICBoYXNoID0gZm9yY2VkSGFzaFxuICB9XG4gIGlmIChoYXNoLnJlcGxhY2UoL14jLywgJycpICE9PSB1cmwpIHtcbiAgICAvLyBwdXNoIHJlcXVlc3QgaW4gdGhlIHF1ZXVlXG4gICAgcXVldWUodXJsLCBhcmdzLCBzdG9yZSlcblxuICAgIHNldEhhc2godXJsKVxuICAgIGlmICghbXVzdFVwZGF0ZUxvY2F0aW9uSGFzaCgpKSB7XG4gICAgICBmb3JjZWRIYXNoID0gdXJsXG4gICAgICBoYW5kbGVIYXNoQ2hhbmdlKHVybClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGFwcC5fcmVmb2N1cygpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICAgIH0pXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3MucmVsb2FkKSB7XG4gICAgLy8gcHVzaCByZXF1ZXN0IGluIHRoZSBxdWV1ZVxuICAgIHF1ZXVlKHVybCwgYXJncywgc3RvcmUpXG5cbiAgICBoYW5kbGVIYXNoQ2hhbmdlKHVybClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgYXBwLl9yZWZvY3VzKClcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgIH0pXG4gIH1cbn1cblxuY29uc3QgcXVldWUgPSAoaGFzaCwgYXJncyA9IHt9LCBzdG9yZSkgPT4ge1xuICBoYXNoID0gY2xlYW5IYXNoKGhhc2gpXG4gIGlmICghbmF2aWdhdGVRdWV1ZS5oYXMoaGFzaCkpIHtcbiAgICBmb3IgKGxldCByZXF1ZXN0IG9mIG5hdmlnYXRlUXVldWUudmFsdWVzKCkpIHtcbiAgICAgIHJlcXVlc3QuY2FuY2VsKClcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QoaGFzaCwgYXJncywgc3RvcmUpXG4gICAgbmF2aWdhdGVRdWV1ZS5zZXQoZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpLCByZXF1ZXN0KVxuXG4gICAgcmV0dXJuIHJlcXVlc3RcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBIYW5kbGUgY2hhbmdlIG9mIGhhc2hcbiAqIEBwYXJhbSBvdmVycmlkZVxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmNvbnN0IGhhbmRsZUhhc2hDaGFuZ2UgPSBhc3luYyBvdmVycmlkZSA9PiB7XG4gIGNvbnN0IGhhc2ggPSBjbGVhbkhhc2gob3ZlcnJpZGUgfHwgZ2V0SGFzaCgpKVxuICBjb25zdCBxdWV1ZUlkID0gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpXG4gIGxldCByZXF1ZXN0ID0gbmF2aWdhdGVRdWV1ZS5nZXQocXVldWVJZClcblxuICAvLyBoYW5kbGUgaGFzaCB1cGRhdGVkIG1hbnVhbGx5XG4gIGlmICghcmVxdWVzdCAmJiAhbmF2aWdhdGVRdWV1ZS5zaXplKSB7XG4gICAgcmVxdWVzdCA9IHF1ZXVlKGhhc2gpXG4gIH1cblxuICBjb25zdCByb3V0ZSA9IGdldFJvdXRlQnlIYXNoKGhhc2gpXG5cbiAgaWYgKCFyb3V0ZSkge1xuICAgIGlmIChyb3V0ZUV4aXN0cygnKicpKSB7XG4gICAgICBuYXZpZ2F0ZSgnKicsIHsgZmFpbGVkSGFzaDogaGFzaCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBVbmFibGUgdG8gbmF2aWdhdGUgdG86ICR7aGFzaH1gKVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIHVwZGF0ZSBjdXJyZW50IHByb2Nlc3NlZCByZXF1ZXN0XG4gIHJlcXVlc3QuaGFzaCA9IGhhc2hcbiAgcmVxdWVzdC5yb3V0ZSA9IHJvdXRlXG5cbiAgbGV0IHJlc3VsdCA9IGF3YWl0IGJlZm9yZUVhY2hSb3V0ZShnZXRBY3RpdmVIYXNoKCksIHJlcXVlc3QpXG5cbiAgLy8gdGVzdCBpZiBhIGxvY2FsIGhvb2sgaXMgY29uZmlndXJlZCBmb3IgdGhlIHJvdXRlXG4gIGlmIChyb3V0ZS5iZWZvcmVOYXZpZ2F0ZSkge1xuICAgIHJlc3VsdCA9IGF3YWl0IHJvdXRlLmJlZm9yZU5hdmlnYXRlKGdldEFjdGl2ZUhhc2goKSwgcmVxdWVzdClcbiAgfVxuXG4gIGlmIChpc0Jvb2xlYW4ocmVzdWx0KSkge1xuICAgIC8vIG9ubHkgaWYgcmVzb2x2ZSB2YWx1ZSBpcyBleHBsaWNpdGx5IHRydWVcbiAgICAvLyB3ZSBjb250aW51ZSB0aGUgY3VycmVudCByb3V0ZSByZXF1ZXN0XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVIYXNoQ2hhbmdlKHJlcXVlc3QpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlmIG5hdmlnYXRpb24gZ3VhcmQgZGlkbid0IHJldHVybiB0cnVlXG4gICAgLy8gd2UgY2FuY2VsIHRoZSBjdXJyZW50IHJlcXVlc3RcbiAgICByZXF1ZXN0LmNhbmNlbCgpXG4gICAgbmF2aWdhdGVRdWV1ZS5kZWxldGUocXVldWVJZClcblxuICAgIGlmIChpc1N0cmluZyhyZXN1bHQpKSB7XG4gICAgICBuYXZpZ2F0ZShyZXN1bHQpXG4gICAgfSBlbHNlIGlmIChpc09iamVjdChyZXN1bHQpKSB7XG4gICAgICBsZXQgc3RvcmUgPSB0cnVlXG4gICAgICBpZiAoaXNCb29sZWFuKHJlc3VsdC5zdG9yZSkpIHtcbiAgICAgICAgc3RvcmUgPSByZXN1bHQuc3RvcmVcbiAgICAgIH1cbiAgICAgIG5hdmlnYXRlKHJlc3VsdC5wYXRoLCByZXN1bHQucGFyYW1zLCBzdG9yZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb250aW51ZSBwcm9jZXNzaW5nIHRoZSBoYXNoIGNoYW5nZSBpZiBub3QgYmxvY2tlZFxuICogYnkgZ2xvYmFsIG9yIGxvY2FsIGhvb2tcbiAqIEBwYXJhbSByZXF1ZXN0IC0ge31cbiAqL1xuY29uc3QgcmVzb2x2ZUhhc2hDaGFuZ2UgPSByZXF1ZXN0ID0+IHtcbiAgY29uc3QgaGFzaCA9IHJlcXVlc3QuaGFzaFxuICBjb25zdCByb3V0ZSA9IHJlcXVlc3Qucm91dGVcbiAgY29uc3QgcXVldWVJZCA9IGRlY29kZVVSSUNvbXBvbmVudChoYXNoKVxuICAvLyBzdG9yZSBsYXN0IHJlcXVlc3RlZCBoYXNoIHNvIHdlIGNhblxuICAvLyBwcmV2ZW50IGEgcm91dGUgdGhhdCByZXNvbHZlZCBsYXRlclxuICAvLyBmcm9tIGRpc3BsYXlpbmcgaXRzZWxmXG4gIHNldExhc3RIYXNoKGhhc2gpXG5cbiAgaWYgKHJvdXRlLnBhdGgpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBnZXRDb21wb25lbnQocm91dGUucGF0aClcbiAgICAvLyBpZiBhIGhvb2sgaXMgcHJvdmlkZWQgZm9yIHRoZSBjdXJyZW50IHJvdXRlXG4gICAgaWYgKGlzRnVuY3Rpb24ocm91dGUuaG9vaykpIHtcbiAgICAgIGNvbnN0IHVybFBhcmFtcyA9IGdldFZhbHVlc0Zyb21IYXNoKGhhc2gsIHJvdXRlLnBhdGgpXG4gICAgICBjb25zdCBwYXJhbXMgPSB7fVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXJsUGFyYW1zLmtleXMoKSkge1xuICAgICAgICBwYXJhbXNba2V5XSA9IHVybFBhcmFtcy5nZXQoa2V5KVxuICAgICAgfVxuICAgICAgcm91dGUuaG9vayhhcHAsIHsgLi4ucGFyYW1zIH0pXG4gICAgfVxuICAgIC8vIGlmIHRoZXJlIGlzIGEgY29tcG9uZW50IGF0dGFjaGVkIHRvIHRoZSByb3V0ZVxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIC8vIGZvcmNlIHBhZ2UgdG8gcm9vdCBzdGF0ZSB0byBwcmV2ZW50IHNoYXJlZCBzdGF0ZSBpc3N1ZXNcbiAgICAgIGNvbnN0IGFjdGl2ZVBhZ2UgPSBnZXRBY3RpdmVQYWdlKClcbiAgICAgIGlmIChhY3RpdmVQYWdlKSB7XG4gICAgICAgIGNvbnN0IGtlZXBBbGl2ZSA9IGtlZXBBY3RpdmVQYWdlQWxpdmUoZ2V0QWN0aXZlUm91dGUoKSwgcmVxdWVzdClcbiAgICAgICAgaWYgKGFjdGl2ZVBhZ2UgJiYgcm91dGUucGF0aCA9PT0gZ2V0QWN0aXZlUm91dGUoKSAmJiAha2VlcEFsaXZlKSB7XG4gICAgICAgICAgYWN0aXZlUGFnZS5fc2V0U3RhdGUoJycpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzUGFnZShjb21wb25lbnQsIHN0YWdlKSkge1xuICAgICAgICBsb2FkKHJlcXVlc3QpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGFwcC5fcmVmb2N1cygpXG4gICAgICAgICAgbmF2aWdhdGVRdWV1ZS5kZWxldGUocXVldWVJZClcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9mIHRoZSBjb21wb25lbnQgaXMgbm90IGEgY29uc3RydWN0b3JcbiAgICAgICAgLy8gb3IgYSBDb21wb25lbnQgaW5zdGFuY2Ugd2UgY2FuIGFzc3VtZVxuICAgICAgICAvLyB0aGF0IGl0J3MgYSBkeW5hbWljIGltcG9ydFxuICAgICAgICBjb21wb25lbnQoKVxuICAgICAgICAgIC50aGVuKGNvbnRlbnRzID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50cy5kZWZhdWx0XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgc3RvcmVDb21wb25lbnQocm91dGUucGF0aCwgbW9kdWxlKVxuICAgICAgICAgICAgcmV0dXJuIGxvYWQocmVxdWVzdClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGFwcC5fcmVmb2N1cygpXG4gICAgICAgICAgICBuYXZpZ2F0ZVF1ZXVlLmRlbGV0ZShxdWV1ZUlkKVxuICAgICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hdmlnYXRlUXVldWUuZGVsZXRlKHF1ZXVlSWQpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlyZWN0aW9uYWwgc3RlcCBpbiBoaXN0b3J5XG4gKiBAcGFyYW0gZGlyZWN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdGVwID0gKGxldmVsID0gMCkgPT4ge1xuICBpZiAoIWxldmVsIHx8IGlzTmFOKGxldmVsKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGNvbnN0IGhpc3RvcnkgPSBnZXRIaXN0b3J5KClcbiAgLy8gZm9yIG5vdyB3ZSBvbmx5IHN1cHBvcnQgbmVnYXRpdmUgbnVtYmVyc1xuICBsZXZlbCA9IE1hdGguYWJzKGxldmVsKVxuXG4gIC8vIHdlIGNhbid0IHN0ZXAgYmFjayBwYXN0IHRoZSBhbW91bnRcbiAgLy8gb2YgaGlzdG9yeSBlbnRyaWVzXG4gIGlmIChsZXZlbCA+IGhpc3RvcnkubGVuZ3RoKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oYXBwLl9oYW5kbGVBcHBDbG9zZSkpIHtcbiAgICAgIHJldHVybiBhcHAuX2hhbmRsZUFwcENsb3NlKClcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoaGlzdG9yeS5sZW5ndGgpIHtcbiAgICAvLyBmb3Igbm93IHdlIG9ubHkgc3VwcG9ydCBoaXN0b3J5IGJhY2tcbiAgICBjb25zdCByb3V0ZSA9IGhpc3Rvcnkuc3BsaWNlKGhpc3RvcnkubGVuZ3RoIC0gbGV2ZWwsIGxldmVsKVswXVxuICAgIC8vIHN0b3JlIGNoYW5nZWQgaGlzdG9yeVxuICAgIHNldEhpc3RvcnkoaGlzdG9yeSlcbiAgICByZXR1cm4gbmF2aWdhdGUoXG4gICAgICByb3V0ZS5oYXNoLFxuICAgICAge1xuICAgICAgICBbc3ltYm9scy5iYWNrdHJhY2tdOiB0cnVlLFxuICAgICAgICBbc3ltYm9scy5oaXN0b3J5U3RhdGVdOiByb3V0ZS5zdGF0ZSxcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgIClcbiAgfSBlbHNlIGlmIChyb3V0ZXJDb25maWcuZ2V0KCdiYWNrdHJhY2snKSkge1xuICAgIGNvbnN0IGhhc2hMYXN0UGFydCA9IC8oXFwvOj9bXFx3JVxccy1dKykkL1xuICAgIGxldCBoYXNoID0gc3RyaXBSZWdleChnZXRIYXNoKCkpXG4gICAgbGV0IGZsb29yID0gZ2V0Rmxvb3IoaGFzaClcblxuICAgIC8vIHRlc3QgaWYgd2UgZ290IGRlZXAtbGlua2VkXG4gICAgaWYgKGZsb29yID4gMSkge1xuICAgICAgd2hpbGUgKGZsb29yLS0pIHtcbiAgICAgICAgLy8gc3RyaXAgb2YgbGFzdCBwYXJ0XG4gICAgICAgIGhhc2ggPSBoYXNoLnJlcGxhY2UoaGFzaExhc3RQYXJ0LCAnJylcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGNvbmZpZ3VyZWQgcm91dGVcbiAgICAgICAgLy8gd2UgbmF2aWdhdGUgdG8gaXRcbiAgICAgICAgaWYgKGdldFJvdXRlQnlIYXNoKGhhc2gpKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRlKGhhc2gsIHsgW3N5bWJvbHMuYmFja3RyYWNrXTogdHJ1ZSB9LCBmYWxzZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBSZXN1bWUgUm91dGVyJ3MgcGFnZSBsb2FkaW5nIHByb2Nlc3MgYWZ0ZXJcbiAqIHRoZSBCb290Q29tcG9uZW50IGJlY2FtZSB2aXNpYmxlO1xuICovXG5jb25zdCByZXN1bWUgPSAoKSA9PiB7XG4gIGlmIChpc1N0cmluZyhyZXN1bWVIYXNoKSkge1xuICAgIG5hdmlnYXRlKHJlc3VtZUhhc2gsIGZhbHNlKVxuICAgIHJlc3VtZUhhc2ggPSAnJ1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocmVzdW1lSGFzaCkpIHtcbiAgICByZXN1bWVIYXNoKCkudGhlbihyZXMgPT4ge1xuICAgICAgcmVzdW1lSGFzaCA9ICcnXG4gICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICBuYXZpZ2F0ZShyZXMucGF0aCwgcmVzLnBhcmFtcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hdmlnYXRlKHJlcylcbiAgICAgIH1cbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybignW1JvdXRlcl06IHJlc3VtZSgpIGNhbGxlZCBidXQgbm8gaGFzaCBmb3VuZCcpXG4gIH1cbn1cblxuLyoqXG4gKiBGb3JjZSByZWxvYWQgYWN0aXZlIGhhc2hcbiAqL1xuY29uc3QgcmVsb2FkID0gKCkgPT4ge1xuICBpZiAoIWlzTmF2aWdhdGluZygpKSB7XG4gICAgY29uc3QgaGFzaCA9IGdldEFjdGl2ZUhhc2goKVxuICAgIG5hdmlnYXRlKGhhc2gsIHsgcmVsb2FkOiB0cnVlIH0sIGZhbHNlKVxuICB9XG59XG5cbi8qKlxuICogUXVlcnkgaWYgdGhlIFJvdXRlciBpcyBzdGlsbCBwcm9jZXNzaW5nIGEgUmVxdWVzdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzTmF2aWdhdGluZyA9ICgpID0+IHtcbiAgaWYgKG5hdmlnYXRlUXVldWUuc2l6ZSkge1xuICAgIGxldCBpc1Byb2Nlc3NpbmcgPSBmYWxzZVxuICAgIGZvciAobGV0IHJlcXVlc3Qgb2YgbmF2aWdhdGVRdWV1ZS52YWx1ZXMoKSkge1xuICAgICAgaWYgKCFyZXF1ZXN0LmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgIGlzUHJvY2Vzc2luZyA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzUHJvY2Vzc2luZ1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgY29uc3QgZ2V0UmVzdW1lSGFzaCA9ICgpID0+IHtcbiAgcmV0dXJuIHJlc3VtZUhhc2hcbn1cblxuLyoqXG4gKiBCeSBkZWZhdWx0IHdlIHJldHVybiB0aGUgbG9jYXRpb24gaGFzaFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubGV0IGdldEhhc2ggPSAoKSA9PiB7XG4gIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5oYXNoXG59XG5cbi8qKlxuICogVXBkYXRlIGxvY2F0aW9uIGhhc2hcbiAqIEBwYXJhbSB1cmxcbiAqL1xubGV0IHNldEhhc2ggPSB1cmwgPT4ge1xuICBkb2N1bWVudC5sb2NhdGlvbi5oYXNoID0gdXJsXG59XG5cbi8qKlxuICogVGhpcyBjYW4gYmUgY2FsbGVkIGZyb20gdGhlIHBsYXRmb3JtIC8gYm9vdHN0cmFwcGVyIHRvIG92ZXJyaWRlXG4gKiB0aGUgZGVmYXVsdCBnZXR0aW5nIGFuZCBzZXR0aW5nIG9mIHRoZSBoYXNoXG4gKiBAcGFyYW0gY29uZmlnXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0Um91dGVyID0gY29uZmlnID0+IHtcbiAgaWYgKGNvbmZpZy5nZXRIYXNoKSB7XG4gICAgZ2V0SGFzaCA9IGNvbmZpZy5nZXRIYXNoXG4gIH1cbiAgaWYgKGNvbmZpZy5zZXRIYXNoKSB7XG4gICAgc2V0SGFzaCA9IGNvbmZpZy5zZXRIYXNoXG4gIH1cbn1cblxuLyoqXG4gKiBPbiBoYXNoIGNoYW5nZSB3ZSBzdGFydCBwcm9jZXNzaW5nXG4gKi9cbmNvbnN0IHJlZ2lzdGVyTGlzdGVuZXIgPSAoKSA9PiB7XG4gIFJlZ2lzdHJ5LmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAnaGFzaGNoYW5nZScsIGFzeW5jICgpID0+IHtcbiAgICBpZiAobXVzdFVwZGF0ZUxvY2F0aW9uSGFzaCgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBoYW5kbGVIYXNoQ2hhbmdlKClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBOYXZpZ2F0ZSB0byByb290IGhhc2hcbiAqL1xuY29uc3Qgcm9vdCA9ICgpID0+IHtcbiAgY29uc3Qgcm9vdEhhc2ggPSBnZXRSb290SGFzaCgpXG4gIGlmIChpc1N0cmluZyhyb290SGFzaCkpIHtcbiAgICBuYXZpZ2F0ZShyb290SGFzaClcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHJvb3RIYXNoKSkge1xuICAgIHJvb3RIYXNoKCkudGhlbihyZXMgPT4ge1xuICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgICAgbmF2aWdhdGUocmVzLnBhdGgsIHJlcy5wYXJhbXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYXZpZ2F0ZShyZXMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vLyBleHBvcnQgQVBJXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN0YXJ0Um91dGVyLFxuICBuYXZpZ2F0ZSxcbiAgcmVzdW1lLFxuICBzdGVwLFxuICBnbzogc3RlcCxcbiAgYmFjazogc3RlcC5iaW5kKG51bGwsIC0xKSxcbiAgYWN0aXZlUGFnZTogZ2V0QWN0aXZlUGFnZSxcbiAgZ2V0QWN0aXZlUGFnZSgpIHtcbiAgICAvLyB3YXJuaW5nXG4gICAgcmV0dXJuIGdldEFjdGl2ZVBhZ2UoKVxuICB9LFxuICBnZXRBY3RpdmVSb3V0ZSxcbiAgZ2V0QWN0aXZlSGFzaCxcbiAgZm9jdXNXaWRnZXQsXG4gIGdldEFjdGl2ZVdpZGdldCxcbiAgcmVzdG9yZUZvY3VzLFxuICBpc05hdmlnYXRpbmcsXG4gIGdldEhpc3RvcnksXG4gIHNldEhpc3RvcnksXG4gIGdldEhpc3RvcnlTdGF0ZSxcbiAgcmVwbGFjZUhpc3RvcnlTdGF0ZSxcbiAgZ2V0UXVlcnlTdHJpbmdQYXJhbXMsXG4gIHJlbG9hZCxcbiAgc3ltYm9scyxcbiAgQXBwOiBSb3V0ZWRBcHAsXG4gIC8vIGtlZXAgYmFja3dhcmRzIGNvbXBhdGlibGVcbiAgZm9jdXNQYWdlOiByZXN0b3JlRm9jdXMsXG4gIHJvb3Q6IHJvb3QsXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIGFwaSBtZXRob2RzXG4gICAqL1xuICBzZXR1cFJvdXRlcygpIHtcbiAgICBjb25zb2xlLndhcm4oJ1JvdXRlcjogc2V0dXBSb3V0ZXMgaXMgZGVwcmVjYXRlZCwgY29uc29saWRhdGUgeW91ciBjb25maWd1cmF0aW9uJylcbiAgICBjb25zb2xlLndhcm4oJ2h0dHBzOi8vcmRrY2VudHJhbC5naXRodWIuaW8vTGlnaHRuaW5nLVNESy8jL3BsdWdpbnMvcm91dGVyL2NvbmZpZ3VyYXRpb24nKVxuICB9LFxuICBvbigpIHtcbiAgICBjb25zb2xlLndhcm4oJ1JvdXRlci5vbigpIGlzIGRlcHJlY2F0ZWQsIGNvbnNvbGlkYXRlIHlvdXIgY29uZmlndXJhdGlvbicpXG4gICAgY29uc29sZS53YXJuKCdodHRwczovL3Jka2NlbnRyYWwuZ2l0aHViLmlvL0xpZ2h0bmluZy1TREsvIy9wbHVnaW5zL3JvdXRlci9jb25maWd1cmF0aW9uJylcbiAgfSxcbiAgYmVmb3JlKCkge1xuICAgIGNvbnNvbGUud2FybignUm91dGVyLmJlZm9yZSgpIGlzIGRlcHJlY2F0ZWQsIGNvbnNvbGlkYXRlIHlvdXIgY29uZmlndXJhdGlvbicpXG4gICAgY29uc29sZS53YXJuKCdodHRwczovL3Jka2NlbnRyYWwuZ2l0aHViLmlvL0xpZ2h0bmluZy1TREsvIy9wbHVnaW5zL3JvdXRlci9jb25maWd1cmF0aW9uJylcbiAgfSxcbiAgYWZ0ZXIoKSB7XG4gICAgY29uc29sZS53YXJuKCdSb3V0ZXIuYWZ0ZXIoKSBpcyBkZXByZWNhdGVkLCBjb25zb2xpZGF0ZSB5b3VyIGNvbmZpZ3VyYXRpb24nKVxuICAgIGNvbnNvbGUud2FybignaHR0cHM6Ly9yZGtjZW50cmFsLmdpdGh1Yi5pby9MaWdodG5pbmctU0RLLyMvcGx1Z2lucy9yb3V0ZXIvY29uZmlndXJhdGlvbicpXG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBpc0Jvb2xlYW4sIGlzT2JqZWN0LCBzeW1ib2xzIH0gZnJvbSAnLi4vdXRpbHMvaGVscGVycydcbmltcG9ydCB7IGNyZWF0ZVJlZ2lzdGVyIH0gZnJvbSAnLi4vdXRpbHMvcmVnaXN0ZXInXG5pbXBvcnQgTG9nIGZyb20gJy4uLy4uL0xvZydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKGhhc2ggPSAnJywgbmF2QXJncywgc3RvcmVDYWxsZXIpIHtcbiAgICAvKipcbiAgICAgKiBIYXNoIHdlIG5hdmlnYXRlIHRvXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2hhc2ggPSBoYXNoXG5cbiAgICAvKipcbiAgICAgKiBEbyB3ZSBzdG9yZSBwcmV2aW91cyBoYXNoIGluIGhpc3RvcnlcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3N0b3JlQ2FsbGVyID0gc3RvcmVDYWxsZXJcblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgYW5kIG5hdmlnYXRlIGRhdGFcbiAgICAgKiBAdHlwZSB7TWFwfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmVnaXN0ZXIgPSBuZXcgTWFwKClcblxuICAgIC8qKlxuICAgICAqIEZsYWcgaWYgdGhlIGluc3RhbmNlIGlzIGNyZWF0ZWQgZHVlIHRvXG4gICAgICogdGhpcyByZXF1ZXN0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9pc0NyZWF0ZWQgPSBmYWxzZVxuXG4gICAgLyoqXG4gICAgICogRmxhZyBpZiB0aGUgaW5zdGFuY2UgaXMgc2hhcmVkIGJldHdlZW5cbiAgICAgKiBwcmV2aW91cyBhbmQgY3VycmVudCByZXF1ZXN0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9pc1NoYXJlZEluc3RhbmNlID0gZmFsc2VcblxuICAgIC8qKlxuICAgICAqIEZsYWcgaWYgdGhlIHJlcXVlc3QgaGFzIGJlZW4gY2FuY2VsbGVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jYW5jZWxsZWQgPSBmYWxzZVxuXG4gICAgLyoqXG4gICAgICogaWYgaW5zdGFuY2UgaXMgc2hhcmVkIGJldHdlZW4gcmVxdWVzdHMgd2UgY29weSBzdGF0ZSBvYmplY3RcbiAgICAgKiBmcm9tIGluc3RhbmNlIGJlZm9yZSB0aGUgbmV3IHJlcXVlc3Qgb3ZlcnJpZGVzIHN0YXRlXG4gICAgICogQHR5cGUge251bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jb3BpZWRIaXN0b3J5U3RhdGUgPSBudWxsXG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgYXJndW1lbnRzIGF0dGFjaGVkIHRvIG5hdmlnYXRlKClcbiAgICAvLyB3ZSBzdG9yZSB0aGVtIGluIG5ldyByZXF1ZXN0XG4gICAgaWYgKGlzT2JqZWN0KG5hdkFyZ3MpKSB7XG4gICAgICB0aGlzLl9yZWdpc3RlciA9IGNyZWF0ZVJlZ2lzdGVyKG5hdkFyZ3MpXG4gICAgfSBlbHNlIGlmIChpc0Jvb2xlYW4obmF2QXJncykpIHtcbiAgICAgIC8vIGlmIHNlY29uZCBuYXZpZ2F0ZSgpIGFyZ3VtZW50IGlzIGV4cGxpY2l0bHlcbiAgICAgIC8vIHNldCB0byBmYWxzZSB3ZSBwcmV2ZW50IHRoZSBjYWxsaW5nIHBhZ2VcbiAgICAgIC8vIGZyb20gZW5kaW5nIHVwIGluIGhpc3RvcnlcbiAgICAgIHRoaXMuX3N0b3JlQ2FsbGVyID0gbmF2QXJnc1xuICAgIH1cbiAgICAvLyBAdG9kbzogcmVtb3ZlIGJlY2F1c2Ugd2UgY2FuIHNpbXBseSBjaGVja1xuICAgIC8vIC5fc3RvcmVDYWxsZXIgcHJvcGVydHlcbiAgICB0aGlzLl9yZWdpc3Rlci5zZXQoc3ltYm9scy5zdG9yZSwgdGhpcy5fc3RvcmVDYWxsZXIpXG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgTG9nLmRlYnVnKCdbcm91dGVyXTonLCBgY2FuY2VsbGVkICR7dGhpcy5faGFzaH1gKVxuICAgIHRoaXMuX2NhbmNlbGxlZCA9IHRydWVcbiAgfVxuXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc2hcbiAgfVxuXG4gIGdldCByZWdpc3RlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJcbiAgfVxuXG4gIGdldCBoYXNoKCkge1xuICAgIHJldHVybiB0aGlzLl9oYXNoXG4gIH1cblxuICBzZXQgaGFzaChhcmdzKSB7XG4gICAgdGhpcy5faGFzaCA9IGFyZ3NcbiAgfVxuXG4gIGdldCByb3V0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm91dGVcbiAgfVxuXG4gIHNldCByb3V0ZShhcmdzKSB7XG4gICAgdGhpcy5fcm91dGUgPSBhcmdzXG4gIH1cblxuICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3ZpZGVyXG4gIH1cblxuICBzZXQgcHJvdmlkZXIoYXJncykge1xuICAgIHRoaXMuX3Byb3ZpZGVyID0gYXJnc1xuICB9XG5cbiAgZ2V0IHByb3ZpZGVyVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXJUeXBlXG4gIH1cblxuICBzZXQgcHJvdmlkZXJUeXBlKGFyZ3MpIHtcbiAgICB0aGlzLl9wcm92aWRlclR5cGUgPSBhcmdzXG4gIH1cblxuICBzZXQgcGFnZShhcmdzKSB7XG4gICAgdGhpcy5fcGFnZSA9IGFyZ3NcbiAgfVxuXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlXG4gIH1cblxuICBzZXQgaXNDcmVhdGVkKGFyZ3MpIHtcbiAgICB0aGlzLl9pc0NyZWF0ZWQgPSBhcmdzXG4gIH1cblxuICBnZXQgaXNDcmVhdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0NyZWF0ZWRcbiAgfVxuXG4gIGdldCBpc1NoYXJlZEluc3RhbmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1NoYXJlZEluc3RhbmNlXG4gIH1cblxuICBzZXQgaXNTaGFyZWRJbnN0YW5jZShhcmdzKSB7XG4gICAgdGhpcy5faXNTaGFyZWRJbnN0YW5jZSA9IGFyZ3NcbiAgfVxuXG4gIGdldCBpc0NhbmNlbGxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FuY2VsbGVkXG4gIH1cblxuICBzZXQgY29waWVkSGlzdG9yeVN0YXRlKHYpIHtcbiAgICB0aGlzLl9jb3BpZWRIaXN0b3J5U3RhdGUgPSB2XG4gIH1cblxuICBnZXQgY29waWVkSGlzdG9yeVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb3BpZWRIaXN0b3J5U3RhdGVcbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzL2hlbHBlcnMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdXRlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAvLyBrZWVwIGJhY2t3YXJkcyBjb21wYXRpYmxlXG4gICAgbGV0IHR5cGUgPSBbJ29uJywgJ2JlZm9yZScsICdhZnRlciddLnJlZHVjZSgoYWNjLCB0eXBlKSA9PiB7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihjb25maWdbdHlwZV0pID8gdHlwZSA6IGFjY1xuICAgIH0sIHVuZGVmaW5lZClcblxuICAgIHRoaXMuX2NmZyA9IGNvbmZpZ1xuICAgIGlmICh0eXBlKSB7XG4gICAgICB0aGlzLl9wcm92aWRlciA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVxdWVzdDogY29uZmlnW3R5cGVdLFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9jZmcucGF0aFxuICB9XG5cbiAgZ2V0IGNvbXBvbmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2ZnLmNvbXBvbmVudFxuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NmZy5vcHRpb25zXG4gIH1cblxuICBnZXQgd2lkZ2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2ZnLndpZGdldHNcbiAgfVxuXG4gIGdldCBjYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2ZnLmNhY2hlXG4gIH1cblxuICBnZXQgaG9vaygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2ZnLmhvb2tcbiAgfVxuXG4gIGdldCBiZWZvcmVOYXZpZ2F0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2ZnLmJlZm9yZU5hdmlnYXRlXG4gIH1cblxuICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3ZpZGVyXG4gIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IGZhZGUgPSAoaSwgbykgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgaS5wYXRjaCh7XG4gICAgICBhbHBoYTogMCxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBzbW9vdGg6IHtcbiAgICAgICAgYWxwaGE6IFsxLCB7IGR1cmF0aW9uOiAwLjUsIGRlbGF5OiAwLjEgfV0sXG4gICAgICB9LFxuICAgIH0pXG4gICAgLy8gcmVzb2x2ZSBvbiB5IGZpbmlzaFxuICAgIGkudHJhbnNpdGlvbignYWxwaGEnKS5vbignZmluaXNoJywgKCkgPT4ge1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgby52aXNpYmxlID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKVxuICAgIH0pXG4gIH0pXG59XG5cbmNvbnN0IGNyb3NzRmFkZSA9IChpLCBvKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBpLnBhdGNoKHtcbiAgICAgIGFscGhhOiAwLFxuICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgIHNtb290aDoge1xuICAgICAgICBhbHBoYTogWzEsIHsgZHVyYXRpb246IDAuNSwgZGVsYXk6IDAuMSB9XSxcbiAgICAgIH0sXG4gICAgfSlcbiAgICBpZiAobykge1xuICAgICAgby5wYXRjaCh7XG4gICAgICAgIHNtb290aDoge1xuICAgICAgICAgIGFscGhhOiBbMCwgeyBkdXJhdGlvbjogMC41LCBkZWxheTogMC4zIH1dLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9XG4gICAgLy8gcmVzb2x2ZSBvbiB5IGZpbmlzaFxuICAgIGkudHJhbnNpdGlvbignYWxwaGEnKS5vbignZmluaXNoJywgKCkgPT4ge1xuICAgICAgcmVzb2x2ZSgpXG4gICAgfSlcbiAgfSlcbn1cblxuY29uc3QgbW92ZU9uQXhlcyA9IChheGlzLCBkaXJlY3Rpb24sIGksIG8pID0+IHtcbiAgY29uc3QgYm91bmRzID0gYXhpcyA9PT0gJ3gnID8gMTkyMCA6IDEwODBcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGkucGF0Y2goe1xuICAgICAgW2Ake2F4aXN9YF06IGRpcmVjdGlvbiA/IGJvdW5kcyAqIC0xIDogYm91bmRzLFxuICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgIHNtb290aDoge1xuICAgICAgICBbYCR7YXhpc31gXTogWzAsIHsgZHVyYXRpb246IDAuNCwgZGVsYXk6IDAuMiB9XSxcbiAgICAgIH0sXG4gICAgfSlcbiAgICAvLyBvdXQgaXMgb3B0aW9uYWxcbiAgICBpZiAobykge1xuICAgICAgby5wYXRjaCh7XG4gICAgICAgIFtgJHtheGlzfWBdOiAwLFxuICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICBbYCR7YXhpc31gXTogW2RpcmVjdGlvbiA/IGJvdW5kcyA6IGJvdW5kcyAqIC0xLCB7IGR1cmF0aW9uOiAwLjQsIGRlbGF5OiAwLjIgfV0sXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cbiAgICAvLyByZXNvbHZlIG9uIHkgZmluaXNoXG4gICAgaS50cmFuc2l0aW9uKGF4aXMpLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICByZXNvbHZlKClcbiAgICB9KVxuICB9KVxufVxuXG5jb25zdCB1cCA9IChpLCBvKSA9PiB7XG4gIHJldHVybiBtb3ZlT25BeGVzKCd5JywgMCwgaSwgbylcbn1cblxuY29uc3QgZG93biA9IChpLCBvKSA9PiB7XG4gIHJldHVybiBtb3ZlT25BeGVzKCd5JywgMSwgaSwgbylcbn1cblxuY29uc3QgbGVmdCA9IChpLCBvKSA9PiB7XG4gIHJldHVybiBtb3ZlT25BeGVzKCd4JywgMCwgaSwgbylcbn1cblxuY29uc3QgcmlnaHQgPSAoaSwgbykgPT4ge1xuICByZXR1cm4gbW92ZU9uQXhlcygneCcsIDEsIGksIG8pXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZmFkZSxcbiAgY3Jvc3NGYWRlLFxuICB1cCxcbiAgZG93bixcbiAgbGVmdCxcbiAgcmlnaHQsXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBnZXRSZWZlcmVuY2VzIH0gZnJvbSAnLi93aWRnZXRzJ1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQ29tcG9uZW50ID0gKHN0YWdlLCB0eXBlKSA9PiB7XG4gIHJldHVybiBzdGFnZS5jKHtcbiAgICB0eXBlLFxuICAgIHZpc2libGU6IGZhbHNlLFxuICAgIHdpZGdldHM6IGdldFJlZmVyZW5jZXMoKSxcbiAgfSlcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGlzQXJyYXksIGlzRnVuY3Rpb24sIHVjZmlyc3QgfSBmcm9tICcuL2hlbHBlcnMnXG5cbmV4cG9ydCBkZWZhdWx0IChwYWdlLCBldmVudHMgPSBbXSwgcGFyYW1zID0ge30pID0+IHtcbiAgaWYgKCFpc0FycmF5KGV2ZW50cykpIHtcbiAgICBldmVudHMgPSBbZXZlbnRzXVxuICB9XG4gIGV2ZW50cy5mb3JFYWNoKGUgPT4ge1xuICAgIGNvbnN0IGV2ZW50ID0gYF9vbiR7dWNmaXJzdChlKX1gXG4gICAgaWYgKGlzRnVuY3Rpb24ocGFnZVtldmVudF0pKSB7XG4gICAgICBwYWdlW2V2ZW50XShwYXJhbXMpXG4gICAgfVxuICB9KVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExpZ2h0bmluZyBmcm9tICcuLi8uLi9MaWdodG5pbmcnXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vLi4vU2V0dGluZ3MnXG5pbXBvcnQgeyBnZXRBY3RpdmVIYXNoIH0gZnJvbSAnLi9yb3V0ZXInXG5pbXBvcnQgeyBnZXRSZXN1bWVIYXNoIH0gZnJvbSAnLi4vaW5kZXgnXG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gdiA9PiB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSB2ID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiB2ICE9PSBudWxsXG59XG5cbmV4cG9ydCBjb25zdCBpc0Jvb2xlYW4gPSB2ID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnYm9vbGVhbidcbn1cblxuZXhwb3J0IGNvbnN0IGlzUGFnZSA9IHYgPT4ge1xuICBpZiAodiBpbnN0YW5jZW9mIExpZ2h0bmluZy5FbGVtZW50IHx8IGlzQ29tcG9uZW50Q29uc3RydWN0b3IodikpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgY29uc3QgaXNDb21wb25lbnRDb25zdHJ1Y3RvciA9IHR5cGUgPT4ge1xuICByZXR1cm4gdHlwZS5wcm90b3R5cGUgJiYgJ2lzQ29tcG9uZW50JyBpbiB0eXBlLnByb3RvdHlwZVxufVxuXG5leHBvcnQgY29uc3QgaXNBcnJheSA9IHYgPT4ge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KVxufVxuXG5leHBvcnQgY29uc3QgdWNmaXJzdCA9IHYgPT4ge1xuICByZXR1cm4gYCR7di5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3Yuc2xpY2UoMSl9YFxufVxuXG5leHBvcnQgY29uc3QgaXNTdHJpbmcgPSB2ID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnc3RyaW5nJ1xufVxuXG5leHBvcnQgY29uc3QgaXNQcm9taXNlID0gbWV0aG9kID0+IHtcbiAgbGV0IHJlc3VsdFxuICBpZiAoaXNGdW5jdGlvbihtZXRob2QpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShudWxsKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlc3VsdCA9IGVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gbWV0aG9kXG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgJiYgaXNGdW5jdGlvbihyZXN1bHQudGhlbilcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFuSGFzaCA9IChoYXNoID0gJycpID0+IHtcbiAgcmV0dXJuIGhhc2gucmVwbGFjZSgvXiMvLCAnJykucmVwbGFjZSgvXFwvKyQvLCAnJylcbn1cblxuZXhwb3J0IGNvbnN0IGdldENvbmZpZ01hcCA9ICgpID0+IHtcbiAgY29uc3Qgcm91dGVyU2V0dGluZ3MgPSBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ3JvdXRlcicpXG4gIGNvbnN0IGlzT2JqID0gaXNPYmplY3Qocm91dGVyU2V0dGluZ3MpXG4gIHJldHVybiBbXG4gICAgJ2JhY2t0cmFjaycsXG4gICAgJ2djT25VbmxvYWQnLFxuICAgICdkZXN0cm95T25IaXN0b3J5QmFjaycsXG4gICAgJ2xhenlDcmVhdGUnLFxuICAgICdsYXp5RGVzdHJveScsXG4gICAgJ3JldXNlSW5zdGFuY2UnLFxuICAgICdhdXRvUmVzdG9yZVJlbW90ZScsXG4gICAgJ251bWJlck5hdmlnYXRpb24nLFxuICAgICd1cGRhdGVIYXNoJyxcbiAgICAnc3RvcmVTYW1lSGFzaCcsXG4gIF0ucmVkdWNlKChjb25maWcsIGtleSkgPT4ge1xuICAgIGNvbmZpZy5zZXQoa2V5LCBpc09iaiA/IHJvdXRlclNldHRpbmdzW2tleV0gOiBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywga2V5KSlcbiAgICByZXR1cm4gY29uZmlnXG4gIH0sIG5ldyBNYXAoKSlcbn1cblxuZXhwb3J0IGNvbnN0IGluY29ycmVjdFBhcmFtcyA9IChjYiwgcm91dGUpID0+IHtcbiAgY29uc3QgaXNJbmNvcnJlY3QgPSAvXlxcdyo/XFxzP1xcKFxccz9cXHsuKj9cXH1cXHM/XFwpL2lcbiAgaWYgKGlzSW5jb3JyZWN0LnRlc3QoY2IudG9TdHJpbmcoKSkpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBbXG4gICAgICAgIGBERVBSRUNBVElPTjogVGhlIGRhdGEtcHJvdmlkZXIgZm9yIHJvdXRlOiAke3JvdXRlfSBpcyBub3QgY29ycmVjdC5gLFxuICAgICAgICAnXCJwYWdlXCIgaXMgbm8gbG9uZ2VyIGEgcHJvcGVydHkgb2YgdGhlIHBhcmFtcyBvYmplY3QgYnV0IGlzIG5vdyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFyYW1ldGVyOiAnLFxuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Jka2NlbnRyYWwvTGlnaHRuaW5nLVNESy9ibG9iL2ZlYXR1cmUvcm91dGVyL2RvY3MvcGx1Z2lucy9yb3V0ZXIvZGF0YXByb3ZpZGluZy5tZCNkYXRhLXByb3ZpZGluZycsXG4gICAgICAgIFwiSXQncyBzdXBwb3J0ZWQgZm9yIG5vdyBidXQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXCIsXG4gICAgICBdLmpvaW4oJ1xcbicpXG4gICAgKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBjb25zdCBnZXRRdWVyeVN0cmluZ1BhcmFtcyA9IChoYXNoID0gZ2V0QWN0aXZlSGFzaCgpKSA9PiB7XG4gIGNvbnN0IHJlc3VtZUhhc2ggPSBnZXRSZXN1bWVIYXNoKClcbiAgaWYgKChoYXNoID09PSAnJCcgfHwgIWhhc2gpICYmIHJlc3VtZUhhc2gpIHtcbiAgICBpZiAoaXNTdHJpbmcocmVzdW1lSGFzaCkpIHtcbiAgICAgIGhhc2ggPSByZXN1bWVIYXNoXG4gICAgfVxuICB9XG5cbiAgbGV0IHBhcnNlID0gJydcbiAgY29uc3QgZ2V0UXVlcnkgPSAvKFs/Jl0uKikvXG4gIGNvbnN0IG1hdGNoZXMgPSBnZXRRdWVyeS5leGVjKGhhc2gpXG4gIGNvbnN0IHBhcmFtcyA9IHt9XG5cbiAgaWYgKGRvY3VtZW50LmxvY2F0aW9uICYmIGRvY3VtZW50LmxvY2F0aW9uLnNlYXJjaCkge1xuICAgIHBhcnNlID0gZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoXG4gIH1cblxuICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCkge1xuICAgIGxldCBoYXNoUGFyYW1zID0gbWF0Y2hlc1sxXVxuICAgIGlmIChwYXJzZSkge1xuICAgICAgLy8gaWYgbG9jYXRpb24uc2VhcmNoIGlzIG5vdCBlbXB0eSB3ZVxuICAgICAgLy8gcmVtb3ZlIHRoZSBsZWFkaW5nID8gdG8gY3JlYXRlIGFcbiAgICAgIC8vIHZhbGlkIHN0cmluZ1xuICAgICAgaGFzaFBhcmFtcyA9IGhhc2hQYXJhbXMucmVwbGFjZSgvXlxcPy8sICcnKVxuICAgICAgLy8gd2UgcGFyc2UgaGFzaCBwYXJhbXMgbGFzdCBzbyB0aGV5IHdlIGNhbiBhbHdheXNcbiAgICAgIC8vIG92ZXJyaWRlIHNlYXJjaCBwYXJhbXMgd2l0aCBoYXNoIHBhcmFtc1xuICAgICAgcGFyc2UgPSBgJHtwYXJzZX0mJHtoYXNoUGFyYW1zfWBcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2UgPSBoYXNoUGFyYW1zXG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlKSB7XG4gICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJzZSlcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB1cmxQYXJhbXMuZW50cmllcygpKSB7XG4gICAgICBwYXJhbXNba2V5XSA9IHZhbHVlXG4gICAgfVxuICAgIHJldHVybiBwYXJhbXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgb2JqZWN0VG9RdWVyeVN0cmluZyA9IG9iaiA9PiB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiAnJ1xuICB9XG4gIHJldHVybiAoXG4gICAgJz8nICtcbiAgICBPYmplY3Qua2V5cyhvYmopXG4gICAgICAubWFwKGtleSA9PiB7XG4gICAgICAgIHJldHVybiBgJHtrZXl9PSR7b2JqW2tleV19YFxuICAgICAgfSlcbiAgICAgIC5qb2luKCcmJylcbiAgKVxufVxuXG5leHBvcnQgY29uc3Qgc3ltYm9scyA9IHtcbiAgcm91dGU6IFN5bWJvbCgncm91dGUnKSxcbiAgaGFzaDogU3ltYm9sKCdoYXNoJyksXG4gIHN0b3JlOiBTeW1ib2woJ3N0b3JlJyksXG4gIGZyb21IaXN0b3J5OiBTeW1ib2woJ2Zyb21IaXN0b3J5JyksXG4gIGV4cGlyZXM6IFN5bWJvbCgnZXhwaXJlcycpLFxuICByZXN1bWU6IFN5bWJvbCgncmVzdW1lJyksXG4gIGJhY2t0cmFjazogU3ltYm9sKCdiYWNrdHJhY2snKSxcbiAgaGlzdG9yeVN0YXRlOiBTeW1ib2woJ2hpc3RvcnlTdGF0ZScpLFxuICBxdWVyeVBhcmFtczogU3ltYm9sKCdxdWVyeVBhcmFtcycpLFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgZ2V0QWN0aXZlSGFzaCwgZ2V0QWN0aXZlUGFnZSB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IHsgZ2V0T3B0aW9uLCBnZXRSb3V0ZUJ5SGFzaCB9IGZyb20gJy4vcm91dGUnXG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNBcnJheSwgaXNCb29sZWFuLCBzeW1ib2xzIH0gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHsgZ2V0Um91dGVyQ29uZmlnIH0gZnJvbSAnLi9yb3V0ZXInXG5cbi8qKlxuICogU2ltcGxlIGZsYXQgYXJyYXkgdGhhdCBob2xkcyB0aGUgdmlzaXRlZCBoYXNoZXMgKyBzdGF0ZSBPYmplY3RcbiAqIHNvIHRoZSByb3V0ZXIgY2FuIG5hdmlnYXRlIGJhY2sgdG8gdGhlbVxuICogQHR5cGUge0FycmF5fVxuICovXG5sZXQgaGlzdG9yeSA9IFtdXG5cbmV4cG9ydCBjb25zdCB1cGRhdGVIaXN0b3J5ID0gcmVxdWVzdCA9PiB7XG4gIGNvbnN0IGhhc2ggPSBnZXRBY3RpdmVIYXNoKClcbiAgaWYgKCFoYXNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBuYXZpZ2F0ZSBzdG9yYWdlIGZsYWdcbiAgY29uc3QgcmVnaXN0ZXIgPSByZXF1ZXN0LnJlZ2lzdGVyXG4gIGNvbnN0IGZvcmNlTmF2aWdhdGVTdG9yZSA9IHJlZ2lzdGVyLmdldChzeW1ib2xzLnN0b3JlKVxuXG4gIC8vIHRlc3QgcHJldmVudFN0b3JhZ2Ugb24gcm91dGUgY29uZmlndXJhdGlvblxuICBjb25zdCBhY3RpdmVSb3V0ZSA9IGdldFJvdXRlQnlIYXNoKGhhc2gpXG4gIGNvbnN0IHByZXZlbnRTdG9yYWdlID0gZ2V0T3B0aW9uKGFjdGl2ZVJvdXRlLm9wdGlvbnMsICdwcmV2ZW50U3RvcmFnZScpXG5cbiAgLy8gd2UgZ2l2ZSBwcmlvIHRvIG5hdmlnYXRlIHN0b3JhZ2UgZmxhZ1xuICBsZXQgc3RvcmUgPSBpc0Jvb2xlYW4oZm9yY2VOYXZpZ2F0ZVN0b3JlKSA/IGZvcmNlTmF2aWdhdGVTdG9yZSA6ICFwcmV2ZW50U3RvcmFnZVxuXG4gIGlmIChzdG9yZSkge1xuICAgIGNvbnN0IHRvU3RvcmUgPSBoYXNoLnJlcGxhY2UoL15cXC8vLCAnJylcbiAgICBjb25zdCBsb2NhdGlvbiA9IGxvY2F0aW9uSW5IaXN0b3J5KHRvU3RvcmUpXG4gICAgY29uc3Qgc3RhdGVPYmplY3QgPSBnZXRTdGF0ZU9iamVjdChnZXRBY3RpdmVQYWdlKCksIHJlcXVlc3QpXG4gICAgY29uc3Qgcm91dGVyQ29uZmlnID0gZ2V0Um91dGVyQ29uZmlnKClcblxuICAgIC8vIHN0b3JlIGhhc2ggaWYgaXQncyBub3QgYSBwYXJ0IG9mIGhpc3Rvcnkgb3IgZmxhZyBmb3JcbiAgICAvLyBzdG9yYWdlIG9mIHNhbWUgaGFzaCBpcyB0cnVlXG4gICAgaWYgKGxvY2F0aW9uID09PSAtMSB8fCByb3V0ZXJDb25maWcuZ2V0KCdzdG9yZVNhbWVIYXNoJykpIHtcbiAgICAgIGhpc3RvcnkucHVzaCh7IGhhc2g6IHRvU3RvcmUsIHN0YXRlOiBzdGF0ZU9iamVjdCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiB3ZSB2aXNpdCB0aGUgc2FtZSByb3V0ZSB3ZSB3YW50IHRvIHN5bmMgaGlzdG9yeVxuICAgICAgY29uc3QgcHJldiA9IGhpc3Rvcnkuc3BsaWNlKGxvY2F0aW9uLCAxKVswXVxuICAgICAgaGlzdG9yeS5wdXNoKHsgaGFzaDogcHJldi5oYXNoLCBzdGF0ZTogc3RhdGVPYmplY3QgfSlcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbG9jYXRpb25Jbkhpc3RvcnkgPSBoYXNoID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoaXN0b3J5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhpc3RvcnlbaV0uaGFzaCA9PT0gaGFzaCkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmV4cG9ydCBjb25zdCBnZXRIaXN0b3J5U3RhdGUgPSBoYXNoID0+IHtcbiAgbGV0IHN0YXRlID0gbnVsbFxuICBpZiAoaGlzdG9yeS5sZW5ndGgpIHtcbiAgICAvLyBpZiBubyBoYXNoIGlzIHByb3ZpZGVkIHdlIGdldCB0aGUgbGFzdFxuICAgIC8vIHB1c2hlZCBoaXN0b3J5IHJlY29yZFxuICAgIGlmICghaGFzaCkge1xuICAgICAgY29uc3QgcmVjb3JkID0gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdXG4gICAgICAvLyBjb3VsZCBiZSBudWxsXG4gICAgICBzdGF0ZSA9IHJlY29yZC5zdGF0ZVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9jYXRpb25Jbkhpc3RvcnkoaGFzaCkgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IGhpc3RvcnlbbG9jYXRpb25Jbkhpc3RvcnkoaGFzaCldXG4gICAgICAgIHN0YXRlID0gcmVjb3JkLnN0YXRlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgY29uc3QgcmVwbGFjZUhpc3RvcnlTdGF0ZSA9IChzdGF0ZSA9IG51bGwsIGhhc2gpID0+IHtcbiAgaWYgKCFoaXN0b3J5Lmxlbmd0aCkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGxvY2F0aW9uID0gaGFzaCA/IGxvY2F0aW9uSW5IaXN0b3J5KGhhc2gpIDogaGlzdG9yeS5sZW5ndGggLSAxXG4gIGlmIChsb2NhdGlvbiAhPT0gLTEgJiYgaXNPYmplY3Qoc3RhdGUpKSB7XG4gICAgaGlzdG9yeVtsb2NhdGlvbl0uc3RhdGUgPSBzdGF0ZVxuICB9XG59XG5cbmNvbnN0IGdldFN0YXRlT2JqZWN0ID0gKHBhZ2UsIHJlcXVlc3QpID0+IHtcbiAgLy8gaWYgdGhlIG5ldyByZXF1ZXN0IHNoYXJlZCBpbnN0YW5jZSB3aXRoIHRoZVxuICAvLyBwcmV2aW91cyByZXF1ZXN0IHdlIHVzZWQgdGhlIGNvcGllZCBzdGF0ZSBvYmplY3RcbiAgaWYgKHJlcXVlc3QuaXNTaGFyZWRJbnN0YW5jZSkge1xuICAgIGlmIChyZXF1ZXN0LmNvcGllZEhpc3RvcnlTdGF0ZSkge1xuICAgICAgcmV0dXJuIHJlcXVlc3QuY29waWVkSGlzdG9yeVN0YXRlXG4gICAgfVxuICB9IGVsc2UgaWYgKHBhZ2UgJiYgaXNGdW5jdGlvbihwYWdlLmhpc3RvcnlTdGF0ZSkpIHtcbiAgICByZXR1cm4gcGFnZS5oaXN0b3J5U3RhdGUoKVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBjb25zdCBnZXRIaXN0b3J5ID0gKCkgPT4ge1xuICByZXR1cm4gaGlzdG9yeS5zbGljZSgwKVxufVxuXG5leHBvcnQgY29uc3Qgc2V0SGlzdG9yeSA9IChhcnIgPSBbXSkgPT4ge1xuICBpZiAoaXNBcnJheShhcnIpKSB7XG4gICAgaGlzdG9yeSA9IGFyclxuICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBhcHAsXG4gIGdldENvbXBvbmVudCxcbiAgb25SZXF1ZXN0UmVzb2x2ZWQsXG4gIGdldExhc3RIYXNoLFxuICBwYWdlc0hvc3QsXG4gIHN0YWdlLFxuICBnZXRQcmV2aW91c1N0YXRlLFxuICBnZXRBY3RpdmVQYWdlLFxuICByb3V0ZXJDb25maWcsXG4gIHJvdXRlRXhpc3RzLFxufSBmcm9tICcuL3JvdXRlcidcblxuaW1wb3J0IExvZyBmcm9tICcuLi8uLi9Mb2cnXG5pbXBvcnQgeyBpc0Jvb2xlYW4sIGlzQ29tcG9uZW50Q29uc3RydWN0b3IsIGlzRnVuY3Rpb24sIHN5bWJvbHMgfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgeyBnZXRQcm92aWRlciwgaGFzUHJvdmlkZXIsIGlzUGFnZUV4cGlyZWQsIGRhdGFIb29rcywgYWRkUGVyc2lzdERhdGEgfSBmcm9tICcuL3Byb3ZpZGVyJ1xuaW1wb3J0IHsgY3JlYXRlQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzJ1xuaW1wb3J0IHsgZXhlY3V0ZVRyYW5zaXRpb24gfSBmcm9tICcuL3RyYW5zaXRpb24nXG5pbXBvcnQgeyBnZXRBY3RpdmVXaWRnZXQgfSBmcm9tICcuL3dpZGdldHMnXG5pbXBvcnQgZW1pdCBmcm9tICcuL2VtaXQnXG5pbXBvcnQgeyBnZXRPcHRpb24gfSBmcm9tICcuL3JvdXRlJ1xuaW1wb3J0IHsgbmF2aWdhdGUgfSBmcm9tICcuLi9pbmRleCdcbmltcG9ydCB7IHNldEhpc3RvcnksIHVwZGF0ZUhpc3RvcnkgfSBmcm9tICcuL2hpc3RvcnknXG5pbXBvcnQgeyBpc1dpbGRjYXJkIH0gZnJvbSAnLi9yZWdleCdcblxuLyoqXG4gKiBUaGUgYWN0dWFsIGxvYWRpbmcgb2YgdGhlIGNvbXBvbmVudFxuICogKi9cbmV4cG9ydCBjb25zdCBsb2FkID0gYXN5bmMgcmVxdWVzdCA9PiB7XG4gIGxldCBleHBpcmVkID0gZmFsc2VcbiAgdHJ5IHtcbiAgICByZXF1ZXN0ID0gYXdhaXQgbG9hZGVyKHJlcXVlc3QpXG4gICAgaWYgKHJlcXVlc3QgJiYgIXJlcXVlc3QuaXNDYW5jZWxsZWQpIHtcbiAgICAgIC8vIGluIGNhc2Ugb2Ygb24oKSBwcm92aWRpbmcgd2UgbmVlZCB0byByZXNldFxuICAgICAgLy8gYXBwIHN0YXRlO1xuICAgICAgaWYgKGFwcC5zdGF0ZSA9PT0gJ0xvYWRpbmcnKSB7XG4gICAgICAgIGlmIChnZXRQcmV2aW91c1N0YXRlKCkgPT09ICdXaWRnZXRzJykge1xuICAgICAgICAgIGFwcC5fc2V0U3RhdGUoJ1dpZGdldHMnLCBbZ2V0QWN0aXZlV2lkZ2V0KCldKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwcC5fc2V0U3RhdGUoJycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIERvIHBhZ2UgdHJhbnNpdGlvbiBpZiBpbnN0YW5jZVxuICAgICAgLy8gaXMgbm90IHNoYXJlZCBiZXR3ZWVuIHRoZSByb3V0ZXNcbiAgICAgIGlmICghcmVxdWVzdC5pc1NoYXJlZEluc3RhbmNlICYmICFyZXF1ZXN0LmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgIGF3YWl0IGV4ZWN1dGVUcmFuc2l0aW9uKHJlcXVlc3QucGFnZSwgZ2V0QWN0aXZlUGFnZSgpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBleHBpcmVkID0gdHJ1ZVxuICAgIH1cbiAgICAvLyBvbiBleHBpcmVkIHdlIG9ubHkgY2xlYW51cFxuICAgIGlmIChleHBpcmVkIHx8IHJlcXVlc3QuaXNDYW5jZWxsZWQpIHtcbiAgICAgIExvZy5kZWJ1ZygnW3JvdXRlcl06JywgYFJlamVjdGVkICR7cmVxdWVzdC5oYXNofSBiZWNhdXNlIHJvdXRlIHRvICR7Z2V0TGFzdEhhc2goKX0gc3RhcnRlZGApXG4gICAgICBpZiAocmVxdWVzdC5pc0NyZWF0ZWQgJiYgIXJlcXVlc3QuaXNTaGFyZWRJbnN0YW5jZSkge1xuICAgICAgICAvLyByZW1vdmUgZnJvbSByZW5kZXItdHJlZVxuICAgICAgICBwYWdlc0hvc3QucmVtb3ZlKHJlcXVlc3QucGFnZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25SZXF1ZXN0UmVzb2x2ZWQocmVxdWVzdClcbiAgICAgIC8vIHJlc29sdmUgcHJvbWlzZVxuICAgICAgcmV0dXJuIHJlcXVlc3QucGFnZVxuICAgIH1cbiAgfSBjYXRjaCAocmVxdWVzdCkge1xuICAgIGlmICghcmVxdWVzdC5yb3V0ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihyZXF1ZXN0KVxuICAgIH0gZWxzZSBpZiAoIWV4cGlyZWQpIHtcbiAgICAgIC8vIEB0b2RvOiByZXZpc2l0XG4gICAgICBjb25zdCB7IHJvdXRlIH0gPSByZXF1ZXN0XG4gICAgICAvLyBjbGVhbiB1cCBoaXN0b3J5IGlmIG1vZGlmaWVyIGlzIHNldFxuICAgICAgaWYgKGdldE9wdGlvbihyb3V0ZS5vcHRpb25zLCAnY2xlYXJIaXN0b3J5JykpIHtcbiAgICAgICAgc2V0SGlzdG9yeShbXSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzV2lsZGNhcmQudGVzdChyb3V0ZS5wYXRoKSkge1xuICAgICAgICB1cGRhdGVIaXN0b3J5KHJlcXVlc3QpXG4gICAgICB9XG5cbiAgICAgIGlmIChyZXF1ZXN0LmlzQ3JlYXRlZCAmJiAhcmVxdWVzdC5pc1NoYXJlZEluc3RhbmNlKSB7XG4gICAgICAgIC8vIHJlbW92ZSBmcm9tIHJlbmRlci10cmVlXG4gICAgICAgIHBhZ2VzSG9zdC5yZW1vdmUocmVxdWVzdC5wYWdlKVxuICAgICAgfVxuICAgICAgaGFuZGxlRXJyb3IocmVxdWVzdClcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbG9hZGVyID0gYXN5bmMgcmVxdWVzdCA9PiB7XG4gIGNvbnN0IHJvdXRlID0gcmVxdWVzdC5yb3V0ZVxuICBjb25zdCBoYXNoID0gcmVxdWVzdC5oYXNoXG4gIGNvbnN0IHJlZ2lzdGVyID0gcmVxdWVzdC5yZWdpc3RlclxuXG4gIC8vIHRvZG86IGdyYWIgZnJvbSBSb3V0ZSBpbnN0YW5jZVxuICBsZXQgdHlwZSA9IGdldENvbXBvbmVudChyb3V0ZS5wYXRoKVxuICBsZXQgaXNDb25zdHJ1Y3QgPSBpc0NvbXBvbmVudENvbnN0cnVjdG9yKHR5cGUpXG4gIGxldCBwcm92aWRlID0gZmFsc2VcblxuICAvLyBpZiBpdCdzIGFuIGluc3RhbmNlIGJ0IHdlJ3JlIG5vdCBjb21pbmcgYmFjayBmcm9tXG4gIC8vIGhpc3Rvcnkgd2UgdGVzdCBpZiB3ZSBjYW4gcmUtdXNlIHRoaXMgaW5zdGFuY2VcbiAgaWYgKCFpc0NvbnN0cnVjdCAmJiAhcmVnaXN0ZXIuZ2V0KHN5bWJvbHMuYmFja3RyYWNrKSkge1xuICAgIGlmICghbXVzdFJldXNlKHJvdXRlKSkge1xuICAgICAgdHlwZSA9IHR5cGUuY29uc3RydWN0b3JcbiAgICAgIGlzQ29uc3RydWN0ID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHBhZ2UgaXMgTGlnaHRuaW5nIENvbXBvbmVudCBpbnN0YW5jZVxuICBpZiAoIWlzQ29uc3RydWN0KSB7XG4gICAgcmVxdWVzdC5wYWdlID0gdHlwZVxuICAgIC8vIGlmIHdlIGhhdmUgaGF2ZSBhIGRhdGEgcm91dGUgZm9yIGN1cnJlbnQgcGFnZVxuICAgIGlmIChoYXNQcm92aWRlcihyb3V0ZS5wYXRoKSkge1xuICAgICAgaWYgKGlzUGFnZUV4cGlyZWQodHlwZSkgfHwgdHlwZVtzeW1ib2xzLmhhc2hdICE9PSBoYXNoKSB7XG4gICAgICAgIHByb3ZpZGUgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjdXJyZW50Um91dGUgPSBnZXRBY3RpdmVQYWdlKCkgJiYgZ2V0QWN0aXZlUGFnZSgpW3N5bWJvbHMucm91dGVdXG4gICAgLy8gaWYgdGhlIG5ldyByb3V0ZSBpcyBlcXVhbCB0byB0aGUgY3VycmVudCByb3V0ZSBpdCBtZWFucyB0aGF0IGJvdGhcbiAgICAvLyByb3V0ZSBzaGFyZSB0aGUgQ29tcG9uZW50IGluc3RhbmNlIGFuZCBzdGFjayBsb2NhdGlvbiAvIHNpbmNlIHRoaXMgY2FzZVxuICAgIC8vIGlzIGNvbmZsaWN0aW5nIHdpdGggdGhlIHdheSBiZWZvcmUoKSBhbmQgYWZ0ZXIoKSBsb2FkaW5nIHdvcmtzIHdlIGZsYWcgaXQsXG4gICAgLy8gYW5kIGNoZWNrIHBsYXRmb3JtIHNldHRpbmdzIGluIHdlIHdhbnQgdG8gcmUtdXNlIGluc3RhbmNlXG4gICAgaWYgKHJvdXRlLnBhdGggPT09IGN1cnJlbnRSb3V0ZSkge1xuICAgICAgcmVxdWVzdC5pc1NoYXJlZEluc3RhbmNlID0gdHJ1ZVxuICAgICAgLy8gc2luY2Ugd2UncmUgcmUtdXNpbmcgdGhlIGluc3RhbmNlIHdlIG11c3QgYXR0YWNoXG4gICAgICAvLyBoaXN0b3J5U3RhdGUgdG8gdGhlIHJlcXVlc3QgdG8gcHJldmVudCBpdCBmcm9tXG4gICAgICAvLyBiZWluZyBvdmVycmlkZGVuLlxuICAgICAgaWYgKGlzRnVuY3Rpb24ocmVxdWVzdC5wYWdlLmhpc3RvcnlTdGF0ZSkpIHtcbiAgICAgICAgcmVxdWVzdC5jb3BpZWRIaXN0b3J5U3RhdGUgPSByZXF1ZXN0LnBhZ2UuaGlzdG9yeVN0YXRlKClcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdC5wYWdlID0gY3JlYXRlQ29tcG9uZW50KHN0YWdlLCB0eXBlKVxuICAgIHBhZ2VzSG9zdC5hKHJlcXVlc3QucGFnZSlcbiAgICAvLyB0ZXN0IGlmIG5lZWQgdG8gcmVxdWVzdCBkYXRhIHByb3ZpZGVyXG4gICAgaWYgKGhhc1Byb3ZpZGVyKHJvdXRlLnBhdGgpKSB7XG4gICAgICBwcm92aWRlID0gdHJ1ZVxuICAgIH1cbiAgICByZXF1ZXN0LmlzQ3JlYXRlZCA9IHRydWVcbiAgfVxuXG4gIC8vIHdlIHN0b3JlIGhhc2ggYW5kIHJvdXRlIGFzIHByb3BlcnRpZXMgb24gdGhlIHBhZ2UgaW5zdGFuY2VcbiAgLy8gdGhhdCB3YXkgd2UgY2FuIGVhc2lseSBjYWxjdWxhdGUgbmV3IGJlaGF2aW91ciBvbiBwYWdlIHJlbG9hZFxuICByZXF1ZXN0LnBhZ2Vbc3ltYm9scy5oYXNoXSA9IGhhc2hcbiAgcmVxdWVzdC5wYWdlW3N5bWJvbHMucm91dGVdID0gcm91dGUucGF0aFxuXG4gIHRyeSB7XG4gICAgaWYgKHByb3ZpZGUpIHtcbiAgICAgIC8vIGV4dHJhY3QgYXR0YWNoZWQgZGF0YS1wcm92aWRlciBmb3Igcm91dGVcbiAgICAgIC8vIHdlJ3JlIHByb2Nlc3NpbmdcbiAgICAgIGNvbnN0IHsgdHlwZTogbG9hZFR5cGUsIHByb3ZpZGVyIH0gPSBnZXRQcm92aWRlcihyb3V0ZSlcblxuICAgICAgLy8gdXBkYXRlIHJ1bm5pbmcgcmVxdWVzdFxuICAgICAgcmVxdWVzdC5wcm92aWRlciA9IHByb3ZpZGVyXG4gICAgICByZXF1ZXN0LnByb3ZpZGVyVHlwZSA9IGxvYWRUeXBlXG5cbiAgICAgIGF3YWl0IGRhdGFIb29rc1tsb2FkVHlwZV0ocmVxdWVzdClcblxuICAgICAgLy8gd2UgZWFybHkgZXhpdCBpZiB0aGUgY3VycmVudCByZXF1ZXN0IGlzIGV4cGlyZWRcbiAgICAgIGlmIChoYXNoICE9PSBnZXRMYXN0SGFzaCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucHJvdmlkZXJUeXBlICE9PSAnYWZ0ZXInKSB7XG4gICAgICAgICAgZW1pdChyZXF1ZXN0LnBhZ2UsICdkYXRhUHJvdmlkZWQnKVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlc29sdmUgcHJvbWlzZVxuICAgICAgICByZXR1cm4gcmVxdWVzdFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRQZXJzaXN0RGF0YShyZXF1ZXN0KVxuICAgICAgcmV0dXJuIHJlcXVlc3RcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXF1ZXN0LmVycm9yID0gZVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZXF1ZXN0KVxuICB9XG59XG5cbmNvbnN0IGhhbmRsZUVycm9yID0gcmVxdWVzdCA9PiB7XG4gIGlmIChyZXF1ZXN0ICYmIHJlcXVlc3QuZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKHJlcXVlc3QuZXJyb3IpXG4gIH0gZWxzZSBpZiAocmVxdWVzdCkge1xuICAgIExvZy5lcnJvcihyZXF1ZXN0KVxuICB9XG5cbiAgaWYgKHJlcXVlc3QucGFnZSAmJiByb3V0ZUV4aXN0cygnIScpKSB7XG4gICAgbmF2aWdhdGUoJyEnLCB7IHJlcXVlc3QgfSwgZmFsc2UpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG11c3RSZXVzZSA9IHJvdXRlID0+IHtcbiAgY29uc3Qgb3B0ID0gZ2V0T3B0aW9uKHJvdXRlLm9wdGlvbnMsICdyZXVzZUluc3RhbmNlJylcbiAgY29uc3QgY29uZmlnID0gcm91dGVyQ29uZmlnLmdldCgncmV1c2VJbnN0YW5jZScpXG5cbiAgLy8gcm91dGUgYWx3YXlzIGhhcyBmaW5hbCBkZWNpc2lvblxuICBpZiAoaXNCb29sZWFuKG9wdCkpIHtcbiAgICByZXR1cm4gb3B0XG4gIH1cbiAgcmV0dXJuICEoaXNCb29sZWFuKGNvbmZpZykgJiYgY29uZmlnID09PSBmYWxzZSlcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IHN5bWJvbHMsIGdldFF1ZXJ5U3RyaW5nUGFyYW1zIH0gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHsgYXBwLCByb3V0ZXMsIHJvdXRlRXhpc3RzIH0gZnJvbSAnLi9yb3V0ZXInXG5pbXBvcnQgeyBnZXRWYWx1ZXNGcm9tSGFzaCB9IGZyb20gJy4vcm91dGUnXG5pbXBvcnQgZW1pdCBmcm9tICcuL2VtaXQnXG5cbmV4cG9ydCBsZXQgcHJldmlvdXNTdGF0ZVxuXG5leHBvcnQgY29uc3QgZGF0YUhvb2tzID0ge1xuICBvbjogcmVxdWVzdCA9PiB7XG4gICAgcHJldmlvdXNTdGF0ZSA9IGFwcC5zdGF0ZSB8fCAnJ1xuICAgIGFwcC5fc2V0U3RhdGUoJ0xvYWRpbmcnKVxuICAgIHJldHVybiBleGVjUHJvdmlkZXIocmVxdWVzdClcbiAgfSxcbiAgYmVmb3JlOiByZXF1ZXN0ID0+IHtcbiAgICByZXR1cm4gZXhlY1Byb3ZpZGVyKHJlcXVlc3QpXG4gIH0sXG4gIGFmdGVyOiByZXF1ZXN0ID0+IHtcbiAgICB0cnkge1xuICAgICAgZXhlY1Byb3ZpZGVyKHJlcXVlc3QsIHRydWUpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZm9yIG5vdyB3ZSBmYWlsIHNpbGVudGx5XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9LFxufVxuXG5jb25zdCBleGVjUHJvdmlkZXIgPSAocmVxdWVzdCwgZW1pdFByb3ZpZGVkKSA9PiB7XG4gIGNvbnN0IHJvdXRlID0gcmVxdWVzdC5yb3V0ZVxuICBjb25zdCBwcm92aWRlciA9IHJvdXRlLnByb3ZpZGVyXG4gIGNvbnN0IGV4cGlyZXMgPSByb3V0ZS5jYWNoZSA/IHJvdXRlLmNhY2hlICogMTAwMCA6IDBcbiAgY29uc3QgcGFyYW1zID0gYWRkUGVyc2lzdERhdGEocmVxdWVzdClcbiAgcmV0dXJuIHByb3ZpZGVyLnJlcXVlc3QocmVxdWVzdC5wYWdlLCB7IC4uLnBhcmFtcyB9KS50aGVuKCgpID0+IHtcbiAgICByZXF1ZXN0LnBhZ2Vbc3ltYm9scy5leHBpcmVzXSA9IERhdGUubm93KCkgKyBleHBpcmVzXG4gICAgaWYgKGVtaXRQcm92aWRlZCkge1xuICAgICAgZW1pdChyZXF1ZXN0LnBhZ2UsICdkYXRhUHJvdmlkZWQnKVxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IGFkZFBlcnNpc3REYXRhID0gKHsgcGFnZSwgcm91dGUsIGhhc2gsIHJlZ2lzdGVyID0gbmV3IE1hcCgpIH0pID0+IHtcbiAgY29uc3QgdXJsVmFsdWVzID0gZ2V0VmFsdWVzRnJvbUhhc2goaGFzaCwgcm91dGUucGF0aClcbiAgY29uc3QgcXVlcnlQYXJhbXMgPSBnZXRRdWVyeVN0cmluZ1BhcmFtcyhoYXNoKVxuICBjb25zdCBwYWdlRGF0YSA9IG5ldyBNYXAoWy4uLnVybFZhbHVlcywgLi4ucmVnaXN0ZXJdKVxuICBjb25zdCBwYXJhbXMgPSB7fVxuXG4gIC8vIG1ha2UgZHluYW1pYyB1cmwgZGF0YSBhdmFpbGFibGUgdG8gdGhlIHBhZ2VcbiAgLy8gYXMgaW5zdGFuY2UgcHJvcGVydGllc1xuICBmb3IgKGxldCBbbmFtZSwgdmFsdWVdIG9mIHBhZ2VEYXRhKSB7XG4gICAgcGFyYW1zW25hbWVdID0gdmFsdWVcbiAgfVxuXG4gIGlmIChxdWVyeVBhcmFtcykge1xuICAgIHBhcmFtc1tzeW1ib2xzLnF1ZXJ5UGFyYW1zXSA9IHF1ZXJ5UGFyYW1zXG4gIH1cblxuICAvLyBjaGVjayBuYXZpZ2F0aW9uIHJlZ2lzdGVyIGZvciBwZXJzaXN0ZW50IGRhdGFcbiAgaWYgKHJlZ2lzdGVyLnNpemUpIHtcbiAgICBjb25zdCBvYmogPSB7fVxuICAgIGZvciAobGV0IFtrLCB2XSBvZiByZWdpc3Rlcikge1xuICAgICAgb2JqW2tdID0gdlxuICAgIH1cbiAgICBwYWdlLnBlcnNpc3QgPSBvYmpcbiAgfVxuXG4gIC8vIG1ha2UgdXJsIGRhdGEgYW5kIHBlcnNpc3QgZGF0YSBhdmFpbGFibGVcbiAgLy8gdmlhIHBhcmFtcyBwcm9wZXJ0eVxuICBwYWdlLnBhcmFtcyA9IHBhcmFtc1xuICBlbWl0KHBhZ2UsIFsndXJsUGFyYW1zJ10sIHBhcmFtcylcblxuICByZXR1cm4gcGFyYW1zXG59XG5cbi8qKlxuICogVGVzdCBpZiBwYWdlIHBhc3NlZCBjYWNoZS10aW1lXG4gKiBAcGFyYW0gcGFnZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1BhZ2VFeHBpcmVkID0gcGFnZSA9PiB7XG4gIGlmICghcGFnZVtzeW1ib2xzLmV4cGlyZXNdKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBleHBpcmVzID0gcGFnZVtzeW1ib2xzLmV4cGlyZXNdXG4gIGNvbnN0IG5vdyA9IERhdGUubm93KClcblxuICByZXR1cm4gbm93ID49IGV4cGlyZXNcbn1cblxuZXhwb3J0IGNvbnN0IGhhc1Byb3ZpZGVyID0gcGF0aCA9PiB7XG4gIGlmIChyb3V0ZUV4aXN0cyhwYXRoKSkge1xuICAgIGNvbnN0IHJlY29yZCA9IHJvdXRlcy5nZXQocGF0aClcbiAgICByZXR1cm4gISFyZWNvcmQucHJvdmlkZXJcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGNvbnN0IGdldFByb3ZpZGVyID0gcm91dGUgPT4ge1xuICAvLyBAdG9kbzogZml4LCByb3V0ZSBhbHJlYWR5IGlzIHBhc3NlZCBpblxuICBpZiAocm91dGVFeGlzdHMocm91dGUucGF0aCkpIHtcbiAgICBjb25zdCB7IHByb3ZpZGVyIH0gPSByb3V0ZXMuZ2V0KHJvdXRlLnBhdGgpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHByb3ZpZGVyLnR5cGUsXG4gICAgICBwcm92aWRlcjogcHJvdmlkZXIucmVxdWVzdCxcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBoYXNSZWdleCA9IC9cXHtcXC8oLio/KVxcLyhbaWdtXXswLDN9KVxcfS9nXG5leHBvcnQgY29uc3QgaXNXaWxkY2FyZCA9IC9eWyEqJF0kL1xuZXhwb3J0IGNvbnN0IGhhc0xvb2t1cElkID0gL1xcLzpcXHcrP0BAKFswLTldKz8pQEAvXG5leHBvcnQgY29uc3QgaXNOYW1lZEdyb3VwID0gL15cXC86L1xuXG4vKipcbiAqIFRlc3QgaWYgYSByb3V0ZSBpcyBwYXJ0IHJlZ3VsYXIgZXhwcmVzc2VkXG4gKiBhbmQgcmVwbGFjZSBpdCBmb3IgYSBzaW1wbGUgY2hhcmFjdGVyXG4gKiBAcGFyYW0gcm91dGVcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgY29uc3Qgc3RyaXBSZWdleCA9IChyb3V0ZSwgY2hhciA9ICdSJykgPT4ge1xuICAvLyBpZiByb3V0ZSBpcyBwYXJ0IHJlZ3VsYXIgZXhwcmVzc2VkIHdlIHJlcGxhY2VcbiAgLy8gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgYSBjaGFyYWN0ZXIgdG9cbiAgLy8gc2ltcGxpZnkgZmxvb3IgY2FsY3VsYXRpb24gYW5kIGJhY2t0cmFja2luZ1xuICBpZiAoaGFzUmVnZXgudGVzdChyb3V0ZSkpIHtcbiAgICByb3V0ZSA9IHJvdXRlLnJlcGxhY2UoaGFzUmVnZXgsIGNoYXIpXG4gIH1cbiAgcmV0dXJuIHJvdXRlXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIGxvY2FsIHJlcXVlc3QgcmVnaXN0ZXJcbiAqIEBwYXJhbSBmbGFnc1xuICogQHJldHVybnMge01hcDxhbnksIGFueT59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWdpc3RlciA9IGZsYWdzID0+IHtcbiAgY29uc3QgcmVnID0gbmV3IE1hcCgpXG4gIC8vIHN0b3JlIHVzZXIgZGVmaW5lZCBhbmQgcm91dGVyXG4gIC8vIGRlZmluZWQgZmxhZ3MgaW4gcmVnaXN0ZXJcbiAgO1suLi5PYmplY3Qua2V5cyhmbGFncyksIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZmxhZ3MpXS5mb3JFYWNoKGtleSA9PiB7XG4gICAgcmVnLnNldChrZXksIGZsYWdzW2tleV0pXG4gIH0pXG4gIHJldHVybiByZWdcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGhhc1JlZ2V4LCBoYXNMb29rdXBJZCwgaXNOYW1lZEdyb3VwLCBzdHJpcFJlZ2V4IH0gZnJvbSAnLi9yZWdleCdcbmltcG9ydCB7IHJvdXRlcywgcm91dGVFeGlzdHMsIGJvb3RSZXF1ZXN0LCBnZXRSb3V0ZXMgfSBmcm9tICcuL3JvdXRlcidcbmltcG9ydCBSZXF1ZXN0IGZyb20gJy4uL21vZGVsL1JlcXVlc3QnXG5pbXBvcnQgUm91dGUgZnJvbSAnLi4vbW9kZWwvUm91dGUnXG5pbXBvcnQgeyBvYmplY3RUb1F1ZXJ5U3RyaW5nLCBpc09iamVjdCwgaXNTdHJpbmcgfSBmcm9tICcuL2hlbHBlcnMnXG5cbi8qKlxuICogU2ltcGxlIHJvdXRlIGxlbmd0aCBjYWxjdWxhdGlvblxuICogQHBhcmFtIHJvdXRlIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIGZsb29yXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGbG9vciA9IHJvdXRlID0+IHtcbiAgcmV0dXJuIHN0cmlwUmVnZXgocm91dGUpLnNwbGl0KCcvJykubGVuZ3RoXG59XG5cbi8qKlxuICogcmV0dXJuIGFsbCBzdG9yZWQgcm91dGVzIHRoYXQgbGl2ZSBvbiB0aGUgc2FtZSBmbG9vclxuICogQHBhcmFtIGZsb29yXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmNvbnN0IGdldFJvdXRlc0J5Rmxvb3IgPSBmbG9vciA9PiB7XG4gIGNvbnN0IG1hdGNoZXMgPSBbXVxuICAvLyBzaW1wbGUgZmlsdGVyIG9mIGxldmVsIGNhbmRpZGF0ZXNcbiAgZm9yIChsZXQgW3JvdXRlXSBvZiByb3V0ZXMuZW50cmllcygpKSB7XG4gICAgaWYgKGdldEZsb29yKHJvdXRlKSA9PT0gZmxvb3IpIHtcbiAgICAgIG1hdGNoZXMucHVzaChyb3V0ZSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXNcbn1cblxuLyoqXG4gKiByZXR1cm4gYSBtYXRjaGluZyByb3V0ZSBieSBwcm92aWRlZCBoYXNoXG4gKiBoYXNoOiBob21lL2Jyb3dzZS8xMiB3aWxsIG1hdGNoOlxuICogcm91dGU6IGhvbWUvYnJvd3NlLzpjYXRlZ29yeUlkXG4gKiBAcGFyYW0gaGFzaCB7c3RyaW5nfVxuICogQHJldHVybnMge2Jvb2xlYW58e319IC0gcm91dGVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFJvdXRlQnlIYXNoID0gaGFzaCA9PiB7XG4gIC8vIEB0b2RvOiBjbGVhbiB1cCBvbiBoYW5kbGVIYXNoXG4gIGhhc2ggPSBoYXNoLnJlcGxhY2UoL14jLywgJycpXG5cbiAgY29uc3QgZ2V0VXJsUGFydHMgPSAvKFxcLz86P1teL10rKS9nXG4gIC8vIGdyYWIgcG9zc2libGUgY2FuZGlkYXRlcyBmcm9tIHN0b3JlZCByb3V0ZXNcbiAgY29uc3QgY2FuZGlkYXRlcyA9IGdldFJvdXRlc0J5Rmxvb3IoZ2V0Rmxvb3IoaGFzaCkpXG4gIC8vIGJyZWFrIGhhc2ggZG93biBpbiBjaHVua3NcbiAgY29uc3QgaGFzaFBhcnRzID0gaGFzaC5tYXRjaChnZXRVcmxQYXJ0cykgfHwgW11cblxuICAvLyB0byBzaW1wbGlmeSB0aGUgcm91dGUgbWF0Y2hpbmcgYW5kIHByZXZlbnQgbG9vayBhcm91bmRcbiAgLy8gaW4gb3VyIGdldFVybFBhcnRzIHJlZ2V4IHdlIGdldCB0aGUgcmVnZXggcGFydCBmcm9tXG4gIC8vIHJvdXRlIGNhbmRpZGF0ZSBhbmQgc3RvcmUgdGhlbSBzbyB0aGF0IHdlIGNhbiByZWZlcmVuY2VcbiAgLy8gdGhlbSB3aGVuIHdlIHBlcmZvcm0gdGhlIGFjdHVhbCByZWdleCBhZ2FpbnN0IGhhc2hcbiAgbGV0IHJlZ2V4U3RvcmUgPSBbXVxuXG4gIGxldCBtYXRjaGVzID0gY2FuZGlkYXRlcy5maWx0ZXIocm91dGUgPT4ge1xuICAgIGxldCBpc01hdGNoaW5nID0gdHJ1ZVxuICAgIC8vIHJlcGxhY2UgcmVnZXggaW4gcm91dGUgd2l0aCBsb29rdXAgaWQgPT4gQEB7c3RvcmVJZH1AQFxuICAgIGlmIChoYXNSZWdleC50ZXN0KHJvdXRlKSkge1xuICAgICAgY29uc3QgcmVnTWF0Y2hlcyA9IHJvdXRlLm1hdGNoKGhhc1JlZ2V4KVxuICAgICAgaWYgKHJlZ01hdGNoZXMgJiYgcmVnTWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcm91dGUgPSByZWdNYXRjaGVzLnJlZHVjZSgoZnVsbFJvdXRlLCByZWdleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGxvb2t1cElkID0gcmVnZXhTdG9yZS5sZW5ndGhcbiAgICAgICAgICBmdWxsUm91dGUgPSBmdWxsUm91dGUucmVwbGFjZShyZWdleCwgYEBAJHtsb29rdXBJZH1AQGApXG4gICAgICAgICAgcmVnZXhTdG9yZS5wdXNoKHJlZ2V4LnN1YnN0cmluZygxLCByZWdleC5sZW5ndGggLSAxKSlcbiAgICAgICAgICByZXR1cm4gZnVsbFJvdXRlXG4gICAgICAgIH0sIHJvdXRlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlUGFydHMgPSByb3V0ZS5tYXRjaChnZXRVcmxQYXJ0cykgfHwgW11cblxuICAgIGZvciAobGV0IGkgPSAwLCBqID0gcm91dGVQYXJ0cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IHJvdXRlUGFydCA9IHJvdXRlUGFydHNbaV1cbiAgICAgIGNvbnN0IGhhc2hQYXJ0ID0gaGFzaFBhcnRzW2ldXG5cbiAgICAgIC8vIFNpbmNlIHdlIHN1cHBvcnQgY2F0Y2gtYWxsIGFuZCByZWdleCBkcml2ZW4gbmFtZSBncm91cHNcbiAgICAgIC8vIHdlIGZpcnN0IHRlc3QgZm9yIHJlZ2V4IGxvb2t1cCBpZCBhbmQgc2VlIGlmIHRoZSByZWdleFxuICAgICAgLy8gbWF0Y2hlcyB0aGUgdmFsdWUgZnJvbSB0aGUgaGFzaFxuICAgICAgaWYgKGhhc0xvb2t1cElkLnRlc3Qocm91dGVQYXJ0KSkge1xuICAgICAgICBjb25zdCByb3V0ZU1hdGNoZXMgPSBoYXNMb29rdXBJZC5leGVjKHJvdXRlUGFydClcbiAgICAgICAgY29uc3Qgc3RvcmVJZCA9IHJvdXRlTWF0Y2hlc1sxXVxuICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gcmVnZXhTdG9yZVtzdG9yZUlkXVxuXG4gICAgICAgIC8vIHNwbGl0IHJlZ2V4IGFuZCBtb2RpZmllcnMgc28gd2UgY2FuIHVzZSBib3RoXG4gICAgICAgIC8vIHRvIGNyZWF0ZSBhIG5ldyBSZWdFeHBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnTWF0Y2hlcyA9IC9cXC8oW15cXC9dKylcXC8oW2lnbV17MCwzfSkvLmV4ZWMocm91dGVSZWdleClcblxuICAgICAgICBpZiAocmVnTWF0Y2hlcyAmJiByZWdNYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSByZWdNYXRjaGVzWzFdXG4gICAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gcmVnTWF0Y2hlc1syXVxuXG4gICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeLyR7ZXhwcmVzc2lvbn0kYCwgbW9kaWZpZXJzKVxuXG4gICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGhhc2hQYXJ0KSkge1xuICAgICAgICAgICAgaXNNYXRjaGluZyA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzTmFtZWRHcm91cC50ZXN0KHJvdXRlUGFydCkpIHtcbiAgICAgICAgLy8gd2Uga2luZGx5IHNraXAgbmFtZWRHcm91cHMgYmVjYXVzZSB0aGlzIGlzIGR5bmFtaWNcbiAgICAgICAgLy8gd2Ugb25seSBuZWVkIHRvIHRoZSBzdGF0aWMgYW5kIHJlZ2V4IGRyaXZlIHBhcnRzXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYgKGhhc2hQYXJ0ICYmIHJvdXRlUGFydC50b0xvd2VyQ2FzZSgpICE9PSBoYXNoUGFydC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGlzTWF0Y2hpbmcgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNNYXRjaGluZ1xuICB9KVxuXG4gIGlmIChtYXRjaGVzLmxlbmd0aCkge1xuICAgIGlmIChtYXRjaGVzLmluZGV4T2YoaGFzaCkgIT09IC0xKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5pbmRleE9mKGhhc2gpXVxuICAgICAgcmV0dXJuIHJvdXRlcy5nZXQobWF0Y2gpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlIGdpdmUgcHJpbyB0byBzdGF0aWMgcm91dGVzIG92ZXIgZHluYW1pY1xuICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMuc29ydChhID0+IHtcbiAgICAgICAgcmV0dXJuIGlzTmFtZWRHcm91cC50ZXN0KGEpID8gLTEgOiAxXG4gICAgICB9KVxuICAgICAgLy8gd291bGQgYmUgc3RyYW5nZSBpZiB0aGlzIGZhaWxzXG4gICAgICAvLyBidXQgc3RpbGwgd2UgdGVzdFxuICAgICAgaWYgKHJvdXRlRXhpc3RzKG1hdGNoZXNbMF0pKSB7XG4gICAgICAgIHJldHVybiByb3V0ZXMuZ2V0KG1hdGNoZXNbMF0pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgY29uc3QgZ2V0VmFsdWVzRnJvbUhhc2ggPSAoaGFzaCA9ICcnLCBwYXRoKSA9PiB7XG4gIC8vIHJlcGxhY2UgdGhlIHJlZ2V4IGRlZmluaXRpb24gZnJvbSB0aGUgcm91dGUgYmVjYXVzZVxuICAvLyB3ZSBhbHJlYWR5IGRpZCB0aGUgbWF0Y2hpbmcgcGFydFxuICBwYXRoID0gc3RyaXBSZWdleChwYXRoLCAnJylcblxuICBjb25zdCBnZXRVcmxQYXJ0cyA9IC8oXFwvPzo/W1xcdyVcXHM6Li1dKykvZ1xuICBjb25zdCBoYXNoUGFydHMgPSBoYXNoLm1hdGNoKGdldFVybFBhcnRzKSB8fCBbXVxuICBjb25zdCByb3V0ZVBhcnRzID0gcGF0aC5tYXRjaChnZXRVcmxQYXJ0cykgfHwgW11cbiAgY29uc3QgZ2V0TmFtZWRHcm91cCA9IC9eXFwvOihbXFx3LV0rKVxcLz8vXG5cbiAgcmV0dXJuIHJvdXRlUGFydHMucmVkdWNlKChzdG9yYWdlLCB2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBtYXRjaCA9IGdldE5hbWVkR3JvdXAuZXhlYyh2YWx1ZSlcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoKSB7XG4gICAgICBzdG9yYWdlLnNldChtYXRjaFsxXSwgZGVjb2RlVVJJQ29tcG9uZW50KGhhc2hQYXJ0c1tpbmRleF0ucmVwbGFjZSgvXlxcLy8sICcnKSkpXG4gICAgfVxuICAgIHJldHVybiBzdG9yYWdlXG4gIH0sIG5ldyBNYXAoKSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldE9wdGlvbiA9IChzdGFjaywgcHJvcCkgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpZihzdGFjayAmJiBzdGFjay5oYXNPd25Qcm9wZXJ0eShwcm9wKSl7XG4gICAgcmV0dXJuIHN0YWNrW3Byb3BdXG4gIH1cbiAgLy8gd2UgZXhwbGljaXRseSByZXR1cm4gdW5kZWZpbmVkIHNpbmNlIHdlJ3JlIHRlc3RpbmdcbiAgLy8gZm9yIGV4cGxpY2l0IHRlc3QgdmFsdWVzXG59XG5cbi8qKlxuICogY3JlYXRlIGFuZCByZXR1cm4gbmV3IFJvdXRlIGluc3RhbmNlXG4gKiBAcGFyYW0gY29uZmlnXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSb3V0ZSA9IGNvbmZpZyA9PiB7XG4gIC8vIHdlIG5lZWQgdG8gcHJvdmlkZSBhIGJpdCBvZiBhZGRpdGlvbmFsIGxvZ2ljXG4gIC8vIGZvciB0aGUgYm9vdENvbXBvbmVudFxuICBpZiAoY29uZmlnLnBhdGggPT09ICckJykge1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgcHJldmVudFN0b3JhZ2U6IHRydWUsXG4gICAgfVxuICAgIGlmIChpc09iamVjdChjb25maWcub3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLmNvbmZpZy5vcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgfVxuICAgIH1cbiAgICBjb25maWcub3B0aW9ucyA9IG9wdGlvbnNcbiAgICAvLyBpZiBjb25maWd1cmVkIGFkZCByZWZlcmVuY2UgdG8gYm9vdFJlcXVlc3RcbiAgICAvLyBhcyByb3V0ZXIgYWZ0ZXIgcHJvdmlkZXJcbiAgICBpZiAoYm9vdFJlcXVlc3QpIHtcbiAgICAgIGNvbmZpZy5hZnRlciA9IGJvb3RSZXF1ZXN0XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUm91dGUoY29uZmlnKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBSb3V0ZXIgcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSB1cmxcbiAqIEBwYXJhbSBhcmdzXG4gKiBAcGFyYW0gc3RvcmVcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUmVxdWVzdCA9ICh1cmwsIGFyZ3MsIHN0b3JlKSA9PiB7XG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwsIGFyZ3MsIHN0b3JlKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0SGFzaEJ5TmFtZSA9IG9iaiA9PiB7XG4gIGlmICghb2JqLnRvICYmICFvYmoubmFtZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGNvbnN0IHJvdXRlID0gZ2V0Um91dGVCeU5hbWUob2JqLnRvIHx8IG9iai5uYW1lKVxuICBjb25zdCBoYXNEeW5hbWljR3JvdXAgPSAvXFwvOihbXFx3LV0rKVxcLz8vXG4gIGxldCBoYXNoID0gcm91dGVcblxuICAvLyBpZiByb3V0ZSBjb250YWlucyBkeW5hbWljIGdyb3VwXG4gIC8vIHdlIHJlcGxhY2UgdGhlbSB3aXRoIHRoZSBwcm92aWRlZCBwYXJhbXNcbiAgaWYgKGhhc0R5bmFtaWNHcm91cC50ZXN0KHJvdXRlKSkge1xuICAgIGlmIChvYmoucGFyYW1zKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqLnBhcmFtcylcbiAgICAgIGhhc2ggPSBrZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIGFjYy5yZXBsYWNlKGA6JHtrZXl9YCwgb2JqLnBhcmFtc1trZXldKVxuICAgICAgfSwgcm91dGUpXG4gICAgfVxuICAgIGlmIChvYmoucXVlcnkpIHtcbiAgICAgIHJldHVybiBgJHtoYXNofSR7b2JqZWN0VG9RdWVyeVN0cmluZyhvYmoucXVlcnkpfWBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc2hcbn1cblxuY29uc3QgZ2V0Um91dGVCeU5hbWUgPSBuYW1lID0+IHtcbiAgZm9yIChsZXQgW3BhdGgsIHJvdXRlXSBvZiByb3V0ZXMuZW50cmllcygpKSB7XG4gICAgaWYgKHJvdXRlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBwYXRoXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgY29uc3Qga2VlcEFjdGl2ZVBhZ2VBbGl2ZSA9IChyb3V0ZSwgcmVxdWVzdCkgPT4ge1xuICBpZiAoaXNTdHJpbmcocm91dGUpKSB7XG4gICAgY29uc3Qgcm91dGVzID0gZ2V0Um91dGVzKClcbiAgICBpZiAocm91dGVzLmhhcyhyb3V0ZSkpIHtcbiAgICAgIHJvdXRlID0gcm91dGVzLmdldChyb3V0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVnaXN0ZXIgPSByZXF1ZXN0LnJlZ2lzdGVyXG4gIGNvbnN0IHJvdXRlT3B0aW9ucyA9IHJvdXRlLm9wdGlvbnNcblxuICBpZiAocmVnaXN0ZXIuaGFzKCdrZWVwQWxpdmUnKSkge1xuICAgIHJldHVybiByZWdpc3Rlci5nZXQoJ2tlZXBBbGl2ZScpXG4gIH0gZWxzZSBpZiAocm91dGVPcHRpb25zICYmIHJvdXRlT3B0aW9ucy5rZWVwQWxpdmUpIHtcbiAgICByZXR1cm4gcm91dGVPcHRpb25zLmtlZXBBbGl2ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBnZXRDb25maWdNYXAsXG4gIGlzQXJyYXksXG4gIGlzQm9vbGVhbixcbiAgaXNDb21wb25lbnRDb25zdHJ1Y3RvcixcbiAgaXNGdW5jdGlvbixcbiAgaXNQYWdlLFxuICBzeW1ib2xzLFxuICBjbGVhbkhhc2gsXG59IGZyb20gJy4vaGVscGVycydcbmltcG9ydCB7IHN0ZXAsIG5hdmlnYXRlUXVldWUgfSBmcm9tICcuLi9pbmRleCdcbmltcG9ydCB7IGNyZWF0ZVJvdXRlLCBnZXRPcHRpb24gfSBmcm9tICcuL3JvdXRlJ1xuaW1wb3J0IHsgY3JlYXRlQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzJ1xuaW1wb3J0IExvZyBmcm9tICcuLi8uLi9Mb2cnXG5pbXBvcnQgeyBpc1dpbGRjYXJkIH0gZnJvbSAnLi9yZWdleCdcbmltcG9ydCBlbWl0IGZyb20gJy4vZW1pdCdcbmltcG9ydCB7IHVwZGF0ZVdpZGdldHMgfSBmcm9tICcuL3dpZGdldHMnXG5pbXBvcnQgeyBzZXRIaXN0b3J5LCB1cGRhdGVIaXN0b3J5IH0gZnJvbSAnLi9oaXN0b3J5J1xuaW1wb3J0IHsgQXBwSW5zdGFuY2UgfSBmcm9tICcuLi8uLi9BcHBsaWNhdGlvbidcblxuLyoqXG4gKiBAdHlwZSB7TGlnaHRuaW5nLkFwcGxpY2F0aW9ufVxuICovXG5leHBvcnQgbGV0IGFwcGxpY2F0aW9uXG5cbi8qKlxuICogQWN0dWFsIGluc3RhbmNlIG9mIHRoZSBhcHBcbiAqIEB0eXBlIHtMaWdodG5pbmcuQ29tcG9uZW50fVxuICovXG5leHBvcnQgbGV0IGFwcFxuXG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGhvc3RzIGFsbCByb3V0ZWQgcGFnZXNcbiAqIEB0eXBlIHtMaWdodG5pbmcuQ29tcG9uZW50fVxuICovXG5leHBvcnQgbGV0IHBhZ2VzSG9zdFxuXG4vKipcbiAqIEB0eXBlIHtMaWdodG5pbmcuU3RhZ2V9XG4gKi9cbmV4cG9ydCBsZXQgc3RhZ2VcblxuLyoqXG4gKiBQbGF0Zm9ybSBkcml2ZW4gUm91dGVyIGNvbmZpZ3VyYXRpb25cbiAqIEB0eXBlIHtNYXA8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGxldCByb3V0ZXJDb25maWdcblxuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBob3N0cyBhbGwgYXR0YWNoZWQgd2lkZ2V0c1xuICogQHR5cGUge0xpZ2h0bmluZy5Db21wb25lbnR9XG4gKi9cbmV4cG9ydCBsZXQgd2lkZ2V0c0hvc3RcblxuLyoqXG4gKiBIYXNoIHdlIHBvaW50IHRoZSBicm93c2VyIHRvIHdoZW4gd2UgYm9vdCB0aGUgYXBwXG4gKiBhbmQgdGhlcmUgaXMgbm8gZGVlcC1saW5rIHByb3ZpZGVkXG4gKiBAdHlwZSB7c3RyaW5nfEZ1bmN0aW9ufVxuICovXG5sZXQgcm9vdEhhc2hcblxuLyoqXG4gKiBCb290IHJlcXVlc3Qgd2lsbCBmaXJlIGJlZm9yZSBhcHAgc3RhcnRcbiAqIGNhbiBiZSB1c2VkIHRvIGV4ZWN1dGUgc29tZSBnbG9iYWwgbG9naWNcbiAqIGFuZCBjYW4gYmUgY29uZmlndXJlZFxuICovXG5leHBvcnQgbGV0IGJvb3RSZXF1ZXN0XG5cbi8qKlxuICogRmxhZyBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgYnJvd3NlciBsb2NhdGlvbiBoYXNoLlxuICogUm91dGVyIGNhbiB3b3JrIHdpdGhvdXQuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGxldCB1cGRhdGVIYXNoID0gdHJ1ZVxuXG4vKipcbiAqIFdpbGwgYmUgY2FsbGVkIGJlZm9yZSBhIHJvdXRlIHN0YXJ0cywgY2FuIGJlIG92ZXJyaWRkZW5cbiAqIHZpYSByb3V0ZXMgY29uZmlnXG4gKiBAcGFyYW0gZnJvbSAtIHJvdXRlIHdlIGNhbWUgZnJvbVxuICogQHBhcmFtIHRvIC0gcm91dGUgd2UgbmF2aWdhdGUgdG9cbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmV4cG9ydCBsZXQgYmVmb3JlRWFjaFJvdXRlID0gYXN5bmMgKGZyb20sIHRvKT0+e1xuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqICAqIFdpbGwgYmUgY2FsbGVkIGFmdGVyIGEgbmF2aWdhdGUgc3VjY2Vzc2Z1bGx5IHJlc29sdmVkLFxuICogY2FuIGJlIG92ZXJyaWRkZW4gdmlhIHJvdXRlcyBjb25maWdcbiAqL1xuZXhwb3J0IGxldCBhZnRlckVhY2hSb3V0ZSA9ICgpID0+IHt9XG5cbi8qKlxuICogQWxsIGNvbmZpZ3VyZWQgcm91dGVzXG4gKiBAdHlwZSB7TWFwPHN0cmluZywgb2JqZWN0Pn1cbiAqL1xuZXhwb3J0IGxldCByb3V0ZXMgPSBuZXcgTWFwKClcblxuLyoqXG4gKiBTdG9yZSBhbGwgcGFnZSBjb21wb25lbnRzIHBlciByb3V0ZVxuICogQHR5cGUge01hcDxzdHJpbmcsIG9iamVjdD59XG4gKi9cbmV4cG9ydCBsZXQgY29tcG9uZW50cyA9IG5ldyBNYXAoKVxuXG4vKipcbiAqIEZsYWcgaWYgcm91dGVyIGhhcyBiZWVuIGluaXRpYWxpc2VkXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xubGV0IGluaXRpYWxpc2VkID0gZmFsc2VcblxuLyoqXG4gKiBDdXJyZW50IHBhZ2UgYmVpbmcgcmVuZGVyZWQgb24gc2NyZWVuXG4gKiBAdHlwZSB7bnVsbH1cbiAqL1xubGV0IGFjdGl2ZVBhZ2UgPSBudWxsXG5sZXQgYWN0aXZlSGFzaFxubGV0IGFjdGl2ZVJvdXRlXG5cbi8qKlxuICogIER1cmluZyB0aGUgcHJvY2VzcyBvZiBhIG5hdmlnYXRpb24gcmVxdWVzdCBhIG5ld1xuICogIHJlcXVlc3QgY2FuIHN0YXJ0LCB0byBwcmV2ZW50IHVud2FudGVkIGJlaGF2aW91clxuICogIHRoZSBuYXZpZ2F0ZSgpLW1ldGhvZCBzdG9yZXMgdGhlIGxhc3QgYWNjZXB0ZWQgaGFzaFxuICogIHNvIHdlIGNhbiBpbnZhbGlkYXRlIGFueSBwcmlvciByZXF1ZXN0c1xuICovXG5sZXQgbGFzdEFjY2VwdGVkSGFzaFxuXG4vKipcbiAqIFdpdGggb24oKS1kYXRhIHByb3ZpZGluZyBiZWhhdmlvdXIgdGhlIFJvdXRlciBmb3JjZWQgdGhlIEFwcFxuICogaW4gYSBMb2FkaW5nIHN0YXRlLiBXaGVuIHRoZSBkYXRhLXByb3ZpZGVyIHJlc29sdmVzIHdlIHdhbnQgdG9cbiAqIGNoYW5nZSB0aGUgc3RhdGUgYmFjayB0byB3aGVyZSB3ZSBjYW1lIGZyb21cbiAqL1xubGV0IHByZXZpb3VzU3RhdGVcblxuY29uc3QgbWl4aW4gPSBhcHAgPT4ge1xuICAvLyBieSBkZWZhdWx0IHRoZSBSb3V0ZXIgQmFzZWNsYXNzIHByb3ZpZGVzIHRoZSBjb21wb25lbnRcbiAgLy8gcmVmZXJlbmNlIGluIHdoaWNoIHdlIHN0b3JlIG91ciBwYWdlc1xuICBpZiAoYXBwLnBhZ2VzKSB7XG4gICAgcGFnZXNIb3N0ID0gYXBwLnBhZ2VzLmNoaWxkTGlzdFxuICB9XG4gIC8vIGlmIHRoZSBhcHAgaXMgdXNpbmcgd2lkZ2V0cyB3ZSBncmFiIHJlZnNcbiAgLy8gYW5kIGhpZGUgYWxsIHRoZSB3aWRnZXRzXG4gIGlmIChhcHAud2lkZ2V0cyAmJiBhcHAud2lkZ2V0cy5jaGlsZHJlbikge1xuICAgIHdpZGdldHNIb3N0ID0gYXBwLndpZGdldHMuY2hpbGRMaXN0XG4gICAgLy8gaGlkZSBhbGwgd2lkZ2V0cyBvbiBib290XG4gICAgd2lkZ2V0c0hvc3QuZm9yRWFjaCh3ID0+ICh3LnZpc2libGUgPSBmYWxzZSkpXG4gIH1cbiAgYXBwLl9oYW5kbGVCYWNrID0gZSA9PiB7XG4gICAgc3RlcCgtMSlcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYm9vdFJvdXRlciA9IChjb25maWcsIGluc3RhbmNlKSA9PiB7XG4gIGxldCB7IGFwcEluc3RhbmNlLCByb3V0ZXMgfSA9IGNvbmZpZ1xuXG4gIC8vIGlmIGluc3RhbmNlIGlzIHByb3ZpZGVkIGFuZCBpdCdzIGFuZCBMaWdodG5pbmcgQ29tcG9uZW50IGluc3RhbmNlXG4gIGlmIChpbnN0YW5jZSAmJiBpc1BhZ2UoaW5zdGFuY2UpKSB7XG4gICAgYXBwID0gaW5zdGFuY2VcbiAgfVxuICBpZiAoIWFwcCkge1xuICAgIGFwcCA9IGFwcEluc3RhbmNlIHx8IEFwcEluc3RhbmNlXG4gIH1cblxuICBhcHBsaWNhdGlvbiA9IGFwcC5hcHBsaWNhdGlvblxuICBwYWdlc0hvc3QgPSBhcHBsaWNhdGlvbi5jaGlsZExpc3RcbiAgc3RhZ2UgPSBhcHAuc3RhZ2VcbiAgcm91dGVyQ29uZmlnID0gZ2V0Q29uZmlnTWFwKClcblxuICBtaXhpbihhcHApXG5cbiAgaWYgKGlzQXJyYXkocm91dGVzKSkge1xuICAgIHNldHVwKGNvbmZpZylcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHJvdXRlcykpIHtcbiAgICBjb25zb2xlLndhcm4oJ1tSb3V0ZXJdOiBDYWxsaW5nIFJvdXRlci5yb3V0ZSgpIGRpcmVjdGx5IGlzIGRlcHJlY2F0ZWQuJylcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnVXNlIG9iamVjdCBjb25maWc6IGh0dHBzOi8vcmRrY2VudHJhbC5naXRodWIuaW8vTGlnaHRuaW5nLVNESy8jL3BsdWdpbnMvcm91dGVyL2NvbmZpZ3VyYXRpb24nXG4gICAgKVxuICB9XG59XG5cbmNvbnN0IHNldHVwID0gY29uZmlnID0+IHtcbiAgaWYgKCFpbml0aWFsaXNlZCkge1xuICAgIGluaXQoY29uZmlnKVxuICB9XG4gIGNvbmZpZy5yb3V0ZXMuZm9yRWFjaChyID0+IHtcbiAgICBjb25zdCBwYXRoID0gY2xlYW5IYXNoKHIucGF0aClcbiAgICBpZiAoIXJvdXRlRXhpc3RzKHBhdGgpKSB7XG4gICAgICBjb25zdCByb3V0ZSA9IGNyZWF0ZVJvdXRlKHIpXG4gICAgICByb3V0ZXMuc2V0KHBhdGgsIHJvdXRlKVxuICAgICAgLy8gaWYgcm91dGUgaGFzIGEgY29uZmlndXJlZCBjb21wb25lbnQgcHJvcGVydHlcbiAgICAgIC8vIHdlIHN0b3JlIGl0IGluIGEgZGlmZmVyZW50IG1hcCB0byBzaW1wbGlmeVxuICAgICAgLy8gdGhlIGNyZWF0aW5nIGFuZCBkZXN0cm95aW5nIHBlciByb3V0ZVxuICAgICAgaWYgKHJvdXRlLmNvbXBvbmVudCkge1xuICAgICAgICBsZXQgdHlwZSA9IHJvdXRlLmNvbXBvbmVudFxuICAgICAgICBpZiAoaXNDb21wb25lbnRDb25zdHJ1Y3Rvcih0eXBlKSkge1xuICAgICAgICAgIGlmICghcm91dGVyQ29uZmlnLmdldCgnbGF6eUNyZWF0ZScpKSB7XG4gICAgICAgICAgICB0eXBlID0gY3JlYXRlQ29tcG9uZW50KHN0YWdlLCB0eXBlKVxuICAgICAgICAgICAgcGFnZXNIb3N0LmEodHlwZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50cy5zZXQocGF0aCwgdHlwZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgJHtwYXRofSBhbHJlYWR5IGV4aXN0cyBpbiByb3V0ZXMgY29uZmlndXJhdGlvbmApXG4gICAgfVxuICB9KVxufVxuXG5jb25zdCBpbml0ID0gY29uZmlnID0+IHtcbiAgcm9vdEhhc2ggPSBjb25maWcucm9vdFxuICBpZiAoaXNGdW5jdGlvbihjb25maWcuYm9vdCkpIHtcbiAgICBib290UmVxdWVzdCA9IGNvbmZpZy5ib290XG4gIH1cbiAgaWYgKGlzQm9vbGVhbihjb25maWcudXBkYXRlSGFzaCkpIHtcbiAgICB1cGRhdGVIYXNoID0gY29uZmlnLnVwZGF0ZUhhc2hcbiAgfVxuICBpZiAoaXNGdW5jdGlvbihjb25maWcuYmVmb3JlRWFjaFJvdXRlKSkge1xuICAgIGJlZm9yZUVhY2hSb3V0ZSA9IGNvbmZpZy5iZWZvcmVFYWNoUm91dGVcbiAgfVxuICBpZiAoaXNGdW5jdGlvbihjb25maWcuYWZ0ZXJFYWNoUm91dGUpKSB7XG4gICAgYWZ0ZXJFYWNoUm91dGUgPSBjb25maWcuYWZ0ZXJFYWNoUm91dGVcbiAgfVxuICBpZiAoY29uZmlnLmJvb3RDb21wb25lbnQpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnW1JvdXRlcl06IEJvb3QgQ29tcG9uZW50IGlzIG5vdyBhdmFpbGFibGUgYXMgYSBzcGVjaWFsIHJvdXRlcjogaHR0cHM6Ly9yZGtjZW50cmFsLmdpdGh1Yi5pby9MaWdodG5pbmctU0RLLyMvcGx1Z2lucy9yb3V0ZXIvY29uZmlndXJhdGlvbj9pZD1zcGVjaWFsLXJvdXRlcydcbiAgICApXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1tSb3V0ZXJdOiBzZXR0aW5nIHsgYm9vdENvbXBvbmVudCB9IHByb3BlcnR5IHdpbGwgYmUgZGVwcmVjYXRlZCBpbiBhIGZ1dHVyZSByZWxlYXNlJ1xuICAgIClcbiAgICBpZiAoaXNQYWdlKGNvbmZpZy5ib290Q29tcG9uZW50KSkge1xuICAgICAgY29uZmlnLnJvdXRlcy5wdXNoKHtcbiAgICAgICAgcGF0aDogJyQnLFxuICAgICAgICBjb21wb25lbnQ6IGNvbmZpZy5ib290Q29tcG9uZW50LFxuICAgICAgICAvLyB3ZSB0cnkgdG8gYXNzaWduIHRoZSBib290UmVxdWVzdCBhcyBhZnRlciBkYXRhLXByb3ZpZGVyXG4gICAgICAgIC8vIHNvIGl0IHdpbGwgYmVoYXZlIGFzIGFueSBvdGhlciBjb21wb25lbnRcbiAgICAgICAgYWZ0ZXI6IGJvb3RSZXF1ZXN0IHx8IG51bGwsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBwcmV2ZW50U3RvcmFnZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtSb3V0ZXJdOiAke2NvbmZpZy5ib290Q29tcG9uZW50fSBpcyBub3QgYSB2YWxpZCBib290IGNvbXBvbmVudGApXG4gICAgfVxuICB9XG4gIGluaXRpYWxpc2VkID0gdHJ1ZVxufVxuXG5leHBvcnQgY29uc3Qgc3RvcmVDb21wb25lbnQgPSAocm91dGUsIHR5cGUpID0+IHtcbiAgaWYgKGNvbXBvbmVudHMuaGFzKHJvdXRlKSkge1xuICAgIGNvbXBvbmVudHMuc2V0KHJvdXRlLCB0eXBlKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRDb21wb25lbnQgPSByb3V0ZSA9PiB7XG4gIGlmIChjb21wb25lbnRzLmhhcyhyb3V0ZSkpIHtcbiAgICByZXR1cm4gY29tcG9uZW50cy5nZXQocm91dGUpXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cbi8qKlxuICogVGVzdCBpZiByb3V0ZXIgbmVlZHMgdG8gdXBkYXRlIGJyb3dzZXIgbG9jYXRpb24gaGFzaFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBtdXN0VXBkYXRlTG9jYXRpb25IYXNoID0gKCkgPT4ge1xuICBpZiAoIXJvdXRlckNvbmZpZyB8fCAhcm91dGVyQ29uZmlnLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICAvLyB3ZSBuZWVkIHN1cHBvcnQgdG8gZWl0aGVyIHR1cm4gY2hhbmdlIGhhc2ggb2ZmXG4gIC8vIHBlciBwbGF0Zm9ybSBvciBwZXIgYXBwXG4gIGNvbnN0IHVwZGF0ZUNvbmZpZyA9IHJvdXRlckNvbmZpZy5nZXQoJ3VwZGF0ZUhhc2gnKVxuICByZXR1cm4gISgoaXNCb29sZWFuKHVwZGF0ZUNvbmZpZykgJiYgIXVwZGF0ZUNvbmZpZykgfHwgKGlzQm9vbGVhbih1cGRhdGVIYXNoKSAmJiAhdXBkYXRlSGFzaCkpXG59XG5cbi8qKlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIG5ldyBuYXZpZ2F0ZSgpIHJlcXVlc3QgaGFzIGNvbXBsZXRlZFxuICogYW5kIGhhcyBub3QgYmVlbiBleHBpcmVkIGR1ZSB0byBpdCdzIGFzeW5jIG5hdHVyZVxuICogQHBhcmFtIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGNvbnN0IG9uUmVxdWVzdFJlc29sdmVkID0gcmVxdWVzdCA9PiB7XG4gIGNvbnN0IGhhc2ggPSByZXF1ZXN0Lmhhc2hcbiAgY29uc3Qgcm91dGUgPSByZXF1ZXN0LnJvdXRlXG4gIGNvbnN0IHJlZ2lzdGVyID0gcmVxdWVzdC5yZWdpc3RlclxuICBjb25zdCBwYWdlID0gcmVxdWVzdC5wYWdlXG5cbiAgLy8gY2xlYW4gdXAgaGlzdG9yeSBpZiBtb2RpZmllciBpcyBzZXRcbiAgaWYgKGdldE9wdGlvbihyb3V0ZS5vcHRpb25zLCAnY2xlYXJIaXN0b3J5JykpIHtcbiAgICBzZXRIaXN0b3J5KFtdKVxuICB9IGVsc2UgaWYgKGhhc2ggJiYgIWlzV2lsZGNhcmQudGVzdChyb3V0ZS5wYXRoKSkge1xuICAgIHVwZGF0ZUhpc3RvcnkocmVxdWVzdClcbiAgfVxuXG4gIC8vIHdlIG9ubHkgdXBkYXRlIHRoZSBzdGFja0xvY2F0aW9uIGlmIGEgcm91dGVcbiAgLy8gaXMgbm90IGV4cGlyZWQgYmVmb3JlIGl0IHJlc29sdmVzXG4gIHN0b3JlQ29tcG9uZW50KHJvdXRlLnBhdGgsIHBhZ2UpXG5cbiAgaWYgKHJlcXVlc3QuaXNTaGFyZWRJbnN0YW5jZSB8fCAhcmVxdWVzdC5pc0NyZWF0ZWQpIHtcbiAgICBlbWl0KHBhZ2UsICdjaGFuZ2VkJylcbiAgfSBlbHNlIGlmIChyZXF1ZXN0LmlzQ3JlYXRlZCkge1xuICAgIGVtaXQocGFnZSwgJ21vdW50ZWQnKVxuICB9XG5cbiAgLy8gb25seSB1cGRhdGUgd2lkZ2V0cyBpZiB3ZSBoYXZlIGEgaG9zdFxuICBpZiAod2lkZ2V0c0hvc3QpIHtcbiAgICB1cGRhdGVXaWRnZXRzKHJvdXRlLndpZGdldHMsIHBhZ2UpXG4gIH1cblxuICAvLyB3ZSB3YW50IHRvIGNsZWFuIHVwIGlmIHRoZXJlIGlzIGFuXG4gIC8vIGFjdGl2ZSBwYWdlIHRoYXQgaXMgbm90IGJlaW5nIHNoYXJlZFxuICAvLyBiZXR3ZWVuIGN1cnJlbnQgYW5kIHByZXZpb3VzIHJvdXRlXG4gIGlmIChnZXRBY3RpdmVQYWdlKCkgJiYgIXJlcXVlc3QuaXNTaGFyZWRJbnN0YW5jZSkge1xuICAgIGNsZWFuVXAoYWN0aXZlUGFnZSwgcmVxdWVzdClcbiAgfVxuXG4gIC8vIHByb3ZpZGUgaGlzdG9yeSBvYmplY3QgdG8gYWN0aXZlIHBhZ2VcbiAgaWYgKHJlZ2lzdGVyLmdldChzeW1ib2xzLmhpc3RvcnlTdGF0ZSkgJiYgaXNGdW5jdGlvbihwYWdlLmhpc3RvcnlTdGF0ZSkpIHtcbiAgICBwYWdlLmhpc3RvcnlTdGF0ZShyZWdpc3Rlci5nZXQoc3ltYm9scy5oaXN0b3J5U3RhdGUpKVxuICB9XG5cbiAgc2V0QWN0aXZlUGFnZShwYWdlKVxuXG4gIGFjdGl2ZUhhc2ggPSByZXF1ZXN0Lmhhc2hcbiAgYWN0aXZlUm91dGUgPSByb3V0ZS5wYXRoXG5cbiAgLy8gY2xlYW51cCBhbGwgY2FuY2VsbGVkIHJlcXVlc3RzXG4gIGZvciAobGV0IHJlcXVlc3Qgb2YgbmF2aWdhdGVRdWV1ZS52YWx1ZXMoKSkge1xuICAgIGlmIChyZXF1ZXN0LmlzQ2FuY2VsbGVkICYmIHJlcXVlc3QuaGFzaCkge1xuICAgICAgbmF2aWdhdGVRdWV1ZS5kZWxldGUocmVxdWVzdC5oYXNoKVxuICAgIH1cbiAgfVxuXG4gIGFmdGVyRWFjaFJvdXRlKHJlcXVlc3QpXG5cbiAgTG9nLmluZm8oJ1tyb3V0ZV06Jywgcm91dGUucGF0aClcbiAgTG9nLmluZm8oJ1toYXNoXTonLCBoYXNoKVxufVxuXG5jb25zdCBjbGVhblVwID0gKHBhZ2UsIHJlcXVlc3QpID0+IHtcbiAgY29uc3Qgcm91dGUgPSBhY3RpdmVSb3V0ZVxuICBjb25zdCByZWdpc3RlciA9IHJlcXVlc3QucmVnaXN0ZXJcbiAgY29uc3QgbGF6eURlc3Ryb3kgPSByb3V0ZXJDb25maWcuZ2V0KCdsYXp5RGVzdHJveScpXG4gIGNvbnN0IGRlc3Ryb3lPbkJhY2sgPSByb3V0ZXJDb25maWcuZ2V0KCdkZXN0cm95T25IaXN0b3J5QmFjaycpXG4gIGNvbnN0IGtlZXBBbGl2ZSA9IHJlZ2lzdGVyLmdldCgna2VlcEFsaXZlJylcbiAgY29uc3QgaXNGcm9tSGlzdG9yeSA9IHJlZ2lzdGVyLmdldChzeW1ib2xzLmJhY2t0cmFjaylcblxuICBsZXQgZG9DbGVhbnVwID0gZmFsc2VcblxuICAvLyBpZiB0aGlzIHJlcXVlc3QgaXMgZXhlY3V0ZWQgZHVlIHRvIGEgc3RlcCBiYWNrIGluIGhpc3RvcnlcbiAgLy8gYW5kIHdlIGhhdmUgY29uZmlndXJlZCB0byBkZXN0cm95IGFjdGl2ZSBwYWdlIHdoZW4gd2UgZ28gYmFja1xuICAvLyBpbiBoaXN0b3J5IG9yIGxhenlEZXN0b3J5IGlzIGVuYWJsZWRcbiAgaWYgKGlzRnJvbUhpc3RvcnkgJiYgKGRlc3Ryb3lPbkJhY2sgfHwgbGF6eURlc3Ryb3kpKSB7XG4gICAgZG9DbGVhbnVwID0gdHJ1ZVxuICB9XG5cbiAgLy8gY2xlYW4gdXAgaWYgbGF6eURlc3Ryb3kgaXMgZW5hYmxlZCBhbmQgdGhlIGtlZXBBbGl2ZSBmbGFnXG4gIC8vIGluIG5hdmlnYXRpb24gcmVnaXN0ZXIgaXMgZmFsc2VcbiAgaWYgKGxhenlEZXN0cm95ICYmICFrZWVwQWxpdmUpIHtcbiAgICBkb0NsZWFudXAgPSB0cnVlXG4gIH1cblxuICAvLyBpZiB0aGUgY3VycmVudCBhbmQgbmV3IHJlcXVlc3Qgc2hhcmUgdGhlIHNhbWUgcm91dGUgYmx1ZXByaW50XG4gIGlmIChhY3RpdmVSb3V0ZSA9PT0gcmVxdWVzdC5yb3V0ZS5wYXRoKSB7XG4gICAgZG9DbGVhbnVwID0gdHJ1ZVxuICB9XG5cbiAgaWYgKGRvQ2xlYW51cCkge1xuICAgIC8vIGdyYWIgb3JpZ2luYWwgY2xhc3MgY29uc3RydWN0b3IgaWZcbiAgICAvLyBzdGF0ZW1hY2hpbmUgcm91dGVkIGVsc2Ugc3RvcmUgY29uc3RydWN0b3JcbiAgICBzdG9yZUNvbXBvbmVudChyb3V0ZSwgcGFnZS5fcm91dGVkVHlwZSB8fCBwYWdlLmNvbnN0cnVjdG9yKVxuXG4gICAgLy8gYWN0dWFsIHJlbW92ZSBvZiBwYWdlIGZyb20gbWVtb3J5XG4gICAgcGFnZXNIb3N0LnJlbW92ZShwYWdlKVxuXG4gICAgLy8gZm9yY2UgdGV4dHVyZSBnYygpIGlmIGNvbmZpZ3VyZWRcbiAgICAvLyBzbyB3ZSBjYW4gY2xlYW51cCB0ZXh0dXJlcyBpbiB0aGUgc2FtZSB0aWNrXG4gICAgaWYgKHJvdXRlckNvbmZpZy5nZXQoJ2djT25VbmxvYWQnKSkge1xuICAgICAgc3RhZ2UuZ2MoKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB3ZSdyZSBub3QgcmVtb3ZpbmcgdGhlIHBhZ2Ugd2UgbmVlZCB0b1xuICAgIC8vIHJlc2V0IGl0J3MgcHJvcGVydGllc1xuICAgIHBhZ2UucGF0Y2goe1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICBzY2FsZTogMSxcbiAgICAgIGFscGhhOiAxLFxuICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0QWN0aXZlSGFzaCA9ICgpID0+IHtcbiAgcmV0dXJuIGFjdGl2ZUhhc2hcbn1cblxuZXhwb3J0IGNvbnN0IHNldEFjdGl2ZUhhc2ggPSBoYXNoID0+IHtcbiAgYWN0aXZlSGFzaCA9IGhhc2hcbn1cblxuZXhwb3J0IGNvbnN0IHNldEFjdGl2ZVBhZ2UgPSBwYWdlID0+IHtcbiAgYWN0aXZlUGFnZSA9IHBhZ2Vcbn1cblxuZXhwb3J0IGNvbnN0IGdldEFjdGl2ZVBhZ2UgPSAoKSA9PiB7XG4gIHJldHVybiBhY3RpdmVQYWdlXG59XG5cbmV4cG9ydCBjb25zdCBnZXRBY3RpdmVSb3V0ZSA9ICgpID0+IHtcbiAgcmV0dXJuIGFjdGl2ZVJvdXRlXG59XG5cbmV4cG9ydCBjb25zdCBnZXRMYXN0SGFzaCA9ICgpID0+IHtcbiAgcmV0dXJuIGxhc3RBY2NlcHRlZEhhc2hcbn1cblxuZXhwb3J0IGNvbnN0IHNldExhc3RIYXNoID0gaGFzaCA9PiB7XG4gIGxhc3RBY2NlcHRlZEhhc2ggPSBoYXNoXG59XG5cbmV4cG9ydCBjb25zdCBzZXRQcmV2aW91c1N0YXRlID0gc3RhdGUgPT4ge1xuICBwcmV2aW91c1N0YXRlID0gc3RhdGVcbn1cblxuZXhwb3J0IGNvbnN0IGdldFByZXZpb3VzU3RhdGUgPSAoKSA9PiB7XG4gIHJldHVybiBwcmV2aW91c1N0YXRlXG59XG5cbmV4cG9ydCBjb25zdCByb3V0ZUV4aXN0cyA9IGtleSA9PiB7XG4gIHJldHVybiByb3V0ZXMuaGFzKGtleSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldFJvb3RIYXNoID0gKCkgPT4ge1xuICByZXR1cm4gcm9vdEhhc2hcbn1cblxuZXhwb3J0IGNvbnN0IGdldEJvb3RSZXF1ZXN0ID0gKCkgPT4ge1xuICByZXR1cm4gYm9vdFJlcXVlc3Rcbn1cblxuZXhwb3J0IGNvbnN0IGdldFJvdXRlckNvbmZpZyA9ICgpID0+IHtcbiAgcmV0dXJuIHJvdXRlckNvbmZpZ1xufVxuXG5leHBvcnQgY29uc3QgZ2V0Um91dGVzID0gKCkgPT4ge1xuICByZXR1cm4gcm91dGVzXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBnZXRSb3V0ZXJDb25maWcgfSBmcm9tICcuL3JvdXRlcidcbmltcG9ydCB7IGlzUHJvbWlzZSwgaXNTdHJpbmcgfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgVHJhbnNpdGlvbnMgZnJvbSAnLi4vdHJhbnNpdGlvbnMnXG5cbi8qKlxuICogZXhlY3V0ZSB0cmFuc2l0aW9uIGJldHdlZW4gbmV3IC8gb2xkIHBhZ2UgYW5kXG4gKiB0b2dnbGUgdGhlIGRlZmluZWQgd2lkZ2V0c1xuICogQHRvZG86IHBsYXRmb3JtIG92ZXJyaWRlIGRlZmF1bHQgdHJhbnNpdGlvblxuICogQHBhcmFtIHBhZ2VJblxuICogQHBhcmFtIHBhZ2VPdXRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4ZWN1dGVUcmFuc2l0aW9uID0gKHBhZ2VJbiwgcGFnZU91dCA9IG51bGwpID0+IHtcbiAgY29uc3QgdHJhbnNpdGlvbiA9IHBhZ2VJbi5wYWdlVHJhbnNpdGlvbiB8fCBwYWdlSW4uZWFzaW5nXG4gIGNvbnN0IGhhc0N1c3RvbVRyYW5zaXRpb25zID0gISEocGFnZUluLnNtb290aEluIHx8IHBhZ2VJbi5zbW9vdGhJbk91dCB8fCB0cmFuc2l0aW9uKVxuICBjb25zdCB0cmFuc2l0aW9uc0Rpc2FibGVkID0gZ2V0Um91dGVyQ29uZmlnKCkuZ2V0KCdkaXNhYmxlVHJhbnNpdGlvbnMnKVxuXG4gIGlmIChwYWdlSW4uZWFzaW5nKSB7XG4gICAgY29uc29sZS53YXJuKCdlYXNpbmcoKSBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkLiBVc2UgcGFnZVRyYW5zaXRpb24oKScpXG4gIH1cblxuICAvLyBkZWZhdWx0IGJlaGF2aW91ciBpcyBhIHZpc2liaWxpdHkgdG9nZ2xlXG4gIGlmICghaGFzQ3VzdG9tVHJhbnNpdGlvbnMgfHwgdHJhbnNpdGlvbnNEaXNhYmxlZCkge1xuICAgIHBhZ2VJbi52aXNpYmxlID0gdHJ1ZVxuICAgIGlmIChwYWdlT3V0KSB7XG4gICAgICBwYWdlT3V0LnZpc2libGUgPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgbGV0IHR5cGVcbiAgICB0cnkge1xuICAgICAgdHlwZSA9IHRyYW5zaXRpb24uY2FsbChwYWdlSW4sIHBhZ2VJbiwgcGFnZU91dClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0eXBlID0gJ2Nyb3NzRmFkZSdcbiAgICB9XG5cbiAgICBpZiAoaXNQcm9taXNlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHlwZVxuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyh0eXBlKSkge1xuICAgICAgY29uc3QgZm4gPSBUcmFuc2l0aW9uc1t0eXBlXVxuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHJldHVybiBmbihwYWdlSW4sIHBhZ2VPdXQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8ga2VlcCBiYWNrd2FyZHMgY29tcGF0aWJsZSBmb3Igbm93XG4gICAgaWYgKHBhZ2VJbi5zbW9vdGhJbikge1xuICAgICAgLy8gcHJvdmlkZSBhIHNtb290aCBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIGl0c2VsZlxuICAgICAgLy8gb24gdHJhbnNpdGlvbiBmaW5pc2hcbiAgICAgIGNvbnN0IHNtb290aCA9IChwLCB2LCBhcmdzID0ge30pID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIHBhZ2VJbi52aXNpYmxlID0gdHJ1ZVxuICAgICAgICAgIHBhZ2VJbi5zZXRTbW9vdGgocCwgdiwgYXJncylcbiAgICAgICAgICBwYWdlSW4udHJhbnNpdGlvbihwKS5vbignZmluaXNoJywgKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYWdlSW4uc21vb3RoSW4oeyBwYWdlSW4sIHNtb290aCB9KVxuICAgIH1cbiAgfVxuICByZXR1cm4gVHJhbnNpdGlvbnMuY3Jvc3NGYWRlKHBhZ2VJbiwgcGFnZU91dClcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGFwcCwgd2lkZ2V0c0hvc3QgfSBmcm9tICcuL3JvdXRlcidcbmltcG9ydCB7IHVjZmlyc3QgfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgZW1pdCBmcm9tICcuL2VtaXQnXG5cbmxldCBhY3RpdmVXaWRnZXQgPSBudWxsXG5cbmV4cG9ydCBjb25zdCBnZXRSZWZlcmVuY2VzID0gKCkgPT4ge1xuICBpZiAoIXdpZGdldHNIb3N0KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIHdpZGdldHNIb3N0LmdldCgpLnJlZHVjZSgoc3RvcmFnZSwgd2lkZ2V0KSA9PiB7XG4gICAgY29uc3Qga2V5ID0gd2lkZ2V0LnJlZi50b0xvd2VyQ2FzZSgpXG4gICAgc3RvcmFnZVtrZXldID0gd2lkZ2V0XG4gICAgcmV0dXJuIHN0b3JhZ2VcbiAgfSwge30pXG59XG5cbi8qKlxuICogdXBkYXRlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBhdmFpbGFibGUgd2lkZ2V0c1xuICogZm9yIHRoZSBjdXJyZW50IHBhZ2UgLyByb3V0ZVxuICogQHBhcmFtIHBhZ2VcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVdpZGdldHMgPSAod2lkZ2V0cywgcGFnZSkgPT4ge1xuICAvLyBmb3JjZSBsb3dlcmNhc2UgbG9va3VwXG4gIGNvbnN0IGNvbmZpZ3VyZWQgPSAod2lkZ2V0cyB8fCBbXSkubWFwKHJlZiA9PiByZWYudG9Mb3dlckNhc2UoKSlcblxuICB3aWRnZXRzSG9zdC5mb3JFYWNoKHdpZGdldCA9PiB7XG4gICAgd2lkZ2V0LnZpc2libGUgPSBjb25maWd1cmVkLmluZGV4T2Yod2lkZ2V0LnJlZi50b0xvd2VyQ2FzZSgpKSAhPT0gLTFcbiAgICBpZiAod2lkZ2V0LnZpc2libGUpIHtcbiAgICAgIGVtaXQod2lkZ2V0LCBbJ2FjdGl2YXRlZCddLCBwYWdlKVxuICAgIH1cbiAgfSlcbiAgaWYgKGFwcC5zdGF0ZSA9PT0gJ1dpZGdldHMnICYmIGFjdGl2ZVdpZGdldCAmJiAhYWN0aXZlV2lkZ2V0LnZpc2libGUpIHtcbiAgICBhcHAuX3NldFN0YXRlKCcnKVxuICB9XG59XG5cbmNvbnN0IGdldFdpZGdldEJ5TmFtZSA9IG5hbWUgPT4ge1xuICBuYW1lID0gdWNmaXJzdChuYW1lKVxuICByZXR1cm4gd2lkZ2V0c0hvc3QuZ2V0QnlSZWYobmFtZSkgfHwgZmFsc2Vcbn1cblxuLyoqXG4gKiBkZWxlZ2F0ZSBhcHAgZm9jdXMgdG8gYSBvbi1zY3JlZW4gd2lkZ2V0XG4gKiBAcGFyYW0gbmFtZSAtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBmb2N1c1dpZGdldCA9IG5hbWUgPT4ge1xuICBjb25zdCB3aWRnZXQgPSBnZXRXaWRnZXRCeU5hbWUobmFtZSlcbiAgaWYgKHdpZGdldCkge1xuICAgIHNldEFjdGl2ZVdpZGdldCh3aWRnZXQpXG5cbiAgICAvLyBpZiBhcHAgaXMgYWxyZWFkeSBpbiAnV2lkZ2V0cycgc3RhdGUgd2UgY2FuIGFzc3VtZSB0aGF0XG4gICAgLy8gZm9jdXMgaGFzIGJlZW4gZGVsZWdhdGVkIGZyb20gb25lIHdpZGdldCB0byBhbm90aGVyIHNvXG4gICAgLy8gd2UgbmVlZCB0byBzZXQgdGhlIG5ldyB3aWRnZXQgcmVmZXJlbmNlIGFuZCB0cmlnZ2VyIGFcbiAgICAvLyBuZXcgZm9jdXMgY2FsY3VsYXRpb24gb2YgTGlnaHRuaW5nJ3MgZm9jdXNwYXRoXG4gICAgaWYgKGFwcC5zdGF0ZSA9PT0gJ1dpZGdldHMnKSB7XG4gICAgICBhcHAucmVsb2FkKGFjdGl2ZVdpZGdldClcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwLl9zZXRTdGF0ZSgnV2lkZ2V0cycsIFthY3RpdmVXaWRnZXRdKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaGFuZGxlUmVtb3RlID0gKHR5cGUsIG5hbWUpID0+IHtcbiAgaWYgKHR5cGUgPT09ICd3aWRnZXQnKSB7XG4gICAgZm9jdXNXaWRnZXQobmFtZSlcbiAgfSBlbHNlIGlmICh0eXBlID09PSAncGFnZScpIHtcbiAgICByZXN0b3JlRm9jdXMoKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZXN0b3JlRm9jdXMgPSAoKSA9PiB7XG4gIGFjdGl2ZVdpZGdldCA9IG51bGxcbiAgYXBwLl9zZXRTdGF0ZSgnJylcbn1cblxuZXhwb3J0IGNvbnN0IGdldEFjdGl2ZVdpZGdldCA9ICgpID0+IHtcbiAgcmV0dXJuIGFjdGl2ZVdpZGdldFxufVxuXG5leHBvcnQgY29uc3Qgc2V0QWN0aXZlV2lkZ2V0ID0gaW5zdGFuY2UgPT4ge1xuICBhY3RpdmVXaWRnZXQgPSBpbnN0YW5jZVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuY29uc3Qgc2V0dGluZ3MgPSB7fVxuY29uc3Qgc3Vic2NyaWJlcnMgPSB7fVxuXG5leHBvcnQgY29uc3QgaW5pdFNldHRpbmdzID0gKGFwcFNldHRpbmdzLCBwbGF0Zm9ybVNldHRpbmdzKSA9PiB7XG4gIHNldHRpbmdzWydhcHAnXSA9IGFwcFNldHRpbmdzXG4gIHNldHRpbmdzWydwbGF0Zm9ybSddID0gcGxhdGZvcm1TZXR0aW5nc1xuICBzZXR0aW5nc1sndXNlciddID0ge31cbn1cblxuY29uc3QgcHVibGlzaCA9IChrZXksIHZhbHVlKSA9PiB7XG4gIHN1YnNjcmliZXJzW2tleV0gJiYgc3Vic2NyaWJlcnNba2V5XS5mb3JFYWNoKHN1YnNjcmliZXIgPT4gc3Vic2NyaWJlcih2YWx1ZSkpXG59XG5cbmNvbnN0IGRvdEdyYWIgPSAob2JqID0ge30sIGtleSkgPT4ge1xuICBpZiAob2JqID09PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkXG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBvYmogPSBvYmpba2V5c1tpXV0gPSBvYmpba2V5c1tpXV0gIT09IHVuZGVmaW5lZCA/IG9ialtrZXlzW2ldXSA6IHt9XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCA/IChPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA/IG9iaiA6IHVuZGVmaW5lZCkgOiBvYmpcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXQodHlwZSwga2V5LCBmYWxsYmFjayA9IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHZhbCA9IGRvdEdyYWIoc2V0dGluZ3NbdHlwZV0sIGtleSlcbiAgICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgPyB2YWwgOiBmYWxsYmFja1xuICB9LFxuICBoYXModHlwZSwga2V5KSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXQodHlwZSwga2V5KVxuICB9LFxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHNldHRpbmdzWyd1c2VyJ11ba2V5XSA9IHZhbHVlXG4gICAgcHVibGlzaChrZXksIHZhbHVlKVxuICB9LFxuICBzdWJzY3JpYmUoa2V5LCBjYWxsYmFjaykge1xuICAgIHN1YnNjcmliZXJzW2tleV0gPSBzdWJzY3JpYmVyc1trZXldIHx8IFtdXG4gICAgc3Vic2NyaWJlcnNba2V5XS5wdXNoKGNhbGxiYWNrKVxuICB9LFxuICB1bnN1YnNjcmliZShrZXksIGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHN1YnNjcmliZXJzW2tleV0gJiYgc3Vic2NyaWJlcnNba2V5XS5maW5kSW5kZXgoY2IgPT4gY2IgPT09IGNhbGxiYWNrKVxuICAgICAgaW5kZXggPiAtMSAmJiBzdWJzY3JpYmVyc1trZXldLnNwbGljZShpbmRleCwgMSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtleSBpbiBzdWJzY3JpYmVycykge1xuICAgICAgICBzdWJzY3JpYmVyc1trZXldID0gW11cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNsZWFyU3Vic2NyaWJlcnMoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3Vic2NyaWJlcnMpKSB7XG4gICAgICBkZWxldGUgc3Vic2NyaWJlcnNba2V5XVxuICAgIH1cbiAgfSxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi9TZXR0aW5ncydcbmltcG9ydCBsb2NhbENvb2tpZSBmcm9tICdsb2NhbENvb2tpZS9tb2R1bGUvbG9jYWxDb29raWUuanMnXG5cbmxldCBuYW1lc3BhY2VcbmxldCBsY1xuXG5leHBvcnQgY29uc3QgaW5pdFN0b3JhZ2UgPSAoKSA9PiB7XG4gIG5hbWVzcGFjZSA9IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnaWQnKVxuICAvLyB0b2RvOiBwYXNzIG9wdGlvbnMgKGZvciBleGFtcGxlIHRvIGZvcmNlIHRoZSB1c2Ugb2YgY29va2llcylcbiAgbGMgPSBuZXcgbG9jYWxDb29raWUoKVxufVxuXG5jb25zdCBuYW1lc3BhY2VkS2V5ID0ga2V5ID0+IChuYW1lc3BhY2UgPyBbbmFtZXNwYWNlLCBrZXldLmpvaW4oJy4nKSA6IGtleSlcblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXQoa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGxjLmdldEl0ZW0obmFtZXNwYWNlZEtleShrZXkpKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfSxcbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgbGMuc2V0SXRlbShuYW1lc3BhY2VkS2V5KGtleSksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9LFxuICByZW1vdmUoa2V5KSB7XG4gICAgbGMucmVtb3ZlSXRlbShuYW1lc3BhY2VkS2V5KGtleSkpXG4gIH0sXG4gIGNsZWFyKCkge1xuICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgIGxjLmtleXMoKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgaXRlbSBpZiBpbiB0aGUgbmFtZXNwYWNlXG4gICAgICAgIGtleS5pbmRleE9mKG5hbWVzcGFjZSArICcuJykgPT09IDAgPyBsYy5yZW1vdmVJdGVtKGtleSkgOiBudWxsXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBsYy5jbGVhcigpXG4gICAgfVxuICB9LFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL1NldHRpbmdzJ1xuXG5jb25zdCBkZWZhdWx0Q2hhbm5lbHMgPSBbXG4gIHtcbiAgICBudW1iZXI6IDEsXG4gICAgbmFtZTogJ01ldHJvIE5ld3MgMScsXG4gICAgZGVzY3JpcHRpb246ICdOZXcgWW9yayBDYWJsZSBOZXdzIENoYW5uZWwnLFxuICAgIGVudGl0bGVkOiB0cnVlLFxuICAgIHByb2dyYW06IHtcbiAgICAgIHRpdGxlOiAnVGhlIE1vcm5pbmcgU2hvdycsXG4gICAgICBkZXNjcmlwdGlvbjogXCJOZXcgWW9yaydzIGJlc3QgbW9ybmluZyBzaG93XCIsXG4gICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKG5ldyBEYXRlKCkgLSA2MCAqIDUgKiAxMDAwKS50b1VUQ1N0cmluZygpLCAvLyBzdGFydGVkIDUgbWludXRlcyBhZ29cbiAgICAgIGR1cmF0aW9uOiA2MCAqIDMwLCAvLyAzMCBtaW51dGVzXG4gICAgICBhZ2VSYXRpbmc6IDAsXG4gICAgfSxcbiAgfSxcbiAge1xuICAgIG51bWJlcjogMixcbiAgICBuYW1lOiAnTVRWJyxcbiAgICBkZXNjcmlwdGlvbjogJ011c2ljIFRlbGV2aXNpb24nLFxuICAgIGVudGl0bGVkOiB0cnVlLFxuICAgIHByb2dyYW06IHtcbiAgICAgIHRpdGxlOiAnQmVhdmlzIGFuZCBCdXR0aGVhZCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ0FtZXJpY2FuIGFkdWx0IGFuaW1hdGVkIHNpdGNvbSBjcmVhdGVkIGJ5IE1pa2UgSnVkZ2UnLFxuICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZShuZXcgRGF0ZSgpIC0gNjAgKiAyMCAqIDEwMDApLnRvVVRDU3RyaW5nKCksIC8vIHN0YXJ0ZWQgMjAgbWludXRlcyBhZ29cbiAgICAgIGR1cmF0aW9uOiA2MCAqIDQ1LCAvLyA0NSBtaW51dGVzXG4gICAgICBhZ2VSYXRpbmc6IDE4LFxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICBudW1iZXI6IDMsXG4gICAgbmFtZTogJ05CQycsXG4gICAgZGVzY3JpcHRpb246ICdOQkMgVFYgTmV0d29yaycsXG4gICAgZW50aXRsZWQ6IGZhbHNlLFxuICAgIHByb2dyYW06IHtcbiAgICAgIHRpdGxlOiAnVGhlIFRvbmlnaHQgU2hvdyBTdGFycmluZyBKaW1teSBGYWxsb24nLFxuICAgICAgZGVzY3JpcHRpb246ICdMYXRlLW5pZ2h0IHRhbGsgc2hvdyBob3N0ZWQgYnkgSmltbXkgRmFsbG9uIG9uIE5CQycsXG4gICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKG5ldyBEYXRlKCkgLSA2MCAqIDEwICogMTAwMCkudG9VVENTdHJpbmcoKSwgLy8gc3RhcnRlZCAxMCBtaW51dGVzIGFnb1xuICAgICAgZHVyYXRpb246IDYwICogNjAsIC8vIDEgaG91clxuICAgICAgYWdlUmF0aW5nOiAxMCxcbiAgICB9LFxuICB9LFxuXVxuXG5leHBvcnQgY29uc3QgY2hhbm5lbHMgPSAoKSA9PiBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ3R2JywgZGVmYXVsdENoYW5uZWxzKVxuXG5leHBvcnQgY29uc3QgcmFuZG9tQ2hhbm5lbCA9ICgpID0+IGNoYW5uZWxzKClbfn4oY2hhbm5lbHMubGVuZ3RoICogTWF0aC5yYW5kb20oKSldXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcblxuaW1wb3J0IHsgY2hhbm5lbHMsIHJhbmRvbUNoYW5uZWwgfSBmcm9tICcuL2RlZmF1bHRzJ1xuXG5sZXQgY3VycmVudENoYW5uZWxcbmNvbnN0IGNhbGxiYWNrcyA9IHt9XG5cbmNvbnN0IGVtaXQgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgY2FsbGJhY2tzW2V2ZW50XSAmJlxuICAgIGNhbGxiYWNrc1tldmVudF0uZm9yRWFjaChjYiA9PiB7XG4gICAgICBjYi5hcHBseShudWxsLCBhcmdzKVxuICAgIH0pXG59XG5cbi8vIGxvY2FsIG1vY2sgbWV0aG9kc1xubGV0IG1ldGhvZHMgPSB7XG4gIGdldENoYW5uZWwoKSB7XG4gICAgaWYgKCFjdXJyZW50Q2hhbm5lbCkgY3VycmVudENoYW5uZWwgPSByYW5kb21DaGFubmVsKClcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnRDaGFubmVsKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSB7IC4uLmN1cnJlbnRDaGFubmVsIH1cbiAgICAgICAgZGVsZXRlIGNoYW5uZWwucHJvZ3JhbVxuICAgICAgICByZXNvbHZlKGNoYW5uZWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QoJ05vIGNoYW5uZWwgZm91bmQnKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIGdldFByb2dyYW0oKSB7XG4gICAgaWYgKCFjdXJyZW50Q2hhbm5lbCkgY3VycmVudENoYW5uZWwgPSByYW5kb21DaGFubmVsKClcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY3VycmVudENoYW5uZWwucHJvZ3JhbSA/IHJlc29sdmUoY3VycmVudENoYW5uZWwucHJvZ3JhbSkgOiByZWplY3QoJ05vIHByb2dyYW0gZm91bmQnKVxuICAgIH0pXG4gIH0sXG4gIHNldENoYW5uZWwobnVtYmVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChudW1iZXIpIHtcbiAgICAgICAgY29uc3QgbmV3Q2hhbm5lbCA9IGNoYW5uZWxzKCkuZmluZChjID0+IGMubnVtYmVyID09PSBudW1iZXIpXG4gICAgICAgIGlmIChuZXdDaGFubmVsKSB7XG4gICAgICAgICAgY3VycmVudENoYW5uZWwgPSBuZXdDaGFubmVsXG4gICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHsgLi4uY3VycmVudENoYW5uZWwgfVxuICAgICAgICAgIGRlbGV0ZSBjaGFubmVsLnByb2dyYW1cbiAgICAgICAgICBlbWl0KCdjaGFubmVsQ2hhbmdlJywgY2hhbm5lbClcbiAgICAgICAgICByZXNvbHZlKGNoYW5uZWwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KCdDaGFubmVsIG5vdCBmb3VuZCcpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdCgnTm8gY2hhbm5lbCBudW1iZXIgc3VwcGxpZWQnKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG59XG5cbmV4cG9ydCBjb25zdCBpbml0VFYgPSBjb25maWcgPT4ge1xuICBtZXRob2RzID0ge31cbiAgaWYgKGNvbmZpZy5nZXRDaGFubmVsICYmIHR5cGVvZiBjb25maWcuZ2V0Q2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1ldGhvZHMuZ2V0Q2hhbm5lbCA9IGNvbmZpZy5nZXRDaGFubmVsXG4gIH1cbiAgaWYgKGNvbmZpZy5nZXRQcm9ncmFtICYmIHR5cGVvZiBjb25maWcuZ2V0UHJvZ3JhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1ldGhvZHMuZ2V0UHJvZ3JhbSA9IGNvbmZpZy5nZXRQcm9ncmFtXG4gIH1cbiAgaWYgKGNvbmZpZy5zZXRDaGFubmVsICYmIHR5cGVvZiBjb25maWcuc2V0Q2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1ldGhvZHMuc2V0Q2hhbm5lbCA9IGNvbmZpZy5zZXRDaGFubmVsXG4gIH1cbiAgaWYgKGNvbmZpZy5lbWl0ICYmIHR5cGVvZiBjb25maWcuZW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbmZpZy5lbWl0KGVtaXQpXG4gIH1cbn1cblxuLy8gcHVibGljIEFQSVxuZXhwb3J0IGRlZmF1bHQge1xuICBjaGFubmVsKG51bWJlciA9IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gY2FsbCBzZXRDaGFubmVsIHdoZW4gbnVtYmVyIGFyZ3VtZW50IGlzIHBhc3NlZCwgb3RoZXJ3aXNlIGdldENoYW5uZWxcbiAgICAgICAgbWV0aG9kc1tudW1iZXIgPyAnc2V0Q2hhbm5lbCcgOiAnZ2V0Q2hhbm5lbCddKG51bWJlcilcbiAgICAgICAgICAudGhlbihjaGFubmVsID0+IHtcbiAgICAgICAgICAgIC8vIHRvIGRvOiBlbnN1cmUgY29uc2lzdGVudCBmb3JtYXR0aW5nIG9mIGNoYW5uZWwgaW5mbyBoZXJlP1xuICAgICAgICAgICAgcmVzb2x2ZShjaGFubmVsKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgcHJvZ3JhbSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWV0aG9kc1xuICAgICAgICAgIC5nZXRQcm9ncmFtKClcbiAgICAgICAgICAudGhlbihwcm9ncmFtID0+IHtcbiAgICAgICAgICAgIC8vIHRvIGRvOiBlbnN1cmUgY29uc2lzdGVudCBmb3JtYXR0aW5nIG9mIHByb2dyYW0gaW5mbyBoZXJlP1xuICAgICAgICAgICAgcmVzb2x2ZShwcm9ncmFtKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgZW50aXRsZWQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1ldGhvZHNcbiAgICAgICAgICAuZ2V0Q2hhbm5lbCgpXG4gICAgICAgICAgLnRoZW4oY2hhbm5lbCA9PiB7XG4gICAgICAgICAgICAnZW50aXRsZWQnIGluIGNoYW5uZWwgPyByZXNvbHZlKCEhY2hhbm5lbC5lbnRpdGxlZCkgOiByZWplY3QoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2IpIHtcbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFja3NbZXZlbnRdID0gY2FsbGJhY2tzW2V2ZW50XSB8fCBbXVxuICAgICAgY2FsbGJhY2tzW2V2ZW50XS5wdXNoKGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICBMb2cuZXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgZnVuY3Rpb24gYXMgYSBjYWxsYmFjaycpXG4gICAgfVxuICB9LFxuICByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBjYiA9IGZhbHNlKSB7XG4gICAgaWYgKGNhbGxiYWNrc1tldmVudF0gJiYgY2FsbGJhY2tzW2V2ZW50XS5sZW5ndGgpIHtcbiAgICAgIGNhbGxiYWNrc1tldmVudF0gPSBjYiA/IGNhbGxiYWNrc1tldmVudF0uZmlsdGVyKF9jYiA9PiBfY2IgPT09IGNiKSA6IFtdXG4gICAgfVxuICB9LFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxubGV0IGJhc2VQYXRoXG5sZXQgcHJveHlVcmxcblxuZXhwb3J0IGNvbnN0IGluaXRVdGlscyA9IGNvbmZpZyA9PiB7XG4gIGJhc2VQYXRoID0gZW5zdXJlVXJsV2l0aFByb3RvY29sKG1ha2VGdWxsU3RhdGljUGF0aCh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIGNvbmZpZy5wYXRoIHx8ICcvJykpXG5cbiAgaWYgKGNvbmZpZy5wcm94eVVybCkge1xuICAgIHByb3h5VXJsID0gZW5zdXJlVXJsV2l0aFByb3RvY29sKGNvbmZpZy5wcm94eVVybClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGFzc2V0KHJlbFBhdGgpIHtcbiAgICByZXR1cm4gYmFzZVBhdGggKyByZWxQYXRoXG4gIH0sXG4gIHByb3h5VXJsKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHByb3h5VXJsID8gcHJveHlVcmwgKyAnPycgKyBtYWtlUXVlcnlTdHJpbmcodXJsLCBvcHRpb25zKSA6IHVybFxuICB9LFxuICBtYWtlUXVlcnlTdHJpbmcoKSB7XG4gICAgcmV0dXJuIG1ha2VRdWVyeVN0cmluZyguLi5hcmd1bWVudHMpXG4gIH0sXG4gIC8vIHNpbmNlIGltYWdld29ya2VycyBkb24ndCB3b3JrIHdpdGhvdXQgcHJvdG9jb2xcbiAgZW5zdXJlVXJsV2l0aFByb3RvY29sKCkge1xuICAgIHJldHVybiBlbnN1cmVVcmxXaXRoUHJvdG9jb2woLi4uYXJndW1lbnRzKVxuICB9LFxufVxuXG5leHBvcnQgY29uc3QgZW5zdXJlVXJsV2l0aFByb3RvY29sID0gdXJsID0+IHtcbiAgaWYgKC9eXFwvXFwvLy50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgdXJsXG4gIH1cbiAgaWYgKCEvXig/Omh0dHBzPzopL2kudGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB1cmxcbiAgfVxuICByZXR1cm4gdXJsXG59XG5cbmV4cG9ydCBjb25zdCBtYWtlRnVsbFN0YXRpY1BhdGggPSAocGF0aG5hbWUgPSAnLycsIHBhdGgpID0+IHtcbiAgLy8gZW5zdXJlIHBhdGggaGFzIHRyYWxpbmcgc2xhc2hcbiAgcGF0aCA9IHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgIT09ICcvJyA/IHBhdGggKyAnLycgOiBwYXRoXG5cbiAgLy8gaWYgcGF0aCBpcyBVUkwsIHdlIGFzc3VtZSBpdCdzIGFscmVhZHkgdGhlIGZ1bGwgc3RhdGljIHBhdGgsIHNvIHdlIGp1c3QgcmV0dXJuIGl0XG4gIGlmICgvXig/Omh0dHBzPzopPyg/OlxcL1xcLykvLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9IGVsc2Uge1xuICAgIC8vIGNsZWFudXAgdGhlIHBhdGhuYW1lIChpLmUuIHJlbW92ZSBwb3NzaWJsZSBpbmRleC5odG1sKVxuICAgIHBhdGhuYW1lID0gY2xlYW5VcFBhdGhOYW1lKHBhdGhuYW1lKVxuXG4gICAgLy8gcmVtb3ZlIHBvc3NpYmxlIGxlYWRpbmcgZG90IGZyb20gcGF0aFxuICAgIHBhdGggPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy4nID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoXG4gICAgLy8gZW5zdXJlIHBhdGggaGFzIGxlYWRpbmcgc2xhc2hcbiAgICBwYXRoID0gcGF0aC5jaGFyQXQoMCkgIT09ICcvJyA/ICcvJyArIHBhdGggOiBwYXRoXG4gICAgcmV0dXJuIHBhdGhuYW1lICsgcGF0aFxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjbGVhblVwUGF0aE5hbWUgPSBwYXRobmFtZSA9PiB7XG4gIGlmIChwYXRobmFtZS5zbGljZSgtMSkgPT09ICcvJykgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKDAsIC0xKVxuICBjb25zdCBwYXJ0cyA9IHBhdGhuYW1lLnNwbGl0KCcvJylcbiAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLmluZGV4T2YoJy4nKSA+IC0xKSBwYXJ0cy5wb3AoKVxuICByZXR1cm4gcGFydHMuam9pbignLycpXG59XG5cbmNvbnN0IG1ha2VRdWVyeVN0cmluZyA9ICh1cmwsIG9wdGlvbnMgPSB7fSwgdHlwZSA9ICd1cmwnKSA9PiB7XG4gIC8vIGFkZCBvcGVyYXRvciBhcyBhbiBvcHRpb25cbiAgb3B0aW9ucy5vcGVyYXRvciA9ICdtZXRyb2xvZ2ljYWwnIC8vIFRvZG86IG1ha2UgdGhpcyBjb25maWd1cmFibGUgKHZpYSB1cmw/KVxuICAvLyBhZGQgdHlwZSAoPSB1cmwgb3IgcXIpIGFzIGFuIG9wdGlvbiwgd2l0aCB1cmwgYXMgdGhlIHZhbHVlXG4gIG9wdGlvbnNbdHlwZV0gPSB1cmxcblxuICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucylcbiAgICAubWFwKGtleSA9PiB7XG4gICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoJycgKyBvcHRpb25zW2tleV0pXG4gICAgfSlcbiAgICAuam9pbignJicpXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTGlnaHRuaW5nIGZyb20gJy4uL0xpZ2h0bmluZydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVyc2lvbkxhYmVsIGV4dGVuZHMgTGlnaHRuaW5nLkNvbXBvbmVudCB7XG4gIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY3Q6IHRydWUsXG4gICAgICBjb2xvcjogMHhiYjAwNzhhYyxcbiAgICAgIGg6IDQwLFxuICAgICAgdzogMTAwLFxuICAgICAgeDogdyA9PiB3IC0gNTAsXG4gICAgICB5OiBoID0+IGggLSA1MCxcbiAgICAgIG1vdW50OiAxLFxuICAgICAgVGV4dDoge1xuICAgICAgICB3OiB3ID0+IHcsXG4gICAgICAgIGg6IGggPT4gaCxcbiAgICAgICAgeTogNSxcbiAgICAgICAgeDogMjAsXG4gICAgICAgIHRleHQ6IHtcbiAgICAgICAgICBmb250U2l6ZTogMjIsXG4gICAgICAgICAgbGluZUhlaWdodDogMjYsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIF9maXJzdEFjdGl2ZSgpIHtcbiAgICB0aGlzLnRhZygnVGV4dCcpLnRleHQgPSBgQVBQIC0gdiR7dGhpcy52ZXJzaW9ufVxcblNESyAtIHYke3RoaXMuc2RrVmVyc2lvbn1gXG4gICAgdGhpcy50YWcoJ1RleHQnKS5sb2FkVGV4dHVyZSgpXG4gICAgdGhpcy53ID0gdGhpcy50YWcoJ1RleHQnKS5yZW5kZXJXaWR0aCArIDQwXG4gICAgdGhpcy5oID0gdGhpcy50YWcoJ1RleHQnKS5yZW5kZXJIZWlnaHQgKyA1XG4gIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBMaWdodG5pbmcgZnJvbSAnLi4vTGlnaHRuaW5nJ1xuaW1wb3J0IExvZyBmcm9tICcuLi9Mb2cnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZGVvVGV4dHVyZSBleHRlbmRzIExpZ2h0bmluZy5Db21wb25lbnQge1xuICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBWaWRlbzoge1xuICAgICAgICBhbHBoYTogMSxcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgIHBpdm90OiAwLjUsXG4gICAgICAgIHRleHR1cmU6IHsgdHlwZTogTGlnaHRuaW5nLnRleHR1cmVzLlN0YXRpY1RleHR1cmUsIG9wdGlvbnM6IHt9IH0sXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIHNldCB2aWRlb0VsKHYpIHtcbiAgICB0aGlzLl92aWRlb0VsID0gdlxuICB9XG5cbiAgZ2V0IHZpZGVvRWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZGVvRWxcbiAgfVxuXG4gIGdldCB2aWRlb1ZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnKCdWaWRlbycpXG4gIH1cblxuICBnZXQgdmlkZW9UZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnZpZGVvVmlldy50ZXh0dXJlXG4gIH1cblxuICBnZXQgaXNWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnZpZGVvVmlldy5hbHBoYSA9PT0gMSAmJiB0aGlzLnZpZGVvVmlldy52aXNpYmxlID09PSB0cnVlXG4gIH1cblxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9jcmVhdGVWaWRlb1RleHR1cmUoKVxuICB9XG5cbiAgX2NyZWF0ZVZpZGVvVGV4dHVyZSgpIHtcbiAgICBjb25zdCBzdGFnZSA9IHRoaXMuc3RhZ2VcblxuICAgIGNvbnN0IGdsID0gc3RhZ2UuZ2xcbiAgICBjb25zdCBnbFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBnbFRleHR1cmUpXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUilcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKVxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSlcbiAgICB0aGlzLnZpZGVvVGV4dHVyZS5vcHRpb25zID0geyBzb3VyY2U6IGdsVGV4dHVyZSwgdzogdGhpcy52aWRlb0VsLndpZHRoLCBoOiB0aGlzLnZpZGVvRWwuaGVpZ2h0IH1cblxuICAgIHRoaXMudmlkZW9WaWV3LncgPSB0aGlzLnZpZGVvRWwud2lkdGggLyB0aGlzLnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpXG4gICAgdGhpcy52aWRlb1ZpZXcuaCA9IHRoaXMudmlkZW9FbC5oZWlnaHQgLyB0aGlzLnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpXG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBjb25zdCBzdGFnZSA9IHRoaXMuc3RhZ2VcbiAgICB0aGlzLl9sYXN0VGltZSA9IDBcbiAgICBpZiAoIXRoaXMuX3VwZGF0ZVZpZGVvVGV4dHVyZSkge1xuICAgICAgdGhpcy5fdXBkYXRlVmlkZW9UZXh0dXJlID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5zb3VyY2UgJiYgdGhpcy52aWRlb0VsLnZpZGVvV2lkdGggJiYgdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICBjb25zdCBnbCA9IHN0YWdlLmdsXG5cbiAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICAgICAgY29uc3QgZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPSB0aGlzLnZpZGVvRWwuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKVxuXG4gICAgICAgICAgLy8gV2hlbiBCUjJfUEFDS0FHRV9HU1QxX1BMVUdJTlNfQkFEX1BMVUdJTl9ERUJVR1VUSUxTIGlzIG5vdCBzZXQgaW4gV1BFLCB3ZWJraXREZWNvZGVkRnJhbWVDb3VudCB3aWxsIG5vdCBiZSBhdmFpbGFibGUuXG4gICAgICAgICAgLy8gV2UnbGwgZmFsbGJhY2sgdG8gZml4ZWQgMzBmcHMgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgIC8vIEFzICd3ZWJraXREZWNvZGVkRnJhbWVDb3VudCcgaXMgYWJvdXQgdG8gZGVwcmVjYXRlLCBjaGVjayBmb3IgdGhlICd0b3RhbFZpZGVvRnJhbWVzJ1xuICAgICAgICAgIGNvbnN0IGZyYW1lQ291bnQgPSBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eVxuICAgICAgICAgICAgPyBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eS50b3RhbFZpZGVvRnJhbWVzXG4gICAgICAgICAgICA6IHRoaXMudmlkZW9FbC53ZWJraXREZWNvZGVkRnJhbWVDb3VudFxuXG4gICAgICAgICAgY29uc3QgbXVzdFVwZGF0ZSA9IGZyYW1lQ291bnRcbiAgICAgICAgICAgID8gdGhpcy5fbGFzdEZyYW1lICE9PSBmcmFtZUNvdW50XG4gICAgICAgICAgICA6IHRoaXMuX2xhc3RUaW1lIDwgY3VycmVudFRpbWUgLSAzMFxuXG4gICAgICAgICAgaWYgKG11c3RVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUaW1lID0gY3VycmVudFRpbWVcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IGZyYW1lQ291bnRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMuc291cmNlKVxuICAgICAgICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZhbHNlKVxuICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudmlkZW9FbClcbiAgICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gdGhpcy52aWRlb0VsLndlYmtpdERlY29kZWRGcmFtZUNvdW50XG4gICAgICAgICAgICAgIHRoaXMudmlkZW9WaWV3LnZpc2libGUgPSB0cnVlXG5cbiAgICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy53ID0gdGhpcy52aWRlb0VsLndpZHRoXG4gICAgICAgICAgICAgIHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMuaCA9IHRoaXMudmlkZW9FbC5oZWlnaHRcbiAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRBc3BlY3RSYXRpbyA9IHRoaXMudmlkZW9WaWV3LncgLyB0aGlzLnZpZGVvVmlldy5oXG4gICAgICAgICAgICAgIGNvbnN0IHJlYWxBc3BlY3RSYXRpbyA9IHRoaXMudmlkZW9FbC53aWR0aCAvIHRoaXMudmlkZW9FbC5oZWlnaHRcblxuICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWRBc3BlY3RSYXRpbyA+IHJlYWxBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9WaWV3LnNjYWxlWCA9IHJlYWxBc3BlY3RSYXRpbyAvIGV4cGVjdGVkQXNwZWN0UmF0aW9cbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvVmlldy5zY2FsZVkgPSAxXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb1ZpZXcuc2NhbGVZID0gZXhwZWN0ZWRBc3BlY3RSYXRpbyAvIHJlYWxBc3BlY3RSYXRpb1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9WaWV3LnNjYWxlWCA9IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBMb2cuZXJyb3IoJ3RleEltYWdlMmQgdmlkZW8nLCBlKVxuICAgICAgICAgICAgICB0aGlzLnN0b3AoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmUuc291cmNlLmZvcmNlUmVuZGVyVXBkYXRlKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl91cGRhdGluZ1ZpZGVvVGV4dHVyZSkge1xuICAgICAgc3RhZ2Uub24oJ2ZyYW1lU3RhcnQnLCB0aGlzLl91cGRhdGVWaWRlb1RleHR1cmUpXG4gICAgICB0aGlzLl91cGRhdGluZ1ZpZGVvVGV4dHVyZSA9IHRydWVcbiAgICB9XG4gIH1cblxuICBzdG9wKCkge1xuICAgIGNvbnN0IHN0YWdlID0gdGhpcy5zdGFnZVxuICAgIHN0YWdlLnJlbW92ZUxpc3RlbmVyKCdmcmFtZVN0YXJ0JywgdGhpcy5fdXBkYXRlVmlkZW9UZXh0dXJlKVxuICAgIHRoaXMuX3VwZGF0aW5nVmlkZW9UZXh0dXJlID0gZmFsc2VcbiAgICB0aGlzLnZpZGVvVmlldy52aXNpYmxlID0gZmFsc2VcblxuICAgIGlmICh0aGlzLnZpZGVvVGV4dHVyZS5vcHRpb25zLnNvdXJjZSkge1xuICAgICAgY29uc3QgZ2wgPSBzdGFnZS5nbFxuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5zb3VyY2UpXG4gICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDEpXG4gICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKVxuICAgIH1cbiAgfVxuXG4gIHBvc2l0aW9uKHRvcCwgbGVmdCkge1xuICAgIHRoaXMudmlkZW9WaWV3LnBhdGNoKHtcbiAgICAgIHNtb290aDoge1xuICAgICAgICB4OiBsZWZ0LFxuICAgICAgICB5OiB0b3AsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnZpZGVvVmlldy5wYXRjaCh7XG4gICAgICBzbW9vdGg6IHtcbiAgICAgICAgdzogd2lkdGgsXG4gICAgICAgIGg6IGhlaWdodCxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgdGhpcy52aWRlb1ZpZXcuc2V0U21vb3RoKCdhbHBoYScsIDEpXG4gIH1cblxuICBoaWRlKCkge1xuICAgIHRoaXMudmlkZW9WaWV3LnNldFNtb290aCgnYWxwaGEnLCAwKVxuICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGFib3J0OiAnQWJvcnQnLFxuICBjYW5wbGF5OiAnQ2FuUGxheScsXG4gIGNhbnBsYXl0aHJvdWdoOiAnQ2FuUGxheVRocm91Z2gnLFxuICBkdXJhdGlvbmNoYW5nZTogJ0R1cmF0aW9uQ2hhbmdlJyxcbiAgZW1wdGllZDogJ0VtcHRpZWQnLFxuICBlbmNyeXB0ZWQ6ICdFbmNyeXB0ZWQnLFxuICBlbmRlZDogJ0VuZGVkJyxcbiAgZXJyb3I6ICdFcnJvcicsXG4gIGludGVycnVwdGJlZ2luOiAnSW50ZXJydXB0QmVnaW4nLFxuICBpbnRlcnJ1cHRlbmQ6ICdJbnRlcnJ1cHRFbmQnLFxuICBsb2FkZWRkYXRhOiAnTG9hZGVkRGF0YScsXG4gIGxvYWRlZG1ldGFkYXRhOiAnTG9hZGVkTWV0YWRhdGEnLFxuICBsb2Fkc3RhcnQ6ICdMb2FkU3RhcnQnLFxuICBwYXVzZTogJ1BhdXNlJyxcbiAgcGxheTogJ1BsYXknLFxuICBwbGF5aW5nOiAnUGxheWluZycsXG4gIHByb2dyZXNzOiAnUHJvZ3Jlc3MnLFxuICByYXRlY2hhbmdlOiAnUmF0ZWNoYW5nZScsXG4gIHNlZWtlZDogJ1NlZWtlZCcsXG4gIHNlZWtpbmc6ICdTZWVraW5nJyxcbiAgc3RhbGxlZDogJ1N0YWxsZWQnLFxuICAvLyBzdXNwZW5kOiAnU3VzcGVuZCcsIC8vIHRoaXMgb25lIGlzIGNhbGxlZCBhIGxvb29vb3QgZm9yIHNvbWUgdmlkZW9zXG4gIHRpbWV1cGRhdGU6ICdUaW1lVXBkYXRlJyxcbiAgdm9sdW1lY2hhbmdlOiAnVm9sdW1lQ2hhbmdlJyxcbiAgd2FpdGluZzogJ1dhaXRpbmcnLFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IGV4ZWN1dGVBc1Byb21pc2UgZnJvbSAnQG1pY2hpZWxqcy9leGVjdXRlLWFzLXByb21pc2UnXG5cbmltcG9ydCBNZXRyaWNzIGZyb20gJy4uL01ldHJpY3MnXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcbmltcG9ydCBBZHMgZnJvbSAnLi4vQWRzJ1xuXG5pbXBvcnQgZXZlbnRzIGZyb20gJy4vZXZlbnRzJ1xuaW1wb3J0IGF1dG9TZXR1cE1peGluIGZyb20gJy4uL2hlbHBlcnMvYXV0b1NldHVwTWl4aW4nXG5pbXBvcnQgZWFzZUV4ZWN1dGlvbiBmcm9tICcuLi9oZWxwZXJzL2Vhc2VFeGVjdXRpb24nXG5pbXBvcnQgeyBBcHBsaWNhdGlvbkluc3RhbmNlIH0gZnJvbSAnLi4vTGF1bmNoJ1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL1NldHRpbmdzJ1xuaW1wb3J0IFZpZGVvVGV4dHVyZSBmcm9tICcuL1ZpZGVvVGV4dHVyZSdcblxuZXhwb3J0IGxldCBtZWRpYVVybCA9IHVybCA9PiB1cmxcbmxldCB2aWRlb0VsXG5sZXQgdmlkZW9UZXh0dXJlXG5sZXQgbWV0cmljc1xubGV0IGNvbnN1bWVyXG5sZXQgcHJlY2lzaW9uID0gMVxubGV0IHRleHR1cmVNb2RlID0gZmFsc2VcblxuZXhwb3J0IGNvbnN0IGluaXRWaWRlb1BsYXllciA9IGNvbmZpZyA9PiB7XG4gIGlmIChjb25maWcubWVkaWFVcmwpIHtcbiAgICBtZWRpYVVybCA9IGNvbmZpZy5tZWRpYVVybFxuICB9XG59XG5cbi8vIHRvZG86IGFkZCB0aGlzIGluIGEgJ1JlZ2lzdHJ5JyBwbHVnaW5cbi8vIHRvIGJlIGFibGUgdG8gYWx3YXlzIGNsZWFuIHRoaXMgdXAgb24gYXBwIGNsb3NlXG5sZXQgZXZlbnRIYW5kbGVycyA9IHt9XG5cbmNvbnN0IHN0YXRlID0ge1xuICBhZHNFbmFibGVkOiBmYWxzZSxcbiAgcGxheWluZzogZmFsc2UsXG4gIF9wbGF5aW5nQWRzOiBmYWxzZSxcbiAgZ2V0IHBsYXlpbmdBZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsYXlpbmdBZHNcbiAgfSxcbiAgc2V0IHBsYXlpbmdBZHModmFsKSB7XG4gICAgaWYgKHRoaXMuX3BsYXlpbmdBZHMgIT09IHZhbCkge1xuICAgICAgdGhpcy5fcGxheWluZ0FkcyA9IHZhbFxuICAgICAgZmlyZU9uQ29uc3VtZXIodmFsID09PSB0cnVlID8gJ0FkU3RhcnQnIDogJ0FkRW5kJylcbiAgICB9XG4gIH0sXG4gIHNraXBUaW1lOiBmYWxzZSxcbiAgcGxheUFmdGVyU2VlazogbnVsbCxcbn1cblxuY29uc3QgaG9va3MgPSB7XG4gIHBsYXkoKSB7XG4gICAgc3RhdGUucGxheWluZyA9IHRydWVcbiAgfSxcbiAgcGF1c2UoKSB7XG4gICAgc3RhdGUucGxheWluZyA9IGZhbHNlXG4gIH0sXG4gIHNlZWtlZCgpIHtcbiAgICBzdGF0ZS5wbGF5QWZ0ZXJTZWVrID09PSB0cnVlICYmIHZpZGVvUGxheWVyUGx1Z2luLnBsYXkoKVxuICAgIHN0YXRlLnBsYXlBZnRlclNlZWsgPSBudWxsXG4gIH0sXG4gIGFib3J0KCkge1xuICAgIGRlcmVnaXN0ZXJFdmVudExpc3RlbmVycygpXG4gIH0sXG59XG5cbmNvbnN0IHdpdGhQcmVjaXNpb24gPSB2YWwgPT4gTWF0aC5yb3VuZChwcmVjaXNpb24gKiB2YWwpICsgJ3B4J1xuXG5jb25zdCBmaXJlT25Db25zdW1lciA9IChldmVudCwgYXJncykgPT4ge1xuICBpZiAoY29uc3VtZXIpIHtcbiAgICBjb25zdW1lci5maXJlKCckdmlkZW9QbGF5ZXInICsgZXZlbnQsIGFyZ3MsIHZpZGVvRWwuY3VycmVudFRpbWUpXG4gICAgY29uc3VtZXIuZmlyZSgnJHZpZGVvUGxheWVyRXZlbnQnLCBldmVudCwgYXJncywgdmlkZW9FbC5jdXJyZW50VGltZSlcbiAgfVxufVxuXG5jb25zdCBmaXJlSG9vayA9IChldmVudCwgYXJncykgPT4ge1xuICBob29rc1tldmVudF0gJiYgdHlwZW9mIGhvb2tzW2V2ZW50XSA9PT0gJ2Z1bmN0aW9uJyAmJiBob29rc1tldmVudF0uY2FsbChudWxsLCBldmVudCwgYXJncylcbn1cblxubGV0IGN1c3RvbUxvYWRlciA9IG51bGxcbmxldCBjdXN0b21VbmxvYWRlciA9IG51bGxcblxuY29uc3QgbG9hZGVyID0gKHVybCwgdmlkZW9FbCwgY29uZmlnKSA9PiB7XG4gIHJldHVybiBjdXN0b21Mb2FkZXIgJiYgdHlwZW9mIGN1c3RvbUxvYWRlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gY3VzdG9tTG9hZGVyKHVybCwgdmlkZW9FbCwgY29uZmlnKVxuICAgIDogbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHVybCA9IG1lZGlhVXJsKHVybClcbiAgICAgICAgdmlkZW9FbC5zZXRBdHRyaWJ1dGUoJ3NyYycsIHVybClcbiAgICAgICAgdmlkZW9FbC5sb2FkKClcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxufVxuXG5jb25zdCB1bmxvYWRlciA9IHZpZGVvRWwgPT4ge1xuICByZXR1cm4gY3VzdG9tVW5sb2FkZXIgJiYgdHlwZW9mIGN1c3RvbVVubG9hZGVyID09PSAnZnVuY3Rpb24nXG4gICAgPyBjdXN0b21VbmxvYWRlcih2aWRlb0VsKVxuICAgIDogbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHZpZGVvRWwucmVtb3ZlQXR0cmlidXRlKCdzcmMnKVxuICAgICAgICB2aWRlb0VsLmxvYWQoKVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG59XG5cbmV4cG9ydCBjb25zdCBzZXR1cFZpZGVvVGFnID0gKCkgPT4ge1xuICBjb25zdCB2aWRlb0VscyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd2aWRlbycpXG4gIGlmICh2aWRlb0VscyAmJiB2aWRlb0Vscy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdmlkZW9FbHNbMF1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2aWRlb0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgIGNvbnN0IHBsYXRmb3JtU2V0dGluZ3NXaWR0aCA9IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnd2lkdGgnKVxuICAgICAgPyBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ3dpZHRoJylcbiAgICAgIDogMTkyMFxuICAgIGNvbnN0IHBsYXRmb3JtU2V0dGluZ3NIZWlnaHQgPSBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ2hlaWdodCcpXG4gICAgICA/IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnaGVpZ2h0JylcbiAgICAgIDogMTA4MFxuICAgIHZpZGVvRWwuc2V0QXR0cmlidXRlKCdpZCcsICd2aWRlby1wbGF5ZXInKVxuICAgIHZpZGVvRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpdGhQcmVjaXNpb24ocGxhdGZvcm1TZXR0aW5nc1dpZHRoKSlcbiAgICB2aWRlb0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgd2l0aFByZWNpc2lvbihwbGF0Zm9ybVNldHRpbmdzSGVpZ2h0KSlcbiAgICB2aWRlb0VsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgIHZpZGVvRWwuc3R5bGUuekluZGV4ID0gJzEnXG4gICAgdmlkZW9FbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgdmlkZW9FbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICB2aWRlb0VsLnN0eWxlLnRvcCA9IHdpdGhQcmVjaXNpb24oMClcbiAgICB2aWRlb0VsLnN0eWxlLmxlZnQgPSB3aXRoUHJlY2lzaW9uKDApXG4gICAgdmlkZW9FbC5zdHlsZS53aWR0aCA9IHdpdGhQcmVjaXNpb24ocGxhdGZvcm1TZXR0aW5nc1dpZHRoKVxuICAgIHZpZGVvRWwuc3R5bGUuaGVpZ2h0ID0gd2l0aFByZWNpc2lvbihwbGF0Zm9ybVNldHRpbmdzSGVpZ2h0KVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodmlkZW9FbClcbiAgICByZXR1cm4gdmlkZW9FbFxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXRVcFZpZGVvVGV4dHVyZSA9ICgpID0+IHtcbiAgaWYgKCFBcHBsaWNhdGlvbkluc3RhbmNlLnRhZygnVmlkZW9UZXh0dXJlJykpIHtcbiAgICBjb25zdCBlbCA9IEFwcGxpY2F0aW9uSW5zdGFuY2Uuc3RhZ2UuYyh7XG4gICAgICB0eXBlOiBWaWRlb1RleHR1cmUsXG4gICAgICByZWY6ICdWaWRlb1RleHR1cmUnLFxuICAgICAgekluZGV4OiAwLFxuICAgICAgdmlkZW9FbCxcbiAgICB9KVxuICAgIEFwcGxpY2F0aW9uSW5zdGFuY2UuY2hpbGRMaXN0LmFkZEF0KGVsLCAwKVxuICB9XG4gIHJldHVybiBBcHBsaWNhdGlvbkluc3RhbmNlLnRhZygnVmlkZW9UZXh0dXJlJylcbn1cblxuY29uc3QgcmVnaXN0ZXJFdmVudExpc3RlbmVycyA9ICgpID0+IHtcbiAgTG9nLmluZm8oJ1ZpZGVvUGxheWVyJywgJ1JlZ2lzdGVyaW5nIGV2ZW50IGxpc3RlbmVycycpXG4gIE9iamVjdC5rZXlzKGV2ZW50cykuZm9yRWFjaChldmVudCA9PiB7XG4gICAgY29uc3QgaGFuZGxlciA9IGUgPT4ge1xuICAgICAgLy8gRmlyZSBhIG1ldHJpYyBmb3IgZWFjaCBldmVudCAoaWYgaXQgZXhpc3RzIG9uIHRoZSBtZXRyaWNzIG9iamVjdClcbiAgICAgIGlmIChtZXRyaWNzICYmIG1ldHJpY3NbZXZlbnRdICYmIHR5cGVvZiBtZXRyaWNzW2V2ZW50XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtZXRyaWNzW2V2ZW50XSh7IGN1cnJlbnRUaW1lOiB2aWRlb0VsLmN1cnJlbnRUaW1lIH0pXG4gICAgICB9XG4gICAgICAvLyBmaXJlIGFuIGludGVybmFsIGhvb2tcbiAgICAgIGZpcmVIb29rKGV2ZW50LCB7IHZpZGVvRWxlbWVudDogdmlkZW9FbCwgZXZlbnQ6IGUgfSlcblxuICAgICAgLy8gZmlyZSB0aGUgZXZlbnQgKHdpdGggaHVtYW4gZnJpZW5kbHkgZXZlbnQgbmFtZSkgdG8gdGhlIGNvbnN1bWVyIG9mIHRoZSBWaWRlb1BsYXllclxuICAgICAgZmlyZU9uQ29uc3VtZXIoZXZlbnRzW2V2ZW50XSwgeyB2aWRlb0VsZW1lbnQ6IHZpZGVvRWwsIGV2ZW50OiBlIH0pXG4gICAgfVxuXG4gICAgZXZlbnRIYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyXG4gICAgdmlkZW9FbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKVxuICB9KVxufVxuXG5jb25zdCBkZXJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gIExvZy5pbmZvKCdWaWRlb1BsYXllcicsICdEZXJlZ2lzdGVyaW5nIGV2ZW50IGxpc3RlbmVycycpXG4gIE9iamVjdC5rZXlzKGV2ZW50SGFuZGxlcnMpLmZvckVhY2goZXZlbnQgPT4ge1xuICAgIHZpZGVvRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZXZlbnRIYW5kbGVyc1tldmVudF0pXG4gIH0pXG4gIGV2ZW50SGFuZGxlcnMgPSB7fVxufVxuXG5jb25zdCB2aWRlb1BsYXllclBsdWdpbiA9IHtcbiAgY29uc3VtZXIoY29tcG9uZW50KSB7XG4gICAgY29uc3VtZXIgPSBjb21wb25lbnRcbiAgfSxcblxuICBsb2FkZXIobG9hZGVyRm4pIHtcbiAgICBjdXN0b21Mb2FkZXIgPSBsb2FkZXJGblxuICB9LFxuXG4gIHVubG9hZGVyKHVubG9hZGVyRm4pIHtcbiAgICBjdXN0b21VbmxvYWRlciA9IHVubG9hZGVyRm5cbiAgfSxcblxuICBwb3NpdGlvbih0b3AgPSAwLCBsZWZ0ID0gMCkge1xuICAgIHZpZGVvRWwuc3R5bGUubGVmdCA9IHdpdGhQcmVjaXNpb24obGVmdClcbiAgICB2aWRlb0VsLnN0eWxlLnRvcCA9IHdpdGhQcmVjaXNpb24odG9wKVxuICAgIGlmICh0ZXh0dXJlTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgdmlkZW9UZXh0dXJlLnBvc2l0aW9uKHRvcCwgbGVmdClcbiAgICB9XG4gIH0sXG5cbiAgc2l6ZSh3aWR0aCA9IDE5MjAsIGhlaWdodCA9IDEwODApIHtcbiAgICB2aWRlb0VsLnN0eWxlLndpZHRoID0gd2l0aFByZWNpc2lvbih3aWR0aClcbiAgICB2aWRlb0VsLnN0eWxlLmhlaWdodCA9IHdpdGhQcmVjaXNpb24oaGVpZ2h0KVxuICAgIHZpZGVvRWwud2lkdGggPSBwYXJzZUZsb2F0KHZpZGVvRWwuc3R5bGUud2lkdGgpXG4gICAgdmlkZW9FbC5oZWlnaHQgPSBwYXJzZUZsb2F0KHZpZGVvRWwuc3R5bGUuaGVpZ2h0KVxuICAgIGlmICh0ZXh0dXJlTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgdmlkZW9UZXh0dXJlLnNpemUod2lkdGgsIGhlaWdodClcbiAgICB9XG4gIH0sXG5cbiAgYXJlYSh0b3AgPSAwLCByaWdodCA9IDE5MjAsIGJvdHRvbSA9IDEwODAsIGxlZnQgPSAwKSB7XG4gICAgdGhpcy5wb3NpdGlvbih0b3AsIGxlZnQpXG4gICAgdGhpcy5zaXplKHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKVxuICB9LFxuXG4gIG9wZW4odXJsLCBjb25maWcgPSB7fSkge1xuICAgIGlmICghdGhpcy5jYW5JbnRlcmFjdCkgcmV0dXJuXG4gICAgbWV0cmljcyA9IE1ldHJpY3MubWVkaWEodXJsKVxuXG4gICAgdGhpcy5oaWRlKClcbiAgICBkZXJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKVxuXG4gICAgaWYgKHRoaXMuc3JjID09IHVybCkge1xuICAgICAgdGhpcy5jbGVhcigpLnRoZW4odGhpcy5vcGVuKHVybCwgY29uZmlnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWRDb25maWcgPSB7IGVuYWJsZWQ6IHN0YXRlLmFkc0VuYWJsZWQsIGR1cmF0aW9uOiAzMDAgfVxuICAgICAgaWYgKGNvbmZpZy52aWRlb0lkKSB7XG4gICAgICAgIGFkQ29uZmlnLmNhaWQgPSBjb25maWcudmlkZW9JZFxuICAgICAgfVxuICAgICAgQWRzLmdldChhZENvbmZpZywgY29uc3VtZXIpLnRoZW4oYWRzID0+IHtcbiAgICAgICAgc3RhdGUucGxheWluZ0FkcyA9IHRydWVcbiAgICAgICAgYWRzLnByZXJvbGxzKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgc3RhdGUucGxheWluZ0FkcyA9IGZhbHNlXG4gICAgICAgICAgbG9hZGVyKHVybCwgdmlkZW9FbCwgY29uZmlnKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICByZWdpc3RlckV2ZW50TGlzdGVuZXJzKClcbiAgICAgICAgICAgICAgdGhpcy5zaG93KClcbiAgICAgICAgICAgICAgdGhpcy5wbGF5KClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAgIGZpcmVPbkNvbnN1bWVyKCdlcnJvcicsIHsgdmlkZW9FbGVtZW50OiB2aWRlb0VsLCBldmVudDogZSB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIHJlbG9hZCgpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIGNvbnN0IHVybCA9IHZpZGVvRWwuZ2V0QXR0cmlidXRlKCdzcmMnKVxuICAgIHRoaXMuY2xvc2UoKVxuICAgIHRoaXMub3Blbih1cmwpXG4gIH0sXG5cbiAgY2xvc2UoKSB7XG4gICAgQWRzLmNhbmNlbCgpXG4gICAgaWYgKHN0YXRlLnBsYXlpbmdBZHMpIHtcbiAgICAgIHN0YXRlLnBsYXlpbmdBZHMgPSBmYWxzZVxuICAgICAgQWRzLnN0b3AoKVxuICAgICAgLy8gY2FsbCBzZWxmIGluIG5leHQgdGlja1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNhbkludGVyYWN0KSByZXR1cm5cbiAgICB0aGlzLmNsZWFyKClcbiAgICB0aGlzLmhpZGUoKVxuICAgIGRlcmVnaXN0ZXJFdmVudExpc3RlbmVycygpXG4gIH0sXG5cbiAgY2xlYXIoKSB7XG4gICAgaWYgKCF0aGlzLmNhbkludGVyYWN0KSByZXR1cm5cbiAgICAvLyBwYXVzZSB0aGUgdmlkZW8gZmlyc3QgdG8gZGlzYWJsZSBzb3VuZFxuICAgIHRoaXMucGF1c2UoKVxuICAgIGlmICh0ZXh0dXJlTW9kZSA9PT0gdHJ1ZSkgdmlkZW9UZXh0dXJlLnN0b3AoKVxuICAgIHJldHVybiB1bmxvYWRlcih2aWRlb0VsKS50aGVuKCgpID0+IHtcbiAgICAgIGZpcmVPbkNvbnN1bWVyKCdDbGVhcicsIHsgdmlkZW9FbGVtZW50OiB2aWRlb0VsIH0pXG4gICAgfSlcbiAgfSxcblxuICBwbGF5KCkge1xuICAgIGlmICghdGhpcy5jYW5JbnRlcmFjdCkgcmV0dXJuXG4gICAgaWYgKHRleHR1cmVNb2RlID09PSB0cnVlKSB2aWRlb1RleHR1cmUuc3RhcnQoKVxuICAgIGV4ZWN1dGVBc1Byb21pc2UodmlkZW9FbC5wbGF5LCBudWxsLCB2aWRlb0VsKS5jYXRjaChlID0+IHtcbiAgICAgIGZpcmVPbkNvbnN1bWVyKCdlcnJvcicsIHsgdmlkZW9FbGVtZW50OiB2aWRlb0VsLCBldmVudDogZSB9KVxuICAgIH0pXG4gIH0sXG5cbiAgcGF1c2UoKSB7XG4gICAgaWYgKCF0aGlzLmNhbkludGVyYWN0KSByZXR1cm5cbiAgICB2aWRlb0VsLnBhdXNlKClcbiAgfSxcblxuICBwbGF5UGF1c2UoKSB7XG4gICAgaWYgKCF0aGlzLmNhbkludGVyYWN0KSByZXR1cm5cbiAgICB0aGlzLnBsYXlpbmcgPT09IHRydWUgPyB0aGlzLnBhdXNlKCkgOiB0aGlzLnBsYXkoKVxuICB9LFxuXG4gIG11dGUobXV0ZWQgPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLmNhbkludGVyYWN0KSByZXR1cm5cbiAgICB2aWRlb0VsLm11dGVkID0gbXV0ZWRcbiAgfSxcblxuICBsb29wKGxvb3BlZCA9IHRydWUpIHtcbiAgICB2aWRlb0VsLmxvb3AgPSBsb29wZWRcbiAgfSxcblxuICBzZWVrKHRpbWUpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIGlmICghdGhpcy5zcmMpIHJldHVyblxuICAgIC8vIGRlZmluZSB3aGV0aGVyIHNob3VsZCBjb250aW51ZSB0byBwbGF5IGFmdGVyIHNlZWsgaXMgY29tcGxldGUgKGluIHNlZWtlZCBob29rKVxuICAgIGlmIChzdGF0ZS5wbGF5QWZ0ZXJTZWVrID09PSBudWxsKSB7XG4gICAgICBzdGF0ZS5wbGF5QWZ0ZXJTZWVrID0gISFzdGF0ZS5wbGF5aW5nXG4gICAgfVxuICAgIC8vIHBhdXNlIGJlZm9yZSBhY3R1YWxseSBzZWVraW5nXG4gICAgdGhpcy5wYXVzZSgpXG4gICAgLy8gY3VycmVudFRpbWUgYWx3YXlzIGJldHdlZW4gMCBhbmQgdGhlIGR1cmF0aW9uIG9mIHRoZSB2aWRlbyAobWludXMgMC4xcyB0byBub3Qgc2V0IHRvIHRoZSBmaW5hbCBmcmFtZSBhbmQgc3RhbGwgdGhlIHZpZGVvKVxuICAgIHZpZGVvRWwuY3VycmVudFRpbWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aW1lLCB0aGlzLmR1cmF0aW9uIC0gMC4xKSlcbiAgfSxcblxuICBza2lwKHNlY29uZHMpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIGlmICghdGhpcy5zcmMpIHJldHVyblxuXG4gICAgc3RhdGUuc2tpcFRpbWUgPSAoc3RhdGUuc2tpcFRpbWUgfHwgdmlkZW9FbC5jdXJyZW50VGltZSkgKyBzZWNvbmRzXG4gICAgZWFzZUV4ZWN1dGlvbigoKSA9PiB7XG4gICAgICB0aGlzLnNlZWsoc3RhdGUuc2tpcFRpbWUpXG4gICAgICBzdGF0ZS5za2lwVGltZSA9IGZhbHNlXG4gICAgfSwgMzAwKVxuICB9LFxuXG4gIHNob3coKSB7XG4gICAgaWYgKCF0aGlzLmNhbkludGVyYWN0KSByZXR1cm5cbiAgICBpZiAodGV4dHVyZU1vZGUgPT09IHRydWUpIHtcbiAgICAgIHZpZGVvVGV4dHVyZS5zaG93KClcbiAgICB9IGVsc2Uge1xuICAgICAgdmlkZW9FbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgdmlkZW9FbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgfVxuICB9LFxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLmNhbkludGVyYWN0KSByZXR1cm5cbiAgICBpZiAodGV4dHVyZU1vZGUgPT09IHRydWUpIHtcbiAgICAgIHZpZGVvVGV4dHVyZS5oaWRlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdmlkZW9FbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICB2aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgIH1cbiAgfSxcblxuICBlbmFibGVBZHMoZW5hYmxlZCA9IHRydWUpIHtcbiAgICBzdGF0ZS5hZHNFbmFibGVkID0gZW5hYmxlZFxuICB9LFxuXG4gIC8qIFB1YmxpYyBnZXR0ZXJzICovXG4gIGdldCBkdXJhdGlvbigpIHtcbiAgICByZXR1cm4gdmlkZW9FbCAmJiAoaXNOYU4odmlkZW9FbC5kdXJhdGlvbikgPyBJbmZpbml0eSA6IHZpZGVvRWwuZHVyYXRpb24pXG4gIH0sXG5cbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIHJldHVybiB2aWRlb0VsICYmIHZpZGVvRWwuY3VycmVudFRpbWVcbiAgfSxcblxuICBnZXQgbXV0ZWQoKSB7XG4gICAgcmV0dXJuIHZpZGVvRWwgJiYgdmlkZW9FbC5tdXRlZFxuICB9LFxuXG4gIGdldCBsb29wZWQoKSB7XG4gICAgcmV0dXJuIHZpZGVvRWwgJiYgdmlkZW9FbC5sb29wXG4gIH0sXG5cbiAgZ2V0IHNyYygpIHtcbiAgICByZXR1cm4gdmlkZW9FbCAmJiB2aWRlb0VsLmdldEF0dHJpYnV0ZSgnc3JjJylcbiAgfSxcblxuICBnZXQgcGxheWluZygpIHtcbiAgICByZXR1cm4gc3RhdGUucGxheWluZ1xuICB9LFxuXG4gIGdldCBwbGF5aW5nQWRzKCkge1xuICAgIHJldHVybiBzdGF0ZS5wbGF5aW5nQWRzXG4gIH0sXG5cbiAgZ2V0IGNhbkludGVyYWN0KCkge1xuICAgIC8vIHRvZG86IHBlcmhhcHMgYWRkIGFuIGV4dHJhIGZsYWcgd2V0aGVyIHdlIGFsbG93IGludGVyYWN0aW9ucyAoaS5lLiBwYXV6ZSwgbXV0ZSwgZXRjLikgZHVyaW5nIGFkIHBsYXliYWNrXG4gICAgcmV0dXJuIHN0YXRlLnBsYXlpbmdBZHMgPT09IGZhbHNlXG4gIH0sXG5cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdmlkZW9FbCAmJiBwYXJzZUZsb2F0KHZpZGVvRWwuc3R5bGUudG9wKVxuICB9LFxuXG4gIGdldCBsZWZ0KCkge1xuICAgIHJldHVybiB2aWRlb0VsICYmIHBhcnNlRmxvYXQodmlkZW9FbC5zdHlsZS5sZWZ0KVxuICB9LFxuXG4gIGdldCBib3R0b20oKSB7XG4gICAgcmV0dXJuIHZpZGVvRWwgJiYgcGFyc2VGbG9hdCh2aWRlb0VsLnN0eWxlLnRvcCAtIHZpZGVvRWwuc3R5bGUuaGVpZ2h0KVxuICB9LFxuXG4gIGdldCByaWdodCgpIHtcbiAgICByZXR1cm4gdmlkZW9FbCAmJiBwYXJzZUZsb2F0KHZpZGVvRWwuc3R5bGUubGVmdCAtIHZpZGVvRWwuc3R5bGUud2lkdGgpXG4gIH0sXG5cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB2aWRlb0VsICYmIHBhcnNlRmxvYXQodmlkZW9FbC5zdHlsZS53aWR0aClcbiAgfSxcblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB2aWRlb0VsICYmIHBhcnNlRmxvYXQodmlkZW9FbC5zdHlsZS5oZWlnaHQpXG4gIH0sXG5cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgaWYgKHRleHR1cmVNb2RlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdmlkZW9UZXh0dXJlLmlzVmlzaWJsZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlkZW9FbCAmJiB2aWRlb0VsLnN0eWxlLmRpc3BsYXkgPT09ICdibG9jaydcbiAgICB9XG4gIH0sXG5cbiAgZ2V0IGFkc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHN0YXRlLmFkc0VuYWJsZWRcbiAgfSxcblxuICAvLyBwcmVmaXhlZCB3aXRoIHVuZGVyc2NvcmUgdG8gaW5kaWNhdGUgJ3NlbWktcHJpdmF0ZSdcbiAgLy8gYmVjYXVzZSBpdCdzIG5vdCByZWNvbW1lbmRlZCB0byBpbnRlcmFjdCBkaXJlY3RseSB3aXRoIHRoZSB2aWRlbyBlbGVtZW50XG4gIGdldCBfdmlkZW9FbCgpIHtcbiAgICByZXR1cm4gdmlkZW9FbFxuICB9LFxuXG4gIGdldCBfY29uc3VtZXIoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWVyXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGF1dG9TZXR1cE1peGluKHZpZGVvUGxheWVyUGx1Z2luLCAoKSA9PiB7XG4gIHByZWNpc2lvbiA9XG4gICAgKEFwcGxpY2F0aW9uSW5zdGFuY2UgJiZcbiAgICAgIEFwcGxpY2F0aW9uSW5zdGFuY2Uuc3RhZ2UgJiZcbiAgICAgIEFwcGxpY2F0aW9uSW5zdGFuY2Uuc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKCkpIHx8XG4gICAgcHJlY2lzaW9uXG5cbiAgdmlkZW9FbCA9IHNldHVwVmlkZW9UYWcoKVxuXG4gIHRleHR1cmVNb2RlID0gU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICd0ZXh0dXJlTW9kZScsIGZhbHNlKVxuICBpZiAodGV4dHVyZU1vZGUgPT09IHRydWUpIHtcbiAgICB2aWRlb0VsLnNldEF0dHJpYnV0ZSgnY3Jvc3NvcmlnaW4nLCAnYW5vbnltb3VzJylcbiAgICB2aWRlb1RleHR1cmUgPSBzZXRVcFZpZGVvVGV4dHVyZSgpXG4gIH1cbn0pXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCAoc291cmNlT2JqZWN0LCBzZXR1cCA9ICgpID0+IHt9KSA9PiB7XG4gIGxldCByZWFkeSA9IGZhbHNlXG5cbiAgY29uc3QgZG9TZXR1cCA9ICgpID0+IHtcbiAgICBpZiAocmVhZHkgPT09IGZhbHNlKSB7XG4gICAgICBzZXR1cCgpXG4gICAgICByZWFkeSA9IHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlT2JqZWN0KS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VPYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb2JqW2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9TZXR1cCgpXG4gICAgICAgIHJldHVybiBzb3VyY2VPYmplY3Rba2V5XS5hcHBseShzb3VyY2VPYmplY3QsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZU9iamVjdCwga2V5KS5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9iai5fX2RlZmluZUdldHRlcl9fKGtleSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvU2V0dXAoKVxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VPYmplY3QsIGtleSkuZ2V0LmFwcGx5KHNvdXJjZU9iamVjdClcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VPYmplY3QsIGtleSkuc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvYmouX19kZWZpbmVTZXR0ZXJfXyhrZXksIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb1NldHVwKClcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlT2JqZWN0LCBrZXkpLnNldC5zb3VyY2VPYmplY3Rba2V5XS5hcHBseShcbiAgICAgICAgICBzb3VyY2VPYmplY3QsXG4gICAgICAgICAgYXJndW1lbnRzXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gc291cmNlT2JqZWN0W2tleV1cbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9LCB7fSlcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmxldCB0aW1lb3V0ID0gbnVsbFxuXG5leHBvcnQgZGVmYXVsdCAoY2IsIGRlbGF5KSA9PiB7XG4gIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY2IoKVxuICB9LCBkZWxheSlcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IHN0ZXBzID0+IHtcbiAgcmV0dXJuIHN0ZXBzLnJlZHVjZSgocHJvbWlzZSwgbWV0aG9kKSA9PiB7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbWV0aG9kKC4uLmFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZSA9PiBQcm9taXNlLnJlamVjdChlKSlcbiAgfSwgUHJvbWlzZS5yZXNvbHZlKG51bGwpKVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgKG1ldGhvZCwgYXJncyA9IG51bGwsIGNvbnRleHQgPSBudWxsKSA9PiB7XG4gIGxldCByZXN1bHRcbiAgaWYgKG1ldGhvZCAmJiB0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlc3VsdCA9IGVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gbWV0aG9kXG4gIH1cblxuICAvLyBpZiBpdCBsb29rcyBsaWtlIGEgZHVjayAuLiBlaG0gLi4uIHByb21pc2UgYW5kIHRhbGtzIGxpa2UgYSBwcm9taXNlLCBsZXQncyBhc3N1bWUgaXQncyBhIHByb21pc2VcbiAgaWYgKFxuICAgIHJlc3VsdCAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmXG4gICAgcmVzdWx0LnRoZW4gJiZcbiAgICB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG4gIC8vIG90aGVyd2lzZSBtYWtlIGl0IGludG8gYSBwcm9taXNlXG4gIGVsc2Uge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KHJlc3VsdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzTWVyZ2VhYmxlT2JqZWN0ID0gZnVuY3Rpb24gaXNNZXJnZWFibGVPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSlcblx0XHQmJiAhaXNTcGVjaWFsKHZhbHVlKVxufTtcblxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuZnVuY3Rpb24gaXNTcGVjaWFsKHZhbHVlKSB7XG5cdHZhciBzdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cblx0cmV0dXJuIHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBSZWdFeHBdJ1xuXHRcdHx8IHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXSdcblx0XHR8fCBpc1JlYWN0RWxlbWVudCh2YWx1ZSlcbn1cblxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I1YWM5NjNmYjc5MWQxMjk4ZTdmMzk2MjM2MzgzYmM5NTVmOTE2YzEvc3JjL2lzb21vcnBoaWMvY2xhc3NpYy9lbGVtZW50L1JlYWN0RWxlbWVudC5qcyNMMjEtTDI1XG52YXIgY2FuVXNlU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGNhblVzZVN5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcblxuZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbn1cblxuZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9XG59XG5cbmZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zKSB7XG5cdHJldHVybiAob3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkpXG5cdFx0PyBkZWVwbWVyZ2UoZW1wdHlUYXJnZXQodmFsdWUpLCB2YWx1ZSwgb3B0aW9ucylcblx0XHQ6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRBcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9ucylcblx0fSlcbn1cblxuZnVuY3Rpb24gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcblx0aWYgKCFvcHRpb25zLmN1c3RvbU1lcmdlKSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZVxuXHR9XG5cdHZhciBjdXN0b21NZXJnZSA9IG9wdGlvbnMuY3VzdG9tTWVyZ2Uoa2V5KTtcblx0cmV0dXJuIHR5cGVvZiBjdXN0b21NZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1lcmdlIDogZGVlcG1lcmdlXG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdFx0PyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5wcm9wZXJ0eUlzRW51bWVyYWJsZShzeW1ib2wpXG5cdFx0fSlcblx0XHQ6IFtdXG59XG5cbmZ1bmN0aW9uIGdldEtleXModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpLmNvbmNhdChnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpXG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5SXNPbk9iamVjdChvYmplY3QsIHByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHByb3BlcnR5IGluIG9iamVjdFxuXHR9IGNhdGNoKF8pIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG4vLyBQcm90ZWN0cyBmcm9tIHByb3RvdHlwZSBwb2lzb25pbmcgYW5kIHVuZXhwZWN0ZWQgbWVyZ2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluLlxuZnVuY3Rpb24gcHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkge1xuXHRyZXR1cm4gcHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAvLyBQcm9wZXJ0aWVzIGFyZSBzYWZlIHRvIG1lcmdlIGlmIHRoZXkgZG9uJ3QgZXhpc3QgaW4gdGhlIHRhcmdldCB5ZXQsXG5cdFx0JiYgIShPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkgLy8gdW5zYWZlIGlmIHRoZXkgZXhpc3QgdXAgdGhlIHByb3RvdHlwZSBjaGFpbixcblx0XHRcdCYmIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwga2V5KSkgLy8gYW5kIGFsc28gdW5zYWZlIGlmIHRoZXkncmUgbm9uZW51bWVyYWJsZS5cbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0dmFyIGRlc3RpbmF0aW9uID0ge307XG5cdGlmIChvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcblx0XHRnZXRLZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh0YXJnZXRba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH1cblx0Z2V0S2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHRpZiAocHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5mdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXJyYXlNZXJnZSA9IG9wdGlvbnMuYXJyYXlNZXJnZSB8fCBkZWZhdWx0QXJyYXlNZXJnZTtcblx0b3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCA9IG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgfHwgaXNNZXJnZWFibGVPYmplY3Q7XG5cdC8vIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIGlzIGFkZGVkIHRvIGBvcHRpb25zYCBzbyB0aGF0IGN1c3RvbSBhcnJheU1lcmdlKClcblx0Ly8gaW1wbGVtZW50YXRpb25zIGNhbiB1c2UgaXQuIFRoZSBjYWxsZXIgbWF5IG5vdCByZXBsYWNlIGl0LlxuXHRvcHRpb25zLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQ7XG5cblx0dmFyIHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG5cdHZhciB0YXJnZXRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuXHR2YXIgc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCA9IHNvdXJjZUlzQXJyYXkgPT09IHRhcmdldElzQXJyYXk7XG5cblx0aWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH1cbn1cblxuZGVlcG1lcmdlLmFsbCA9IGZ1bmN0aW9uIGRlZXBtZXJnZUFsbChhcnJheSwgb3B0aW9ucykge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXknKVxuXHR9XG5cblx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZShwcmV2LCBuZXh0LCBvcHRpb25zKVxuXHR9LCB7fSlcbn07XG5cbnZhciBkZWVwbWVyZ2VfMSA9IGRlZXBtZXJnZTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwbWVyZ2VfMTtcbiIsImNsYXNzIGxvY2FsQ29va2lle2NvbnN0cnVjdG9yKGUpe3JldHVybiBlPWV8fHt9LHRoaXMuZm9yY2VDb29raWVzPWUuZm9yY2VDb29raWVzfHwhMSwhMD09PXRoaXMuX2NoZWNrSWZMb2NhbFN0b3JhZ2VXb3JrcygpJiYhMCE9PWUuZm9yY2VDb29raWVzP3tnZXRJdGVtOnRoaXMuX2dldEl0ZW1Mb2NhbFN0b3JhZ2Usc2V0SXRlbTp0aGlzLl9zZXRJdGVtTG9jYWxTdG9yYWdlLHJlbW92ZUl0ZW06dGhpcy5fcmVtb3ZlSXRlbUxvY2FsU3RvcmFnZSxjbGVhcjp0aGlzLl9jbGVhckxvY2FsU3RvcmFnZX06e2dldEl0ZW06dGhpcy5fZ2V0SXRlbUNvb2tpZSxzZXRJdGVtOnRoaXMuX3NldEl0ZW1Db29raWUscmVtb3ZlSXRlbTp0aGlzLl9yZW1vdmVJdGVtQ29va2llLGNsZWFyOnRoaXMuX2NsZWFyQ29va2llc319X2NoZWNrSWZMb2NhbFN0b3JhZ2VXb3Jrcygpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBsb2NhbFN0b3JhZ2UpcmV0dXJuITE7dHJ5e3JldHVybiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImZlYXR1cmVfdGVzdFwiLFwieWVzXCIpLFwieWVzXCI9PT1sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImZlYXR1cmVfdGVzdFwiKSYmKGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwiZmVhdHVyZV90ZXN0XCIpLCEwKX1jYXRjaChlKXtyZXR1cm4hMX19X2dldEl0ZW1Mb2NhbFN0b3JhZ2UoZSl7cmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShlKX1fc2V0SXRlbUxvY2FsU3RvcmFnZShlLHQpe3JldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oZSx0KX1fcmVtb3ZlSXRlbUxvY2FsU3RvcmFnZShlKXtyZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGUpfV9jbGVhckxvY2FsU3RvcmFnZSgpe3JldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLmNsZWFyKCl9X2dldEl0ZW1Db29raWUoZSl7dmFyIHQ9ZG9jdW1lbnQuY29va2llLm1hdGNoKFJlZ0V4cChcIig/Ol58O1xcXFxzKilcIitmdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKC8oWy4qKz9cXF4ke30oKXxcXFtcXF1cXC9cXFxcXSkvZyxcIlxcXFwkMVwiKX0oZSkrXCI9KFteO10qKVwiKSk7cmV0dXJuIHQmJlwiXCI9PT10WzFdJiYodFsxXT1udWxsKSx0P3RbMV06bnVsbH1fc2V0SXRlbUNvb2tpZShlLHQpe3ZhciBvPW5ldyBEYXRlLHI9bmV3IERhdGUoby5nZXRUaW1lKCkrMTU3NjhlNyk7ZG9jdW1lbnQuY29va2llPWAke2V9PSR7dH07IGV4cGlyZXM9JHtyLnRvVVRDU3RyaW5nKCl9O2B9X3JlbW92ZUl0ZW1Db29raWUoZSl7ZG9jdW1lbnQuY29va2llPWAke2V9PTtNYXgtQWdlPS05OTk5OTk5OTtgfV9jbGVhckNvb2tpZXMoKXtkb2N1bWVudC5jb29raWUuc3BsaXQoXCI7XCIpLmZvckVhY2goZT0+e2RvY3VtZW50LmNvb2tpZT1lLnJlcGxhY2UoL14gKy8sXCJcIikucmVwbGFjZSgvPS4qLyxcIj07ZXhwaXJlcz1NYXgtQWdlPS05OTk5OTk5OVwiKX0pfX1leHBvcnQgZGVmYXVsdCBsb2NhbENvb2tpZTtcbiIsImltcG9ydCB7IExpZ2h0bmluZywgVXRpbHMsIExvZyB9IGZyb20gXCJAbGlnaHRuaW5nanMvc2RrXCI7XG5pbXBvcnQgeyBEZXZpY2UsIExvY2FsaXphdGlvbixNZXRyaWNzIH0gZnJvbSBcIkBmaXJlYm9sdC1qcy9zZGtcIjtcbi8vaW1wb3J0IHsgV2lmaSB9IGZyb20gJ0BmaXJlYm9sdC1qcy9tYW5hZ2Utc2RrJztcbi8vaW1wb3J0IHtCdXR0b259IGZyb20gJy4vYnV0dG9uLmpzJztcbmltcG9ydCB7IE15QnV0dG9uIH0gZnJvbSBcIi4vTXlCdXR0b25cIjtcbmltcG9ydCB7IEJsYWNrQWRhbSB9IGZyb20gXCIuL0JsYWNrQWRhbVwiO1xuXG4vLyBjb25zdCBMaWZlY3ljbGVDb2xvcnMgPSB7XG4vLyAgIC8vIEJMVUVcbi8vICAgQk9PVDogXCIweGZmMDAwMGZmXCIsXG4vLyAgIC8vIFJFRFxuLy8gICBJTkFDVElWRTogXCIweGZmZmYwMDAwXCIsXG4vLyAgIC8vIE9SQU5HRVxuLy8gICBCQUNLR1JPVU5EOiBcIjB4ZmZFNjk3MzhcIixcbi8vICAgLy8gR1JFRU5cbi8vICAgRk9SRUdST1VORDogXCIweGZmMDBhYTAwXCIsXG4vLyB9O1xuXG5leHBvcnQgIGNsYXNzIEFwcCBleHRlbmRzIExpZ2h0bmluZy5Db21wb25lbnQge1xuICBzdGF0aWMgZ2V0Rm9udHMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgZmFtaWx5OiBcIlJlZ3VsYXJcIiwgdXJsOiBVdGlscy5hc3NldChcImZvbnRzL1JvYm90by1SZWd1bGFyLnR0ZlwiKSB9LFxuICAgIF07XG4gIH1cblxuICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcblxuICAgICAgSGVsbG9Xb3JsZDoge1xuICAgICAgICB3OiAxOTIwLFxuICAgICAgICBoOiAxMDgwLFxuICAgICAgICB5OiAwLFxuICAgICAgICByZWN0OiB0cnVlLFxuICAgICAgICBjb2xvcjogMHhmZmZmZmZmZixcbiAgICAgICAgRmlyZWJvbHRTdGF0dXM6IHtcbiAgICAgICAgICAvLyBMaWZlY3ljbGU6IHtcbiAgICAgICAgICAvLyAgIG1vdW50WDogMC41LFxuICAgICAgICAgIC8vICAgeDogOTYwLFxuICAgICAgICAgIC8vICAgeTogMTAwLFxuICAgICAgICAgIC8vICAgdGV4dDoge1xuICAgICAgICAgIC8vICAgICB0ZXh0OiBcIkxpZmVjeWNsZSBub3QgUmVhZHkhXCIsXG4gICAgICAgICAgLy8gICAgIGZvbnRGYWNlOiBcIlJlZ3VsYXJcIixcbiAgICAgICAgICAvLyAgICAgZm9udFNpemU6IDUwLFxuICAgICAgICAgIC8vICAgfSxcbiAgICAgICAgICAvLyB9LFxuICAgICAgICAgIFJka2xvZ286IHtcbiAgICAgICAgICAgIHg6IDMwLFxuICAgICAgICAgICAgeTogNDAsXG4gICAgICAgICAgICB3OiAzMDAsXG4gICAgICAgICAgICBoOiA4MCxcbiAgICAgICAgICAgIHNoYWRvd0NvbG9yOiAweGZmZmYwMGZmLFxuICAgICAgICAgICAgc3JjOiBVdGlscy5hc3NldChcImltYWdlcy9yZGtsb2dvLnBuZ1wiKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIEFsZXhhbG9nbzoge1xuICAgICAgICAgICAgeDogMTIwMCxcbiAgICAgICAgICAgIHk6IDUsXG4gICAgICAgICAgICB3OiAxNTAsXG4gICAgICAgICAgICBoOiAxNTAsXG4gICAgICAgICAgICBzcmM6IFV0aWxzLmFzc2V0KFwiaW1hZ2VzL2FsZXhhLnBuZ1wiKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFNldHRsb2dvOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMTcwLFxuICAgICAgICAgICAgdzogMTkyMCxcbiAgICAgICAgICAgIGg6IDcwMCxcbiAgICAgICAgICAgIHNyYzogVXRpbHMuYXNzZXQoXCJpbWFnZXMvYmlnLmpwZ1wiKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIEJlbGxsb2dvOiB7XG4gICAgICAgICAgICB4OiAxNDAwLFxuICAgICAgICAgICAgeTogMjAsXG4gICAgICAgICAgICB3OiAxMDAsXG4gICAgICAgICAgICBoOiAxMDAsXG4gICAgICAgICAgICBzcmM6IFV0aWxzLmFzc2V0KFwiaW1hZ2VzL3NldHRpbmcucG5nXCIpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgTm90aWZpbG9nbzoge1xuICAgICAgICAgICAgeDogMTYwMCxcbiAgICAgICAgICAgIHk6IDIwLFxuICAgICAgICAgICAgdzogMTAwLFxuICAgICAgICAgICAgaDogMTAwLFxuICAgICAgICAgICAgc3JjOiBVdGlscy5hc3NldChcImltYWdlcy9ub3RpLnBuZ1wiKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIERldmljZToge1xuICAgICAgICAgICAgbW91bnRYOiAwLjUsXG4gICAgICAgICAgICB4OiA5NjAsXG4gICAgICAgICAgICB5OiA5MDAsXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgIHRleHQ6IFwiRGV2aWNlIG5vdCBSZWFkeSFcIixcblxuICAgICAgICAgICAgICBmb250RmFjZTogXCJSZWd1bGFyXCIsXG4gICAgICAgICAgICAgIGZvbnRTaXplOiAzNSxcbiAgICAgICAgICAgICAgdGV4dENvbG9yOiAweGZmMDAwMDAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIExvY2FsaXphdGlvbjoge1xuICAgICAgICAgICAgbW91bnRYOiAwLjUsXG4gICAgICAgICAgICB4OiA5NjAsXG4gICAgICAgICAgICB5OiA5NTAsXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgIHRleHQ6IFwibG9hY2xpemF0aW9uIEFQSSA9PT4gXCIsXG4gICAgICAgICAgICAgIGZvbnRGYWNlOiBcIlJlZ3VsYXJcIixcbiAgICAgICAgICAgICAgZm9udFNpemU6IDM1LFxuICAgICAgICAgICAgICB0ZXh0Q29sb3I6IDB4ZmYwMDAwMDAsXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBNZXRyaWNzOntcbiAgICAgICAgICBtb3VudFg6IDAuNSxcbiAgICAgICAgICB4OiA5NjAsXG4gICAgICAgICAgeTogMTAwMCxcbiAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICB0ZXh0OiBcIk1ldHJpY3MgQVBJID09PiBcIixcbiAgICAgICAgICAgIGZvbnRGYWNlOiBcIlJlZ3VsYXJcIixcbiAgICAgICAgICAgIGZvbnRTaXplOiAzNSxcbiAgICAgICAgICAgIHRleHRDb2xvcjogMHhmZjAwMDAwMCxcblxuICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgICAgUGxheWJ1dHRvbjoge1xuICAgICAgICAgIHR5cGU6IE15QnV0dG9uLFxuICAgICAgICAgIHg6IDE1MDAsXG4gICAgICAgICAgeTogNzcwLFxuICAgICAgICAgIHNpZ25hbHM6IHtcbiAgICAgICAgICAgIG9uQ2xpY2s6IFwiaGFuZGxlQnV0dG9uRW50ZXJcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICAvLyBDb21wbGV0ZToge1xuICAgICAgICAvLyBcdHZpc2libGU6dHJ1ZSwgbW91bnRYOjAuNSwgeDogOTYwLCB5OiA1MCxcbiAgICAgICAgLy8gXHR0ZXh0OiB7IHRleHQ6ICdGaXJlYm9sdCA+PiBIZWxsbyBXb3JsZCcsIGZvbnRGYWNlOiAnUmVndWxhcicsIGZvbnRTaXplOiA5MCB9LFxuICAgICAgICAvLyB9LFxuICAgICAgICAvL0J1dHRvbjoge21vdW50OiAwLjUsIHg6IDk2MCwgeToxNSwgdHlwZTogQnV0dG9uLCBsYWJlbDogJ0J1dHRvbid9LFxuICAgICAgfSxcbiAgICAgIFZpZGVvU2VjdGlvbjoge1xuICAgICAgICBhbHBoYTogMSxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdzogMTkyMCxcbiAgICAgICAgaDogMTA4MCxcbiAgICAgICAgY29sb3I6IFwiMHhmZjAwMDAwMFwiLFxuICAgICAgICByZWN0OiB0cnVlLFxuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgSGVscE1zZzoge1xuICAgICAgICAgIHg6IDgwLFxuICAgICAgICAgIHk6IDUwLFxuICAgICAgICAgIHc6IDE5MjAsXG4gICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgdGV4dDogXCJQbGF5IHRoZSBWaWRlbyB1c2luZyBBQU1QIFBsYXllclwiLFxuICAgICAgICAgICAgZm9udFNpemU6IDQwLFxuICAgICAgICAgICAgZm9udEZhY2U6IFwiUmVndWxhclwiLFxuICAgICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgbGluZUhlaWdodDogNTAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb2xvcjogXCIweGZmZmZmZmZmXCIsXG4gICAgICAgICAgYWxwaGE6IDEsXG4gICAgICAgIH0sXG4gICAgICAgIFZpZGVvOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHc6IDE5MjAsIC8vIFNldCB0byB5b3VyIGRlc2lyZWQgd2lkdGhcbiAgICAgICAgICBoOiAxMDgwLCAvLyBTZXQgdG8geW91ciBkZXNpcmVkIGhlaWdodFxuICAgICAgICAgIHR5cGU6IExpZ2h0bmluZy5jb21wb25lbnRzLlZpZGVvSXRlbSwgLy8gVXNlIHRoZSBhcHByb3ByaWF0ZSBMaWdodG5pbmcgdmlkZW9cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBTbGlkZXI6IHtcblxuICAgICAgICB3OiA4MDAsXG5cbiAgICAgICAgaDogMzUwLFxuXG4gICAgICAgIHg6IDQ4MCxcblxuICAgICAgICB5OiAzNTAsXG5cbiAgICAgICAgbW91bnQ6IDAuNSxcblxuICAgICAgICBXcmFwcGVyOiB7XG5cbiBcblxuICAgICAgICB9LFxuXG4gICAgICB9LFxuXG4gICAgICBMb2dvOiB7XG5cbiAgICAgICAgbW91bnQ6IDAuNSxcblxuICAgICAgICB3OiAxMjAsXG5cbiAgICAgICAgaDogNjAsXG5cbiAgICAgICAgeDogMTMwLFxuXG4gICAgICAgIHk6IDUwLFxuXG4gICAgICAgXG5cbiAgICAgIH0sXG5cbiAgICAgIEJsYWNrQWRhbToge1xuXG4gICAgICAgIG1vdW50OiAwLjUsXG5cbiAgICAgICAgeDogMTUwLFxuXG4gICAgICAgIHk6IDEzMCxcblxuICAgICAgICB0ZXh0OiB7XG5cbiAgICAgICAgICB0ZXh0OiBcIkV4cGxvcmVcIixcblxuICAgICAgICAgIGZvbnRGYWNlOiAnUmVndWxhcicsXG5cbiAgICAgICAgICBmb250U2l6ZTogMjUsXG5cbiAgICAgICAgICB0ZXh0Q29sb3I6IDB4ZmZmZmZmZmYsXG5cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfVxuICB9XG4gIF9nZXRGb2N1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLnRhZyhcIlBsYXlidXR0b25cIik7XG4gICAgXG5cbiAgfVxuXG4gIF9pbml0KCkge1xuICAgIHRoaXMuaW5kZXggPSAwO1xuXG4gICAgdGhpcy5kYXRhTGVuZ3RoID0gMztcblxuICAgIGNvbnN0IGJ1dHRvbnMgPSBbXTtcblxuIFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGFMZW5ndGg7IGkrKykge1xuXG4gICAgICBidXR0b25zLnB1c2goXG5cbiAgICAgICAgeyB0eXBlOiBCbGFja0FkYW0sIHg6IGkgKiAoMzAwICsgMzApLCBpdGVtOiB7IGxhYmVsOiBgVHJhaW5gLCBzcmM6IFV0aWxzLmFzc2V0KGBpbWFnZXMvYmxhY2suanBnYCkgfSB9LFxuXG4gICAgICApO1xuXG4gICAgfVxuXG4gXG5cbiAgICB0aGlzLnRhZygnV3JhcHBlcicpLmNoaWxkcmVuID0gYnV0dG9ucztcbiAgfVxuXG5cbiAgcmVwb3NpdGlvbldyYXBwZXIoKSB7XG5cbiAgICBjb25zdCB3cmFwcGVyID0gdGhpcy50YWcoJ1dyYXBwZXInKTtcblxuICAgIGNvbnN0IHNsaWRlclcgPSB0aGlzLnRhZygnU2xpZGVyJykudztcblxuICAgIGNvbnN0IGN1cnJlbnRXcmFwcGVyWCA9IHdyYXBwZXIudHJhbnNpdGlvbigneCcpLnRhcmdldHZhbHVlIHx8IHdyYXBwZXIueDtcblxuICAgIGNvbnN0IGN1cnJlbnRGb2N1cyA9IHdyYXBwZXIuY2hpbGRyZW5bdGhpcy5pbmRleF07XG5cbiAgICBjb25zdCBjdXJyZW50Rm9jdXNYID0gY3VycmVudEZvY3VzLnggKyBjdXJyZW50V3JhcHBlclg7XG5cbiAgICBjb25zdCBjdXJyZW50Rm9jdXNPdXRlcldpZHRoID0gY3VycmVudEZvY3VzLnggKyBjdXJyZW50Rm9jdXMudztcblxuIFxuXG4gICAgaWYgKGN1cnJlbnRGb2N1c1ggPCAwKSB7XG5cbiAgICAgIHdyYXBwZXIuc2V0U21vb3RoKCd4JywgLSBjdXJyZW50Rm9jdXMueCk7XG5cbiAgICB9XG5cbiAgICBlbHNlIGlmIChjdXJyZW50Rm9jdXNPdXRlcldpZHRoID4gc2xpZGVyVykge1xuXG4gICAgICB3cmFwcGVyLnNldFNtb290aCgneCcsIHNsaWRlclcgLSAoY3VycmVudEZvY3VzT3V0ZXJXaWR0aCkpO1xuXG4gICAgfVxuXG4gIH1cblxuIFxuXG4gIF9oYW5kbGVMZWZ0KCkge1xuXG4gICAgaWYgKHRoaXMuaW5kZXggPT09IDApIHtcblxuICAgICAgdGhpcy5pbmRleCA9IHRoaXMuZGF0YUxlbmd0aCAtIDE7XG5cbiAgICB9XG5cbiAgICBlbHNlIHtcblxuICAgICAgdGhpcy5pbmRleCAtPSAxO1xuXG4gICAgfVxuXG4gICAgdGhpcy5yZXBvc2l0aW9uV3JhcHBlcigpO1xuXG4gIH1cblxuIFxuXG4gIF9oYW5kbGVSaWdodCgpIHtcblxuICAgIGlmICh0aGlzLmluZGV4ID09PSB0aGlzLmRhdGFMZW5ndGggLSAxKSB7XG5cbiAgICAgIHRoaXMuaW5kZXggPSAwO1xuXG4gICAgfVxuXG4gICAgZWxzZSB7XG5cbiAgICAgIHRoaXMuaW5kZXggKz0gMTtcblxuICAgIH1cblxuICAgIHRoaXMucmVwb3NpdGlvbldyYXBwZXIoKTtcblxuICB9XG5cbiBcblxuICBfZ2V0Rm9jdXNlZCgpIHtcblxuICAgIHJldHVybiB0aGlzLnRhZygnU2xpZGVyLldyYXBwZXInKS5jaGlsZHJlblt0aGlzLmluZGV4XVxuXG4gIH1cblxuXG5cblxuXG4gIGluaXRpYXRlUGxheWVyKCkge1xuICAgIGNvbnN0IHVybCA9XG4gICAgICBcImh0dHBzOi8vYW1zc2FtcGxlcy5zdHJlYW1pbmcubWVkaWFzZXJ2aWNlcy53aW5kb3dzLm5ldC82ODNmN2U0Ny1iZDgzLTQ0MjctYjBhMy0yNmE2YzQ1NDc3ODIvQmlnQnVja0J1bm55LmlzbS9tYW5pZmVzdChmb3JtYXQ9bXBkLXRpbWUtY3NmKVwiO1xuICAgIHRoaXMuX3BsYXllciA9IG5ldyBBQU1QTWVkaWFQbGF5ZXIoKTtcbiAgICB0aGlzLl9wbGF5ZXIubG9hZCh1cmwpO1xuICB9XG5cbiAgc3RhdGljIF9zdGF0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGNsYXNzIExhdW5jaFZpZXcgZXh0ZW5kcyB0aGlzIHtcbiAgICAgICAgX2dldEZvY3VzZWQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGFnKFwiUGxheWJ1dHRvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVCdXR0b25FbnRlcigpIHtcbiAgICAgICAgICB0aGlzLmluaXRpYXRlUGxheWVyKCk7XG4gICAgICAgICAgdGhpcy5fc2V0U3RhdGUoXCJWaWRlb1BsYXlcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbGFzcyBWaWRlb1BsYXkgZXh0ZW5kcyB0aGlzIHtcbiAgICAgICAgX2dldEZvY3VzZWQoKSB7XG4gICAgICAgICAgLy9yZXR1cm4gdGhpcy50YWcoXCJWaWRlb1NlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgJGVudGVyKCkge1xuICAgICAgICAgIHRoaXMudGFnKFwiVmlkZW9TZWN0aW9uXCIpLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMudGFnKFwiSGVsbG9Xb3JsZFwiKS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgX2hhbmRsZUJhY2soKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJiYWNrIHRvIGxhdW5jaFZpZXdcIik7XG4gICAgICAgICAgdGhpcy50YWcoXCJWaWRlb1NlY3Rpb25cIikudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudGFnKFwiSGVsbG9Xb3JsZFwiKS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9zZXRTdGF0ZShcIkxhdW5jaFZpZXdcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgXTtcbiAgfVxuXG4gIF9hY3RpdmUoKSB7XG4gICAgY29uc29sZS5sb2coXCJhY3RpdmUgc2V0IHN0YXRlIHRvIGxhdW5jaFZpZXdcIik7XG4gICAgdGhpcy5fc2V0U3RhdGUoXCJMYXVuY2hWaWV3XCIpO1xuXG4gICAgRGV2aWNlLmF1ZGlvKCkudGhlbigoc3VwcG9ydGVkQXVkaW9Qcm9maWxlcykgPT4ge1xuICAgICAgY29uc3QgbmV3QXVkaW8gPSBcImF1ZGlvIHByb2ZpbGUgKipcIiArIHN1cHBvcnRlZEF1ZGlvUHJvZmlsZXMuc3RlcmVvO1xuICAgICAgLy9Mb2cuaW5mbyhzdXBwb3J0ZWRBdWRpb1Byb2ZpbGVzLnN0ZXJlbyk7XG4gICAgICBMb2cuaW5mbyhcIkRldmljZVwiLCBuZXdBdWRpbyk7XG4gICAgICAvL3RoaXMudGFnKCdEZXZpY2UnKS50ZXh0LnRleHQgPSBuZXdBdWRpbyArICcgOjogJztcbiAgICAgIHRoaXMudGFnKFwiRGV2aWNlXCIpLnRleHQudGV4dCA9IHN1cHBvcnRlZEF1ZGlvUHJvZmlsZXMgKyBcIiA6OiBcIjtcbiAgICAgIC8vY29uc29sZS5sb2coXCJJcyBzdGVyZW8gc3VwcG9ydGVkXCIsc3VwcG9ydGVkQXVkaW9Qcm9maWxlcy5zdGVyZW8pO1xuICAgICAgY29uc29sZS5sb2coXCJJcyBzdGVyZW8gc3VwcG9ydGVkXCIsIHN1cHBvcnRlZEF1ZGlvUHJvZmlsZXMuc3RlcmVvKTtcbiAgICB9KTtcblxuICAgIC8vIERldmljZS5hdWRpbygpXG4gICAgLy8gLnRoZW4oc3VwcG9ydGVkQXVkaW9Qcm9maWxlcyA9PiB7XG4gICAgLy8gICAgIGNvbnNvbGUubG9nKHN1cHBvcnRlZEF1ZGlvUHJvZmlsZXMpO1xuICAgIC8vICAgICBjb25zdCBuZXdBdWRpb1Byb2ZpbGUgPSBzdXBwb3J0ZWRBdWRpb1Byb2ZpbGVzLnN0ZXJlbztcbiAgICAvLyAgICAgTG9nLmluZm8oXCJEZXZpY2VcIiwgbmV3QXVkaW9Qcm9maWxlKTtcbiAgICAvLyAgICAgdGhpcy50YWcoXCJEZXZpY2VcIikudGV4dC50ZXh0ID0gbmV3QXVkaW9Qcm9maWxlICtcIjo6XCI7XG4gICAgLy8gICAgIGNvbnNvbGUubG9nKG5ld0F1ZGlvUHJvZmlsZSk7XG4gICAgLy8gfSlcblxuICAgIC8vIERldmljZS5uYW1lKClcbiAgICAvLyAgICAgICAgIC50aGVuKHZhbHVlID0+IHtcbiAgICAvLyBcdFx0Y29uc29sZS5sb2codmFsdWUpXG4gICAgLy8gXHRcdExvZy5pbmZvKFwibGlzdGVuZXJJZCoqXCIsIHZhbHVlKTtcbiAgICAvLyBcdFx0dGhpcy50YWcoJ0RldmljZScpLnRleHQudGV4dCA9IHZhbHVlICsgJyA6OiAnO1xuICAgIC8vIFx0ICB9KS50aGVuKGxpc3RlbmVySWQgPT4ge1xuICAgIC8vIFx0XHRMb2cuaW5mbyhcImxpc3RlbmVySWQqKlwiLHZhbHVlKTtcbiAgICAvLyBcdFx0Y29uc29sZS5sb2cobGlzdGVuZXJJZClcbiAgICAvLyBcdCAgfSk7XG5cbiAgICBEZXZpY2UuZGlzdHJpYnV0b3IoKS50aGVuKChkaXN0cmlidXRvcikgPT4ge1xuICAgICAgY29uc3QgZGV2aWNlRGlzdHJpYnV0b3IgPSBcImRpc3RyaWJ1dG9yOlwiICsgZGlzdHJpYnV0b3I7XG4gICAgICBMb2cuaW5mbyhkZXZpY2VEaXN0cmlidXRvcik7XG4gICAgICB0aGlzLnRhZyhcIkRldmljZVwiKS50ZXh0LnRleHQgPSBkZXZpY2VEaXN0cmlidXRvciArIFwiIDo6IFwiO1xuICAgIH0pO1xuXG4gICAgLy8gRGV2aWNlLm1vZGVsKClcbiAgICAvLyBcdC50aGVuKG1vZGVsID0+IHtcbiAgICAvLyBcdFx0Y29uc3QgZGV2aWNlTW9kZWwgPSAnbW9kZWw6JyArIG1vZGVsO1xuICAgIC8vIFx0XHRMb2cuaW5mbyhkZXZpY2VNb2RlbCk7XG4gICAgLy8gXHRcdHRoaXMudGFnKCdEZXZpY2UnKS50ZXh0LnRleHQgKz0gZGV2aWNlTW9kZWwgKyAnIDo6ICc7XG4gICAgLy8gXHRcdGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGRldmljZU1vZGVsLCBudWxsLCAzKSk7XG4gICAgLy8gXHR9KTtcblxuICAgIERldmljZS5wbGF0Zm9ybSgpLnRoZW4oKHBsYXRmb3JtKSA9PiB7XG4gICAgICBjb25zdCBkZXZpY2VQbGF0Zm9ybSA9IFwicGxhdGZvcm06XCIgKyBwbGF0Zm9ybTtcbiAgICAgIExvZy5pbmZvKGRldmljZVBsYXRmb3JtKTtcbiAgICAgIHRoaXMudGFnKFwiRGV2aWNlXCIpLnRleHQudGV4dCArPSBkZXZpY2VQbGF0Zm9ybSArIFwiIDo6IFwiO1xuICAgIH0pO1xuXG4gICAgRGV2aWNlLnZlcnNpb24oKS50aGVuKCh2ZXJzaW9uKSA9PiB7XG4gICAgICBjb25zdCBkZXZpY2VWZXJzaW9uID1cbiAgICAgICAgXCJ2ZXJzaW9uOlwiICtcbiAgICAgICAgdmVyc2lvbi5zZGsucmVhZGFibGUgK1xuICAgICAgICBcIiA6IHZcIiArXG4gICAgICAgIHZlcnNpb24uc2RrLm1ham9yICtcbiAgICAgICAgXCIuXCIgK1xuICAgICAgICB2ZXJzaW9uLnNkay5taW5vciArXG4gICAgICAgIFwiLlwiICtcbiAgICAgICAgdmVyc2lvbi5zZGsucGF0Y2g7XG4gICAgICBMb2cuaW5mbyhkZXZpY2VWZXJzaW9uKTtcbiAgICAgIHRoaXMudGFnKFwiRGV2aWNlXCIpLnRleHQudGV4dCArPSBkZXZpY2VWZXJzaW9uO1xuICAgIH0pO1xuICAgIExvY2FsaXphdGlvbi5sYW5ndWFnZSgpLnRoZW4obGFuZyA9PiB7XG4gICAgICBjb25zdCBsYW5ndSA9IFwibGFuZ3VhZ2U6XCIgKyBsYW5nO1xuICAgICAgTG9nLmluZm8obGFuZ3UpO1xuICAgICAgdGhpcy50YWcoXCJMb2NhbGl6YXRpb25cIikudGV4dC50ZXh0ICs9IGxhbmd1ICsgXCIgOjpcIjtcbiAgICAgICBcbiAgICB9KVxuICAgIExvY2FsaXphdGlvbi5jb3VudHJ5Q29kZSgpLnRoZW4oY29kZSA9PiB7XG4gICAgICBjb25zdCBDX0NvZGUgPSBcIiBDb3VudHJ5X0NvZGU6XCIgKyBjb2RlO1xuICAgICAgTG9nLmluZm8oQ19Db2RlKTtcbiAgICAgIHRoaXMudGFnKFwiTG9jYWxpemF0aW9uXCIpLnRleHQudGV4dCArPSBDX0NvZGUgKyBcIiBcIjtcbiAgICAgICAgY29uc29sZS5sb2coY29kZSlcbiAgICB9KVxuXG4gICAgTWV0cmljcy5hY3Rpb24oXCJ1c2VyXCIsIFwiVGhlIHVzZXIgZGlkIGZvb1wiLCBudWxsKS50aGVuKHN1Y2Nlc3MgPT4ge1xuICAgICAgY29uc3QgbWV0X2FjdCA9IFwiIGFjdGlvbiA6IFwiICsgc3VjY2VzcztcbiAgICAgIExvZy5pbmZvKG1ldF9hY3QpO1xuICAgICAgdGhpcy50YWcoXCJNZXRyaWNzXCIpLnRleHQudGV4dCArPSBtZXRfYWN0ICsgXCIgXCI7XG4gICAgICAgXG4gICAgfSlcblxuICAgIC8vIHRoaXMuX3JlZ2lzdGVyTGlmZWN5Y2xlQ2FsbGJhY2tzKCk7XG4gICAgLy8gTGlmZWN5Y2xlLnJlYWR5KCk7XG4gICAgLy8gTG9nLmluZm8oXCJMaWZlY3ljbGUgcmVhZHkhXCIpO1xuICB9XG5cbiAgLy8gX3JlZ2lzdGVyTGlmZWN5Y2xlQ2FsbGJhY2tzKCkge1xuICAvLyAgIExpZmVjeWNsZS5saXN0ZW4oKGV2ZW50LCB2YWx1ZSkgPT4ge1xuICAvLyAgICAgTG9nLmluZm8oXCJMaWZlY3ljbGUubGlzdGVuOlwiLCBldmVudCwgdmFsdWUpO1xuXG4gIC8vICAgICBpZiAodmFsdWUuc3RhdGUpIHtcbiAgLy8gICAgICAgTG9nLndhcm4oXCJMaWZlY3ljbGU6ID4+IDogcHJldmlvdXMgc3RhdGUgOlwiICsgdmFsdWUucHJldmlvdXMsIHZhbHVlKTtcbiAgLy8gICAgICAgTG9nLndhcm4oXCJMaWZlY3ljbGU6ID4+IDogY3VycmVudCBzdGF0ZSA6XCIgKyB2YWx1ZS5zdGF0ZSwgdmFsdWUpO1xuICAvLyAgICAgfVxuXG4gIC8vICAgICBpZiAodmFsdWUuc3RhdGUgPT0gXCJmb3JlZ3JvdW5kXCIpIHtcbiAgLy8gICAgICAgTG9nLmluZm8oXCJMaWZlY3ljbGUgOiBGb3JlZ3JvdW5kIFN0YXRlXCIsIG51bGwpO1xuICAvLyAgICAgICB0aGlzLnRhZyhcIkhlbGxvV29ybGRcIikuY29sb3IgPSBMaWZlY3ljbGVDb2xvcnMuRk9SRUdST1VORDtcbiAgLy8gICAgICAgdGhpcy50YWcoXCJMaWZlY3ljbGVcIikudGV4dC50ZXh0ID0gXCJMaWZlY3ljbGUgOiBGb3JlZ3JvdW5kIFN0YXRlXCI7XG4gIC8vICAgICAgIHRoaXMudGFnKFwiQ29tcGxldGVcIikudmlzaWJsZSA9IHRydWU7XG4gIC8vICAgICB9XG4gIC8vICAgICBpZiAodmFsdWUuc3RhdGUgPT0gXCJpbmFjdGl2ZVwiKSB7XG4gIC8vICAgICAgIExvZy5pbmZvKFwiTGlmZWN5Y2xlIDogSW5hY3RpdmUgU3RhdGVcIiwgbnVsbCk7XG4gIC8vICAgICAgIHRoaXMudGFnKFwiSGVsbG9Xb3JsZFwiKS5jb2xvciA9IExpZmVjeWNsZUNvbG9ycy5JTkFDVElWRTtcbiAgLy8gICAgICAgdGhpcy50YWcoXCJMaWZlY3ljbGVcIikudGV4dC50ZXh0ID0gXCJMaWZlY3ljbGUgOiBJbmFjdGl2ZSBTdGF0ZVwiO1xuICAvLyAgICAgfVxuICAvLyAgICAgaWYgKHZhbHVlLnN0YXRlID09IFwiYmFja2dyb3VuZFwiKSB7XG4gIC8vICAgICAgIExvZy5pbmZvKFwiTGlmZWN5Y2xlIDogQmFja2dyb3VuZCBTdGF0ZVwiLCBudWxsKTtcbiAgLy8gICAgICAgdGhpcy50YWcoXCJIZWxsb1dvcmxkXCIpLmNvbG9yID0gTGlmZWN5Y2xlQ29sb3JzLkJBQ0tHUk9VTkQ7XG4gIC8vICAgICAgIHRoaXMudGFnKFwiTGlmZWN5Y2xlXCIpLnRleHQudGV4dCA9IFwiTGlmZWN5Y2xlIDogQmFja2dyb3VuZCBTdGF0ZVwiO1xuICAvLyAgICAgfVxuICAvLyAgIH0pO1xuICAvLyB9XG59XG4iLCJpbXBvcnQgeyBMaWdodG5pbmcsIFV0aWxzIH0gZnJvbSBcIkBsaWdodG5pbmdqcy9zZGtcIjtcblxuZXhwb3J0ICBjbGFzcyBCbGFja0FkYW0gZXh0ZW5kcyBMaWdodG5pbmcuQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gIFxuICAgICAgcmV0dXJuIHtcbiAgXG4gICAgICAgIHc6IDMwMCxcbiAgXG4gICAgICAgIGg6IDQ1MCxcbiAgXG4gICAgICAgIEltYWdlOiB7XG4gIFxuICAgICAgICAgIHc6IHcgPT4gdywgaDogaCA9PiBoIC0gNTAsXG4gIFxuICAgICAgICB9LFxuICBcbiAgICAgIH1cbiAgXG4gICAgfVxuICBcbiAgIFxuICBcbiAgICBzZXQgaXRlbShvYmopIHtcbiAgXG4gICAgICBjb25zdCB7IGxhYmVsLCBzcmMgfSA9IG9iajtcbiAgXG4gICAgICB0aGlzLnBhdGNoKHtcbiAgXG4gICAgICAgIEltYWdlOiB7IHNyYyB9LFxuICBcbiAgICAgIH0pXG4gIFxuICAgIH1cbiAgXG4gICBcbiAgXG4gICAgX2ZvY3VzKCkge1xuICBcbiAgICAgIHRoaXMucGF0Y2goe1xuICBcbiAgICAgICAgc21vb3RoOiB7IGNvbG9yOiAweGZmMDA1NTAwLCBzY2FsZTogMS4xIH0sXG4gIFxuICAgICAgICBzaGFkZXI6IHsgdHlwZTogTGlnaHRuaW5nLnNoYWRlcnMuT3V0bGluZSwgc3Ryb2tlOiAxLjEsIGNvbG9yOiAweGZmMDlmNjc2IH0sXG4gIFxuICAgICAgfSk7XG4gIFxuICAgIH1cbiAgXG4gICBcbiAgXG4gICAgX3VuZm9jdXMoKSB7XG4gIFxuICAgICAgdGhpcy5wYXRjaCh7XG4gIFxuICAgICAgICBzbW9vdGg6IHsgY29sb3I6IDB4ZmZmZmZmZmYsIHNjYWxlOiAxLjAgfSxcbiAgXG4gICAgICAgIHNoYWRlcjogeyB0eXBlOiBMaWdodG5pbmcuc2hhZGVycy5PdXRsaW5lLCBzdHJva2U6IDAsIGNvbG9yOiAweDAwMDAwMDAgfSxcbiAgXG4gICAgICB9KTtcbiAgXG4gICAgfVxuICBcbiAgfSIsImltcG9ydCB7IExpZ2h0bmluZyB9IGZyb20gXCJAbGlnaHRuaW5nanMvc2RrXCI7XG5cbmV4cG9ydCBjbGFzcyBNeUJ1dHRvbiBleHRlbmRzIExpZ2h0bmluZy5Db21wb25lbnQge1xuICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBBZGQgYSBjb2xvcmVkIHJlY3RhbmdsZSBhcyB0aGUgYmFja2dyb3VuZCBvZiB0aGUgYnV0dG9uXG4gICAgICBCYWNrZ3JvdW5kOiB7XG4gICAgICAgIHc6IDI1MCxcbiAgICAgICAgaDogMTAwLFxuICAgICAgICByZWN0OiB0cnVlLFxuICAgICAgICByYWRpdXM6IDEwLFxuICAgICAgICBjb2xvcjogMHhmZmMwYzBjMCwgLy8weGZmMDA3YWZmLCAvLyBCbHVlIGNvbG9yXG4gICAgICB9LFxuXG4gICAgICBMYWJlbDoge1xuICAgICAgICB4OiA4MCxcbiAgICAgICAgeTogMjAsXG4gICAgICAgIHRleHQ6IHtcbiAgICAgICAgICB0ZXh0OiBcIlBsYXlcIixcbiAgICAgICAgICBmb250U2l6ZTogMjgsXG4gICAgICAgICAgdGV4dENvbG9yOiAweGZmMDAwMDAwLCAvLzB4ZmZmZmZmZmYsIC8vIFdoaXRlIGNvbG9yXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgX2hhbmRsZUVudGVyKCkge1xuICAgIHRoaXMuc2lnbmFsKFwib25DbGlja1wiKTtcbiAgfVxuXG4gIF9mb2N1cygpIHtcbiAgICAvKiB0aGlzLnBhdGNoKHtcbiAgICAgIExhYmVsOiB7XG4gICAgICAgIHRleHQ6IHtcbiAgICAgICAgICBmb250U2l6ZTogNTAsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pOyAqL1xuICAgIGNvbnNvbGUubG9nKFwiYnV0dG9uIGZvY3VzXCIpO1xuICAgIHRoaXMucGF0Y2goe1xuICAgICAgc21vb3RoOiB7IGNvbG9yOiAweGZmMDA3YWZmIH0sXG4gICAgICBMYWJlbDoge1xuICAgICAgICBzbW9vdGg6IHsgY29sb3I6IDB4ZmZmZmZmZmYgfSxcbiAgICAgICAgdGV4dDogeyBmb250U2l6ZTogNTAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBfdW5mb2N1cygpIHtcbiAgICAvKiB0aGlzLnBhdGNoKHtcbiAgICAgIExhYmVsOiB7XG4gICAgICAgIHRleHQ6IHtcbiAgICAgICAgICBmb250U2l6ZTogNDAsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pOyAqL1xuICAgIHRoaXMucGF0Y2goe1xuICAgICAgc21vb3RoOiB7IGNvbG9yOiAweGZmZmZmZmZmIH0sXG4gICAgICBMYWJlbDoge1xuICAgICAgICBzbW9vdGg6IHsgY29sb3I6IDB4ZmYwMDAwMDAgfSxcbiAgICAgICAgdGV4dDogeyBmb250U2l6ZTogMzUgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn0iLCIvKlxuKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKlxuKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuKi9cblxuaW1wb3J0IHBrZyBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xuXG5jb25zdCBpc0RldmVsb3BtZW50ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCc7XG5cbmV4cG9ydCBjb25zdCBhcHBEYXRhID0ge307XG5cbmV4cG9ydCBjb25zdCBhcHBTZXR0aW5ncyA9IHtcbiAgdmVyc2lvbjogcGtnLnZlcnNpb24sXG4gIHN0YWdlOiB7XG4gICAgY2xlYXJDb2xvcjogJzB4MDAwMDAwJyxcbiAgfSxcbiAgZGVidWc6IGZhbHNlLFxufTtcblxuZXhwb3J0IGNvbnN0IHBsYXRmb3JtU2V0dGluZ3MgPSB7XG4gIGxvZzogdHJ1ZSxcbiAgcGF0aDogXCIuL3N0YXRpY1wiLFxuICBzaG93VmVyc2lvbjogZmFsc2Vcbn07XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBwYXJ0aWFsIChhbmQgbW9yZSBlZmZpY2llbnQpIGltcGxlbWVudGF0aW9uIG9mIHRoZSBldmVudCBlbWl0dGVyLlxuICogSXQgYXR0ZW1wdHMgdG8gbWFpbnRhaW4gYSBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlbiBldmVudHMgYW5kIGxpc3RlbmVycywgc2tpcHBpbmcgYW4gYXJyYXkgbG9va3VwLlxuICogT25seSBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgbGlzdGVuZXJzLCB0aGV5IGFyZSBjb21iaW5lZCBpbiBhbiBhcnJheS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRFbWl0dGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBUaGlzIGlzIHNldCAoYW5kIGtlcHQpIHRvIHRydWUgd2hlbiBldmVudHMgYXJlIHVzZWQgYXQgYWxsLlxuICAgICAgICB0aGlzLl9oYXNFdmVudExpc3RlbmVycyA9IGZhbHNlO1xuICAgIH1cblxuICAgIG9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5faGFzRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50RnVuY3Rpb24gPSB7fVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fVxuICAgICAgICAgICAgdGhpcy5faGFzRXZlbnRMaXN0ZW5lcnMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV07XG4gICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXSA9IGxpc3RlbmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV0gIT09IEV2ZW50RW1pdHRlci5jb21iaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdID0gW3RoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV0sIGxpc3RlbmVyXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdID0gRXZlbnRFbWl0dGVyLmNvbWJpbmVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uY2UobmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IChhcmcxLCBhcmcyLCBhcmczKSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lcihhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKG5hbWUsIHdyYXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZXIuX19vcmlnaW5hbEZ1bmMgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5vbihuYW1lLCB3cmFwcGVyKTtcbiAgICB9XG5cbiAgICBoYXMobmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc0V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IEV2ZW50RW1pdHRlci5jb21iaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBsIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwgPT09IGxpc3RlbmVyIHx8IGwuX19vcmlnaW5hbEZ1bmMgPT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXSA9PT0gbGlzdGVuZXIgfHwgdGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXS5fX29yaWdpbmFsRnVuYyA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBvZmYobmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc0V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IEV2ZW50RW1pdHRlci5jb21iaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBsaXN0ZW5lcnMubWFwKChsKSA9PiBsLl9fb3JpZ2luYWxGdW5jKS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdID0gbGlzdGVuZXJzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV0gPT09IGxpc3RlbmVyIHx8IHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV0uX19vcmlnaW5hbEZ1bmMgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlTGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5vZmYobmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIGVtaXQobmFtZSwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBpZiAodGhpcy5faGFzRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmMgPSB0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdO1xuICAgICAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVuYyA9PT0gRXZlbnRFbWl0dGVyLmNvbWJpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmModGhpcywgbmFtZSwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuYyhhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0ZW5lckNvdW50KG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc0V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXTtcbiAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmMgPT09IEV2ZW50RW1pdHRlci5jb21iaW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5faGFzRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbkV2ZW50RW1pdHRlci5jb21iaW5lciA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZSwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IG9iamVjdC5fZXZlbnRMaXN0ZW5lcnNbbmFtZV07XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvKiBCZWNhdXNlIGxpc3RlbmVyIG1heSBkZXRhY2ggaXRzZWxmIHdoaWxlIGJlaW5nIGludm9rZWQgYW5kIHRoZXJlZm9yZSBpbnZhbGlkYXRlIHRoZSBpdGVyYXRvcixcbiAgICAgICAgICAgd2UgbmVlZCB0byBjcmVhdGUgYSBjb3B5IHRvIGxvb3Agb3ZlciBpdCAqL1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIFsuLi5saXN0ZW5lcnNdKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcihhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuRXZlbnRFbWl0dGVyLmFkZEFzTWl4aW4gPSBmdW5jdGlvbihjbHMpIHtcbiAgICBjbHMucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcbiAgICBjbHMucHJvdG90eXBlLm9uY2UgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2U7XG4gICAgY2xzLnByb3RvdHlwZS5oYXMgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmhhcztcbiAgICBjbHMucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmO1xuICAgIGNscy5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuICAgIGNscy5wcm90b3R5cGUuZW1pdCA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdDtcbiAgICBjbHMucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQ7XG4gICAgY2xzLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycztcbn1cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiLi4vRXZlbnRFbWl0dGVyLm1qc1wiO1xuaW1wb3J0IEFuaW1hdGlvblNldHRpbmdzIGZyb20gXCIuL0FuaW1hdGlvblNldHRpbmdzLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb24gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gICAgY29uc3RydWN0b3IobWFuYWdlciwgc2V0dGluZ3MsIGVsZW1lbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuXG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gc2V0dGluZ3M7XG5cbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLklETEU7XG5cbiAgICAgICAgdGhpcy5fcCA9IDA7XG4gICAgICAgIHRoaXMuX2RlbGF5TGVmdCA9IDA7XG4gICAgICAgIHRoaXMuX3JlcGVhdHNMZWZ0ID0gMDtcblxuICAgICAgICB0aGlzLl9zdG9wRGVsYXlMZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5fc3RvcFAgPSAwO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5fZWxlbWVudCAmJiB0aGlzLl9lbGVtZW50LmF0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5TGVmdCA9IHRoaXMuc2V0dGluZ3MuZGVsYXk7XG4gICAgICAgICAgICB0aGlzLl9yZXBlYXRzTGVmdCA9IHRoaXMuc2V0dGluZ3MucmVwZWF0O1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlBMQVlJTkc7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N0YXJ0Jyk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQWN0aXZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbTGlnaHRuaW5nXSBFbGVtZW50IG11c3QgYmUgYXR0YWNoZWQgYmVmb3JlIHN0YXJ0aW5nIGFuaW1hdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBsYXkoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQW5pbWF0aW9uLlNUQVRFUy5QQVVTRUQpIHtcbiAgICAgICAgICAgIC8vIENvbnRpbnVlLjtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5QTEFZSU5HO1xuICAgICAgICAgICAgdGhpcy5jaGVja0FjdGl2ZSgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PSBBbmltYXRpb24uU1RBVEVTLlNUT1BQSU5HICYmIHRoaXMuc2V0dGluZ3Muc3RvcE1ldGhvZCA9PSBBbmltYXRpb25TZXR0aW5ncy5TVE9QX01FVEhPRFMuUkVWRVJTRSkge1xuICAgICAgICAgICAgLy8gQ29udGludWUuO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlBMQVlJTkc7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3BDb250aW51ZScpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9IEFuaW1hdGlvbi5TVEFURVMuUExBWUlORyAmJiB0aGlzLl9zdGF0ZSAhPSBBbmltYXRpb24uU1RBVEVTLkZJTklTSEVEKSB7XG4gICAgICAgICAgICAvLyBSZXN0YXJ0LjtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhdXNlKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IEFuaW1hdGlvbi5TVEFURVMuUExBWUlORykge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlBBVVNFRDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlcGxheSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09IEFuaW1hdGlvbi5TVEFURVMuRklOSVNIRUQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2tpcERlbGF5KCkge1xuICAgICAgICB0aGlzLl9kZWxheUxlZnQgPSAwO1xuICAgICAgICB0aGlzLl9zdG9wRGVsYXlMZWZ0ID0gMDtcbiAgICB9XG5cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQW5pbWF0aW9uLlNUQVRFUy5QTEFZSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxheUxlZnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BEZWxheUxlZnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fcCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBFRCB8fCB0aGlzLl9zdGF0ZSA9PT0gQW5pbWF0aW9uLlNUQVRFUy5JRExFKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5fc3RvcERlbGF5TGVmdCA9IHRoaXMuc2V0dGluZ3Muc3RvcERlbGF5IHx8IDA7XG5cbiAgICAgICAgaWYgKCgodGhpcy5zZXR0aW5ncy5zdG9wTWV0aG9kID09PSBBbmltYXRpb25TZXR0aW5ncy5TVE9QX01FVEhPRFMuSU1NRURJQVRFKSAmJiAhdGhpcy5fc3RvcERlbGF5TGVmdCkgfHwgdGhpcy5fZGVsYXlMZWZ0ID4gMCkge1xuICAgICAgICAgICAgLy8gU3RvcCB1cG9uIG5leHQgcHJvZ3Jlc3MuO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlNUT1BQSU5HO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdG9wTWV0aG9kID09PSBBbmltYXRpb25TZXR0aW5ncy5TVE9QX01FVEhPRFMuRkFERSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BQID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlNUT1BQSU5HO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoZWNrQWN0aXZlKCk7XG4gICAgfVxuXG4gICAgc3RvcE5vdygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBBbmltYXRpb24uU1RBVEVTLlNUT1BQRUQgfHwgdGhpcy5fc3RhdGUgIT09IEFuaW1hdGlvbi5TVEFURVMuSURMRSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlNUT1BQSU5HO1xuICAgICAgICAgICAgdGhpcy5fcCA9IDA7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3AnKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUEVEO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wRmluaXNoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc1BhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlID09PSBBbmltYXRpb24uU1RBVEVTLlBBVVNFRDtcbiAgICB9XG5cbiAgICBpc1BsYXlpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSA9PT0gQW5pbWF0aW9uLlNUQVRFUy5QTEFZSU5HO1xuICAgIH1cblxuICAgIGlzU3RvcHBpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSA9PT0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUElORztcbiAgICB9XG5cbiAgICBpc0ZpbmlzaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUgPT09IEFuaW1hdGlvbi5TVEFURVMuRklOSVNIRUQ7XG4gICAgfVxuXG4gICAgY2hlY2tBY3RpdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5hZGRBY3RpdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9zdGF0ZSA9PSBBbmltYXRpb24uU1RBVEVTLlBMQVlJTkcgfHwgdGhpcy5fc3RhdGUgPT0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUElORykgJiYgdGhpcy5fZWxlbWVudCAmJiB0aGlzLl9lbGVtZW50LmF0dGFjaGVkO1xuICAgIH1cblxuICAgIHByb2dyZXNzKGR0KSB7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudCkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9wcm9ncmVzcyhkdCk7XG4gICAgICAgIHRoaXMuYXBwbHkoKTtcbiAgICB9XG5cbiAgICBfcHJvZ3Jlc3MoZHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BQcm9ncmVzcyhkdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT0gQW5pbWF0aW9uLlNUQVRFUy5QTEFZSU5HKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZGVsYXlMZWZ0ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fZGVsYXlMZWZ0IC09IGR0O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZGVsYXlMZWZ0IDwgMCkge1xuICAgICAgICAgICAgICAgIGR0ID0gLXRoaXMuX2RlbGF5TGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWxheUxlZnQgPSAwO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkZWxheUVuZCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kdXJhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5kdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3AgKz0gZHQgLyB0aGlzLnNldHRpbmdzLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wID49IDEpIHtcbiAgICAgICAgICAgIC8vIEZpbmlzaGVkITtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnJlcGVhdCA9PSAtMSB8fCB0aGlzLl9yZXBlYXRzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVwZWF0c0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcGVhdHNMZWZ0LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3AgPSB0aGlzLnNldHRpbmdzLnJlcGVhdE9mZnNldDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgdGhpcy5fcCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmVwZWF0RGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsYXlMZWZ0ID0gdGhpcy5zZXR0aW5ncy5yZXBlYXREZWxheTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlcGVhdCcsIHRoaXMuX3JlcGVhdHNMZWZ0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHRoaXMuX3ApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5GSU5JU0hFRDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmF1dG9zdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCB0aGlzLl9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBfc3RvcFByb2dyZXNzKGR0KSB7XG4gICAgICAgIGxldCBkdXJhdGlvbiA9IHRoaXMuX2dldFN0b3BEdXJhdGlvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zdG9wRGVsYXlMZWZ0ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcERlbGF5TGVmdCAtPSBkdDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BEZWxheUxlZnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgZHQgPSAtdGhpcy5fc3RvcERlbGF5TGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wRGVsYXlMZWZ0ID0gMDtcblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcERlbGF5RW5kJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdG9wTWV0aG9kID09IEFuaW1hdGlvblNldHRpbmdzLlNUT1BfTUVUSE9EUy5JTU1FRElBVEUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUEVEO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wRmluaXNoJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5zdG9wTWV0aG9kID09IEFuaW1hdGlvblNldHRpbmdzLlNUT1BfTUVUSE9EUy5SRVZFUlNFKSB7XG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcCAtPSBkdCAvIGR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fcCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlNUT1BQRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wRmluaXNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5zdG9wTWV0aG9kID09IEFuaW1hdGlvblNldHRpbmdzLlNUT1BfTUVUSE9EUy5GQURFKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc1N0b3BUcmFuc2l0aW9uKGR0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wUCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlNUT1BQRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wRmluaXNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5zdG9wTWV0aG9kID09IEFuaW1hdGlvblNldHRpbmdzLlNUT1BfTUVUSE9EUy5PTkVUT1RXTykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3AgPCAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcCArPSBkdCAvIHRoaXMuc2V0dGluZ3MuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wICs9IGR0IC8gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3AgPj0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wID0gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlNUT1BQRUQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcEZpbmlzaCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCB0aGlzLl9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5zdG9wTWV0aG9kID09IEFuaW1hdGlvblNldHRpbmdzLlNUT1BfTUVUSE9EUy5GT1JXQVJEKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcCA8IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kdXJhdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3AgKz0gZHQgLyB0aGlzLnNldHRpbmdzLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0b3BNZXRob2QgPT0gQW5pbWF0aW9uU2V0dGluZ3MuU1RPUF9NRVRIT0RTLkZPUldBUkQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlNUT1BQRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3BGaW5pc2gnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZXBlYXRzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBlYXRzTGVmdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVwZWF0JywgdGhpcy5fcmVwZWF0c0xlZnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3BGaW5pc2gnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCB0aGlzLl9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuICAgIFxuICAgIF9wcm9ncmVzc1N0b3BUcmFuc2l0aW9uKGR0KSB7XG4gICAgICAgIGlmICh0aGlzLl9zdG9wUCA8IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wRGVsYXlMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BEZWxheUxlZnQgLT0gZHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RvcERlbGF5TGVmdCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZHQgPSAtdGhpcy5fc3RvcERlbGF5TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcERlbGF5TGVmdCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkZWxheUVuZCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fZ2V0U3RvcER1cmF0aW9uKCk7XG5cbiAgICAgICAgICAgIGlmIChkdXJhdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcFAgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wUCArPSBkdCAvIGR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BQID49IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5pc2hlZCE7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcFAgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFN0b3BEdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3Muc3RvcER1cmF0aW9uIHx8IHRoaXMuc2V0dGluZ3MuZHVyYXRpb247XG4gICAgfVxuXG4gICAgYXBwbHkoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUEVEKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZmFjdG9yID0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUElORyAmJiB0aGlzLnNldHRpbmdzLnN0b3BNZXRob2QgPT09IEFuaW1hdGlvblNldHRpbmdzLlNUT1BfTUVUSE9EUy5GQURFKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yID0gKDEgLSB0aGlzLnNldHRpbmdzLnN0b3BUaW1pbmdGdW5jdGlvbkltcGwodGhpcy5fc3RvcFApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzLmFwcGx5KHRoaXMuX2VsZW1lbnQsIHRoaXMuX3AsIGZhY3Rvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MucmVzZXQodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuXG4gICAgZ2V0IHAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wO1xuICAgIH1cblxuICAgIGdldCBkZWxheUxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxheUxlZnQ7XG4gICAgfVxuXG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgIH1cblxuICAgIGdldCBmcmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fcCAqIHRoaXMuX3NldHRpbmdzLmR1cmF0aW9uICogNjApO1xuICAgIH1cblxuICAgIGdldCBzZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzO1xuICAgIH1cblxufVxuXG5BbmltYXRpb24uU1RBVEVTID0ge1xuICAgIElETEU6IDAsXG4gICAgUExBWUlORzogMSxcbiAgICBTVE9QUElORzogMixcbiAgICBTVE9QUEVEOiAzLFxuICAgIEZJTklTSEVEOiA0LFxuICAgIFBBVVNFRDogNVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uQWN0aW9uU2V0dGluZ3Mge1xuXG4gICAgY29uc3RydWN0b3IoYW5pbWF0aW9uU2V0dGluZ3MpIHtcblxuICAgICAgICB0aGlzLmFuaW1hdGlvblNldHRpbmdzID0gYW5pbWF0aW9uU2V0dGluZ3M7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZWxlY3RvciB0aGF0IHNlbGVjdHMgdGhlIGVsZW1lbnRzLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmFsdWUgaXRlbXMsIG9yZGVyZWQgYnkgcHJvZ3Jlc3Mgb2Zmc2V0LlxuICAgICAgICAgKiBAdHlwZSB7TXVsdGlTcGxpbmV9XG4gICAgICAgICAqIEBwcml2YXRlO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXRlbXMgPSBuZXcgTXVsdGlTcGxpbmUoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFmZmVjdGVkIHByb3BlcnRpZXMgKHBhdGhzKS5cbiAgICAgICAgICogQHByaXZhdGU7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcm9wcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0eSBzZXR0ZXJzLCBpbmRleGVkIGFjY29yZGluZyB0byBwcm9wcy5cbiAgICAgICAgICogQHByaXZhdGU7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcm9wU2V0dGVycyA9IFtdO1xuXG4gICAgICAgIHRoaXMuX3Jlc2V0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2hhc1Jlc2V0VmFsdWUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9oYXNDb2xvclByb3BlcnR5ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGdldFJlc2V0VmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNSZXNldFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzZXRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5nZXRWYWx1ZSgwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFwcGx5KGVsZW1lbnQsIHAsIGZhY3Rvcikge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZ2V0QW5pbWF0ZWRFbGVtZW50cyhlbGVtZW50KTtcblxuICAgICAgICBsZXQgdiA9IHRoaXMuX2l0ZW1zLmdldFZhbHVlKHApO1xuXG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgIWVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZhY3RvciAhPT0gMSkge1xuICAgICAgICAgICAgLy8gU3RvcCBmYWN0b3IuO1xuICAgICAgICAgICAgbGV0IHN2ID0gdGhpcy5nZXRSZXNldFZhbHVlKCk7XG5cbiAgICAgICAgICAgIGlmIChVdGlscy5pc051bWJlcih2KSAmJiBVdGlscy5pc051bWJlcihzdikpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNDb2xvclByb3BlcnR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IFN0YWdlVXRpbHMubWVyZ2VDb2xvcnModiwgc3YsIGZhY3Rvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IFN0YWdlVXRpbHMubWVyZ2VOdW1iZXJzKHYsIHN2LCBmYWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5IHRyYW5zZm9ybWF0aW9uIHRvIGFsbCBjb21wb25lbnRzLjtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX3Byb3BTZXR0ZXJzLmxlbmd0aDtcblxuICAgICAgICBjb25zdCBtID0gZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wU2V0dGVyc1tpXShlbGVtZW50c1tqXSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZ2V0QW5pbWF0ZWRFbGVtZW50cyhlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnNlbGVjdCh0aGlzLl9zZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgcmVzZXQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZ2V0QW5pbWF0ZWRFbGVtZW50cyhlbGVtZW50KTtcblxuICAgICAgICBsZXQgdiA9IHRoaXMuZ2V0UmVzZXRWYWx1ZSgpO1xuXG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgIWVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgdHJhbnNmb3JtYXRpb24gdG8gYWxsIGNvbXBvbmVudHMuXG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9wcm9wU2V0dGVycy5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgbSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcFNldHRlcnNbaV0oZWxlbWVudHNbal0sIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHNldCBzZWxlY3Rvcih2KSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gdjtcbiAgICB9XG5cbiAgICBzZXQgdCh2KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSB2O1xuICAgIH1cblxuICAgIGdldCByZXNldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzZXRWYWx1ZTtcbiAgICB9XG4gICAgXG4gICAgc2V0IHJlc2V0VmFsdWUodikge1xuICAgICAgICB0aGlzLl9yZXNldFZhbHVlID0gdjtcbiAgICAgICAgdGhpcy5faGFzUmVzZXRWYWx1ZSA9ICh2ICE9PSB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHNldCBydih2KSB7XG4gICAgICAgIHRoaXMucmVzZXRWYWx1ZSA9IHY7XG4gICAgfVxuXG4gICAgc2V0IHZhbHVlKHYpIHtcbiAgICAgICAgdGhpcy5faXRlbXMucGFyc2UodGhpcy5oYXNDb2xvclByb3BlcnR5KCksIHYpO1xuICAgIH1cblxuICAgIHNldCB2KHYpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHY7XG4gICAgfVxuXG4gICAgc2V0IHByb3BlcnRpZXModikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIHYgPSBbdl07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wcm9wcyA9IFtdO1xuXG4gICAgICAgIHYuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJvcHMucHVzaChwcm9wKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BTZXR0ZXJzLnB1c2goRWxlbWVudC5nZXRTZXR0ZXIocHJvcCkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXQgcHJvcGVydHkodikge1xuICAgICAgICB0aGlzLl9oYXNDb2xvclByb3BlcnR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB2O1xuICAgIH1cblxuICAgIHNldCBwKHYpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gdjtcbiAgICB9XG5cbiAgICBwYXRjaChzZXR0aW5ncykge1xuICAgICAgICBCYXNlLnBhdGNoT2JqZWN0KHRoaXMsIHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBoYXNDb2xvclByb3BlcnR5KCkge1xuICAgICAgICBpZiAodGhpcy5faGFzQ29sb3JQcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNDb2xvclByb3BlcnR5ID0gdGhpcy5fcHJvcHMubGVuZ3RoID8gRWxlbWVudC5pc0NvbG9yUHJvcGVydHkodGhpcy5fcHJvcHNbMF0pIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0NvbG9yUHJvcGVydHk7XG4gICAgfVxufVxuXG5BbmltYXRpb25BY3Rpb25TZXR0aW5ncy5wcm90b3R5cGUuaXNBbmltYXRpb25BY3Rpb25TZXR0aW5ncyA9IHRydWU7XG5cbmltcG9ydCBNdWx0aVNwbGluZSBmcm9tIFwiLi4vdG9vbHMvTXVsdGlTcGxpbmUubWpzXCI7XG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi4vdHJlZS9FbGVtZW50Lm1qc1wiO1xuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4uL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdHJlZS9VdGlscy5tanNcIjtcbmltcG9ydCBCYXNlIGZyb20gXCIuLi90cmVlL0Jhc2UubWpzXCI7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25NYW5hZ2VyIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcblxuICAgICAgICB0aGlzLnN0YWdlLm9uKCdmcmFtZVN0YXJ0JywgKCkgPT4gdGhpcy5wcm9ncmVzcygpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHJ1bm5pbmcgYW5pbWF0aW9ucyBvbiBhdHRhY2hlZCBzdWJqZWN0cy5cbiAgICAgICAgICogQHR5cGUge1NldDxBbmltYXRpb24+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmUgPSBuZXcgU2V0KCk7XG4gICAgfVxuXG4gICAgcHJvZ3Jlc3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZS5zaXplKSB7XG4gICAgICAgICAgICBsZXQgZHQgPSB0aGlzLnN0YWdlLmR0O1xuXG4gICAgICAgICAgICBsZXQgZmlsdGVyID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHJvZ3Jlc3MoZHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IG5ldyBTZXQoWy4uLnRoaXMuYWN0aXZlXS5maWx0ZXIodCA9PiB0LmlzQWN0aXZlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZUFuaW1hdGlvbihlbGVtZW50LCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHNldHRpbmdzKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBwbGFpbiBvYmplY3QgdG8gcHJvcGVyIHNldHRpbmdzIG9iamVjdC5cbiAgICAgICAgICAgIHNldHRpbmdzID0gdGhpcy5jcmVhdGVTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbihcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBzZXR0aW5ncyxcbiAgICAgICAgICAgIGVsZW1lbnRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBjcmVhdGVTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICBjb25zdCBhbmltYXRpb25TZXR0aW5ncyA9IG5ldyBBbmltYXRpb25TZXR0aW5ncygpO1xuICAgICAgICBCYXNlLnBhdGNoT2JqZWN0KGFuaW1hdGlvblNldHRpbmdzLCBzZXR0aW5ncyk7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25TZXR0aW5ncztcbiAgICB9XG5cbiAgICBhZGRBY3RpdmUodHJhbnNpdGlvbikge1xuICAgICAgICB0aGlzLmFjdGl2ZS5hZGQodHJhbnNpdGlvbik7XG4gICAgfVxufVxuXG5pbXBvcnQgQmFzZSBmcm9tIFwiLi4vdHJlZS9CYXNlLm1qc1wiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi90cmVlL1V0aWxzLm1qc1wiO1xuaW1wb3J0IEFuaW1hdGlvblNldHRpbmdzIGZyb20gXCIuL0FuaW1hdGlvblNldHRpbmdzLm1qc1wiO1xuaW1wb3J0IEFuaW1hdGlvbiBmcm9tIFwiLi9BbmltYXRpb24ubWpzXCI7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuaW1wb3J0IEFuaW1hdGlvbkFjdGlvblNldHRpbmdzIGZyb20gXCIuL0FuaW1hdGlvbkFjdGlvblNldHRpbmdzLm1qc1wiO1xuaW1wb3J0IEJhc2UgZnJvbSBcIi4uL3RyZWUvQmFzZS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uU2V0dGluZ3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FuaW1hdGlvbkFjdGlvblNldHRpbmdzW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hY3Rpb25zID0gW107XG5cbiAgICAgICAgdGhpcy5kZWxheSA9IDA7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAxO1xuXG4gICAgICAgIHRoaXMucmVwZWF0ID0gMDtcbiAgICAgICAgdGhpcy5yZXBlYXRPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLnJlcGVhdERlbGF5ID0gMDtcblxuICAgICAgICB0aGlzLmF1dG9zdG9wID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5zdG9wTWV0aG9kID0gQW5pbWF0aW9uU2V0dGluZ3MuU1RPUF9NRVRIT0RTLkZBREU7XG4gICAgICAgIHRoaXMuX3N0b3BUaW1pbmdGdW5jdGlvbiA9ICdlYXNlJztcbiAgICAgICAgdGhpcy5fc3RvcFRpbWluZ0Z1bmN0aW9uSW1wbCA9IFN0YWdlVXRpbHMuZ2V0VGltaW5nRnVuY3Rpb24odGhpcy5fc3RvcFRpbWluZ0Z1bmN0aW9uKTtcbiAgICAgICAgdGhpcy5zdG9wRHVyYXRpb24gPSAwO1xuICAgICAgICB0aGlzLnN0b3BEZWxheSA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IGFjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zO1xuICAgIH1cblxuICAgIHNldCBhY3Rpb25zKHYpIHtcbiAgICAgICAgdGhpcy5fYWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHYubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gdltpXTtcbiAgICAgICAgICAgIGlmICghZS5pc0FuaW1hdGlvbkFjdGlvblNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWFzID0gbmV3IEFuaW1hdGlvbkFjdGlvblNldHRpbmdzKHRoaXMpO1xuICAgICAgICAgICAgICAgIGFhcy5wYXRjaChlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zLnB1c2goYWFzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgYW5pbWF0aW9uIHRvIHRoZSBzcGVjaWZpZWQgZWxlbWVudCwgZm9yIHRoZSBzcGVjaWZpZWQgcHJvZ3Jlc3MgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudDtcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcDtcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yO1xuICAgICAqL1xuICAgIGFwcGx5KGVsZW1lbnQsIHAsIGZhY3RvciA9IDEpIHtcbiAgICAgICAgdGhpcy5fYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgYWN0aW9uLmFwcGx5KGVsZW1lbnQsIHAsIGZhY3Rvcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgYW5pbWF0aW9uIHRvIHRoZSByZXNldCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50O1xuICAgICAqL1xuICAgIHJlc2V0KGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgYWN0aW9uLnJlc2V0KGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXQgc3RvcFRpbWluZ0Z1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcFRpbWluZ0Z1bmN0aW9uO1xuICAgIH1cblxuICAgIHNldCBzdG9wVGltaW5nRnVuY3Rpb24odikge1xuICAgICAgICB0aGlzLl9zdG9wVGltaW5nRnVuY3Rpb24gPSB2O1xuICAgICAgICB0aGlzLl9zdG9wVGltaW5nRnVuY3Rpb25JbXBsID0gU3RhZ2VVdGlscy5nZXRUaW1pbmdGdW5jdGlvbih2KTtcbiAgICB9XG5cbiAgICBnZXQgc3RvcFRpbWluZ0Z1bmN0aW9uSW1wbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BUaW1pbmdGdW5jdGlvbkltcGw7XG4gICAgfVxuXG4gICAgcGF0Y2goc2V0dGluZ3MpIHtcbiAgICAgICAgQmFzZS5wYXRjaE9iamVjdCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgfVxuXG59XG5cbkFuaW1hdGlvblNldHRpbmdzLlNUT1BfTUVUSE9EUyA9IHtcbiAgICBGQURFOiAnZmFkZScsXG4gICAgUkVWRVJTRTogJ3JldmVyc2UnLFxuICAgIEZPUldBUkQ6ICdmb3J3YXJkJyxcbiAgICBJTU1FRElBVEU6ICdpbW1lZGlhdGUnLFxuICAgIE9ORVRPVFdPOiAnb25ldG90d28nXG59O1xuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCIuLi9FdmVudEVtaXR0ZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zaXRpb24gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gICAgY29uc3RydWN0b3IobWFuYWdlciwgc2V0dGluZ3MsIGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcblxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHNldHRpbmdzO1xuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICAgIHRoaXMuX2dldHRlciA9IGVsZW1lbnQuY29uc3RydWN0b3IuZ2V0R2V0dGVyKHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5fc2V0dGVyID0gZWxlbWVudC5jb25zdHJ1Y3Rvci5nZXRTZXR0ZXIocHJvcGVydHkpO1xuXG4gICAgICAgIHRoaXMuX21lcmdlciA9IHNldHRpbmdzLm1lcmdlcjtcblxuICAgICAgICBpZiAoIXRoaXMuX21lcmdlcikge1xuICAgICAgICAgICAgdGhpcy5fbWVyZ2VyID0gZWxlbWVudC5jb25zdHJ1Y3Rvci5nZXRNZXJnZXIocHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMuX2dldHRlcih0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0VmFsdWUgPSB0aGlzLl9zdGFydFZhbHVlO1xuXG4gICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICB0aGlzLl9kZWxheUxlZnQgPSAwO1xuICAgIH1cblxuICAgIHN0YXJ0KHRhcmdldFZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLl9nZXR0ZXIodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCB0cmFuc2l0aW9ucyBvbiBub24tYXR0YWNoZWQgZWxlbWVudHMuIEp1c3Qgc2V0IHZhbHVlIHdpdGhvdXQgaW52b2tpbmcgbGlzdGVuZXJzLlxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0VmFsdWUgPSB0YXJnZXRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRHJhd1ZhbHVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0VmFsdWUgPT09IHRoaXMuX3N0YXJ0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KHRhcmdldFZhbHVlLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0VmFsdWUgPSB0YXJnZXRWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWxheUxlZnQgPSB0aGlzLl9zZXR0aW5ncy5kZWxheTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3AgPCAxKSB7XG4gICAgICAgICAgICAvLyBWYWx1ZSBzZXR0aW5nIGFuZCB3aWxsIG11c3QgYmUgaW52b2tlZCAoYXN5bmMpIHVwb24gbmV4dCB0cmFuc2l0aW9uIGN5Y2xlLlxuICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgICAvLyBKdXN0IHN0b3Agd2hlcmUgdGhlIHRyYW5zaXRpb24gaXMgYXQuXG4gICAgICAgIHRoaXMuZW1pdCgnc3RvcCcpO1xuICAgICAgICB0aGlzLm1hbmFnZXIucmVtb3ZlQWN0aXZlKHRoaXMpO1xuICAgIH1cblxuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG5cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuYWRkQWN0aXZlKHRoaXMpO1xuICAgIH1cblxuICAgIHJlc2V0KHRhcmdldFZhbHVlLCBwKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgdHJhbnNpdGlvbnMgb24gbm9uLWF0dGFjaGVkIGVsZW1lbnRzLiBKdXN0IHNldCB2YWx1ZSB3aXRob3V0IGludm9raW5nIGxpc3RlbmVycy5cbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLl9nZXR0ZXIodGhpcy5fZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRWYWx1ZSA9IHRhcmdldFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEcmF3VmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLl9nZXR0ZXIodGhpcy5fZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRWYWx1ZSA9IHRhcmdldFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICAgICAgICB0aGlzLmFkZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3VwZGF0ZURyYXdWYWx1ZSgpIHtcbiAgICAgICAgdGhpcy5fc2V0dGVyKHRoaXMuX2VsZW1lbnQsIHRoaXMuZ2V0RHJhd1ZhbHVlKCkpO1xuICAgIH1cblxuICAgIGFkZCgpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmFkZEFjdGl2ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBpc0F0dGFjaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5hdHRhY2hlZDtcbiAgICB9XG5cbiAgICBpc1J1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fcCA8IDEuMCk7XG4gICAgfVxuXG4gICAgcHJvZ3Jlc3MoZHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgLy8gU2tpcCB0byBlbmQgb2YgdHJhbnNpdGlvbiBzbyB0aGF0IGl0IGlzIHJlbW92ZWQuXG4gICAgICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnAgPCAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxheUxlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsYXlMZWZ0IC09IGR0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXlMZWZ0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBkdCA9IC10aGlzLmRlbGF5TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsYXlMZWZ0ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RlbGF5RW5kJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmR1cmF0aW9uID09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcCArPSBkdCAvIHRoaXMuX3NldHRpbmdzLmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3AgPj0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmlzaGVkITtcbiAgICAgICAgICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZURyYXdWYWx1ZSgpO1xuXG4gICAgICAgIHRoaXMuaW52b2tlTGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgaW52b2tlTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgdGhpcy5wKTtcbiAgICAgICAgaWYgKHRoaXMucCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVRhcmdldFZhbHVlKHRhcmdldFZhbHVlKSB7XG4gICAgICAgIGxldCB0ID0gdGhpcy5fc2V0dGluZ3MudGltaW5nRnVuY3Rpb25JbXBsKHRoaXMucCk7XG4gICAgICAgIGlmICh0ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRWYWx1ZSA9IHRhcmdldFZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLl90YXJnZXRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFZhbHVlID0gdGFyZ2V0VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFZhbHVlID0gdGFyZ2V0VmFsdWUgLSAoKHRhcmdldFZhbHVlIC0gdGhpcy5fdGFyZ2V0VmFsdWUpIC8gKDEgLSB0KSk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRWYWx1ZSA9IHRhcmdldFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0RHJhd1ZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5wID49IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHYgPSB0aGlzLl9zZXR0aW5ncy5fdGltaW5nRnVuY3Rpb25JbXBsKHRoaXMucCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVyZ2VyKHRoaXMudGFyZ2V0VmFsdWUsIHRoaXMuc3RhcnRWYWx1ZSwgdik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBza2lwRGVsYXkoKSB7XG4gICAgICAgIHRoaXMuX2RlbGF5TGVmdCA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IHN0YXJ0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydFZhbHVlO1xuICAgIH1cblxuICAgIGdldCB0YXJnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldFZhbHVlO1xuICAgIH1cblxuICAgIGdldCBwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcDtcbiAgICB9XG5cbiAgICBnZXQgZGVsYXlMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVsYXlMZWZ0O1xuICAgIH1cblxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICB9XG5cbiAgICBnZXQgc2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncztcbiAgICB9XG5cbiAgICBzZXQgc2V0dGluZ3Modikge1xuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHY7XG4gICAgfVxuXG59XG5cblRyYW5zaXRpb24ucHJvdG90eXBlLmlzVHJhbnNpdGlvbiA9IHRydWU7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc2l0aW9uTWFuYWdlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG5cbiAgICAgICAgdGhpcy5zdGFnZS5vbignZnJhbWVTdGFydCcsICgpID0+IHRoaXMucHJvZ3Jlc3MoKSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCB0cmFuc2l0aW9ucyB0aGF0IGFyZSBydW5uaW5nIGFuZCBhdHRhY2hlZC5cbiAgICAgICAgICogKHdlIGRvbid0IHN1cHBvcnQgdHJhbnNpdGlvbnMgb24gdW4tYXR0YWNoZWQgZWxlbWVudHMgdG8gcHJldmVudCBtZW1vcnkgbGVha3MpXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8VHJhbnNpdGlvbj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IG5ldyBTZXQoKTtcblxuICAgICAgICB0aGlzLmRlZmF1bHRUcmFuc2l0aW9uU2V0dGluZ3MgPSBuZXcgVHJhbnNpdGlvblNldHRpbmdzKHRoaXMuc3RhZ2UpO1xuICAgIH1cblxuICAgIHByb2dyZXNzKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGR0ID0gdGhpcy5zdGFnZS5kdDtcblxuICAgICAgICAgICAgbGV0IGZpbHRlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgYS5wcm9ncmVzcyhkdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IG5ldyBTZXQoWy4uLnRoaXMuYWN0aXZlXS5maWx0ZXIodCA9PiAodC5pc1J1bm5pbmcoKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZVNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25TZXR0aW5ncyA9IG5ldyBUcmFuc2l0aW9uU2V0dGluZ3MoKTtcbiAgICAgICAgQmFzZS5wYXRjaE9iamVjdCh0cmFuc2l0aW9uU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zaXRpb25TZXR0aW5ncztcbiAgICB9XG5cbiAgICBhZGRBY3RpdmUodHJhbnNpdGlvbikge1xuICAgICAgICB0aGlzLmFjdGl2ZS5hZGQodHJhbnNpdGlvbik7XG4gICAgfVxuXG4gICAgcmVtb3ZlQWN0aXZlKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhpcy5hY3RpdmUuZGVsZXRlKHRyYW5zaXRpb24pO1xuICAgIH1cbn1cblxuaW1wb3J0IEJhc2UgZnJvbSBcIi4uL3RyZWUvQmFzZS5tanNcIjtcbmltcG9ydCBUcmFuc2l0aW9uU2V0dGluZ3MgZnJvbSBcIi4vVHJhbnNpdGlvblNldHRpbmdzLm1qc1wiO1xuaW1wb3J0IFRyYW5zaXRpb24gZnJvbSBcIi4vVHJhbnNpdGlvbi5tanNcIjtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5pbXBvcnQgQmFzZSBmcm9tIFwiLi4vdHJlZS9CYXNlLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc2l0aW9uU2V0dGluZ3Mge1xuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcbiAgICAgICAgdGhpcy5fdGltaW5nRnVuY3Rpb24gPSAnZWFzZSc7XG4gICAgICAgIHRoaXMuX3RpbWluZ0Z1bmN0aW9uSW1wbCA9IFN0YWdlVXRpbHMuZ2V0VGltaW5nRnVuY3Rpb24odGhpcy5fdGltaW5nRnVuY3Rpb24pO1xuICAgICAgICB0aGlzLmRlbGF5ID0gMDtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDAuMjtcbiAgICAgICAgdGhpcy5tZXJnZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGdldCB0aW1pbmdGdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWluZ0Z1bmN0aW9uO1xuICAgIH1cblxuICAgIHNldCB0aW1pbmdGdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX3RpbWluZ0Z1bmN0aW9uID0gdjtcbiAgICAgICAgdGhpcy5fdGltaW5nRnVuY3Rpb25JbXBsID0gU3RhZ2VVdGlscy5nZXRUaW1pbmdGdW5jdGlvbih2KTtcbiAgICB9XG5cbiAgICBnZXQgdGltaW5nRnVuY3Rpb25JbXBsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGltaW5nRnVuY3Rpb25JbXBsO1xuICAgIH1cblxuICAgIHBhdGNoKHNldHRpbmdzKSB7XG4gICAgICAgIEJhc2UucGF0Y2hPYmplY3QodGhpcywgc2V0dGluZ3MpO1xuICAgIH1cbn1cblxuVHJhbnNpdGlvblNldHRpbmdzLnByb3RvdHlwZS5pc1RyYW5zaXRpb25TZXR0aW5ncyA9IHRydWU7XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4vQ29tcG9uZW50Lm1qc1wiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi90cmVlL1V0aWxzLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHBsaWNhdGlvbiBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30sIHByb3BlcnRpZXMpIHtcbiAgICAgICAgLy8gU2F2ZSBvcHRpb25zIHRlbXBvcmFyaWx5IHRvIGF2b2lkIGhhdmluZyB0byBwYXNzIGl0IHRocm91Z2ggdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICBBcHBsaWNhdGlvbi5fdGVtcF9vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICAvLyBCb290aW5nIGZsYWcgaXMgdXNlZCB0byBwb3N0cG9uZSB1cGRhdGVGb2N1c1NldHRpbmdzO1xuICAgICAgICBBcHBsaWNhdGlvbi5ib290aW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc3RhZ2UgPSBuZXcgU3RhZ2Uob3B0aW9ucy5zdGFnZSk7XG4gICAgICAgIHN1cGVyKHN0YWdlLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgQXBwbGljYXRpb24uYm9vdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX191cGRhdGVGb2N1c0NvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9fa2V5cHJlc3NUaW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX19ob3ZlcmVkQ2hpbGQgPSBudWxsO1xuXG4gICAgICAgIC8vIFdlIG11c3QgY29uc3RydWN0IHdoaWxlIHRoZSBhcHBsaWNhdGlvbiBpcyBub3QgeWV0IGF0dGFjaGVkLlxuICAgICAgICAvLyBUaGF0J3Mgd2h5IHdlICdpbml0JyB0aGUgc3RhZ2UgbGF0ZXIgKHdoaWNoIGFjdHVhbGx5IGVtaXRzIHRoZSBhdHRhY2ggZXZlbnQpLlxuICAgICAgICB0aGlzLnN0YWdlLmluaXQoKTtcblxuICAgICAgICAvLyBJbml0aWFsbHksIHRoZSBmb2N1cyBzZXR0aW5ncyBhcmUgdXBkYXRlZCBhZnRlciBib3RoIHRoZSBzdGFnZSBhbmQgYXBwbGljYXRpb24gYXJlIGNvbnN0cnVjdGVkLlxuICAgICAgICB0aGlzLnVwZGF0ZUZvY3VzU2V0dGluZ3MoKTtcblxuICAgICAgICB0aGlzLl9fa2V5bWFwID0gdGhpcy5nZXRPcHRpb24oJ2tleXMnKTtcblxuICAgICAgICBpZiAodGhpcy5fX2tleW1hcCkge1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5wbGF0Zm9ybS5yZWdpc3RlcktleWRvd25IYW5kbGVyKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjZWl2ZUtleWRvd24oZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5zdGFnZS5wbGF0Zm9ybS5yZWdpc3RlcktleXVwSGFuZGxlcigoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY2VpdmVLZXl1cChlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9uKFwiZW5hYmxlUG9pbnRlclwiKSkge1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5wbGF0Zm9ybS5yZWdpc3RlckNsaWNrSGFuZGxlcigoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY2VpdmVDbGljayhlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnN0YWdlLnBsYXRmb3JtLnJlZ2lzdGVySG92ZXJIYW5kbGVyKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjZWl2ZUhvdmVyKGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhZ2UucGxhdGZvcm0ucmVnaXN0ZXJTY3JvbGxXaGVlbEhhbmRsZXIoKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNpZXZlU2Nyb2xsV2hlZWwoZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRPcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29wdGlvbnNbbmFtZV07XG4gICAgfVxuXG4gICAgX3NldE9wdGlvbnMobykge1xuICAgICAgICB0aGlzLl9fb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIGxldCBvcHQgPSAobmFtZSwgZGVmKSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBvW25hbWVdO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19vcHRpb25zW25hbWVdID0gZGVmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fb3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0KCdkZWJ1ZycsIGZhbHNlKTtcbiAgICAgICAgb3B0KCdrZXlzJywge1xuICAgICAgICAgICAgMzg6IFwiVXBcIixcbiAgICAgICAgICAgIDQwOiBcIkRvd25cIixcbiAgICAgICAgICAgIDM3OiBcIkxlZnRcIixcbiAgICAgICAgICAgIDM5OiBcIlJpZ2h0XCIsXG4gICAgICAgICAgICAxMzogXCJFbnRlclwiLFxuICAgICAgICAgICAgODogXCJCYWNrXCIsXG4gICAgICAgICAgICAyNzogXCJFeGl0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdCgnZW5hYmxlUG9pbnRlcicsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBfX2NvbnN0cnVjdCgpIHtcbiAgICAgICAgdGhpcy5zdGFnZS5zZXRBcHBsaWNhdGlvbih0aGlzKTtcblxuICAgICAgICB0aGlzLl9zZXRPcHRpb25zKEFwcGxpY2F0aW9uLl90ZW1wX29wdGlvbnMpO1xuICAgICAgICBkZWxldGUgQXBwbGljYXRpb24uX3RlbXBfb3B0aW9ucztcblxuICAgICAgICBzdXBlci5fX2NvbnN0cnVjdCgpO1xuICAgIH1cblxuICAgIF9faW5pdCgpIHtcbiAgICAgICAgc3VwZXIuX19pbml0KCk7XG4gICAgICAgIHRoaXMuX191cGRhdGVGb2N1cygpO1xuICAgIH1cblxuICAgIHVwZGF0ZUZvY3VzUGF0aCgpIHtcbiAgICAgICAgdGhpcy5fX3VwZGF0ZUZvY3VzKCk7XG4gICAgfVxuXG4gICAgX191cGRhdGVGb2N1cygpIHtcbiAgICAgICAgY29uc3Qgbm90T3ZlcnJpZGRlbiA9IHRoaXMuX191cGRhdGVGb2N1c1JlYygpO1xuXG4gICAgICAgIGlmICghQXBwbGljYXRpb24uYm9vdGluZyAmJiBub3RPdmVycmlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvY3VzU2V0dGluZ3MoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9fdXBkYXRlRm9jdXNSZWMoKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUZvY3VzSWQgPSArK3RoaXMuX191cGRhdGVGb2N1c0NvdW50ZXI7XG4gICAgICAgIHRoaXMuX191cGRhdGVGb2N1c0lkID0gdXBkYXRlRm9jdXNJZDtcblxuICAgICAgICBjb25zdCBuZXdGb2N1c1BhdGggPSB0aGlzLl9fZ2V0Rm9jdXNQYXRoKCk7XG4gICAgICAgIGNvbnN0IG5ld0ZvY3VzZWRDb21wb25lbnQgPSBuZXdGb2N1c1BhdGhbbmV3Rm9jdXNQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBwcmV2Rm9jdXNlZENvbXBvbmVudCA9IHRoaXMuX2ZvY3VzUGF0aCA/IHRoaXMuX2ZvY3VzUGF0aFt0aGlzLl9mb2N1c1BhdGgubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKCFwcmV2Rm9jdXNlZENvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gRm9jdXMgZXZlbnRzLlxuICAgICAgICAgICAgdGhpcy5fZm9jdXNQYXRoID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IG5ld0ZvY3VzUGF0aC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb2N1c1BhdGgucHVzaChuZXdGb2N1c1BhdGhbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzUGF0aFtpXS5fZm9jdXMobmV3Rm9jdXNlZENvbXBvbmVudCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmb2N1c092ZXJyaWRkZW4gPSAodGhpcy5fX3VwZGF0ZUZvY3VzSWQgIT09IHVwZGF0ZUZvY3VzSWQpO1xuICAgICAgICAgICAgICAgIGlmIChmb2N1c092ZXJyaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG0gPSBNYXRoLm1pbih0aGlzLl9mb2N1c1BhdGgubGVuZ3RoLCBuZXdGb2N1c1BhdGgubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IG07IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZm9jdXNQYXRoW2luZGV4XSAhPT0gbmV3Rm9jdXNQYXRoW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mb2N1c1BhdGgubGVuZ3RoICE9PSBuZXdGb2N1c1BhdGgubGVuZ3RoIHx8IGluZGV4ICE9PSBuZXdGb2N1c1BhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRPcHRpb24oJ2RlYnVnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tMaWdodG5pbmddIEZvY3VzIGNoYW5nZWQ6ICcgKyBuZXdGb2N1c2VkQ29tcG9uZW50LmdldExvY2F0aW9uU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVuZm9jdXMgZXZlbnRzLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9mb2N1c1BhdGgubGVuZ3RoIC0gMTsgaSA+PSBpbmRleDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuZm9jdXNlZEVsZW1lbnQgPSB0aGlzLl9mb2N1c1BhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHVuZm9jdXNlZEVsZW1lbnQuX3VuZm9jdXMobmV3Rm9jdXNlZENvbXBvbmVudCwgcHJldkZvY3VzZWRDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb2N1c092ZXJyaWRkZW4gPSAodGhpcy5fX3VwZGF0ZUZvY3VzSWQgIT09IHVwZGF0ZUZvY3VzSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNPdmVycmlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGb2N1cyBldmVudHMuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4LCBuID0gbmV3Rm9jdXNQYXRoLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb2N1c1BhdGgucHVzaChuZXdGb2N1c1BhdGhbaV0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb2N1c1BhdGhbaV0uX2ZvY3VzKG5ld0ZvY3VzZWRDb21wb25lbnQsIHByZXZGb2N1c2VkQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9jdXNPdmVycmlkZGVuID0gKHRoaXMuX191cGRhdGVGb2N1c0lkICE9PSB1cGRhdGVGb2N1c0lkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzT3ZlcnJpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRm9jdXMgY2hhbmdlZCBldmVudHMuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzUGF0aFtpXS5fZm9jdXNDaGFuZ2UobmV3Rm9jdXNlZENvbXBvbmVudCwgcHJldkZvY3VzZWRDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHVwZGF0ZUZvY3VzU2V0dGluZ3MoKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzZWRDb21wb25lbnQgPSB0aGlzLl9mb2N1c1BhdGhbdGhpcy5fZm9jdXNQYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIC8vIEdldCBmb2N1cyBzZXR0aW5ncy4gVGhlc2UgY2FuIGJlIHVzZWQgZm9yIGR5bmFtaWMgYXBwbGljYXRpb24td2lkZSBzZXR0aW5ncyB0aGF0IGRlcGVuZCBvbiB0aGVcbiAgICAgICAgLy8gZm9jdXMgZGlyZWN0bHkgKHN1Y2ggYXMgdGhlIGFwcGxpY2F0aW9uIGJhY2tncm91bmQpLlxuICAgICAgICBjb25zdCBmb2N1c1NldHRpbmdzID0ge307XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTZXRGb2N1c1NldHRpbmdzID0gQ29tcG9uZW50LnByb3RvdHlwZS5fc2V0Rm9jdXNTZXR0aW5ncztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9mb2N1c1BhdGgubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZm9jdXNQYXRoW2ldLl9zZXRGb2N1c1NldHRpbmdzICE9PSBkZWZhdWx0U2V0Rm9jdXNTZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzUGF0aFtpXS5fc2V0Rm9jdXNTZXR0aW5ncyhmb2N1c1NldHRpbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlZmF1bHRIYW5kbGVGb2N1c1NldHRpbmdzID0gQ29tcG9uZW50LnByb3RvdHlwZS5faGFuZGxlRm9jdXNTZXR0aW5ncztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9mb2N1c1BhdGgubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZm9jdXNQYXRoW2ldLl9oYW5kbGVGb2N1c1NldHRpbmdzICE9PSBkZWZhdWx0SGFuZGxlRm9jdXNTZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzUGF0aFtpXS5faGFuZGxlRm9jdXNTZXR0aW5ncyhmb2N1c1NldHRpbmdzLCB0aGlzLl9fcHJldkZvY3VzU2V0dGluZ3MsIGZvY3VzZWRDb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3ByZXZGb2N1c1NldHRpbmdzID0gZm9jdXNTZXR0aW5ncztcbiAgICB9XG5cbiAgICBfaGFuZGxlRm9jdXNTZXR0aW5ncyhzZXR0aW5ncywgcHJldlNldHRpbmdzLCBmb2N1c2VkLCBwcmV2Rm9jdXNlZCkge1xuICAgICAgICAvLyBPdmVycmlkZSB0byBoYW5kbGUgZm9jdXMtYmFzZWQgc2V0dGluZ3MuXG4gICAgfVxuXG4gICAgX19nZXRGb2N1c1BhdGgoKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBbdGhpc107XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgbmV4dEZvY3VzID0gY3VycmVudC5fZ2V0Rm9jdXNlZCgpO1xuICAgICAgICAgICAgaWYgKCFuZXh0Rm9jdXMgfHwgKG5leHRGb2N1cyA9PT0gY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgbGV0IHB0ciA9IG5leHRGb2N1cy5jcGFyZW50O1xuICAgICAgICAgICAgaWYgKHB0ciA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHBhdGgucHVzaChuZXh0Rm9jdXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgYW4gaW1tZWRpYXRlIGNoaWxkOiBpbmNsdWRlIGZ1bGwgcGF0aCB0byBkZXNjZW5kYW50LlxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhcnRzID0gW25leHRGb2N1c107XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXB0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5fdGhyb3dFcnJvcihcIlJldHVybiB2YWx1ZSBmb3IgX2dldEZvY3VzZWQgbXVzdCBiZSBhbiBhdHRhY2hlZCBkZXNjZW5kYW50IGNvbXBvbmVudCBidXQgaXRzICdcIiArIG5leHRGb2N1cy5nZXRMb2NhdGlvblN0cmluZygpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcnRzLnB1c2gocHRyKTtcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLmNwYXJlbnQ7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocHRyICE9PSBjdXJyZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGVtIHJldmVyc2VkLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbmV3UGFydHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChuZXdQYXJ0c1tuIC0gaSAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0Rm9jdXM7XG4gICAgICAgIH0gd2hpbGUodHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgZ2V0IGZvY3VzUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzUGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmplY3RzIGFuIGV2ZW50IGluIHRoZSBzdGF0ZSBtYWNoaW5lcywgdG9wLWRvd24gZnJvbSBhcHBsaWNhdGlvbiB0byBmb2N1c2VkIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBmb2N1c1RvcERvd25FdmVudChldmVudHMsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuZm9jdXNQYXRoO1xuICAgICAgICBjb25zdCBuID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgICAgLy8gTXVsdGlwbGUgZXZlbnRzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBwYXRoW2ldLl9nZXRNb3N0U3BlY2lmaWNIYW5kbGVkTWVtYmVyKGV2ZW50cyk7XG4gICAgICAgICAgICBpZiAoZXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gcGF0aFtpXVtldmVudF0oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5qZWN0cyBhbiBldmVudCBpbiB0aGUgc3RhdGUgbWFjaGluZXMsIGJvdHRvbS11cCBmcm9tIGZvY3VzZWQgY29tcG9uZW50IHRvIGFwcGxpY2F0aW9uLlxuICAgICAqL1xuICAgIGZvY3VzQm90dG9tVXBFdmVudChldmVudHMsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuZm9jdXNQYXRoO1xuICAgICAgICBjb25zdCBuID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgICAgLy8gTXVsdGlwbGUgZXZlbnRzLlxuICAgICAgICBmb3IgKGxldCBpID0gbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHBhdGhbaV0uX2dldE1vc3RTcGVjaWZpY0hhbmRsZWRNZW1iZXIoZXZlbnRzKTtcbiAgICAgICAgICAgIGlmIChldmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBwYXRoW2ldW2V2ZW50XSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBfcmVjZWl2ZUtleWRvd24oZSkge1xuICAgICAgICBjb25zdCBvYmogPSBlO1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLl9fa2V5bWFwW2Uua2V5Q29kZV07XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmZvY3VzUGF0aDtcblxuICAgICAgICBsZXQga2V5cztcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleSA6IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNUaW1lciA9IHRoaXMuX19rZXlwcmVzc1RpbWVycy5oYXMoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBldmVudCBmcm9tIGdldHRpbmcgZmlyZWQgd2hlbiB0aGUgdGltZW91dCBpcyBzdGlsbCBhY3RpdmVcbiAgICAgICAgICAgICAgICBpZiAocGF0aFtwYXRoLmxlbmd0aCAtIDFdLmxvbmdwcmVzcyAmJiBoYXNUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmZvY3VzVG9wRG93bkV2ZW50KFtgX2NhcHR1cmUke2tleXNbaV19YCwgXCJfY2FwdHVyZUtleVwiXSwgb2JqKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmZvY3VzQm90dG9tVXBFdmVudChbYF9oYW5kbGUke2tleXNbaV19YCwgXCJfaGFuZGxlS2V5XCJdLCBvYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5mb2N1c1RvcERvd25FdmVudChbXCJfY2FwdHVyZUtleVwiXSwgb2JqKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UuYXBwbGljYXRpb24uZm9jdXNCb3R0b21VcEV2ZW50KFtcIl9oYW5kbGVLZXlcIl0sIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUZvY3VzUGF0aCgpO1xuXG4gICAgICAgIGNvbnN0IGNvbnN1bWVyID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChrZXlzICYmIGNvbnN1bWVyLmxvbmdwcmVzcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0TG9uZ3ByZXNzVGltZXIoa2V5c1tpXSwgY29uc3VtZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogS2V5dXAgbGlzdGVuZXJcbiAgICAgKiBUbyB0YWtlIGF3YXkgc29tZSBjb25mdXNpb24gd2UgYWRkIGBSZWxlYXNlYCB0byB0aGUgZXZlbnQgdG8gcHJldmVudCBlbmRpbmcgdXAgd2l0aCBtZXRob2QgbmFtZXMgbGlrZTpcbiAgICAgKiAgX2hhbmRsZUxlZnRVcCAvIF9oYW5kbGVVcFVwIC8gX2hhbmRsZUVudGVyVXAgZXRjXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlY2VpdmVLZXl1cChlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGU7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuX19rZXltYXBbZS5rZXlDb2RlXTtcblxuICAgICAgICBsZXQga2V5cztcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleSA6IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhZ2UuYXBwbGljYXRpb24uZm9jdXNUb3BEb3duRXZlbnQoW2BfY2FwdHVyZSR7a2V5c1tpXX1SZWxlYXNlYCwgXCJfY2FwdHVyZUtleVJlbGVhc2VcIl0sIG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5mb2N1c0JvdHRvbVVwRXZlbnQoW2BfaGFuZGxlJHtrZXlzW2ldfVJlbGVhc2VgLCBcIl9oYW5kbGVLZXlSZWxlYXNlXCJdLCBvYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5mb2N1c1RvcERvd25FdmVudChbXCJfY2FwdHVyZUtleVJlbGVhc2VcIl0sIG9iaikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmZvY3VzQm90dG9tVXBFdmVudChbXCJfaGFuZGxlS2V5UmVsZWFzZVwiXSwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlRm9jdXNQYXRoKCk7XG5cbiAgICAgICAgaWYgKGtleXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2tleXByZXNzVGltZXJzLmhhcyhrZXlzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBrZXl1cCBoYXMgZmlyZWQgYmVmb3JlIGVuZCBvZiB0aW1lb3V0IHNvIHdlIGNsZWFyIGl0XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9fa2V5cHJlc3NUaW1lcnMuZ2V0KGtleXNbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIHNvIHdlIGNhbiByZWdpc3RlciBpdCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fa2V5cHJlc3NUaW1lcnMuZGVsZXRlKGtleXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbmQgc3RhcnRzIGEgdGltZXIgZm9yIHRoZSBwcmVzc2VkIGtleS4gVGltZXIgd2lsbCBiZSBjbGVhcmVkIHdoZW4gdGhlIGtleSBpcyByZWxlYXNlZFxuICAgICAqIGJlZm9yZSB0aGUgdGltZXIgZ29lcyBvZmYuXG4gICAgICpcbiAgICAgKiBJZiBrZXkgaXMgbm90IHJlbGVhc2UgKGtleXVwKSB0aGUgbG9uZ3ByZXNzIGhhbmRsZXIgd2lsbCBiZSBmaXJlZC5cbiAgICAgKiBDb25maWd1cmF0aW9uIGNhbiBiZSB2aWEgdGhlIENvbXBvbmVudHMgdGVtcGxhdGU6XG4gICAgICpcbiAgICAgKiBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgICAqICAgICByZXR1cm4ge1xuICAgICAqICAgICAgICAgdzoxMDAsIGg6MTAwLFxuICAgICAqICAgICAgICAgbG9uZ3ByZXNzOnt1cDo3MDAsIGRvd246NTAwfVxuICAgICAqICAgICB9XG4gICAgICogfSAgICAgKlxuICAgICAqIC8vIHRoaXMgd2lsbCBnZXQgY2FsbGVkIHdoZW4gdXAgaGFzIGJlZW4gcHJlc3NlZCBmb3IgNzAwbXNcbiAgICAgKiBfaGFuZGxlVXBMb25nKCkge1xuICAgICAqXG4gICAgICogfVxuICAgICAqXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc3RhcnRMb25ncHJlc3NUaW1lcihrZXksIGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZWxlbWVudC5sb25ncHJlc3M7XG4gICAgICAgIGNvbnN0IGxvb2t1cCA9IGtleS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChjb25maWdbbG9va3VwXSkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IGNvbmZpZ1tsb29rdXBdO1xuICAgICAgICAgICAgaWYgKCFVdGlscy5pc051bWJlcih0aW1lb3V0KSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuX3Rocm93RXJyb3IoXCJjb25maWcgdmFsdWUgZm9yIGxvbmdwcmVzcyBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fa2V5cHJlc3NUaW1lcnMuc2V0KGtleSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5mb2N1c1RvcERvd25FdmVudChbYF9jYXB0dXJlJHtrZXl9TG9uZ2AsIFwiX2NhcHR1cmVLZXlcIl0sIHt9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5mb2N1c0JvdHRvbVVwRXZlbnQoW2BfaGFuZGxlJHtrZXl9TG9uZ2AsIFwiX2hhbmRsZUtleVwiXSwge30pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2tleXByZXNzVGltZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQgfHwgNTAwIC8qIHByZXZlbnQgMG1zICovKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9yZWNpZXZlU2Nyb2xsV2hlZWwoZSkge1xuICAgICAgICBjb25zdCBvYmogPSBlO1xuICAgICAgICBjb25zdCB7Y2xpZW50WCwgY2xpZW50WX0gPSBvYmo7XG5cbiAgICAgICAgaWYgKGNsaWVudFggPD0gdGhpcy5zdGFnZS53ICYmIGNsaWVudFkgPD0gdGhpcy5zdGFnZS5oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlyZVRvcERvd25TY3JvbGxXaGVlbEhhbmRsZXIoXCJfY2FwdHVyZVNjcm9sbFwiLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlQm90dG9tVXBTY3JvbGxXaGVlbEhhbmRsZXIoXCJfaGFuZGxlU2Nyb2xsXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaXJlVG9wRG93blNjcm9sbFdoZWVsSGFuZGxlcihldmVudCwgb2JqKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuc3RhZ2UuYXBwbGljYXRpb24uY2hpbGRyZW47XG4gICAgICAgIGxldCBhZmZlY3RlZCA9IHRoaXMuX2ZpbmRDaGlsZHJlbihbXSwgY2hpbGRyZW4pLnJldmVyc2UoKTtcbiAgICAgICAgbGV0IG4gPSBhZmZlY3RlZC5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUobi0tKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGFmZmVjdGVkW25dO1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLl9jYXB0dXJlU2Nyb2xsKG9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmaXJlQm90dG9tVXBTY3JvbGxXaGVlbEhhbmRsZXIoZXZlbnQsIG9iaikge1xuICAgICAgICBjb25zdCB7Y2xpZW50WCwgY2xpZW50WX0gPSBvYmo7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2dldFRhcmdldENoaWxkKGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICBsZXQgY2hpbGQgPSB0YXJnZXQ7XG5cbiAgICAgICAgLy8gU2VhcmNoIHRyZWUgYm90dG9tIHVwIGZvciBhIGhhbmRsZXJcbiAgICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGRbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuX2hhbmRsZVNjcm9sbChvYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIF9yZWNlaXZlQ2xpY2soZSkge1xuICAgICAgICBjb25zdCBvYmogPSBlO1xuICAgICAgICBjb25zdCB7Y2xpZW50WCwgY2xpZW50WX0gPSBvYmo7XG5cbiAgICAgICAgaWYgKGNsaWVudFggPD0gdGhpcy5zdGFnZS53ICYmIGNsaWVudFkgPD0gdGhpcy5zdGFnZS5oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmZpcmVCb3R0b21VcENsaWNrSGFuZGxlcihvYmopO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmlyZUJvdHRvbVVwQ2xpY2tIYW5kbGVyKG9iaikge1xuICAgICAgICBjb25zdCB7Y2xpZW50WCwgY2xpZW50WX0gPSBvYmo7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2dldFRhcmdldENoaWxkKGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICBsZXQgY2hpbGQgPSB0YXJnZXQ7XG5cbiAgICAgICAgLy8gU2VhcmNoIHRyZWUgYm90dG9tIHVwIGZvciBhIGhhbmRsZXJcbiAgICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGRbXCJfaGFuZGxlQ2xpY2tcIl0pIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5faGFuZGxlQ2xpY2sodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3JlY2VpdmVIb3ZlcihlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGU7XG4gICAgICAgIGNvbnN0IHtjbGllbnRYLCBjbGllbnRZfSA9IG9iajtcblxuICAgICAgICBpZiAoY2xpZW50WCA8PSB0aGlzLnN0YWdlLncgJiYgY2xpZW50WSA8PSB0aGlzLnN0YWdlLmgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYXBwbGljYXRpb24uZmlyZUJvdHRvbVVwSG92ZXJIYW5kbGVyKG9iaik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaXJlQm90dG9tVXBIb3ZlckhhbmRsZXIob2JqKSB7XG4gICAgICAgIGNvbnN0IHtjbGllbnRYLCBjbGllbnRZfSA9IG9iajtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fZ2V0VGFyZ2V0Q2hpbGQoY2xpZW50WCwgY2xpZW50WSk7XG5cbiAgICAgICAgLy8gT25seSBmaXJlIGhhbmRsZXJzIHdoZW4gcG9pbnRlciB0YXJnZXQgY2hhbmdlc1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB0aGlzLl9faG92ZXJlZENoaWxkKSB7XG5cbiAgICAgICAgICAgIGxldCBob3ZlcmVkQnJhbmNoID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbGV0IG5ld0hvdmVyZWRCcmFuY2ggPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBuZXdIb3ZlcmVkQnJhbmNoID0gbmV3IFNldCh0YXJnZXQuZ2V0QW5jZXN0b3JzKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fX2hvdmVyZWRDaGlsZCkge1xuICAgICAgICAgICAgICAgIGhvdmVyZWRCcmFuY2ggPSBuZXcgU2V0KHRoaXMuX19ob3ZlcmVkQ2hpbGQuZ2V0QW5jZXN0b3JzKCkpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBbLi4uaG92ZXJlZEJyYW5jaF0uZmlsdGVyKChlKSA9PiAhbmV3SG92ZXJlZEJyYW5jaC5oYXMoZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY1tcIl9oYW5kbGVVbmhvdmVyXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLl9oYW5kbGVVbmhvdmVyKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudCAmJiBlbGVtLnBhcmVudC5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UuZ2V0Q2FudmFzKCkuc3R5bGUuY3Vyc29yID0gZWxlbS5wYXJlbnQuY3Vyc29yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9faG92ZXJlZENoaWxkID0gdGFyZ2V0O1xuXG4gICAgICAgICAgICBjb25zdCBkaWZmQnJhbmNoID0gWy4uLm5ld0hvdmVyZWRCcmFuY2hdLmZpbHRlcigoZSkgPT4gIWhvdmVyZWRCcmFuY2guaGFzKGUpKVxuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtIG9mIGRpZmZCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gQ29tcG9uZW50LmdldENvbXBvbmVudChlbGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoY1tcIl9oYW5kbGVIb3ZlclwiXSkge1xuICAgICAgICAgICAgICAgICAgICBjLl9oYW5kbGVIb3ZlcihlbGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5ldyBlbGVtZW50IGhvdmVyIGN1cnNvclxuICAgICAgICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSBkaWZmQnJhbmNoWzBdO1xuICAgICAgICAgICAgaWYgKGxhc3RFbGVtZW50ICYmIGxhc3RFbGVtZW50LmN1cnNvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UuZ2V0Q2FudmFzKCkuc3R5bGUuY3Vyc29yID0gbGFzdEVsZW1lbnQuY3Vyc29yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXJ1biBfaGFuZGxlSG92ZXIgZm9yIHRhcmdldCBlbGVtZW50IGluIGNhc2UgaXQncyBiZWVuIGhvdmVyZWRcbiAgICAgICAgICAgIC8vIGJhY2sgZnJvbSBpdHMgY2hpbGRcbiAgICAgICAgICAgIGlmIChkaWZmQnJhbmNoLmxlbmd0aCA9PT0gMCAmJiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gQ29tcG9uZW50LmdldENvbXBvbmVudCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmIChjW1wiX2hhbmRsZUhvdmVyXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuX2hhbmRsZUhvdmVyKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFRhcmdldENoaWxkKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5jaGlsZHJlbjtcbiAgICAgICAgbGV0IGFmZmVjdGVkID0gdGhpcy5fZmluZENoaWxkcmVuKFtdLCBjaGlsZHJlbik7XG4gICAgICAgIGxldCBob3ZlcmFibGVDaGlsZHJlbiA9IHRoaXMuX3dpdGhpbkNsaWNrYWJsZVJhbmdlKGFmZmVjdGVkLCBjbGllbnRYLCBjbGllbnRZKTtcblxuICAgICAgICBob3ZlcmFibGVDaGlsZHJlbi5zb3J0KChhLGIpID0+IHtcbiAgICAgICAgICAgIC8vIFNvcnQgYnkgekluZGV4IGFuZCB0aGVuIGlkXG4gICAgICAgICAgICBpZiAoYS56SW5kZXggPiBiLnpJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhLnpJbmRleCA8IGIuekluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pZCA+IGIuaWQgPyAxOiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhvdmVyYWJsZUNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gQXNzdW1lIHRhcmdldCBoYXMgaGlnaGVzdCB6SW5kZXggKGlkIHdoZW4gekluZGV4IGVxdWFsKVxuICAgICAgICAgICAgcmV0dXJuIGhvdmVyYWJsZUNoaWxkcmVuLnNsaWNlKC0xKVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2ZpbmRDaGlsZHJlbihidWNrZXQsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW25dO1xuICAgICAgICAgICAgLy8gb25seSBhZGQgYWN0aXZlIGNoaWxkcmVuXG4gICAgICAgICAgICBpZiAoY2hpbGQuX19hY3RpdmUgJiYgY2hpbGQuY29sbGlzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNvbGxpc2lvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBidWNrZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmRDaGlsZHJlbihidWNrZXQsIGNoaWxkLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1Y2tldDtcbiAgICB9XG5cbiAgICBfd2l0aGluQ2xpY2thYmxlUmFuZ2UoYWZmZWN0ZWRDaGlsZHJlbiwgY3Vyc29yWCwgY3Vyc29yWSkge1xuICAgICAgICBsZXQgbiA9IGFmZmVjdGVkQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gW107XG5cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFmZmVjdGVkIGNoaWxkcmVuXG4gICAgICAgIC8vIGFuZCBwZXJmb3JtIGNvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBhZmZlY3RlZENoaWxkcmVuW25dO1xuICAgICAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gdGhpcy5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNoaWxkLmNvcmUuX3dvcmxkQ29udGV4dDtcblxuICAgICAgICAgICAgY29uc3QgY3ggPSBjdHgucHggKiBwcmVjaXNpb247XG4gICAgICAgICAgICBjb25zdCBjeSA9IGN0eC5weSAqIHByZWNpc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IGN3ID0gY2hpbGQuZmluYWxXICogY3R4LnRhICogcHJlY2lzaW9uO1xuICAgICAgICAgICAgY29uc3QgY2ggPSBjaGlsZC5maW5hbEggKiBjdHgudGQgKiBwcmVjaXNpb247XG5cbiAgICAgICAgICAgIGlmIChjeCA+IHRoaXMuc3RhZ2UudyB8fCBjeSA+IHRoaXMuc3RhZ2UuaCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50LmNvcmUuX3NjaXNzb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2lzc29yID0gY2hpbGQucGFyZW50LmNvcmUuX3NjaXNzb3IubWFwKCh2KSA9PiB2ICogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Rlc3RDb2xsaXNpb24oY3Vyc29yWCwgY3Vyc29yWSwgLi4uc2Npc3NvcikpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXN0Q29sbGlzaW9uKGN1cnNvclgsIGN1cnNvclksIGN4LCBjeSwgY3csIGNoKSkge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZXM7XG4gICAgfVxuXG4gICAgX3Rlc3RDb2xsaXNpb24ocHgsIHB5LCBjeCwgY3ksIGN3LCBjaCkge1xuICAgICAgICBpZiAocHggPj0gY3ggJiZcbiAgICAgICAgICAgIHB4IDw9IGN4ICsgY3cgJiZcbiAgICAgICAgICAgIHB5ID49IGN5ICYmXG4gICAgICAgICAgICBweSA8PSBjeSArIGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9kZXN0cm95KCkge1xuICAgICAgICAvLyBUaGlzIGZvcmNlcyB0aGUgX2RldGFjaCwgX2Rpc2FibGVkIGFuZCBfYWN0aXZlIGV2ZW50cyB0byBiZSBjYWxsZWQuXG4gICAgICAgIHRoaXMuc3RhZ2Uuc2V0QXBwbGljYXRpb24odW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQXR0YWNoZWRGbGFnKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUVuYWJsZWRGbGFnKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX19rZXlwcmVzc1RpbWVycy5zaXplKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuX19rZXlwcmVzc1RpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX19rZXlwcmVzc1RpbWVycy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q2FudmFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFnZS5nZXRDYW52YXMoKTtcbiAgICB9XG5cbn1cblxuaW1wb3J0IFN0YWdlIGZyb20gXCIuLi90cmVlL1N0YWdlLm1qc1wiO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL3RyZWUvRWxlbWVudC5tanNcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdHJlZS9VdGlscy5tanNcIjtcbmltcG9ydCBTdGF0ZU1hY2hpbmUgZnJvbSBcIi4vU3RhdGVNYWNoaW5lLm1qc1wiO1xuXG4vKipcbiAqIEBleHRlbmRzIFN0YXRlTWFjaGluZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcblxuICAgICAgICAvLyBFbmNhcHN1bGF0ZSB0YWdzIHRvIHByZXZlbnQgbGVha2luZy5cbiAgICAgICAgdGhpcy50YWdSb290ID0gdHJ1ZTtcblxuICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19maXJzdEFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fZmlyc3RFbmFibGUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9fc2lnbmFscyA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0aGlzLl9fcGFzc1NpZ25hbHMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy5fX2NvbnN0cnVjdCgpO1xuXG4gICAgICAgIC8vIFF1aWNrLWFwcGx5IHRlbXBsYXRlLlxuICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXRUZW1wbGF0ZUZ1bmModGhpcyk7XG4gICAgICAgIGZ1bmMuZih0aGlzLCBmdW5jLmEpO1xuXG4gICAgICAgIHRoaXMuX2J1aWxkKCk7XG4gICAgfVxuXG4gICAgX19zdGFydCgpIHtcbiAgICAgICAgU3RhdGVNYWNoaW5lLnNldHVwU3RhdGVNYWNoaW5lKHRoaXMpO1xuICAgICAgICB0aGlzLl9vblN0YXRlQ2hhbmdlID0gQ29tcG9uZW50LnByb3RvdHlwZS5fX29uU3RhdGVDaGFuZ2U7XG4gICAgfVxuXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKTtcbiAgICB9XG5cbiAgICBfX29uU3RhdGVDaGFuZ2UoKSB7XG4gICAgICAgIC8qIEZJWE1FOiBXb3JrYXJvdW5kIGZvciBjYXNlLCB3aGVyZSBhcHBsaWNhdGlvbiB3YXMgc2h1dCBidXQgY29tcG9uZW50IHN0aWxsIGxpdmVzICovXG4gICAgICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLnVwZGF0ZUZvY3VzUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3JlZm9jdXMoKSB7XG4gICAgICAgIC8qIEZJWE1FOiBXb3JrYXJvdW5kIGZvciBjYXNlLCB3aGVyZSBhcHBsaWNhdGlvbiB3YXMgc2h1dCBidXQgY29tcG9uZW50IHN0aWxsIGxpdmVzICovXG4gICAgICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLnVwZGF0ZUZvY3VzUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGJpbmRQcm9wKG5hbWUsIGZ1bmMgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7X19wcm9wZXJ0eUJpbmRpbmc6IHRydWUsIF9fbmFtZTogbmFtZSwgX19mdW5jOiBmdW5jfTtcbiAgICB9XG5cbiAgICBfX2JpbmRQcm9wZXJ0eShwcm9wT2JqLCB0YXJnZXRPYmosIHRhcmdldFByb3ApIHtcbiAgICAgICAgLy8gMS4gZmluZCBiaW5kaW5nIHBvc2l0aW9uOiBmaW5kIG9iamVjdCBhbmQgcHJvcGVydHkgbmFtZSB0byBiZSBib3VuZFxuICAgICAgICBjb25zdCBvYmogPSB0YXJnZXRPYmo7XG4gICAgICAgIGNvbnN0IHByb3AgPSB0YXJnZXRQcm9wO1xuICAgICAgICBjb25zdCBwcm9wRGVwZW5kZW5jaWVzID0gQXJyYXkuaXNBcnJheShwcm9wT2JqLl9fbmFtZSkgPyBwcm9wT2JqLl9fbmFtZSA6IFtwcm9wT2JqLl9fbmFtZV07XG5cbiAgICAgICAgLy8gMi4gY3JlYXRlIHNldHRlcnMgZm9yIGV2ZXJ5IGdpdmVuIGRlcGVuZGVuY3lcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wRGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IHByb3BEZXBlbmRlbmNpZXNbaV07XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gcHJvcE9iai5fX2Z1bmMgPyBwcm9wT2JqLl9fZnVuYyA6IChjb250ZXh0KSA9PiBjb250ZXh0W3Byb3BOYW1lXTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbYF9fcHJvcF9iaW5kaW5nc18ke3Byb3BOYW1lfWBdID0gW3tfX29iajogb2JqLCBfX3Byb3A6IHByb3AsIF9fZnVuYzogZnVuY31dO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tgX19wcm9wXyR7cHJvcE5hbWV9YF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qge19fb2JqLCBfX3Byb3AsIF9fZnVuY30gb2YgdGhpc1tgX19wcm9wX2JpbmRpbmdzXyR7cHJvcE5hbWV9YF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX29ialtfX3Byb3BdID0gX19mdW5jKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHRoaXNbYF9fcHJvcF8ke3Byb3BOYW1lfWBdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbYF9fcHJvcF9iaW5kaW5nc18ke3Byb3BOYW1lfWBdLnB1c2goe19fb2JqOiBvYmosIF9fcHJvcDogcHJvcCwgX19mdW5jOiBmdW5jfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgaGlnaC1wZXJmb3JtYW5jZSB0ZW1wbGF0ZSBwYXRjaGVyLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRUZW1wbGF0ZUZ1bmMoY3R4KSB7XG4gICAgICAgIC8vIFdlIG5lZWQgYSBkaWZmZXJlbnQgdGVtcGxhdGUgZnVuY3Rpb24gcGVyIHBhdGNoIGlkLlxuICAgICAgICBjb25zdCBuYW1lID0gXCJfdGVtcGxhdGVGdW5jXCI7XG5cbiAgICAgICAgLy8gQmUgY2FyZWZ1bCB3aXRoIGNsYXNzLWJhc2VkIHN0YXRpYyBpbmhlcml0YW5jZS5cbiAgICAgICAgY29uc3QgaGFzTmFtZSA9ICdfX2hhcycgKyBuYW1lO1xuICAgICAgICBpZiAodGhpc1toYXNOYW1lXSAhPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpc1toYXNOYW1lXSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdGhpcy5wYXJzZVRlbXBsYXRlKHRoaXMuX3RlbXBsYXRlKGN0eCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW25hbWVdO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZVRlbXBsYXRlKG9iaikge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgbG9jOiBbXSxcbiAgICAgICAgICAgIHN0b3JlOiBbXSxcbiAgICAgICAgICAgIHJpZDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucGFyc2VUZW1wbGF0ZVJlYyhvYmosIGNvbnRleHQsIFwiZWxlbWVudFwiKTtcblxuICAgICAgICBjb25zdCBjb2RlID0gY29udGV4dC5sb2Muam9pbihcIjtcXG5cIik7XG4gICAgICAgIGNvbnN0IGYgPSBuZXcgRnVuY3Rpb24oXCJlbGVtZW50XCIsIFwic3RvcmVcIiwgY29kZSk7XG4gICAgICAgIHJldHVybiB7ZjogZiwgYTogY29udGV4dC5zdG9yZX07XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlVGVtcGxhdGVSZWMob2JqLCBjb250ZXh0LCBjdXJzb3IpIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBjb250ZXh0LnN0b3JlO1xuICAgICAgICBjb25zdCBsb2MgPSBjb250ZXh0LmxvYztcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNVY0NoYXIoa2V5LmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gVmFsdWUgbXVzdCBiZSBleHBhbmRlZCBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZi5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdXJzb3IgPSBgciR7a2V5LnJlcGxhY2UoL1teYS16MC05XS9naSwgXCJcIikgKyBjb250ZXh0LnJpZH1gO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IHZhbHVlLnR5cGUgPyB2YWx1ZS50eXBlIDogRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGB2YXIgJHtjaGlsZEN1cnNvcn0gPSBlbGVtZW50LnN0YWdlLmNyZWF0ZUVsZW1lbnQoKWApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGB2YXIgJHtjaGlsZEN1cnNvcn0gPSBuZXcgc3RvcmVbJHtzdG9yZS5sZW5ndGggLSAxfV0oJHtjdXJzb3J9LnN0YWdlKWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke2NoaWxkQ3Vyc29yfS5yZWYgPSBcIiR7a2V5fVwiYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmlkKys7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRW50ZXIgc3ViLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVGVtcGxhdGVSZWModmFsdWUsIGNvbnRleHQsIGNoaWxkQ3Vyc29yKTtcblxuICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtjdXJzb3J9LmNoaWxkTGlzdC5hZGQoJHtjaGlsZEN1cnNvcn0pYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRHluYW1pYyBhc3NpZ25tZW50LlxuICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7Y3Vyc29yfS5jaGlsZExpc3QuYWRkKHN0b3JlWyR7c3RvcmUubGVuZ3RoIC0gMX1dKWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcEtleSA9IGN1cnNvciArIFwiX190ZXh0XCI7XG4gICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGB2YXIgJHtwcm9wS2V5fSA9ICR7Y3Vyc29yfS5lbmFibGVUZXh0VGV4dHVyZSgpYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5fX3Byb3BlcnR5QmluZGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgYmluZGluZyBlbnRpcmUgb2JqZWN0cyB0byB0ZXh0IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGBlbGVtZW50Ll9fYmluZFByb3BlcnR5KHN0b3JlWyR7c3RvcmUubGVuZ3RoIC0gMX1dLCAke2N1cnNvcn0sIFwiJHtrZXl9XCIpYCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVGVtcGxhdGVQcm9wUmVjKHZhbHVlLCBjb250ZXh0LCBwcm9wS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInNoYWRlclwiICYmIFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhZGVyQ3Vyc29yID0gYCR7Y3Vyc29yfVtcInNoYWRlclwiXWBcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke2N1cnNvcn1bXCIke2tleX1cIl0gPSBzdG9yZVske3N0b3JlLmxlbmd0aCAtIDF9XWApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlUHJvcGVydHlCaW5kaW5ncyh2YWx1ZSwgY29udGV4dCwgc2hhZGVyQ3Vyc29yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ0ZXh0dXJlXCIgJiYgVXRpbHMuaXNPYmplY3RMaXRlcmFsKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wS2V5ID0gY3Vyc29yICsgXCJfX3RleHR1cmVcIjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IHZhbHVlLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYHZhciAke3Byb3BLZXl9ID0gbmV3IHN0b3JlWyR7c3RvcmUubGVuZ3RoIC0gMX1dKCR7Y3Vyc29yfS5zdGFnZSlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VUZW1wbGF0ZVByb3BSZWModmFsdWUsIGNvbnRleHQsIHByb3BLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7Y3Vyc29yfVtcIiR7a2V5fVwiXSA9ICR7cHJvcEtleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke3Byb3BLZXl9ID0gJHtjdXJzb3J9LnRleHR1cmVgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VUZW1wbGF0ZVByb3BSZWModmFsdWUsIGNvbnRleHQsIHByb3BLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwodmFsdWUpICYmIHZhbHVlLl9fcHJvcGVydHlCaW5kaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgZWxlbWVudC5fX2JpbmRQcm9wZXJ0eShzdG9yZVske3N0b3JlLmxlbmd0aCAtIDF9XSwgJHtjdXJzb3J9LCBcIiR7a2V5fVwiKWApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbHMuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtjdXJzb3J9W1wiJHtrZXl9XCJdID0gJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtjdXJzb3J9W1wiJHtrZXl9XCJdID0gJHt2YWx1ZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwifWApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzT2JqZWN0KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRHluYW1pYyBhc3NpZ25tZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBsaXRlcmFsIG9iamVjdHMgbWF5IGNvbnRhaW4gZHluYW1pY3MsIHdlIHN0b3JlIHRoZSBmdWxsIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7Y3Vyc29yfVtcIiR7a2V5fVwiXSA9IHN0b3JlWyR7c3RvcmUubGVuZ3RoIC0gMX1dYCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgZXRjLlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7Y3Vyc29yfVtcIiR7a2V5fVwiXSA9ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2VUZW1wbGF0ZVByb3BSZWMob2JqLCBjb250ZXh0LCBjdXJzb3IpIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBjb250ZXh0LnN0b3JlO1xuICAgICAgICBjb25zdCBsb2MgPSBjb250ZXh0LmxvYztcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7Y3Vyc29yfVtcIiR7a2V5fVwiXSA9ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke2N1cnNvcn1bXCIke2tleX1cIl0gPSAke3ZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCJ9YCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUuX19wcm9wZXJ0eUJpbmRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGBlbGVtZW50Ll9fYmluZFByb3BlcnR5KHN0b3JlWyR7c3RvcmUubGVuZ3RoIC0gMX1dLCAke2N1cnNvcn0sIFwiJHtrZXl9XCIpYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc09iamVjdCh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRHluYW1pYyBhc3NpZ25tZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIGxpdGVyYWwgb2JqZWN0cyBtYXkgY29udGFpbiBkeW5hbWljcywgd2Ugc3RvcmUgdGhlIGZ1bGwgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7Y3Vyc29yfVtcIiR7a2V5fVwiXSA9IHN0b3JlWyR7c3RvcmUubGVuZ3RoIC0gMX1dYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7Y3Vyc29yfVtcIiR7a2V5fVwiXSA9ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlUHJvcGVydHlCaW5kaW5ncyhvYmosIGNvbnRleHQsIGN1cnNvcikge1xuICAgICAgICBjb25zdCBzdG9yZSA9IGNvbnRleHQuc3RvcmU7XG4gICAgICAgIGNvbnN0IGxvYyA9IGNvbnRleHQubG9jO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcInR5cGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2YWx1ZSkgJiYgdmFsdWUuX19wcm9wZXJ0eUJpbmRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGBlbGVtZW50Ll9fYmluZFByb3BlcnR5KHN0b3JlWyR7c3RvcmUubGVuZ3RoIC0gMX1dLCAke2N1cnNvcn0sIFwiJHtrZXl9XCIpYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfb25TZXR1cCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0dXAoKSB7XG4gICAgfVxuXG4gICAgX29uQXR0YWNoKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5fX2luaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX19pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hdHRhY2goKTtcbiAgICB9XG5cbiAgICBfYXR0YWNoKCkge1xuICAgIH1cblxuICAgIF9vbkRldGFjaCgpIHtcbiAgICAgICAgdGhpcy5fZGV0YWNoKCk7XG4gICAgfVxuXG4gICAgX2RldGFjaCgpIHtcbiAgICB9XG5cbiAgICBfb25FbmFibGVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19maXJzdEVuYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fZmlyc3RFbmFibGUoKTtcbiAgICAgICAgICAgIHRoaXMuX19maXJzdEVuYWJsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbmFibGUoKTtcbiAgICB9XG5cbiAgICBfZmlyc3RFbmFibGUoKSB7XG4gICAgfVxuXG4gICAgX2VuYWJsZSgpIHtcbiAgICB9XG5cbiAgICBfb25EaXNhYmxlZCgpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZSgpO1xuICAgIH1cblxuICAgIF9kaXNhYmxlKCkge1xuICAgIH1cblxuICAgIF9vbkFjdGl2ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZmlyc3RBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0QWN0aXZlKCk7XG4gICAgICAgICAgICB0aGlzLl9fZmlyc3RBY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlKCk7XG4gICAgfVxuXG4gICAgX2ZpcnN0QWN0aXZlKCkge1xuICAgIH1cblxuICAgIF9hY3RpdmUoKSB7XG4gICAgfVxuXG4gICAgX29uSW5hY3RpdmUoKSB7XG4gICAgICAgIHRoaXMuX2luYWN0aXZlKCk7XG4gICAgfVxuXG4gICAgX2luYWN0aXZlKCkge1xuICAgIH1cblxuICAgIGdldCBhcHBsaWNhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhZ2UuYXBwbGljYXRpb247XG4gICAgfVxuXG4gICAgX19jb25zdHJ1Y3QoKSB7XG4gICAgICAgIHRoaXMuX2NvbnN0cnVjdCgpO1xuICAgIH1cblxuICAgIF9jb25zdHJ1Y3QoKSB7XG4gICAgfVxuXG4gICAgX2J1aWxkKCkge1xuICAgIH1cblxuICAgIF9faW5pdCgpIHtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cblxuICAgIF9pbml0KCkge1xuICAgIH1cblxuICAgIF9mb2N1cyhuZXdUYXJnZXQsIHByZXZUYXJnZXQpIHtcbiAgICB9XG5cbiAgICBfdW5mb2N1cyhuZXdUYXJnZXQpIHtcbiAgICB9XG5cbiAgICBfZm9jdXNDaGFuZ2UodGFyZ2V0LCBuZXdUYXJnZXQpIHtcbiAgICB9XG5cbiAgICBfZ2V0Rm9jdXNlZCgpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdG8gZGVsZWdhdGUgZm9jdXMgdG8gY2hpbGQgY29tcG9uZW50cy5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX3NldEZvY3VzU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdG8gYWRkIGN1c3RvbSBzZXR0aW5ncy4gU2VlIEFwcGxpY2F0aW9uLl9oYW5kbGVGb2N1c1NldHRpbmdzKCkuXG4gICAgfVxuXG4gICAgX2hhbmRsZUZvY3VzU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdG8gcmVhY3Qgb24gY3VzdG9tIHNldHRpbmdzLiBTZWUgQXBwbGljYXRpb24uX2hhbmRsZUZvY3VzU2V0dGluZ3MoKS5cbiAgICB9XG5cbiAgICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgaGFzRmluYWxGb2N1cygpIHtcbiAgICAgICAgbGV0IHBhdGggPSB0aGlzLmFwcGxpY2F0aW9uLl9mb2N1c1BhdGg7XG4gICAgICAgIHJldHVybiBwYXRoICYmIHBhdGgubGVuZ3RoICYmIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gdGhpcztcbiAgICB9XG5cbiAgICBoYXNGb2N1cygpIHtcbiAgICAgICAgbGV0IHBhdGggPSB0aGlzLmFwcGxpY2F0aW9uLl9mb2N1c1BhdGg7XG4gICAgICAgIHJldHVybiBwYXRoICYmIChwYXRoLmluZGV4T2YodGhpcykgPj0gMCk7XG4gICAgfVxuXG4gICAgZ2V0IGNwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnQuZ2V0UGFyZW50KHRoaXMpO1xuICAgIH1cblxuICAgIHNlZWtBbmNlc3RvckJ5VHlwZSh0eXBlKSB7XG4gICAgICAgIGxldCBjID0gdGhpcy5jcGFyZW50O1xuICAgICAgICB3aGlsZSAoYykge1xuICAgICAgICAgICAgaWYgKGMuY29uc3RydWN0b3IgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSBjLmNwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRTaGFyZWRBbmNlc3RvckNvbXBvbmVudChlbGVtZW50KSB7XG4gICAgICAgIGxldCBhbmNlc3RvciA9IHRoaXMuZ2V0U2hhcmVkQW5jZXN0b3IoZWxlbWVudCk7XG4gICAgICAgIHdoaWxlIChhbmNlc3RvciAmJiAhYW5jZXN0b3IuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmNlc3RvcjtcbiAgICB9XG5cbiAgICBnZXQgc2lnbmFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zaWduYWxzO1xuICAgIH1cblxuICAgIHNldCBzaWduYWxzKHYpIHtcbiAgICAgICAgaWYgKCFVdGlscy5pc09iamVjdExpdGVyYWwodikpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJTaWduYWxzOiBzcGVjaWZ5IGFuIG9iamVjdCB3aXRoIHNpZ25hbC10by1maXJlIG1hcHBpbmdzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19zaWduYWxzID0gdjtcbiAgICB9XG5cbiAgICBzZXQgYWx0ZXJTaWduYWxzKHYpIHtcbiAgICAgICAgaWYgKCFVdGlscy5pc09iamVjdExpdGVyYWwodikpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJTaWduYWxzOiBzcGVjaWZ5IGFuIG9iamVjdCB3aXRoIHNpZ25hbC10by1maXJlIG1hcHBpbmdzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fX3NpZ25hbHMpIHtcbiAgICAgICAgICAgIHRoaXMuX19zaWduYWxzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IGluIHYpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSB2W2tleV07XG4gICAgICAgICAgICBpZiAoZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX19zaWduYWxzW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX19zaWduYWxzW2tleV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHBhc3NTaWduYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3Bhc3NTaWduYWxzIHx8IHt9O1xuICAgIH1cblxuICAgIHNldCBwYXNzU2lnbmFscyh2KSB7XG4gICAgICAgIHRoaXMuX19wYXNzU2lnbmFscyA9IE9iamVjdC5hc3NpZ24odGhpcy5fX3Bhc3NTaWduYWxzIHx8IHt9LCB2KTtcbiAgICB9XG5cbiAgICBzZXQgYWx0ZXJQYXNzU2lnbmFscyh2KSB7XG4gICAgICAgIGlmICghVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYpKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiU2lnbmFsczogc3BlY2lmeSBhbiBvYmplY3Qgd2l0aCBzaWduYWwtdG8tZmlyZSBtYXBwaW5nc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX19wYXNzU2lnbmFscykge1xuICAgICAgICAgICAgdGhpcy5fX3Bhc3NTaWduYWxzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IGluIHYpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSB2W2tleV07XG4gICAgICAgICAgICBpZiAoZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX19wYXNzU2lnbmFsc1trZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fcGFzc1NpZ25hbHNba2V5XSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIHRoZSBwYXJlbnQgb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBBIHBhcmVudC9hbmNlc3RvciB0aGF0IHdpc2hlcyB0byBoYW5kbGUgdGhlIHNpZ25hbCBzaG91bGQgc2V0IHRoZSAnc2lnbmFscycgcHJvcGVydHkgb24gdGhpcyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAgICovXG4gICAgc2lnbmFsKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaWduYWwoZXZlbnQsIGFyZ3MpO1xuICAgIH1cblxuICAgIF9zaWduYWwoZXZlbnQsIGFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc2lnbmFsUGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50U2lnbmFsSGFuZGxlcigpO1xuICAgICAgICBpZiAoc2lnbmFsUGFyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fX3NpZ25hbHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlyZUV2ZW50ID0gdGhpcy5fX3NpZ25hbHNbZXZlbnRdO1xuICAgICAgICAgICAgICAgIGlmIChmaXJlRXZlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlyZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJlRXZlbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gXG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc0Z1bmN0aW9uKGZpcmVFdmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJlRXZlbnQoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbmFsUGFyZW50Ll9oYXNNZXRob2QoZmlyZUV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hbFBhcmVudFtmaXJlRXZlbnRdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcGFzc1NpZ25hbCA9ICh0aGlzLl9fcGFzc1NpZ25hbHMgJiYgdGhpcy5fX3Bhc3NTaWduYWxzW2V2ZW50XSk7XG4gICAgICAgICAgICBpZiAocGFzc1NpZ25hbCkge1xuICAgICAgICAgICAgICAgIC8vIEJ1YmJsZSB1cC5cbiAgICAgICAgICAgICAgICBpZiAocGFzc1NpZ25hbCAmJiBwYXNzU2lnbmFsICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2Ugc2lnbmFsIG5hbWUuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gcGFzc1NpZ25hbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsUGFyZW50Ll9zaWduYWwoZXZlbnQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFBhcmVudFNpZ25hbEhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNwYXJlbnQgPyB0aGlzLmNwYXJlbnQuX2dldFNpZ25hbEhhbmRsZXIoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgX2dldFNpZ25hbEhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaWduYWxQcm94eSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3BhcmVudCA/IHRoaXMuY3BhcmVudC5fZ2V0U2lnbmFsSGFuZGxlcigpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXQgX3NpZ25hbFByb3h5KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZmlyZUFuY2VzdG9ycyhuYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmICghbmFtZS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuY2VzdG9yIGV2ZW50IG5hbWUgbXVzdCBiZSBwcmVmaXhlZCBieSBkb2xsYXIgc2lnbi5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRTaWduYWxIYW5kbGVyKCk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuX2RvRmlyZUFuY2VzdG9ycyhuYW1lLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9kb0ZpcmVBbmNlc3RvcnMobmFtZSwgYXJncykge1xuICAgICAgICBpZiAodGhpcy5faGFzTWV0aG9kKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJlKG5hbWUsIC4uLmFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsUGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50U2lnbmFsSGFuZGxlcigpO1xuICAgICAgICAgICAgaWYgKHNpZ25hbFBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduYWxQYXJlbnQuX2RvRmlyZUFuY2VzdG9ycyhuYW1lLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjb2xsZWN0U3ViQ29tcG9uZW50cyhzdWJzLCBlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTGlzdCA9IGVsZW1lbnQuX19jaGlsZExpc3Q7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGNoaWxkTGlzdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkTGlzdC5nZXRBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vicy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBDb21wb25lbnQuY29sbGVjdFN1YkNvbXBvbmVudHMoc3VicywgY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRDb21wb25lbnQoZWxlbWVudCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiAhcGFyZW50LmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFBhcmVudChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnQuZ2V0Q29tcG9uZW50KGVsZW1lbnQucGFyZW50KTtcbiAgICB9XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNDb21wb25lbnQgPSB0cnVlO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVNYWNoaW5lIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBTdGF0ZU1hY2hpbmUuc2V0dXBTdGF0ZU1hY2hpbmUodGhpcyk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldHVwU3RhdGVNYWNoaW5lKHRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXRDb25zdHJ1Y3RvciA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3Qgcm91dGVyID0gU3RhdGVNYWNoaW5lLmNyZWF0ZSh0YXJnZXRDb25zdHJ1Y3Rvcik7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHJvdXRlci5wcm90b3R5cGUpO1xuICAgICAgICB0YXJnZXQuY29uc3RydWN0b3IgPSB0YXJnZXRDb25zdHJ1Y3RvcjtcbiAgICAgICAgdGFyZ2V0Ll9pbml0U3RhdGVNYWNoaW5lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YXRlIG1hY2hpbmUgaW1wbGVtZW50YXRpb24uXG4gICAgICogSXQgZXh0ZW5kcyB0aGUgb3JpZ2luYWwgdHlwZSBhbmQgc2hvdWxkIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgaW5zdGFuY2VzLlxuICAgICAqIFRoZSBvcmlnaW5hbCB0eXBlIGlzIGF2YWlsYWJsZSBhcyBzdGF0aWMgcHJvcGVydHkgJ29yaWdpbmFsJywgYW5kIGl0IG11c3QgYmUgdXNlZCB3aGVuIHN1YmNsYXNzaW5nIGFzIGZvbGxvd3M6XG4gICAgICogY29uc3QgdHlwZSA9IFN0YXRlTWFjaGluZS5jcmVhdGUoY2xhc3MgWW91ck5ld1N0YXRlTWFjaGluZUNsYXNzIGV4dGVuZHMgWW91ckJhc2VTdGF0ZU1hY2hpbmVDbGFzcy5vcmlnaW5hbCB7ICB9KVxuICAgICAqIEBwYXJhbSB7Q2xhc3N9IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7U3RhdGVNYWNoaW5lfVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUodHlwZSkge1xuICAgICAgICBpZiAoIXR5cGUuaGFzT3duUHJvcGVydHkoJ19zbScpKSB7XG4gICAgICAgICAgICAvLyBPbmx5IG5lZWQgdG8gcnVuIG9uY2UuXG4gICAgICAgICAgICBjb25zdCBzdGF0ZU1hY2hpbmVUeXBlID0gbmV3IFN0YXRlTWFjaGluZVR5cGUodHlwZSk7XG4gICAgICAgICAgICB0eXBlLl9zbSA9IHN0YXRlTWFjaGluZVR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZS5fc20ucm91dGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBzcGVjaWZpZWQgbWV0aG9kIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0geyouLi59IGFyZ3NcbiAgICAgKi9cbiAgICBmaXJlKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNNZXRob2QoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tldmVudF0oLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIHBhdGggKGZvciBleGFtcGxlIFwiSW5pdGlhbGl6ZWQuTG9hZGluZ1wiKS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5fX3BhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmZiBzdGF0ZVBhdGggaXMgKGFuIGFuY2VzdG9yIG9mKSBjdXJyZW50U3RhdGVQYXRoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZVBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudFN0YXRlUGF0aFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaW5TdGF0ZShzdGF0ZVBhdGgsIGN1cnJlbnRTdGF0ZVBhdGggPSB0aGlzLl9zdGF0ZS5fX3BhdGgpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zbS5nZXRTdGF0ZUJ5UGF0aChzdGF0ZVBhdGgpO1xuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLl9zbS5nZXRTdGF0ZUJ5UGF0aChjdXJyZW50U3RhdGVQYXRoKTtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBzdGF0ZS5fX2xldmVsO1xuICAgICAgICBjb25zdCBzdGF0ZUF0TGV2ZWwgPSBTdGF0ZU1hY2hpbmUuX2dldFN0YXRlQXRMZXZlbChjdXJyZW50U3RhdGUsIGxldmVsKTtcbiAgICAgICAgcmV0dXJuIChzdGF0ZUF0TGV2ZWwgPT09IHN0YXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBjbGFzcyBtZW1iZXIgaXMgZGVmaW5lZCBmb3IgdGhlIGN1cnJlbnRseSBzZXQgc3RhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc01lbWJlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlW25hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGNsYXNzIG1lbWJlciBpcyBhIG1ldGhvZCBmb3IgdGhlIGN1cnJlbnRseSBzZXQgc3RhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc01ldGhvZChuYW1lKSB7XG4gICAgICAgIGNvbnN0IG1lbWJlciA9IHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlW25hbWVdO1xuICAgICAgICByZXR1cm4gISFtZW1iZXIgJiYgKHR5cGVvZiBtZW1iZXIgPT09IFwiZnVuY3Rpb25cIilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2l0Y2hlcyB0byB0aGUgc3BlY2lmaWVkIHN0YXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZVBhdGhcbiAgICAgKiAgIFN1YnN0YXRlcyBhcmUgc2VwZXJhdGVkIGJ5IGEgdW5kZXJzY29yZXMgKGZvciBleGFtcGxlIFwiSW5pdGlhbGl6ZWQuTG9hZGluZ1wiKS5cbiAgICAgKiBAcGFyYW0geypbXX0gW2FyZ3NdXG4gICAgICogICBBcmdzIHRoYXQgYXJlIHN1cHBsaWVkIGluICRlbnRlciBhbmQgJGV4aXQgZXZlbnRzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0U3RhdGUoc3RhdGVQYXRoLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IHNldFN0YXRlSWQgPSArK3RoaXMuX3NldFN0YXRlQ291bnRlcjtcbiAgICAgICAgdGhpcy5fc2V0U3RhdGVJZCA9IHNldFN0YXRlSWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLl9fcGF0aCAhPT0gc3RhdGVQYXRoKSB7XG4gICAgICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAgICAgICAgICBsZXQgbmV3U3RhdGUgPSB0aGlzLl9zbS5fc3RhdGVNYXBbc3RhdGVQYXRoXTtcbiAgICAgICAgICAgIGlmICghbmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3Igc3VwZXIgc3RhdGUuXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzLl9zbS5nZXRTdGF0ZUJ5UGF0aChzdGF0ZVBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLl9zdGF0ZTtcblxuICAgICAgICAgICAgY29uc3QgaGFzRGlmZmVyZW50RW50ZXJNZXRob2QgPSAobmV3U3RhdGUucHJvdG90eXBlLiRlbnRlciAhPT0gdGhpcy5fc3RhdGUucHJvdG90eXBlLiRlbnRlcik7XG4gICAgICAgICAgICBjb25zdCBoYXNEaWZmZXJlbnRFeGl0TWV0aG9kID0gKG5ld1N0YXRlLnByb3RvdHlwZS4kZXhpdCAhPT0gdGhpcy5fc3RhdGUucHJvdG90eXBlLiRleGl0KTtcbiAgICAgICAgICAgIGlmIChoYXNEaWZmZXJlbnRFbnRlck1ldGhvZCB8fCBoYXNEaWZmZXJlbnRFeGl0TWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVkU3RhdGUgPSBTdGF0ZU1hY2hpbmUuX2dldFNoYXJlZFN0YXRlKHRoaXMuX3N0YXRlLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGU6IG5ld1N0YXRlLl9fcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlN0YXRlOiBwcmV2U3RhdGUuX19wYXRoLFxuICAgICAgICAgICAgICAgICAgICBzaGFyZWRTdGF0ZTogc2hhcmVkU3RhdGUuX19wYXRoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFyZWRMZXZlbCA9IHNoYXJlZFN0YXRlLl9fbGV2ZWw7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzRGlmZmVyZW50RXhpdE1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGl0U3RhdGVzID0gU3RhdGVNYWNoaW5lLl9nZXRTdGF0ZXNVbnRpbExldmVsKHRoaXMuX3N0YXRlLCBzaGFyZWRMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gZXhpdFN0YXRlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19zZXRTdGF0ZShleGl0U3RhdGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxFeGl0KHRoaXMuX3N0YXRlLCBhcmdzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlQ2hhbmdlT3ZlcnJpZGRlbiA9ICh0aGlzLl9zZXRTdGF0ZUlkICE9PSBzZXRTdGF0ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZUNoYW5nZU92ZXJyaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzRGlmZmVyZW50RW50ZXJNZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50ZXJTdGF0ZXMgPSBTdGF0ZU1hY2hpbmUuX2dldFN0YXRlc1VudGlsTGV2ZWwobmV3U3RhdGUsIHNoYXJlZExldmVsKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gZW50ZXJTdGF0ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fc2V0U3RhdGUoZW50ZXJTdGF0ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbEVudGVyKHRoaXMuX3N0YXRlLCBhcmdzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlQ2hhbmdlT3ZlcnJpZGRlbiA9ICh0aGlzLl9zZXRTdGF0ZUlkICE9PSBzZXRTdGF0ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZUNoYW5nZU92ZXJyaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fX3NldFN0YXRlKG5ld1N0YXRlKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlOiBuZXdTdGF0ZS5fX3BhdGgsXG4gICAgICAgICAgICAgICAgICAgIHByZXZTdGF0ZTogcHJldlN0YXRlLl9fcGF0aFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VkU3RhdGUoY29udGV4dCwgLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFN0YXRlKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX29uU3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZTogbmV3U3RhdGUuX19wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwcmV2U3RhdGU6IHByZXZTdGF0ZS5fX3BhdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhdGVDaGFuZ2UoY29udGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jYWxsRW50ZXIoc3RhdGUsIGFyZ3MgPSBbXSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBoYXNQYXJlbnQgPSAhIXN0YXRlLl9fcGFyZW50O1xuICAgICAgICBpZiAoc3RhdGUucHJvdG90eXBlLiRlbnRlcikge1xuICAgICAgICAgICAgaWYgKCFoYXNQYXJlbnQgfHwgKHN0YXRlLl9fcGFyZW50LnByb3RvdHlwZS4kZW50ZXIgIT09IHN0YXRlLnByb3RvdHlwZS4kZW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucHJvdG90eXBlLiRlbnRlci5hcHBseSh0aGlzLCBbY29udGV4dCwgLi4uYXJnc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NhbGxFeGl0KHN0YXRlLCBhcmdzID0gW10sIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgaGFzUGFyZW50ID0gISFzdGF0ZS5fX3BhcmVudDtcbiAgICAgICAgaWYgKHN0YXRlLnByb3RvdHlwZS4kZXhpdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNQYXJlbnQgfHwgKHN0YXRlLl9fcGFyZW50LnByb3RvdHlwZS4kZXhpdCAhPT0gc3RhdGUucHJvdG90eXBlLiRleGl0KSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnByb3RvdHlwZS4kZXhpdC5hcHBseSh0aGlzLCBbY29udGV4dCwgLi4uYXJnc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX19zZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLl9zdGF0ZUluZGV4ID0gc3RhdGUuX19pbmRleDtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IHN0YXRlO1xuICAgIH1cblxuICAgIF9pbml0U3RhdGVNYWNoaW5lKCkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0YXRlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9zZXRTdGF0ZUNvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9zbSA9IHRoaXMuX3JvdXRlZFR5cGUuX3NtO1xuICAgICAgICB0aGlzLl9fc2V0U3RhdGUodGhpcy5fc20uZ2V0U3RhdGVCeVBhdGgoXCJcIikpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge25ld1N0YXRlOiBcIlwiLCBwcmV2U3RhdGU6IHVuZGVmaW5lZCwgc2hhcmVkU3RhdGU6IHVuZGVmaW5lZH07XG4gICAgICAgIHRoaXMuX2NhbGxFbnRlcih0aGlzLl9zdGF0ZSwgW10sIGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9vblN0YXRlQ2hhbmdlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJldHdlZW4gbXVsdGlwbGUgbWVtYmVyIG5hbWVzLCBzZWxlY3QgdGhlIG9uZSBzcGVjaWZpZWQgaW4gdGhlIGRlZXBlc3Qgc3RhdGUuXG4gICAgICogSWYgbXVsdGlwbGUgbWVtYmVyIG5hbWVzIGFyZSBzcGVjaWZpZWQgaW4gdGhlIHNhbWUgZGVlcGVzdCBzdGF0ZSwgdGhlIGZpcnN0IG9uZSBpbiB0aGUgYXJyYXkgaXMgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbWVtYmVyTmFtZXNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2dldE1vc3RTcGVjaWZpY0hhbmRsZWRNZW1iZXIobWVtYmVyTmFtZXMpIHtcbiAgICAgICAgbGV0IGN1ciA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IG1lbWJlck5hbWVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lbWJlck5hbWUgPSBtZW1iZXJOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1ci5fX3BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLnByb3RvdHlwZVttZW1iZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbWJlck5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGlhcyA9IFN0YXRlTWFjaGluZVR5cGUuZ2V0U3RhdGVNZW1iZXJBbGlhcyhjdXIuX19wYXRoLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbYWxpYXNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVtYmVyTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGN1ci5fX3BhcmVudDtcbiAgICAgICAgfSB3aGlsZSAoY3VyKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldFN0YXRlc1VudGlsTGV2ZWwoc3RhdGUsIGxldmVsKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoc3RhdGUuX19sZXZlbCA+IGxldmVsKSB7XG4gICAgICAgICAgICBzdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLl9fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZXM7XG4gICAgfVxuXG4gICAgc3RhdGljIF9nZXRTaGFyZWRTdGF0ZShzdGF0ZTEsIHN0YXRlMikge1xuICAgICAgICBjb25zdCBzdGF0ZTFBcnJheSA9IFN0YXRlTWFjaGluZS5fZ2V0QW5jZXN0b3JTdGF0ZXMoc3RhdGUxKTtcbiAgICAgICAgY29uc3Qgc3RhdGUyQXJyYXkgPSBTdGF0ZU1hY2hpbmUuX2dldEFuY2VzdG9yU3RhdGVzKHN0YXRlMik7XG4gICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihzdGF0ZTFBcnJheS5sZW5ndGgsIHN0YXRlMkFycmF5Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUxQXJyYXlbaV0gIT09IHN0YXRlMkFycmF5W2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlMUFycmF5W2kgLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGUxQXJyYXlbbiAtIDFdO1xuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0QW5jZXN0b3JTdGF0ZXMoc3RhdGUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YXRlKTtcbiAgICAgICAgfSB3aGlsZShzdGF0ZSA9IHN0YXRlLl9fcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIF9nZXRTdGF0ZUF0TGV2ZWwoc3RhdGUsIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA+IHN0YXRlLl9fbGV2ZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZShsZXZlbCA8IHN0YXRlLl9fbGV2ZWwpIHtcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuX19wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbn1cblxuY2xhc3MgU3RhdGVNYWNoaW5lVHlwZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIGdldCByb3V0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3V0ZXI7XG4gICAgfVxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gdGhpcy5fY3JlYXRlUm91dGVyKCk7XG5cbiAgICAgICAgdGhpcy5fc3RhdGVNYXAgPSB0aGlzLl9nZXRTdGF0ZU1hcCgpO1xuXG4gICAgICAgIHRoaXMuX2FkZFN0YXRlTWVtYmVyRGVsZWdhdG9yc1RvUm91dGVyKCk7XG5cbiAgICB9XG5cbiAgICBfY3JlYXRlUm91dGVyKCkge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5fdHlwZTtcblxuICAgICAgICBjb25zdCByb3V0ZXIgPSBjbGFzcyBTdGF0ZU1hY2hpbmVSb3V0ZXIgZXh0ZW5kcyB0eXBlIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLmhhc093blByb3BlcnR5KCdfaXNSb3V0ZXInKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBuZWVkIHRvIGV4dGVuZCAke3R5cGUubmFtZX0ub3JpZ2luYWwgaW5zdGVhZCBvZiAke3R5cGUubmFtZX0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByb3V0ZXIuX2lzUm91dGVyID0gdHJ1ZTtcbiAgICAgICAgcm91dGVyLnByb3RvdHlwZS5fcm91dGVkVHlwZSA9IHR5cGU7XG4gICAgICAgIHJvdXRlci5vcmlnaW5hbCA9IHR5cGU7XG5cbiAgICAgICAgdGhpcy5fbWl4aW5TdGF0ZU1hY2hpbmVNZXRob2RzKHJvdXRlcik7XG5cbiAgICAgICAgcmV0dXJuIHJvdXRlcjtcbiAgICB9XG5cbiAgICBfbWl4aW5TdGF0ZU1hY2hpbmVNZXRob2RzKHJvdXRlcikge1xuICAgICAgICAvLyBNaXhpbiB0aGUgc3RhdGUgbWFjaGluZSBtZXRob2RzLCBzbyB0aGF0IHdlIHJldXNlIHRoZSBtZXRob2RzIGluc3RlYWQgb2YgcmUtY3JlYXRpbmcgdGhlbS5cbiAgICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTdGF0ZU1hY2hpbmUucHJvdG90eXBlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBuYW1lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihTdGF0ZU1hY2hpbmUucHJvdG90eXBlLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocm91dGVyLnByb3RvdHlwZSwgbmFtZSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfYWRkU3RhdGVNZW1iZXJEZWxlZ2F0b3JzVG9Sb3V0ZXIoKSB7XG4gICAgICAgIGNvbnN0IG1lbWJlcnMgPSB0aGlzLl9nZXRBbGxNZW1iZXJOYW1lcygpO1xuXG4gICAgICAgIG1lbWJlcnMuZm9yRWFjaChtZW1iZXIgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYWRkTWVtYmVyUm91dGVyKG1lbWJlcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBub3RlIFdlIGFyZSBnZW5lcmF0aW5nIGNvZGUgYmVjYXVzZSBpdCB5aWVsZHMgbXVjaCBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICovXG4gICAgX2FkZE1lbWJlclJvdXRlcihtZW1iZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVQYXRocyA9IE9iamVjdC5rZXlzKHRoaXMuX3N0YXRlTWFwKTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgYWxpYXNlcyA9IFtdO1xuICAgICAgICBzdGF0ZVBhdGhzLmZvckVhY2goKHN0YXRlUGF0aCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVNYXBbc3RhdGVQYXRoXTtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLl9nZXREZXNjcmlwdG9yKHN0YXRlLCBtZW1iZXIpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yc1tpbmRleF0gPSBkZXNjcmlwdG9yO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIHByb3RvdHlwZS5cbiAgICAgICAgICAgICAgICBjb25zdCBhbGlhcyA9IFN0YXRlTWFjaGluZVR5cGUuZ2V0U3RhdGVNZW1iZXJBbGlhcyhkZXNjcmlwdG9yLl9zb3VyY2UuX19wYXRoLCBtZW1iZXIpO1xuICAgICAgICAgICAgICAgIGFsaWFzZXNbaW5kZXhdID0gYWxpYXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JvdXRlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoYWxpYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLl9yb3V0ZXIucHJvdG90eXBlLCBhbGlhcywgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGFsaWFzZXNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGRlc2NyaXB0b3JzLmZvckVhY2goZGVzY3JpcHRvciA9PiB7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NUeXBlID0gdGhpcy5fZ2V0RGVzY3JpcHRvclR5cGUoZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgJiYgKHR5cGUgIT09IGRlc2NUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtMaWdodG5pbmddIE1lbWJlciAke21lbWJlcn0gaW4gJHt0aGlzLl90eXBlLm5hbWV9IGhhcyBpbmNvbnNpc3RlbnQgdHlwZXMuYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHlwZSA9IGRlc2NUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzd2l0Y2godHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm1ldGhvZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE1ldGhvZFJvdXRlcihtZW1iZXIsIGRlc2NyaXB0b3JzLCBhbGlhc2VzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnZXR0ZXJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRHZXR0ZXJTZXR0ZXJSb3V0ZXJzKG1lbWJlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicHJvcGVydHlcIjpcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbTGlnaHRuaW5nXSBGaXhlZCBwcm9wZXJ0aWVzIGFyZSBub3Qgc3VwcG9ydGVkOyBwbGVhc2UgdXNlIGEgZ2V0dGVyIGluc3RlYWQhXCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0RGVzY3JpcHRvcihzdGF0ZSwgbWVtYmVyLCBpc1ZhbGlkID0gKCkgPT4gdHJ1ZSkge1xuICAgICAgICBsZXQgdHlwZSA9IHN0YXRlO1xuICAgICAgICBsZXQgY3VyU3RhdGUgPSBzdGF0ZTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0eXBlLnByb3RvdHlwZSwgbWVtYmVyKTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQoZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvci5fc291cmNlID0gY3VyU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodHlwZSk7XG4gICAgICAgICAgICBpZiAodHlwZSAmJiB0eXBlLmhhc093blByb3BlcnR5KCdfX3N0YXRlJykpIHtcbiAgICAgICAgICAgICAgICBjdXJTdGF0ZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUodHlwZSAmJiB0eXBlLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgX2dldERlc2NyaXB0b3JUeXBlKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0IHx8IGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gJ2dldHRlcic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbWV0aG9kJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwcm9wZXJ0eSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgX3N1cHBvcnRzU3ByZWFkKCkge1xuICAgICAgICBpZiAodGhpcy5fX3N1cHBvcnRzU3ByZWFkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX19zdXBwb3J0c1NwcmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jID0gbmV3IEZ1bmN0aW9uKFwicmV0dXJuIFtdLmNvbmNhdCguLi5hcmd1bWVudHMpO1wiKTtcbiAgICAgICAgICAgICAgICBmdW5jKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3N1cHBvcnRzU3ByZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX3N1cHBvcnRzU3ByZWFkO1xuICAgIH1cblxuICAgIF9hZGRNZXRob2RSb3V0ZXIobWVtYmVyLCBkZXNjcmlwdG9ycywgYWxpYXNlcykge1xuICAgICAgICBjb25zdCBjb2RlID0gW1xuICAgICAgICAgICAgLy8gVGhlIGxpbmUgZW5zdXJlcyB0aGF0LCB3aGlsZSBkZWJ1Z2dpbmcsIHlvdXIgSURFIHdvbid0IG9wZW4gbWFueSB0YWJzLlxuICAgICAgICAgICAgXCIvL0Agc291cmNlVVJMPVN0YXRlTWFjaGluZVJvdXRlci5qc1wiLFxuICAgICAgICAgICAgXCJ2YXIgaSA9IHRoaXMuX3N0YXRlSW5kZXg7XCJcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGN1ciA9IGFsaWFzZXNbMF07XG4gICAgICAgIGNvbnN0IHN1cHBvcnRzU3ByZWFkID0gU3RhdGVNYWNoaW5lVHlwZS5fc3VwcG9ydHNTcHJlYWQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDEsIG4gPSBhbGlhc2VzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWxpYXMgPSBhbGlhc2VzW2ldO1xuICAgICAgICAgICAgaWYgKGFsaWFzICE9PSBjdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c1NwcmVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZS5wdXNoKGBpZiAoaSA8ICR7aX0pIHJldHVybiB0aGlzW1wiJHtjdXJ9XCJdKC4uLmFyZ3VtZW50cyk7IGVsc2VgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUucHVzaChgaWYgKGkgPCAke2l9KSByZXR1cm4gdGhpc1tcIiR7Y3VyfVwiXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyBlbHNlYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnB1c2goYGlmIChpIDwgJHtpfSkgcmV0dXJuIDsgZWxzZWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGFsaWFzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1NwcmVhZCkge1xuICAgICAgICAgICAgICAgIGNvZGUucHVzaChgcmV0dXJuIHRoaXNbXCIke2N1cn1cIl0oLi4uYXJndW1lbnRzKTtgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKGByZXR1cm4gdGhpc1tcIiR7Y3VyfVwiXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZS5wdXNoKGA7YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25Cb2R5ID0gY29kZS5qb2luKFwiXFxuXCIpO1xuICAgICAgICBjb25zdCByb3V0ZXIgPSBuZXcgRnVuY3Rpb24oW10sIGZ1bmN0aW9uQm9keSk7XG5cbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHt2YWx1ZTogcm91dGVyfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuX3JvdXRlci5wcm90b3R5cGUsIG1lbWJlciwgZGVzY3JpcHRvcik7XG4gICAgfVxuXG4gICAgX2FkZEdldHRlclNldHRlclJvdXRlcnMobWVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGdldHRlciA9IHRoaXMuX2dldEdldHRlclJvdXRlcihtZW1iZXIpO1xuICAgICAgICBjb25zdCBzZXR0ZXIgPSB0aGlzLl9nZXRTZXR0ZXJSb3V0ZXIobWVtYmVyKTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgIGdldDogZ2V0dGVyLFxuICAgICAgICAgICAgc2V0OiBzZXR0ZXJcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuX3JvdXRlci5wcm90b3R5cGUsIG1lbWJlciwgZGVzY3JpcHRvcik7XG4gICAgfVxuXG4gICAgX2dldEdldHRlclJvdXRlcihtZW1iZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVQYXRocyA9IE9iamVjdC5rZXlzKHRoaXMuX3N0YXRlTWFwKTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgYWxpYXNlcyA9IFtdO1xuICAgICAgICBzdGF0ZVBhdGhzLmZvckVhY2goKHN0YXRlUGF0aCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVNYXBbc3RhdGVQYXRoXTtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLl9nZXREZXNjcmlwdG9yKHN0YXRlLCBtZW1iZXIsIChkZXNjcmlwdG9yID0+IGRlc2NyaXB0b3IuZ2V0KSk7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzW2luZGV4XSA9IGRlc2NyaXB0b3I7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gcHJvdG90eXBlLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFsaWFzID0gU3RhdGVNYWNoaW5lVHlwZS5nZXRTdGF0ZU1lbWJlckFsaWFzKGRlc2NyaXB0b3IuX3NvdXJjZS5fX3BhdGgsIG1lbWJlcik7XG4gICAgICAgICAgICAgICAgYWxpYXNlc1tpbmRleF0gPSBhbGlhcztcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcm91dGVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShhbGlhcykpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuX3JvdXRlci5wcm90b3R5cGUsIGFsaWFzLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzW2luZGV4XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYWxpYXNlc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjb2RlID0gW1xuICAgICAgICAgICAgLy8gVGhlIGxpbmUgZW5zdXJlcyB0aGF0LCB3aGlsZSBkZWJ1Z2dpbmcsIHlvdXIgSURFIHdvbid0IG9wZW4gbWFueSB0YWJzLlxuICAgICAgICAgICAgXCIvL0Agc291cmNlVVJMPVN0YXRlTWFjaGluZVJvdXRlci5qc1wiLFxuICAgICAgICAgICAgXCJ2YXIgaSA9IHRoaXMuX3N0YXRlSW5kZXg7XCJcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGN1ciA9IGFsaWFzZXNbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxLCBuID0gYWxpYXNlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFsaWFzID0gYWxpYXNlc1tpXTtcbiAgICAgICAgICAgIGlmIChhbGlhcyAhPT0gY3VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnB1c2goYGlmIChpIDwgJHtpfSkgcmV0dXJuIHRoaXNbXCIke2N1cn1cIl07IGVsc2VgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnB1c2goYGlmIChpIDwgJHtpfSkgcmV0dXJuIDsgZWxzZWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGFsaWFzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgIGNvZGUucHVzaChgcmV0dXJuIHRoaXNbXCIke2N1cn1cIl07YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlLnB1c2goYDtgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbkJvZHkgPSBjb2RlLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIGNvbnN0IHJvdXRlciA9IG5ldyBGdW5jdGlvbihbXSwgZnVuY3Rpb25Cb2R5KTtcbiAgICAgICAgcmV0dXJuIHJvdXRlcjtcbiAgICB9XG5cbiAgICBfZ2V0U2V0dGVyUm91dGVyKG1lbWJlcikge1xuICAgICAgICBjb25zdCBzdGF0ZVBhdGhzID0gT2JqZWN0LmtleXModGhpcy5fc3RhdGVNYXApO1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9ycyA9IFtdO1xuICAgICAgICBjb25zdCBhbGlhc2VzID0gW107XG4gICAgICAgIHN0YXRlUGF0aHMuZm9yRWFjaCgoc3RhdGVQYXRoLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZU1hcFtzdGF0ZVBhdGhdO1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuX2dldERlc2NyaXB0b3Ioc3RhdGUsIG1lbWJlciwgKGRlc2NyaXB0b3IgPT4gZGVzY3JpcHRvci5zZXQpKTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcnNbaW5kZXhdID0gZGVzY3JpcHRvcjtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBwcm90b3R5cGUuXG4gICAgICAgICAgICAgICAgY29uc3QgYWxpYXMgPSBTdGF0ZU1hY2hpbmVUeXBlLmdldFN0YXRlTWVtYmVyQWxpYXMoZGVzY3JpcHRvci5fc291cmNlLl9fcGF0aCwgbWVtYmVyKTtcbiAgICAgICAgICAgICAgICBhbGlhc2VzW2luZGV4XSA9IGFsaWFzO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9yb3V0ZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KGFsaWFzKSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5fcm91dGVyLnByb3RvdHlwZSwgYWxpYXMsIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcnNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICBhbGlhc2VzW2luZGV4XSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNvZGUgPSBbXG4gICAgICAgICAgICAvLyBUaGUgbGluZSBlbnN1cmVzIHRoYXQsIHdoaWxlIGRlYnVnZ2luZywgeW91ciBJREUgd29uJ3Qgb3BlbiBtYW55IHRhYnMuXG4gICAgICAgICAgICBcIi8vQCBzb3VyY2VVUkw9U3RhdGVNYWNoaW5lUm91dGVyLmpzXCIsXG4gICAgICAgICAgICBcInZhciBpID0gdGhpcy5fc3RhdGVJbmRleDtcIlxuICAgICAgICBdO1xuICAgICAgICBsZXQgY3VyID0gYWxpYXNlc1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDEsIG4gPSBhbGlhc2VzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWxpYXMgPSBhbGlhc2VzW2ldO1xuICAgICAgICAgICAgaWYgKGFsaWFzICE9PSBjdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUucHVzaChgaWYgKGkgPCAke2l9KSB0aGlzW1wiJHtjdXJ9XCJdID0gYXJnOyBlbHNlYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5wdXNoKGBpZiAoaSA8ICR7aX0pIDsgZWxzZWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGFsaWFzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgIGNvZGUucHVzaChgdGhpc1tcIiR7Y3VyfVwiXSA9IGFyZztgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUucHVzaChgO2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQm9keSA9IGNvZGUuam9pbihcIlxcblwiKTtcbiAgICAgICAgY29uc3Qgcm91dGVyID0gbmV3IEZ1bmN0aW9uKFtcImFyZ1wiXSwgZnVuY3Rpb25Cb2R5KTtcbiAgICAgICAgcmV0dXJuIHJvdXRlcjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0U3RhdGVNZW1iZXJBbGlhcyhwYXRoLCBtZW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIFwiJFwiICsgKHBhdGggPyBwYXRoICsgXCIuXCIgOiBcIlwiKSArIG1lbWJlcjtcbiAgICB9XG5cbiAgICBfZ2V0QWxsTWVtYmVyTmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlTWFwID0gdGhpcy5fc3RhdGVNYXA7XG4gICAgICAgIGNvbnN0IG1hcCA9IE9iamVjdC5rZXlzKHN0YXRlTWFwKTtcbiAgICAgICAgbGV0IG1lbWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIG1hcC5mb3JFYWNoKHN0YXRlUGF0aCA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhdGVQYXRoID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgLy8gUm9vdCBzdGF0ZSBjYW4gYmUgc2tpcHBlZDogaWYgdGhlIG1ldGhvZCBvbmx5IG9jY3VycyBpbiB0aGUgcm9vdCBzdGF0ZSwgd2UgZG9uJ3QgbmVlZCB0byByZS1kZWxlZ2F0ZSBpdCBiYXNlZCBvbiBzdGF0ZS5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YXRlTWFwW3N0YXRlUGF0aF07XG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IHRoaXMuX2dldFN0YXRlTWVtYmVyTmFtZXMoc3RhdGUpO1xuICAgICAgICAgICAgbmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICBtZW1iZXJzLmFkZChuYW1lKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gWy4uLm1lbWJlcnNdO1xuICAgIH1cblxuICAgIF9nZXRTdGF0ZU1lbWJlck5hbWVzKHN0YXRlKSB7XG4gICAgICAgIGxldCB0eXBlID0gc3RhdGU7XG4gICAgICAgIGxldCBtZW1iZXJzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBpc1Jvb3QgPSB0aGlzLl90eXBlID09PSBzdGF0ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSB0aGlzLl9nZXRTdGF0ZU1lbWJlck5hbWVzRm9yVHlwZSh0eXBlKTtcbiAgICAgICAgICAgIG5hbWVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgbWVtYmVycy5hZGQobmFtZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHR5cGUpO1xuICAgICAgICB9IHdoaWxlKHR5cGUgJiYgdHlwZS5wcm90b3R5cGUgJiYgKCF0eXBlLmhhc093blByb3BlcnR5KFwiX19zdGF0ZVwiKSB8fCBpc1Jvb3QpKTtcblxuICAgICAgICByZXR1cm4gbWVtYmVycztcbiAgICB9XG5cbiAgICBfZ2V0U3RhdGVNZW1iZXJOYW1lc0ZvclR5cGUodHlwZSkge1xuICAgICAgICBjb25zdCBtZW1iZXJOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHR5cGUucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIG1lbWJlck5hbWVzLmZpbHRlcihtZW1iZXJOYW1lID0+IHtcbiAgICAgICAgICAgIHJldHVybiAobWVtYmVyTmFtZSAhPT0gXCJjb25zdHJ1Y3RvclwiKSAmJiAhU3RhdGVNYWNoaW5lVHlwZS5faXNTdGF0ZUxvY2FsTWVtYmVyKG1lbWJlck5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX2lzU3RhdGVMb2NhbE1lbWJlcihtZW1iZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiAobWVtYmVyTmFtZSA9PT0gXCIkZW50ZXJcIikgfHwgKG1lbWJlck5hbWUgPT09IFwiJGV4aXRcIik7XG4gICAgfVxuXG4gICAgZ2V0U3RhdGVCeVBhdGgoc3RhdGVQYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZU1hcFtzdGF0ZVBhdGhdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVNYXBbc3RhdGVQYXRoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlYXJjaCBmb3IgY2xvc2VzdCBtYXRjaC5cbiAgICAgICAgY29uc3QgcGFydHMgPSBzdGF0ZVBhdGguc3BsaXQoXCIuXCIpO1xuICAgICAgICB3aGlsZShwYXJ0cy5wb3AoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVQYXRoID0gcGFydHMuam9pbihcIi5cIik7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGVNYXBbc3RhdGVQYXRoXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZU1hcFtzdGF0ZVBhdGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFN0YXRlTWFwKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlTWFwKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZU1hcCA9IHRoaXMuX2NyZWF0ZVN0YXRlTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlTWFwO1xuICAgIH1cblxuICAgIF9jcmVhdGVTdGF0ZU1hcCgpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5fYWRkU3RhdGUodGhpcy5fdHlwZSwgbnVsbCwgXCJcIiwgc3RhdGVNYXApO1xuICAgICAgICByZXR1cm4gc3RhdGVNYXA7XG4gICAgfVxuXG4gICAgX2FkZFN0YXRlKHN0YXRlLCBwYXJlbnRTdGF0ZSwgbmFtZSwgc3RhdGVNYXApIHtcbiAgICAgICAgc3RhdGUuX19zdGF0ZSA9IHRydWU7XG4gICAgICAgIHN0YXRlLl9fbmFtZSA9IG5hbWU7XG5cbiAgICAgICAgdGhpcy5fYWRkU3RhdGljU3RhdGVQcm9wZXJ0eShzdGF0ZSwgcGFyZW50U3RhdGUpO1xuXG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSAocGFyZW50U3RhdGUgPyBwYXJlbnRTdGF0ZS5fX3BhdGggOiBcIlwiKTtcbiAgICAgICAgbGV0IHBhdGggPSAocGFyZW50UGF0aCA/IHBhcmVudFBhdGggKyBcIi5cIiA6IFwiXCIpICsgbmFtZTtcbiAgICAgICAgc3RhdGUuX19wYXRoID0gcGF0aDtcbiAgICAgICAgc3RhdGUuX19sZXZlbCA9IHBhcmVudFN0YXRlID8gcGFyZW50U3RhdGUuX19sZXZlbCArIDEgOiAwO1xuICAgICAgICBzdGF0ZS5fX3BhcmVudCA9IHBhcmVudFN0YXRlO1xuICAgICAgICBzdGF0ZS5fX2luZGV4ID0gT2JqZWN0LmtleXMoc3RhdGVNYXApLmxlbmd0aDtcbiAgICAgICAgc3RhdGVNYXBbcGF0aF0gPSBzdGF0ZTtcblxuICAgICAgICBjb25zdCBzdGF0ZXMgPSBzdGF0ZS5fc3RhdGVzO1xuICAgICAgICBpZiAoc3RhdGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpc0luaGVyaXRlZEZyb21QYXJlbnQgPSAocGFyZW50U3RhdGUgJiYgcGFyZW50U3RhdGUuX3N0YXRlcyA9PT0gc3RhdGVzKTtcbiAgICAgICAgICAgIGlmICghaXNJbmhlcml0ZWRGcm9tUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViU3RhdGVzID0gc3RhdGUuX3N0YXRlcygpO1xuICAgICAgICAgICAgICAgIHN1YlN0YXRlcy5mb3JFYWNoKHN1YlN0YXRlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVOYW1lID0gU3RhdGVNYWNoaW5lVHlwZS5fZ2V0U3RhdGVOYW1lKHN1YlN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkU3RhdGUoc3ViU3RhdGUsIHN0YXRlLCBzdGF0ZU5hbWUsIHN0YXRlTWFwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0U3RhdGVOYW1lKHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBzdGF0ZS5uYW1lO1xuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZS5pbmRleE9mKCckJyk7XG4gICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgIC8vIFN0cmlwIG9mZiByb2xsdXAgbmFtZSBzdWZmaXguXG4gICAgICAgICAgICByZXR1cm4gbmFtZS5zdWJzdHIoMCwgaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgX2FkZFN0YXRpY1N0YXRlUHJvcGVydHkoc3RhdGUsIHBhcmVudFN0YXRlKSB7XG4gICAgICAgIGlmIChwYXJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgaXNDbGFzc1N0YXRlTGV2ZWwgPSBwYXJlbnRTdGF0ZSAmJiAhcGFyZW50U3RhdGUuX19wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNDbGFzc1N0YXRlTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3V0ZXJbc3RhdGUuX19uYW1lXSA9IHN0YXRlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRTdGF0ZVtzdGF0ZS5fX25hbWVdID0gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4uL2FwcGxpY2F0aW9uL0NvbXBvbmVudC5tanNcIjtcbmltcG9ydCBMaW5lYXJCbHVyU2hhZGVyIGZyb20gXCIuLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0xpbmVhckJsdXJTaGFkZXIubWpzXCI7XG5pbXBvcnQgQm94Qmx1clNoYWRlciBmcm9tIFwiLi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9Cb3hCbHVyU2hhZGVyLm1qc1wiO1xuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvRGVmYXVsdFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmxvb21Db21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgb25VcGRhdGUgPSBmdW5jdGlvbihlbGVtZW50LCBlbGVtZW50Q29yZSkge1xuICAgICAgICAgICAgaWYgKChlbGVtZW50Q29yZS5fcmVjYWxjICYgKDIgKyAxMjgpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHcgPSBlbGVtZW50Q29yZS53O1xuICAgICAgICAgICAgICAgIGNvbnN0IGggPSBlbGVtZW50Q29yZS5oO1xuICAgICAgICAgICAgICAgIGxldCBjdXIgPSBlbGVtZW50Q29yZTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5fY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgICAgIGN1ci5fZWxlbWVudC53ID0gdztcbiAgICAgICAgICAgICAgICAgICAgY3VyLl9lbGVtZW50LmggPSBoO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUoY3VyLl9jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFRleHR3cmFwOiB7cnR0OiB0cnVlLCBmb3JjZVpJbmRleENvbnRleHQ6IHRydWUsIHJlbmRlck9mZnNjcmVlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBCbG9vbUJhc2U6IHtzaGFkZXI6IHt0eXBlOiBCbG9vbUJhc2VTaGFkZXJ9LFxuICAgICAgICAgICAgICAgICAgICBDb250ZW50OiB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBMYXllcnM6IHtcbiAgICAgICAgICAgICAgICBMMDoge3J0dDogdHJ1ZSwgb25VcGRhdGU6IG9uVXBkYXRlLCBzY2FsZTogMiwgcGl2b3Q6IDAsIHZpc2libGU6IGZhbHNlLCBDb250ZW50OiB7c2hhZGVyOiB7dHlwZTogQm94Qmx1clNoYWRlcn19fSxcbiAgICAgICAgICAgICAgICBMMToge3J0dDogdHJ1ZSwgb25VcGRhdGU6IG9uVXBkYXRlLCBzY2FsZTogNCwgcGl2b3Q6IDAsIHZpc2libGU6IGZhbHNlLCBDb250ZW50OiB7c2hhZGVyOiB7dHlwZTogQm94Qmx1clNoYWRlcn19fSxcbiAgICAgICAgICAgICAgICBMMjoge3J0dDogdHJ1ZSwgb25VcGRhdGU6IG9uVXBkYXRlLCBzY2FsZTogOCwgcGl2b3Q6IDAsIHZpc2libGU6IGZhbHNlLCBDb250ZW50OiB7c2hhZGVyOiB7dHlwZTogQm94Qmx1clNoYWRlcn19fSxcbiAgICAgICAgICAgICAgICBMMzoge3J0dDogdHJ1ZSwgb25VcGRhdGU6IG9uVXBkYXRlLCBzY2FsZTogMTYsIHBpdm90OiAwLCB2aXNpYmxlOiBmYWxzZSwgQ29udGVudDoge3NoYWRlcjoge3R5cGU6IEJveEJsdXJTaGFkZXJ9fX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBfc2lnbmFsUHJveHkoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcbiAgICAgICAgdGhpcy5fdGV4dHdyYXAgPSB0aGlzLnNlbChcIlRleHR3cmFwXCIpO1xuICAgICAgICB0aGlzLl93cmFwcGVyID0gdGhpcy5zZWwoXCJUZXh0d3JhcC5Db250ZW50XCIpO1xuICAgICAgICB0aGlzLl9sYXllcnMgPSB0aGlzLnNlbChcIkxheWVyc1wiKTtcblxuICAgICAgICB0aGlzLl9hbW91bnQgPSAwO1xuICAgICAgICB0aGlzLl9wYWRkaW5nWCA9IDA7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdZID0gMDtcbiAgICB9XG5cbiAgICBfYnVpbGQoKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlclNoYWRlclNldHRpbmdzID0gW3t4OjEseTowLGtlcm5lbFJhZGl1czozfSx7eDowLHk6MSxrZXJuZWxSYWRpdXM6M30se3g6MS41LHk6MCxrZXJuZWxSYWRpdXM6M30se3g6MCx5OjEuNSxrZXJuZWxSYWRpdXM6M31dO1xuICAgICAgICBjb25zdCBmaWx0ZXJTaGFkZXJzID0gZmlsdGVyU2hhZGVyU2V0dGluZ3MubWFwKHMgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2hhZGVyID0gdGhpcy5zdGFnZS5jcmVhdGVTaGFkZXIoT2JqZWN0LmFzc2lnbih7dHlwZTogTGluZWFyQmx1clNoYWRlcn0sIHMpKTtcbiAgICAgICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3NldExheWVyVGV4dHVyZSh0aGlzLmdldExheWVyQ29udGVudHMoMCksIHRoaXMuX3RleHR3cmFwLmdldFRleHR1cmUoKSwgW10pO1xuICAgICAgICB0aGlzLl9zZXRMYXllclRleHR1cmUodGhpcy5nZXRMYXllckNvbnRlbnRzKDEpLCB0aGlzLmdldExheWVyKDApLmdldFRleHR1cmUoKSwgW2ZpbHRlclNoYWRlcnNbMF0sIGZpbHRlclNoYWRlcnNbMV1dKTtcblxuICAgICAgICAvLyBOb3RpY2UgdGhhdCAxLjUgZmlsdGVycyBzaG91bGQgYmUgYXBwbGllZCBiZWZvcmUgMS4wIGZpbHRlcnMuXG4gICAgICAgIHRoaXMuX3NldExheWVyVGV4dHVyZSh0aGlzLmdldExheWVyQ29udGVudHMoMiksIHRoaXMuZ2V0TGF5ZXIoMSkuZ2V0VGV4dHVyZSgpLCBbZmlsdGVyU2hhZGVyc1swXSwgZmlsdGVyU2hhZGVyc1sxXSwgZmlsdGVyU2hhZGVyc1syXSwgZmlsdGVyU2hhZGVyc1szXV0pO1xuICAgICAgICB0aGlzLl9zZXRMYXllclRleHR1cmUodGhpcy5nZXRMYXllckNvbnRlbnRzKDMpLCB0aGlzLmdldExheWVyKDIpLmdldFRleHR1cmUoKSwgW2ZpbHRlclNoYWRlcnNbMF0sIGZpbHRlclNoYWRlcnNbMV0sIGZpbHRlclNoYWRlcnNbMl0sIGZpbHRlclNoYWRlcnNbM11dKTtcbiAgICB9XG5cbiAgICBfc2V0TGF5ZXJUZXh0dXJlKGVsZW1lbnQsIHRleHR1cmUsIHN0ZXBzKSB7XG4gICAgICAgIGlmICghc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbGVtZW50LnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzLnBvcCgpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBlbGVtZW50LnN0YWdlLmMoe3J0dDogdHJ1ZSwgc2hhZGVyOiBzdGVwfSk7XG5cbiAgICAgICAgICAgIC8vIFJlY3Vyc2UuXG4gICAgICAgICAgICB0aGlzLl9zZXRMYXllclRleHR1cmUoY2hpbGQsIHRleHR1cmUsIHN0ZXBzKTtcblxuICAgICAgICAgICAgZWxlbWVudC5jaGlsZExpc3QuYWRkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBnZXQgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsKCdUZXh0d3JhcC5Db250ZW50Jyk7XG4gICAgfVxuXG4gICAgc2V0IGNvbnRlbnQodikge1xuICAgICAgICB0aGlzLnNlbCgnVGV4dHdyYXAuQ29udGVudCcpLnBhdGNoKHYpO1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nKHYpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1ggPSB2O1xuICAgICAgICB0aGlzLl9wYWRkaW5nWSA9IHY7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmdYKHYpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1ggPSB2O1xuICAgICAgICB0aGlzLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nWSh2KSB7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdZID0gdjtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBnZXRMYXllcihpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcnMuc2VsKFwiTFwiICsgaSk7XG4gICAgfVxuXG4gICAgZ2V0TGF5ZXJDb250ZW50cyhpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExheWVyKGkpLnNlbChcIkNvbnRlbnRcIik7XG4gICAgfVxuXG4gICAgX29uUmVzaXplKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIF91cGRhdGVCbHVyU2l6ZSgpIHtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnJlbmRlcldpZHRoO1xuICAgICAgICBsZXQgaCA9IHRoaXMucmVuZGVySGVpZ2h0O1xuXG4gICAgICAgIGxldCBwYWRkaW5nWCA9IHRoaXMuX3BhZGRpbmdYO1xuICAgICAgICBsZXQgcGFkZGluZ1kgPSB0aGlzLl9wYWRkaW5nWTtcblxuICAgICAgICBsZXQgZncgPSB3ICsgcGFkZGluZ1ggKiAyO1xuICAgICAgICBsZXQgZmggPSBoICsgcGFkZGluZ1kgKiAyO1xuICAgICAgICB0aGlzLl90ZXh0d3JhcC53ID0gZnc7XG4gICAgICAgIHRoaXMuX3dyYXBwZXIueCA9IHBhZGRpbmdYO1xuICAgICAgICB0aGlzLmdldExheWVyKDApLncgPSB0aGlzLmdldExheWVyQ29udGVudHMoMCkudyA9IGZ3IC8gMjtcbiAgICAgICAgdGhpcy5nZXRMYXllcigxKS53ID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDEpLncgPSBmdyAvIDQ7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMikudyA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygyKS53ID0gZncgLyA4O1xuICAgICAgICB0aGlzLmdldExheWVyKDMpLncgPSB0aGlzLmdldExheWVyQ29udGVudHMoMykudyA9IGZ3IC8gMTY7XG4gICAgICAgIHRoaXMuX3RleHR3cmFwLnggPSAtcGFkZGluZ1g7XG5cbiAgICAgICAgdGhpcy5fdGV4dHdyYXAuaCA9IGZoO1xuICAgICAgICB0aGlzLl93cmFwcGVyLnkgPSBwYWRkaW5nWTtcbiAgICAgICAgdGhpcy5nZXRMYXllcigwKS5oID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDApLmggPSBmaCAvIDI7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMSkuaCA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygxKS5oID0gZmggLyA0O1xuICAgICAgICB0aGlzLmdldExheWVyKDIpLmggPSB0aGlzLmdldExheWVyQ29udGVudHMoMikuaCA9IGZoIC8gODtcbiAgICAgICAgdGhpcy5nZXRMYXllcigzKS5oID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDMpLmggPSBmaCAvIDE2O1xuICAgICAgICB0aGlzLl90ZXh0d3JhcC55ID0gLXBhZGRpbmdZO1xuXG4gICAgICAgIHRoaXMudyA9IHc7XG4gICAgICAgIHRoaXMuaCA9IGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYW1vdW50IG9mIGJsdXIuIEEgdmFsdWUgYmV0d2VlbiAwIGFuZCA0LiBHb2VzIHVwIGV4cG9uZW50aWFsbHkgZm9yIGJsdXIuXG4gICAgICogQmVzdCByZXN1bHRzIGZvciBub24tZnJhY3Rpb25hbCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHY7XG4gICAgICovXG4gICAgc2V0IGFtb3VudCh2KSB7XG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IHY7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH1cblxuICAgIGdldCBhbW91bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbW91bnQ7XG4gICAgfVxuXG4gICAgX3VwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHYgPSBNYXRoLm1pbig0LCBNYXRoLm1heCgwLCB0aGlzLl9hbW91bnQpKTtcbiAgICAgICAgaWYgKHYgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmdldExheWVyKDApLnZpc2libGUgPSAodiA+IDApO1xuICAgICAgICAgICAgdGhpcy5nZXRMYXllcigxKS52aXNpYmxlID0gKHYgPiAxKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGF5ZXIoMikudmlzaWJsZSA9ICh2ID4gMik7XG4gICAgICAgICAgICB0aGlzLmdldExheWVyKDMpLnZpc2libGUgPSAodiA+IDMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IHNoYWRlcihzKSB7XG4gICAgICAgIHN1cGVyLnNoYWRlciA9IHM7XG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJUb1RleHR1cmUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltMaWdodG5pbmddIFBsZWFzZSBlbmFibGUgcmVuZGVyVG9UZXh0dXJlIHRvIHVzZSB3aXRoIGEgc2hhZGVyLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9maXJzdEFjdGl2ZSgpIHtcbiAgICAgICAgdGhpcy5fYnVpbGQoKTtcbiAgICB9XG5cbn1cblxuY2xhc3MgQmxvb21CYXNlU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG59XG5cbkJsb29tQmFzZVNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XG4gICAgICAgIGZsb2F0IG0gPSBtYXgobWF4KGNvbG9yLnIsIGNvbG9yLmcpLCBjb2xvci5iKTtcbiAgICAgICAgZmxvYXQgYyA9IG1heCgwLjAsIChtIC0gMC44MCkpICogNS4wO1xuICAgICAgICBjb2xvciA9IGNvbG9yICogYztcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG4gICAgfVxuYDtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4uL2FwcGxpY2F0aW9uL0NvbXBvbmVudC5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm9yZGVyQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBDb250ZW50OiB7fSxcbiAgICAgICAgICAgIEJvcmRlcnM6IHtcbiAgICAgICAgICAgICAgICBUb3A6IHtyZWN0OiB0cnVlLCB2aXNpYmxlOiBmYWxzZSwgbW91bnRZOiAxfSxcbiAgICAgICAgICAgICAgICBSaWdodDoge3JlY3Q6IHRydWUsIHZpc2libGU6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICBCb3R0b206IHtyZWN0OiB0cnVlLCB2aXNpYmxlOiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgTGVmdDoge3JlY3Q6IHRydWUsIHZpc2libGU6IGZhbHNlLCBtb3VudFg6IDF9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0IF9zaWduYWxQcm94eSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuXG4gICAgICAgIHRoaXMuX2JvcmRlclRvcCA9IHRoaXMudGFnKFwiVG9wXCIpO1xuICAgICAgICB0aGlzLl9ib3JkZXJSaWdodCA9IHRoaXMudGFnKFwiUmlnaHRcIik7XG4gICAgICAgIHRoaXMuX2JvcmRlckJvdHRvbSA9IHRoaXMudGFnKFwiQm90dG9tXCIpO1xuICAgICAgICB0aGlzLl9ib3JkZXJMZWZ0ID0gdGhpcy50YWcoXCJMZWZ0XCIpO1xuXG4gICAgICAgIHRoaXMub25BZnRlclVwZGF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZWxlbWVudC5jaGlsZExpc3QuZmlyc3Q7XG4gICAgICAgICAgICBsZXQgdyA9IGVsZW1lbnQuY29yZS53IHx8IGNvbnRlbnQucmVuZGVyV2lkdGg7XG4gICAgICAgICAgICBsZXQgaCA9IGVsZW1lbnQuY29yZS5oIHx8IGNvbnRlbnQucmVuZGVySGVpZ2h0O1xuICAgICAgICAgICAgZWxlbWVudC5fYm9yZGVyVG9wLncgPSB3O1xuICAgICAgICAgICAgZWxlbWVudC5fYm9yZGVyQm90dG9tLnkgPSBoO1xuICAgICAgICAgICAgZWxlbWVudC5fYm9yZGVyQm90dG9tLncgPSB3O1xuICAgICAgICAgICAgZWxlbWVudC5fYm9yZGVyTGVmdC5oID0gaCArIGVsZW1lbnQuX2JvcmRlclRvcC5oICsgZWxlbWVudC5fYm9yZGVyQm90dG9tLmg7XG4gICAgICAgICAgICBlbGVtZW50Ll9ib3JkZXJMZWZ0LnkgPSAtZWxlbWVudC5fYm9yZGVyVG9wLmg7XG4gICAgICAgICAgICBlbGVtZW50Ll9ib3JkZXJSaWdodC54ID0gdztcbiAgICAgICAgICAgIGVsZW1lbnQuX2JvcmRlclJpZ2h0LmggPSBoICsgZWxlbWVudC5fYm9yZGVyVG9wLmggKyBlbGVtZW50Ll9ib3JkZXJCb3R0b20uaDtcbiAgICAgICAgICAgIGVsZW1lbnQuX2JvcmRlclJpZ2h0LnkgPSAtZWxlbWVudC5fYm9yZGVyVG9wLmg7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aCA9IDE7XG4gICAgfVxuXG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbCgnQ29udGVudCcpO1xuICAgIH1cblxuICAgIHNldCBjb250ZW50KHYpIHtcbiAgICAgICAgdGhpcy5zZWwoJ0NvbnRlbnQnKS5wYXRjaCh2LCB0cnVlKTtcbiAgICB9XG5cbiAgICBnZXQgYm9yZGVyV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvcmRlcldpZHRoVG9wO1xuICAgIH1cblxuICAgIGdldCBib3JkZXJXaWR0aFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlclRvcC5oO1xuICAgIH1cblxuICAgIGdldCBib3JkZXJXaWR0aFJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyUmlnaHQudztcbiAgICB9XG5cbiAgICBnZXQgYm9yZGVyV2lkdGhCb3R0b20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJCb3R0b20uaDtcbiAgICB9XG5cbiAgICBnZXQgYm9yZGVyV2lkdGhMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyTGVmdC53O1xuICAgIH1cblxuICAgIHNldCBib3JkZXJXaWR0aCh2KSB7XG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGhUb3AgPSB2O1xuICAgICAgICB0aGlzLmJvcmRlcldpZHRoUmlnaHQgPSB2O1xuICAgICAgICB0aGlzLmJvcmRlcldpZHRoQm90dG9tID0gdjtcbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aExlZnQgPSB2O1xuICAgIH1cblxuICAgIHNldCBib3JkZXJXaWR0aFRvcCh2KSB7XG4gICAgICAgIHRoaXMuX2JvcmRlclRvcC5oID0gdjtcbiAgICAgICAgdGhpcy5fYm9yZGVyVG9wLnZpc2libGUgPSAodiA+IDApO1xuICAgIH1cblxuICAgIHNldCBib3JkZXJXaWR0aFJpZ2h0KHYpIHtcbiAgICAgICAgdGhpcy5fYm9yZGVyUmlnaHQudyA9IHY7XG4gICAgICAgIHRoaXMuX2JvcmRlclJpZ2h0LnZpc2libGUgPSAodiA+IDApO1xuICAgIH1cblxuICAgIHNldCBib3JkZXJXaWR0aEJvdHRvbSh2KSB7XG4gICAgICAgIHRoaXMuX2JvcmRlckJvdHRvbS5oID0gdjtcbiAgICAgICAgdGhpcy5fYm9yZGVyQm90dG9tLnZpc2libGUgPSAodiA+IDApO1xuICAgIH1cblxuICAgIHNldCBib3JkZXJXaWR0aExlZnQodikge1xuICAgICAgICB0aGlzLl9ib3JkZXJMZWZ0LncgPSB2O1xuICAgICAgICB0aGlzLl9ib3JkZXJMZWZ0LnZpc2libGUgPSAodiA+IDApO1xuICAgIH1cblxuICAgIGdldCBjb2xvckJvcmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JCb3JkZXJUb3A7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yQm9yZGVyVG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyVG9wLmNvbG9yO1xuICAgIH1cblxuICAgIGdldCBjb2xvckJvcmRlclJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyUmlnaHQuY29sb3I7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yQm9yZGVyQm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyQm90dG9tLmNvbG9yO1xuICAgIH1cblxuICAgIGdldCBjb2xvckJvcmRlckxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJMZWZ0LmNvbG9yO1xuICAgIH1cblxuICAgIHNldCBjb2xvckJvcmRlcih2KSB7XG4gICAgICAgIHRoaXMuY29sb3JCb3JkZXJUb3AgPSB2O1xuICAgICAgICB0aGlzLmNvbG9yQm9yZGVyUmlnaHQgPSB2O1xuICAgICAgICB0aGlzLmNvbG9yQm9yZGVyQm90dG9tID0gdjtcbiAgICAgICAgdGhpcy5jb2xvckJvcmRlckxlZnQgPSB2O1xuICAgIH1cblxuICAgIHNldCBjb2xvckJvcmRlclRvcCh2KSB7XG4gICAgICAgIHRoaXMuX2JvcmRlclRvcC5jb2xvciA9IHY7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yQm9yZGVyUmlnaHQodikge1xuICAgICAgICB0aGlzLl9ib3JkZXJSaWdodC5jb2xvciA9IHY7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yQm9yZGVyQm90dG9tKHYpIHtcbiAgICAgICAgdGhpcy5fYm9yZGVyQm90dG9tLmNvbG9yID0gdjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JCb3JkZXJMZWZ0KHYpIHtcbiAgICAgICAgdGhpcy5fYm9yZGVyTGVmdC5jb2xvciA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGJvcmRlclRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlclRvcDtcbiAgICB9XG5cbiAgICBzZXQgYm9yZGVyVG9wKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuYm9yZGVyVG9wLnBhdGNoKHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBnZXQgYm9yZGVyUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJSaWdodDtcbiAgICB9XG5cbiAgICBzZXQgYm9yZGVyUmlnaHQoc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5ib3JkZXJSaWdodC5wYXRjaChzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgZ2V0IGJvcmRlckJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlckJvdHRvbTtcbiAgICB9XG5cbiAgICBzZXQgYm9yZGVyQm90dG9tKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuYm9yZGVyQm90dG9tLnBhdGNoKHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBnZXQgYm9yZGVyTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlckxlZnQ7XG4gICAgfVxuXG4gICAgc2V0IGJvcmRlckxlZnQoc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5ib3JkZXJMZWZ0LnBhdGNoKHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBzZXQgYm9yZGVycyhzZXR0aW5ncykge1xuICAgICAgICB0aGlzLmJvcmRlclRvcCA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLmJvcmRlckxlZnQgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5ib3JkZXJCb3R0b20gPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5ib3JkZXJSaWdodCA9IHNldHRpbmdzO1xuICAgIH1cblxufVxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuLi9hcHBsaWNhdGlvbi9Db21wb25lbnQubWpzXCI7XG5pbXBvcnQgTGluZWFyQmx1clNoYWRlciBmcm9tIFwiLi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9MaW5lYXJCbHVyU2hhZGVyLm1qc1wiO1xuaW1wb3J0IEJveEJsdXJTaGFkZXIgZnJvbSBcIi4uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvQm94Qmx1clNoYWRlci5tanNcIjtcbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5pbXBvcnQgQzJkQmx1clNoYWRlciBmcm9tIFwiLi4vcmVuZGVyZXIvYzJkL3NoYWRlcnMvQmx1clNoYWRlci5tanNcIjtcbmltcG9ydCBTaGFkZXIgZnJvbSBcIi4uL3RyZWUvU2hhZGVyLm1qc1wiO1xuaW1wb3J0IE11bHRpU3BsaW5lIGZyb20gXCIuLi90b29scy9NdWx0aVNwbGluZS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFzdEJsdXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiB7fVxuICAgIH1cblxuICAgIGdldCB3cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcoXCJXcmFwXCIpO1xuICAgIH1cblxuICAgIHNldCBjb250ZW50KHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcC5jb250ZW50ID0gdjtcbiAgICB9XG5cbiAgICBnZXQgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcC5jb250ZW50O1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nKHYpIHtcbiAgICAgICAgdGhpcy53cmFwLl9wYWRkaW5nWCA9IHY7XG4gICAgICAgIHRoaXMud3JhcC5fcGFkZGluZ1kgPSB2O1xuICAgICAgICB0aGlzLndyYXAuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmdYKHYpIHtcbiAgICAgICAgdGhpcy53cmFwLl9wYWRkaW5nWCA9IHY7XG4gICAgICAgIHRoaXMud3JhcC5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZ1kodikge1xuICAgICAgICB0aGlzLndyYXAuX3BhZGRpbmdZID0gdjtcbiAgICAgICAgdGhpcy53cmFwLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIHNldCBhbW91bnQodikge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwLmFtb3VudCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcC5hbW91bnQ7XG4gICAgfVxuXG4gICAgX29uUmVzaXplKCkge1xuICAgICAgICB0aGlzLndyYXAudyA9IHRoaXMucmVuZGVyV2lkdGg7XG4gICAgICAgIHRoaXMud3JhcC5oID0gdGhpcy5yZW5kZXJIZWlnaHQ7XG4gICAgfVxuXG4gICAgZ2V0IF9zaWduYWxQcm94eSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgX2J1aWxkKCkge1xuICAgICAgICB0aGlzLnBhdGNoKHtcbiAgICAgICAgICAgIFdyYXA6IHt0eXBlOiB0aGlzLnN0YWdlLmdsID8gV2ViR0xGYXN0Qmx1ckNvbXBvbmVudCA6IEMyZEZhc3RCbHVyQ29tcG9uZW50fVxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuXG5jbGFzcyBDMmRGYXN0Qmx1ckNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9yY2VaSW5kZXhDb250ZXh0OiB0cnVlLFxuICAgICAgICAgICAgcnR0OiB0cnVlLFxuICAgICAgICAgICAgVGV4dHdyYXA6IHtzaGFkZXI6IHt0eXBlOiBDMmRCbHVyU2hhZGVyfSwgQ29udGVudDoge319XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG4gICAgICAgIHRoaXMuX3RleHR3cmFwID0gdGhpcy5zZWwoXCJUZXh0d3JhcFwiKTtcbiAgICAgICAgdGhpcy5fd3JhcHBlciA9IHRoaXMuc2VsKFwiVGV4dHdyYXA+Q29udGVudFwiKTtcblxuICAgICAgICB0aGlzLl9hbW91bnQgPSAwO1xuICAgICAgICB0aGlzLl9wYWRkaW5nWCA9IDA7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdZID0gMDtcblxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRTcGxpbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbXVsdGlTcGxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX211bHRpU3BsaW5lID0gbmV3IE11bHRpU3BsaW5lKCk7XG4gICAgICAgICAgICB0aGlzLl9tdWx0aVNwbGluZS5wYXJzZShmYWxzZSwgezA6IDAsIDAuMjU6IDEuNSwgMC41OiA1LjUsIDAuNzU6IDE4LCAxOiAzOX0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tdWx0aVNwbGluZTtcbiAgICB9XG5cbiAgICBnZXQgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsKCdUZXh0d3JhcD5Db250ZW50Jyk7XG4gICAgfVxuXG4gICAgc2V0IGNvbnRlbnQodikge1xuICAgICAgICB0aGlzLnNlbCgnVGV4dHdyYXA+Q29udGVudCcpLnBhdGNoKHYsIHRydWUpO1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nKHYpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1ggPSB2O1xuICAgICAgICB0aGlzLl9wYWRkaW5nWSA9IHY7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmdYKHYpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1ggPSB2O1xuICAgICAgICB0aGlzLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nWSh2KSB7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdZID0gdjtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlQmx1clNpemUoKSB7XG4gICAgICAgIGxldCB3ID0gdGhpcy5yZW5kZXJXaWR0aDtcbiAgICAgICAgbGV0IGggPSB0aGlzLnJlbmRlckhlaWdodDtcblxuICAgICAgICBsZXQgcGFkZGluZ1ggPSB0aGlzLl9wYWRkaW5nWDtcbiAgICAgICAgbGV0IHBhZGRpbmdZID0gdGhpcy5fcGFkZGluZ1k7XG5cbiAgICAgICAgdGhpcy5fd3JhcHBlci54ID0gcGFkZGluZ1g7XG4gICAgICAgIHRoaXMuX3RleHR3cmFwLnggPSAtcGFkZGluZ1g7XG5cbiAgICAgICAgdGhpcy5fd3JhcHBlci55ID0gcGFkZGluZ1k7XG4gICAgICAgIHRoaXMuX3RleHR3cmFwLnkgPSAtcGFkZGluZ1k7XG5cbiAgICAgICAgdGhpcy5fdGV4dHdyYXAudyA9IHcgKyBwYWRkaW5nWCAqIDI7XG4gICAgICAgIHRoaXMuX3RleHR3cmFwLmggPSBoICsgcGFkZGluZ1kgKiAyO1xuICAgIH1cblxuICAgIGdldCBhbW91bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbW91bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYW1vdW50IG9mIGJsdXIuIEEgdmFsdWUgYmV0d2VlbiAwIGFuZCA0LiBHb2VzIHVwIGV4cG9uZW50aWFsbHkgZm9yIGJsdXIuXG4gICAgICogQmVzdCByZXN1bHRzIGZvciBub24tZnJhY3Rpb25hbCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHY7XG4gICAgICovXG4gICAgc2V0IGFtb3VudCh2KSB7XG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IHY7XG4gICAgICAgIHRoaXMuX3RleHR3cmFwLnNoYWRlci5rZXJuZWxSYWRpdXMgPSBDMmRGYXN0Qmx1ckNvbXBvbmVudC5fYW1vdW50VG9LZXJuZWxSYWRpdXModik7XG4gICAgfVxuXG4gICAgc3RhdGljIF9hbW91bnRUb0tlcm5lbFJhZGl1cyh2KSB7XG4gICAgICAgIHJldHVybiBDMmRGYXN0Qmx1ckNvbXBvbmVudC5nZXRTcGxpbmUoKS5nZXRWYWx1ZShNYXRoLm1pbigxLCB2ICogMC4yNSkpO1xuICAgIH1cblxuICAgIGdldCBfc2lnbmFsUHJveHkoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufVxuXG5jbGFzcyBXZWJHTEZhc3RCbHVyQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgICAgIGNvbnN0IG9uVXBkYXRlID0gZnVuY3Rpb24oZWxlbWVudCwgZWxlbWVudENvcmUpIHtcbiAgICAgICAgICAgIGlmICgoZWxlbWVudENvcmUuX3JlY2FsYyAmICgyICsgMTI4KSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gZWxlbWVudENvcmUudztcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gZWxlbWVudENvcmUuaDtcbiAgICAgICAgICAgICAgICBsZXQgY3VyID0gZWxlbWVudENvcmU7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIuX2NoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgICAgICBjdXIuX2VsZW1lbnQudyA9IHc7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5fZWxlbWVudC5oID0gaDtcbiAgICAgICAgICAgICAgICB9IHdoaWxlKGN1ci5fY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBUZXh0d3JhcDoge3J0dDogdHJ1ZSwgZm9yY2VaSW5kZXhDb250ZXh0OiB0cnVlLCByZW5kZXJPZmZzY3JlZW46IHRydWUsIENvbnRlbnQ6IHt9fSxcbiAgICAgICAgICAgIExheWVyczoge1xuICAgICAgICAgICAgICAgIEwwOiB7cnR0OiB0cnVlLCBvblVwZGF0ZTogb25VcGRhdGUsIHJlbmRlck9mZnNjcmVlbjogdHJ1ZSwgdmlzaWJsZTogZmFsc2UsIENvbnRlbnQ6IHtzaGFkZXI6IHt0eXBlOiBCb3hCbHVyU2hhZGVyfX19LFxuICAgICAgICAgICAgICAgIEwxOiB7cnR0OiB0cnVlLCBvblVwZGF0ZTogb25VcGRhdGUsIHJlbmRlck9mZnNjcmVlbjogdHJ1ZSwgdmlzaWJsZTogZmFsc2UsIENvbnRlbnQ6IHtzaGFkZXI6IHt0eXBlOiBCb3hCbHVyU2hhZGVyfX19LFxuICAgICAgICAgICAgICAgIEwyOiB7cnR0OiB0cnVlLCBvblVwZGF0ZTogb25VcGRhdGUsIHJlbmRlck9mZnNjcmVlbjogdHJ1ZSwgdmlzaWJsZTogZmFsc2UsIENvbnRlbnQ6IHtzaGFkZXI6IHt0eXBlOiBCb3hCbHVyU2hhZGVyfX19LFxuICAgICAgICAgICAgICAgIEwzOiB7cnR0OiB0cnVlLCBvblVwZGF0ZTogb25VcGRhdGUsIHJlbmRlck9mZnNjcmVlbjogdHJ1ZSwgdmlzaWJsZTogZmFsc2UsIENvbnRlbnQ6IHtzaGFkZXI6IHt0eXBlOiBCb3hCbHVyU2hhZGVyfX19XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgUmVzdWx0OiB7c2hhZGVyOiB7dHlwZTogRmFzdEJsdXJPdXRwdXRTaGFkZXJ9LCB2aXNpYmxlOiBmYWxzZX1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBfc2lnbmFsUHJveHkoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcbiAgICAgICAgdGhpcy5fdGV4dHdyYXAgPSB0aGlzLnNlbChcIlRleHR3cmFwXCIpO1xuICAgICAgICB0aGlzLl93cmFwcGVyID0gdGhpcy5zZWwoXCJUZXh0d3JhcD5Db250ZW50XCIpO1xuICAgICAgICB0aGlzLl9sYXllcnMgPSB0aGlzLnNlbChcIkxheWVyc1wiKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0ID0gdGhpcy5zZWwoXCJSZXN1bHRcIik7XG5cbiAgICAgICAgdGhpcy5fYW1vdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1ggPSAwO1xuICAgICAgICB0aGlzLl9wYWRkaW5nWSA9IDA7XG4gICAgfVxuXG4gICAgX2J1aWxkTGF5ZXJzKCkge1xuICAgICAgICBjb25zdCBmaWx0ZXJTaGFkZXJTZXR0aW5ncyA9IFt7eDoxLHk6MCxrZXJuZWxSYWRpdXM6MX0se3g6MCx5OjEsa2VybmVsUmFkaXVzOjF9LHt4OjEuNSx5OjAsa2VybmVsUmFkaXVzOjF9LHt4OjAseToxLjUsa2VybmVsUmFkaXVzOjF9XTtcbiAgICAgICAgY29uc3QgZmlsdGVyU2hhZGVycyA9IGZpbHRlclNoYWRlclNldHRpbmdzLm1hcChzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlciA9IFNoYWRlci5jcmVhdGUodGhpcy5zdGFnZSwgT2JqZWN0LmFzc2lnbih7dHlwZTogTGluZWFyQmx1clNoYWRlcn0sIHMpKTtcbiAgICAgICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3NldExheWVyVGV4dHVyZSh0aGlzLmdldExheWVyQ29udGVudHMoMCksIHRoaXMuX3RleHR3cmFwLmdldFRleHR1cmUoKSwgW10pO1xuICAgICAgICB0aGlzLl9zZXRMYXllclRleHR1cmUodGhpcy5nZXRMYXllckNvbnRlbnRzKDEpLCB0aGlzLmdldExheWVyKDApLmdldFRleHR1cmUoKSwgW2ZpbHRlclNoYWRlcnNbMF0sIGZpbHRlclNoYWRlcnNbMV1dKTtcblxuICAgICAgICAvLyBOb3RpY2UgdGhhdCAxLjUgZmlsdGVycyBzaG91bGQgYmUgYXBwbGllZCBiZWZvcmUgMS4wIGZpbHRlcnMuXG4gICAgICAgIHRoaXMuX3NldExheWVyVGV4dHVyZSh0aGlzLmdldExheWVyQ29udGVudHMoMiksIHRoaXMuZ2V0TGF5ZXIoMSkuZ2V0VGV4dHVyZSgpLCBbZmlsdGVyU2hhZGVyc1swXSwgZmlsdGVyU2hhZGVyc1sxXSwgZmlsdGVyU2hhZGVyc1syXSwgZmlsdGVyU2hhZGVyc1szXV0pO1xuICAgICAgICB0aGlzLl9zZXRMYXllclRleHR1cmUodGhpcy5nZXRMYXllckNvbnRlbnRzKDMpLCB0aGlzLmdldExheWVyKDIpLmdldFRleHR1cmUoKSwgW2ZpbHRlclNoYWRlcnNbMF0sIGZpbHRlclNoYWRlcnNbMV0sIGZpbHRlclNoYWRlcnNbMl0sIGZpbHRlclNoYWRlcnNbM11dKTtcbiAgICB9XG5cbiAgICBfc2V0TGF5ZXJUZXh0dXJlKGVsZW1lbnQsIHRleHR1cmUsIHN0ZXBzKSB7XG4gICAgICAgIGlmICghc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbGVtZW50LnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzLnBvcCgpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBlbGVtZW50LnN0YWdlLmMoe3J0dDogdHJ1ZSwgc2hhZGVyOiBzdGVwfSk7XG5cbiAgICAgICAgICAgIC8vIFJlY3Vyc2UuXG4gICAgICAgICAgICB0aGlzLl9zZXRMYXllclRleHR1cmUoY2hpbGQsIHRleHR1cmUsIHN0ZXBzKTtcblxuICAgICAgICAgICAgZWxlbWVudC5jaGlsZExpc3QuYWRkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBnZXQgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsKCdUZXh0d3JhcD5Db250ZW50Jyk7XG4gICAgfVxuXG4gICAgc2V0IGNvbnRlbnQodikge1xuICAgICAgICB0aGlzLnNlbCgnVGV4dHdyYXA+Q29udGVudCcpLnBhdGNoKHYsIHRydWUpO1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nKHYpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1ggPSB2O1xuICAgICAgICB0aGlzLl9wYWRkaW5nWSA9IHY7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmdYKHYpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1ggPSB2O1xuICAgICAgICB0aGlzLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nWSh2KSB7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdZID0gdjtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBnZXRMYXllcihpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcnMuc2VsKFwiTFwiICsgaSk7XG4gICAgfVxuXG4gICAgZ2V0TGF5ZXJDb250ZW50cyhpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExheWVyKGkpLnNlbChcIkNvbnRlbnRcIik7XG4gICAgfVxuXG4gICAgX29uUmVzaXplKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIF91cGRhdGVCbHVyU2l6ZSgpIHtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnJlbmRlcldpZHRoO1xuICAgICAgICBsZXQgaCA9IHRoaXMucmVuZGVySGVpZ2h0O1xuXG4gICAgICAgIGxldCBwYWRkaW5nWCA9IHRoaXMuX3BhZGRpbmdYO1xuICAgICAgICBsZXQgcGFkZGluZ1kgPSB0aGlzLl9wYWRkaW5nWTtcblxuICAgICAgICBsZXQgZncgPSB3ICsgcGFkZGluZ1ggKiAyO1xuICAgICAgICBsZXQgZmggPSBoICsgcGFkZGluZ1kgKiAyO1xuICAgICAgICB0aGlzLl90ZXh0d3JhcC53ID0gZnc7XG4gICAgICAgIHRoaXMuX3dyYXBwZXIueCA9IHBhZGRpbmdYO1xuICAgICAgICB0aGlzLmdldExheWVyKDApLncgPSB0aGlzLmdldExheWVyQ29udGVudHMoMCkudyA9IGZ3IC8gMjtcbiAgICAgICAgdGhpcy5nZXRMYXllcigxKS53ID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDEpLncgPSBmdyAvIDQ7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMikudyA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygyKS53ID0gZncgLyA4O1xuICAgICAgICB0aGlzLmdldExheWVyKDMpLncgPSB0aGlzLmdldExheWVyQ29udGVudHMoMykudyA9IGZ3IC8gMTY7XG4gICAgICAgIHRoaXMuX291dHB1dC54ID0gLXBhZGRpbmdYO1xuICAgICAgICB0aGlzLl90ZXh0d3JhcC54ID0gLXBhZGRpbmdYO1xuICAgICAgICB0aGlzLl9vdXRwdXQudyA9IGZ3O1xuXG4gICAgICAgIHRoaXMuX3RleHR3cmFwLmggPSBmaDtcbiAgICAgICAgdGhpcy5fd3JhcHBlci55ID0gcGFkZGluZ1k7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMCkuaCA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygwKS5oID0gZmggLyAyO1xuICAgICAgICB0aGlzLmdldExheWVyKDEpLmggPSB0aGlzLmdldExheWVyQ29udGVudHMoMSkuaCA9IGZoIC8gNDtcbiAgICAgICAgdGhpcy5nZXRMYXllcigyKS5oID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDIpLmggPSBmaCAvIDg7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMykuaCA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygzKS5oID0gZmggLyAxNjtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnkgPSAtcGFkZGluZ1k7XG4gICAgICAgIHRoaXMuX3RleHR3cmFwLnkgPSAtcGFkZGluZ1k7XG4gICAgICAgIHRoaXMuX291dHB1dC5oID0gZmg7XG5cbiAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgdGhpcy5oID0gaDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhbW91bnQgb2YgYmx1ci4gQSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDQuIEdvZXMgdXAgZXhwb25lbnRpYWxseSBmb3IgYmx1ci5cbiAgICAgKiBCZXN0IHJlc3VsdHMgZm9yIG5vbi1mcmFjdGlvbmFsIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gdjtcbiAgICAgKi9cbiAgICBzZXQgYW1vdW50KHYpIHtcbiAgICAgICAgdGhpcy5fYW1vdW50ID0gdjtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IGFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ftb3VudDtcbiAgICB9XG5cbiAgICBfdXBkYXRlKCkge1xuICAgICAgICBsZXQgdiA9IE1hdGgubWluKDQsIE1hdGgubWF4KDAsIHRoaXMuX2Ftb3VudCkpO1xuICAgICAgICBpZiAodiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHdyYXAucmVuZGVyVG9UZXh0dXJlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXQuc2hhZGVyLm90aGVyVGV4dHVyZVNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHdyYXAucmVuZGVyVG9UZXh0dXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX291dHB1dC52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5nZXRMYXllcigwKS52aXNpYmxlID0gKHYgPiAwKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGF5ZXIoMSkudmlzaWJsZSA9ICh2ID4gMSk7XG4gICAgICAgICAgICB0aGlzLmdldExheWVyKDIpLnZpc2libGUgPSAodiA+IDIpO1xuICAgICAgICAgICAgdGhpcy5nZXRMYXllcigzKS52aXNpYmxlID0gKHYgPiAzKTtcblxuICAgICAgICAgICAgaWYgKHYgPD0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dC50ZXh0dXJlID0gdGhpcy5fdGV4dHdyYXAuZ2V0VGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dC5zaGFkZXIub3RoZXJUZXh0dXJlU291cmNlID0gdGhpcy5nZXRMYXllcigwKS5nZXRUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnNoYWRlci5hID0gdjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnRleHR1cmUgPSB0aGlzLmdldExheWVyKDApLmdldFRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXQuc2hhZGVyLm90aGVyVGV4dHVyZVNvdXJjZSA9IHRoaXMuZ2V0TGF5ZXIoMSkuZ2V0VGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dC5zaGFkZXIuYSA9IHYgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2IDw9IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXQudGV4dHVyZSA9IHRoaXMuZ2V0TGF5ZXIoMSkuZ2V0VGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dC5zaGFkZXIub3RoZXJUZXh0dXJlU291cmNlID0gdGhpcy5nZXRMYXllcigyKS5nZXRUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnNoYWRlci5hID0gdiAtIDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYgPD0gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dC50ZXh0dXJlID0gdGhpcy5nZXRMYXllcigyKS5nZXRUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnNoYWRlci5vdGhlclRleHR1cmVTb3VyY2UgPSB0aGlzLmdldExheWVyKDMpLmdldFRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXQuc2hhZGVyLmEgPSB2IC0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCBzaGFkZXIocykge1xuICAgICAgICBzdXBlci5zaGFkZXIgPSBzO1xuICAgICAgICBpZiAoIXRoaXMucmVuZGVyVG9UZXh0dXJlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbTGlnaHRuaW5nXSBQbGVhc2UgZW5hYmxlIHJlbmRlclRvVGV4dHVyZSB0byB1c2Ugd2l0aCBhIHNoYWRlci5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZmlyc3RBY3RpdmUoKSB7XG4gICAgICAgIHRoaXMuX2J1aWxkTGF5ZXJzKCk7XG4gICAgfVxuXG59XG5cbi8qKlxuICogU2hhZGVyIHRoYXQgY29tYmluZXMgdHdvIHRleHR1cmVzIGludG8gb25lIG91dHB1dC5cbiAqL1xuY2xhc3MgRmFzdEJsdXJPdXRwdXRTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICBzdXBlcihjdHgpO1xuXG4gICAgICAgIHRoaXMuX2EgPSAwO1xuICAgICAgICB0aGlzLl9vdGhlclRleHR1cmVTb3VyY2UgPSBudWxsO1xuICAgIH1cblxuICAgIGdldCBhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYTtcbiAgICB9XG5cbiAgICBzZXQgYSh2KSB7XG4gICAgICAgIHRoaXMuX2EgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldCBvdGhlclRleHR1cmVTb3VyY2Uodikge1xuICAgICAgICB0aGlzLl9vdGhlclRleHR1cmVTb3VyY2UgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImFcIiwgdGhpcy5fYSwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwidVNhbXBsZXIyXCIsIDEsIHRoaXMuZ2wudW5pZm9ybTFpKTtcbiAgICB9XG5cbiAgICBiZWZvcmVEcmF3KG9wZXJhdGlvbikge1xuICAgICAgICBsZXQgZ2xUZXh0dXJlID0gdGhpcy5fb3RoZXJUZXh0dXJlU291cmNlID8gdGhpcy5fb3RoZXJUZXh0dXJlU291cmNlLm5hdGl2ZVRleHR1cmUgOiBudWxsO1xuXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBnbFRleHR1cmUpO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICB9XG59XG5cbkZhc3RCbHVyT3V0cHV0U2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXIyO1xuICAgIHVuaWZvcm0gZmxvYXQgYTtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGlmIChhID09IDEuMCkge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyMiwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSAoKDEuMCAtIGEpICogdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSArIChhICogdGV4dHVyZTJEKHVTYW1wbGVyMiwgdlRleHR1cmVDb29yZCkpKSAqIHZDb2xvcjtcbiAgICAgICAgfVxuICAgIH1cbmA7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuLi9hcHBsaWNhdGlvbi9Db21wb25lbnQubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuXG4gICAgICAgIHRoaXMuX3dyYXBwZXIgPSBzdXBlci5fY2hpbGRyZW4uYSh7fSk7XG5cbiAgICAgICAgdGhpcy5fcmVsb2FkVmlzaWJsZUVsZW1lbnRzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fdmlzaWJsZUl0ZW1zID0gbmV3IFNldCgpO1xuXG4gICAgICAgIHRoaXMuX2luZGV4ID0gMDtcblxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0cmFuc2l0aW9uIGRlZmluaXRpb24gdGhhdCBpcyBiZWluZyB1c2VkIHdoZW4gc2Nyb2xsaW5nIHRoZSBpdGVtcy5cbiAgICAgICAgICogQHR5cGUgVHJhbnNpdGlvblNldHRpbmdzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zY3JvbGxUcmFuc2l0aW9uU2V0dGluZ3MgPSB0aGlzLnN0YWdlLnRyYW5zaXRpb25zLmNyZWF0ZVNldHRpbmdzKHt9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjcm9sbCBhcmVhIHNpemUgaW4gcGl4ZWxzIHBlciBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXRlbVNpemUgPSAxMDA7XG5cbiAgICAgICAgdGhpcy5fdmlld3BvcnRTY3JvbGxPZmZzZXQgPSAwO1xuXG4gICAgICAgIHRoaXMuX2l0ZW1TY3JvbGxPZmZzZXQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgdGhlIGxpc3QganVtcCB3aGVuIHNjcm9sbGluZyBiZXR3ZWVuIGVuZCB0byBzdGFydCwgb3Igc2hvdWxkIGl0IGJlIGNvbnRpbnVvdXMsIGxpa2UgYSBjYXJyb3VzZWw/XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yb2xsID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93cyByZXN0cmljdGluZyB0aGUgc3RhcnQgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcm9sbE1pbiA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93cyByZXN0cmljdGluZyB0aGUgZW5kIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JvbGxNYXggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbml0aW9uIGZvciBhIGN1c3RvbSBhbmltYXRpb24gdGhhdCBpcyBhcHBsaWVkIHdoZW4gYW4gaXRlbSBpcyAocGFydGlhbGx5KSBzZWxlY3RlZC5cbiAgICAgICAgICogQHR5cGUgQW5pbWF0aW9uU2V0dGluZ3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzQW5pbWF0aW9uID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW52ZXJ0cyB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbnZlcnREaXJlY3Rpb24gPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGF5b3V0IHRoZSBpdGVtcyBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseT9cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ob3Jpem9udGFsID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLml0ZW1MaXN0ID0gbmV3IExpc3RJdGVtcyh0aGlzKTtcbiAgICB9XG5cbiAgICBfYWxsb3dDaGlsZHJlbkFjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbUxpc3QuZ2V0KCk7XG4gICAgfVxuXG4gICAgc2V0IGl0ZW1zKGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuaXRlbUxpc3QucGF0Y2goY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLl93cmFwcGVyLnRyYW5zaXRpb24odGhpcy5wcm9wZXJ0eSwgdGhpcy5fc2Nyb2xsVHJhbnNpdGlvblNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVHJhbnNpdGlvbiA9IHRoaXMuX3dyYXBwZXIudHJhbnNpdGlvbih0aGlzLnByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVHJhbnNpdGlvbi5vbigncHJvZ3Jlc3MnLCBwID0+IHRoaXMudXBkYXRlKCkpO1xuXG4gICAgICAgIHRoaXMuc2V0SW5kZXgoMCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBzZXRJbmRleChpbmRleCwgaW1tZWRpYXRlID0gZmFsc2UsIGNsb3Nlc3QgPSBmYWxzZSkge1xuICAgICAgICBsZXQgbkVsZW1lbnRzID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmICghbkVsZW1lbnRzKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5lbWl0KCd1bmZvY3VzJywgdGhpcy5nZXRFbGVtZW50KHRoaXMucmVhbEluZGV4KSwgdGhpcy5faW5kZXgsIHRoaXMucmVhbEluZGV4KTtcblxuICAgICAgICBpZiAoY2xvc2VzdCkge1xuICAgICAgICAgICAgLy8gU2Nyb2xsIHRvIHNhbWUgb2Zmc2V0IGNsb3Nlc3QgdG8gdGhlIGluZGV4LlxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IFV0aWxzLmdldE1vZHVsb0luZGV4KGluZGV4LCBuRWxlbWVudHMpO1xuICAgICAgICAgICAgbGV0IG8gPSBVdGlscy5nZXRNb2R1bG9JbmRleCh0aGlzLmluZGV4LCBuRWxlbWVudHMpO1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBvZmZzZXQgLSBvO1xuICAgICAgICAgICAgaWYgKGRpZmYgPiAwLjUgKiBuRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBkaWZmIC09IG5FbGVtZW50cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZiA8IC0wLjUgKiBuRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBkaWZmICs9IG5FbGVtZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luZGV4ICs9IGRpZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3JvbGwgfHwgKHRoaXMudmlld3BvcnRTaXplID4gdGhpcy5faXRlbVNpemUgKiBuRWxlbWVudHMpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IFV0aWxzLmdldE1vZHVsb0luZGV4KHRoaXMuX2luZGV4LCBuRWxlbWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9ICh0aGlzLl9ob3Jpem9udGFsIF4gdGhpcy5faW52ZXJ0RGlyZWN0aW9uID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IHZhbHVlID0gZGlyZWN0aW9uICogdGhpcy5faW5kZXggKiB0aGlzLl9pdGVtU2l6ZTtcblxuICAgICAgICBpZiAodGhpcy5fcm9sbCkge1xuICAgICAgICAgICAgbGV0IG1pbiwgbWF4LCBzY3JvbGxEZWx0YTtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gMSkge1xuICAgICAgICAgICAgICAgIG1heCA9IChuRWxlbWVudHMgLSAxKSAqIHRoaXMuX2l0ZW1TaXplO1xuICAgICAgICAgICAgICAgIHNjcm9sbERlbHRhID0gdGhpcy5fdmlld3BvcnRTY3JvbGxPZmZzZXQgKiB0aGlzLnZpZXdwb3J0U2l6ZSAtIHRoaXMuX2l0ZW1TY3JvbGxPZmZzZXQgKiB0aGlzLl9pdGVtU2l6ZTtcblxuICAgICAgICAgICAgICAgIG1heCAtPSBzY3JvbGxEZWx0YTtcblxuICAgICAgICAgICAgICAgIG1pbiA9IHRoaXMudmlld3BvcnRTaXplIC0gKHRoaXMuX2l0ZW1TaXplICsgc2Nyb2xsRGVsdGEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JvbGxNaW4pIG1pbiAtPSB0aGlzLl9yb2xsTWluO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yb2xsTWF4KSBtYXggKz0gdGhpcy5fcm9sbE1heDtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIG1heCksIG1pbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1heCA9IChuRWxlbWVudHMgKiB0aGlzLl9pdGVtU2l6ZSAtIHRoaXMudmlld3BvcnRTaXplKTtcbiAgICAgICAgICAgICAgICBzY3JvbGxEZWx0YSA9IHRoaXMuX3ZpZXdwb3J0U2Nyb2xsT2Zmc2V0ICogdGhpcy52aWV3cG9ydFNpemUgLSB0aGlzLl9pdGVtU2Nyb2xsT2Zmc2V0ICogdGhpcy5faXRlbVNpemU7XG5cbiAgICAgICAgICAgICAgICBtYXggKz0gc2Nyb2xsRGVsdGE7XG5cbiAgICAgICAgICAgICAgICBsZXQgbWluID0gc2Nyb2xsRGVsdGE7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcm9sbE1pbikgbWluIC09IHRoaXMuX3JvbGxNaW47XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JvbGxNYXgpIG1heCArPSB0aGlzLl9yb2xsTWF4O1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihNYXRoLm1heCgtbWF4LCB2YWx1ZSksIC1taW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2Nyb2xsVHJhbnNpdGlvbi5zdGFydCh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVHJhbnNpdGlvbi5maW5pc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnZm9jdXMnLCB0aGlzLmdldEVsZW1lbnQodGhpcy5yZWFsSW5kZXgpLCB0aGlzLl9pbmRleCwgdGhpcy5yZWFsSW5kZXgpO1xuICAgIH1cblxuICAgIGdldEF4aXNQb3NpdGlvbigpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IC10aGlzLl9zY3JvbGxUcmFuc2l0aW9uLl90YXJnZXRWYWx1ZTtcblxuICAgICAgICBsZXQgZGlyZWN0aW9uID0gKHRoaXMuX2hvcml6b250YWwgXiB0aGlzLl9pbnZlcnREaXJlY3Rpb24gPyAtMSA6IDEpO1xuICAgICAgICBsZXQgdmFsdWUgPSAtZGlyZWN0aW9uICogdGhpcy5faW5kZXggKiB0aGlzLl9pdGVtU2l6ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRTY3JvbGxPZmZzZXQgKiB0aGlzLnZpZXdwb3J0U2l6ZSArICh2YWx1ZSAtIHRhcmdldCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHJldHVybjtcblxuICAgICAgICBsZXQgbkVsZW1lbnRzID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmICghbkVsZW1lbnRzKSByZXR1cm47XG5cbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9ICh0aGlzLl9ob3Jpem9udGFsIF4gdGhpcy5faW52ZXJ0RGlyZWN0aW9uID8gLTEgOiAxKTtcblxuICAgICAgICAvLyBNYXAgcG9zaXRpb24gdG8gaW5kZXggdmFsdWUuXG4gICAgICAgIGxldCB2ID0gKHRoaXMuX2hvcml6b250YWwgPyB0aGlzLl93cmFwcGVyLnggOiB0aGlzLl93cmFwcGVyLnkpO1xuXG4gICAgICAgIGxldCB2aWV3cG9ydFNpemUgPSB0aGlzLnZpZXdwb3J0U2l6ZTtcbiAgICAgICAgbGV0IHNjcm9sbERlbHRhID0gdGhpcy5fdmlld3BvcnRTY3JvbGxPZmZzZXQgKiB2aWV3cG9ydFNpemUgLSB0aGlzLl9pdGVtU2Nyb2xsT2Zmc2V0ICogdGhpcy5faXRlbVNpemU7XG4gICAgICAgIHYgKz0gc2Nyb2xsRGVsdGE7XG5cbiAgICAgICAgbGV0IHMsIGUsIHBzLCBwZTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSAtMSkge1xuICAgICAgICAgICAgcyA9IE1hdGguZmxvb3IoLXYgLyB0aGlzLl9pdGVtU2l6ZSk7XG4gICAgICAgICAgICBwcyA9IDEgLSAoKC12IC8gdGhpcy5faXRlbVNpemUpIC0gcyk7XG4gICAgICAgICAgICBlID0gTWF0aC5mbG9vcigodmlld3BvcnRTaXplIC0gdikgLyB0aGlzLl9pdGVtU2l6ZSk7XG4gICAgICAgICAgICBwZSA9ICgoKHZpZXdwb3J0U2l6ZSAtIHYpIC8gdGhpcy5faXRlbVNpemUpIC0gZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzID0gTWF0aC5jZWlsKHYgLyB0aGlzLl9pdGVtU2l6ZSk7XG4gICAgICAgICAgICBwcyA9IDEgKyAodiAvIHRoaXMuX2l0ZW1TaXplKSAtIHM7XG4gICAgICAgICAgICBlID0gTWF0aC5jZWlsKCh2IC0gdmlld3BvcnRTaXplKSAvIHRoaXMuX2l0ZW1TaXplKTtcbiAgICAgICAgICAgIHBlID0gZSAtICgodiAtIHZpZXdwb3J0U2l6ZSkgLyB0aGlzLl9pdGVtU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JvbGwgfHwgKHZpZXdwb3J0U2l6ZSA+IHRoaXMuX2l0ZW1TaXplICogbkVsZW1lbnRzKSkge1xuICAgICAgICAgICAgLy8gRG9uJ3Qgc2hvdyBhZGRpdGlvbmFsIGl0ZW1zLlxuICAgICAgICAgICAgaWYgKGUgPj0gbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZSA9IG5FbGVtZW50cyAtIDE7XG4gICAgICAgICAgICAgICAgcGUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMgPj0gbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgcyA9IG5FbGVtZW50cyAtIDE7XG4gICAgICAgICAgICAgICAgcHMgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgPD0gLTEpIHtcbiAgICAgICAgICAgICAgICBlID0gMDtcbiAgICAgICAgICAgICAgICBwZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocyA8PSAtMSkge1xuICAgICAgICAgICAgICAgIHMgPSAwO1xuICAgICAgICAgICAgICAgIHBzID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvZmZzZXQgPSAtZGlyZWN0aW9uICogcyAqIHRoaXMuX2l0ZW1TaXplO1xuXG4gICAgICAgIGxldCBpdGVtO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHM7IChkaXJlY3Rpb24gPT0gLTEgPyBpbmRleCA8PSBlIDogaW5kZXggPj0gZSk7IChkaXJlY3Rpb24gPT0gLTEgPyBpbmRleCsrIDogaW5kZXgtLSkpIHtcbiAgICAgICAgICAgIGxldCByZWFsSW5kZXggPSBVdGlscy5nZXRNb2R1bG9JbmRleChpbmRleCwgbkVsZW1lbnRzKTtcblxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQocmVhbEluZGV4KTtcbiAgICAgICAgICAgIGl0ZW0gPSBlbGVtZW50LnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVJdGVtcy5kZWxldGUoaXRlbSk7XG4gICAgICAgICAgICBpZiAodGhpcy5faG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGl0ZW0ueCA9IG9mZnNldCArIHNjcm9sbERlbHRhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLnkgPSBvZmZzZXQgKyBzY3JvbGxEZWx0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHdhc1Zpc2libGUgPSBpdGVtLnZpc2libGU7XG4gICAgICAgICAgICBpdGVtLnZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIXdhc1Zpc2libGUgfHwgdGhpcy5fcmVsb2FkVmlzaWJsZUVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgLy8gVHVybmVkIHZpc2libGUuXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd2aXNpYmxlJywgaW5kZXgsIHJlYWxJbmRleCk7XG4gICAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgcCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHBzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT0gZSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gcGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGFuaW1hdGlvbiB0byBwcm9ncmVzcy5cbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzc0FuaW1hdGlvbi5hcHBseShlbGVtZW50LCBwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuX2l0ZW1TaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGl0ZW0gdmlzaWJpbGl0eS5cbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLl92aXNpYmxlSXRlbXMuZm9yRWFjaChmdW5jdGlvbihpbnZpc2libGVJdGVtKSB7XG4gICAgICAgICAgICBpbnZpc2libGVJdGVtLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuX3Zpc2libGVJdGVtcy5kZWxldGUoaW52aXNpYmxlSXRlbSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gczsgKGRpcmVjdGlvbiA9PSAtMSA/IGluZGV4IDw9IGUgOiBpbmRleCA+PSBlKTsgKGRpcmVjdGlvbiA9PSAtMSA/IGluZGV4KysgOiBpbmRleC0tKSkge1xuICAgICAgICAgICAgbGV0IHJlYWxJbmRleCA9IFV0aWxzLmdldE1vZHVsb0luZGV4KGluZGV4LCBuRWxlbWVudHMpO1xuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZUl0ZW1zLmFkZCh0aGlzLmdldFdyYXBwZXIocmVhbEluZGV4KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZWxvYWRWaXNpYmxlRWxlbWVudHMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzZXRQcmV2aW91cygpIHtcbiAgICAgICAgdGhpcy5zZXRJbmRleCh0aGlzLl9pbmRleCAtIDEpO1xuICAgIH1cblxuICAgIHNldE5leHQoKSB7XG4gICAgICAgIHRoaXMuc2V0SW5kZXgodGhpcy5faW5kZXggKyAxKTtcbiAgICB9XG5cbiAgICBnZXRXcmFwcGVyKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwcGVyLmNoaWxkcmVuW2luZGV4XTtcbiAgICB9XG5cbiAgICBnZXRFbGVtZW50KGluZGV4KSB7XG4gICAgICAgIGxldCBlID0gdGhpcy5fd3JhcHBlci5jaGlsZHJlbltpbmRleF07XG4gICAgICAgIHJldHVybiBlID8gZS5jaGlsZHJlblswXSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmVsb2FkKCkge1xuICAgICAgICB0aGlzLl9yZWxvYWRWaXNpYmxlRWxlbWVudHMgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICBsZXQgZSA9IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW5bdGhpcy5yZWFsSW5kZXhdO1xuICAgICAgICByZXR1cm4gZSA/IGUuY2hpbGRyZW5bMF0gOiBudWxsO1xuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aDtcbiAgICB9XG5cbiAgICBnZXQgcHJvcGVydHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ob3Jpem9udGFsID8gJ3gnIDogJ3knO1xuICAgIH1cblxuICAgIGdldCB2aWV3cG9ydFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ob3Jpem9udGFsID8gdGhpcy53IDogdGhpcy5oO1xuICAgIH1cblxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICAgIH1cblxuICAgIGdldCByZWFsSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBVdGlscy5nZXRNb2R1bG9JbmRleCh0aGlzLl9pbmRleCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cblxuICAgIGdldCBpdGVtU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1TaXplO1xuICAgIH1cblxuICAgIHNldCBpdGVtU2l6ZSh2KSB7XG4gICAgICAgIHRoaXMuX2l0ZW1TaXplID0gdjtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBnZXQgdmlld3BvcnRTY3JvbGxPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFNjcm9sbE9mZnNldDtcbiAgICB9XG5cbiAgICBzZXQgdmlld3BvcnRTY3JvbGxPZmZzZXQodikge1xuICAgICAgICB0aGlzLl92aWV3cG9ydFNjcm9sbE9mZnNldCA9IHY7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IGl0ZW1TY3JvbGxPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtU2Nyb2xsT2Zmc2V0O1xuICAgIH1cblxuICAgIHNldCBpdGVtU2Nyb2xsT2Zmc2V0KHYpIHtcbiAgICAgICAgdGhpcy5faXRlbVNjcm9sbE9mZnNldCA9IHY7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHNjcm9sbFRyYW5zaXRpb25TZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbFRyYW5zaXRpb25TZXR0aW5ncztcbiAgICB9XG5cbiAgICBzZXQgc2Nyb2xsVHJhbnNpdGlvblNldHRpbmdzKHYpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVHJhbnNpdGlvblNldHRpbmdzLnBhdGNoKHYpO1xuICAgIH1cblxuICAgIHNldCBzY3JvbGxUcmFuc2l0aW9uKHYpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVHJhbnNpdGlvblNldHRpbmdzLnBhdGNoKHYpO1xuICAgIH1cblxuICAgIGdldCBzY3JvbGxUcmFuc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsVHJhbnNpdGlvbjtcbiAgICB9XG5cbiAgICBnZXQgcHJvZ3Jlc3NBbmltYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9ncmVzc0FuaW1hdGlvbjtcbiAgICB9XG5cbiAgICBzZXQgcHJvZ3Jlc3NBbmltYXRpb24odikge1xuICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc0FuaW1hdGlvbiA9IHRoaXMuc3RhZ2UuYW5pbWF0aW9ucy5jcmVhdGVTZXR0aW5ncyh2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzQW5pbWF0aW9uID0gdjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGdldCByb2xsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9sbDtcbiAgICB9XG5cbiAgICBzZXQgcm9sbCh2KSB7XG4gICAgICAgIHRoaXMuX3JvbGwgPSB2O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGdldCByb2xsTWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9sbE1pbjtcbiAgICB9XG5cbiAgICBzZXQgcm9sbE1pbih2KSB7XG4gICAgICAgIHRoaXMuX3JvbGxNaW4gPSB2O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGdldCByb2xsTWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9sbE1heDtcbiAgICB9XG5cbiAgICBzZXQgcm9sbE1heCh2KSB7XG4gICAgICAgIHRoaXMuX3JvbGxNYXggPSB2O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGdldCBpbnZlcnREaXJlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZlcnREaXJlY3Rpb247XG4gICAgfVxuXG4gICAgc2V0IGludmVydERpcmVjdGlvbih2KSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5faW52ZXJ0RGlyZWN0aW9uID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBob3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faG9yaXpvbnRhbDtcbiAgICB9XG5cbiAgICBzZXQgaG9yaXpvbnRhbCh2KSB7XG4gICAgICAgIGlmICh2ICE9PSB0aGlzLl9ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ob3Jpem9udGFsID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5pbXBvcnQgT2JqZWN0TGlzdFdyYXBwZXIgZnJvbSBcIi4uL3Rvb2xzL09iamVjdExpc3RXcmFwcGVyLm1qc1wiO1xuY2xhc3MgTGlzdEl0ZW1zIGV4dGVuZHMgT2JqZWN0TGlzdFdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGxpc3QpIHtcbiAgICAgICAgbGV0IHdyYXAgPSAoaXRlbSA9PiB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gaXRlbS5zdGFnZS5jcmVhdGVFbGVtZW50KCk7XG4gICAgICAgICAgICBwYXJlbnQuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgcGFyZW50LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH0pXG5cbiAgICAgICAgc3VwZXIobGlzdC5fd3JhcHBlci5fY2hpbGRyZW4sIHdyYXApO1xuICAgICAgICB0aGlzLmxpc3QgPSBsaXN0O1xuICAgIH1cblxuICAgIG9uQWRkKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHN1cGVyLm9uQWRkKGl0ZW0sIGluZGV4KTtcbiAgICAgICAgdGhpcy5jaGVja1N0YXJ0ZWQoaW5kZXgpO1xuICAgIH1cblxuICAgIGNoZWNrU3RhcnRlZChpbmRleCkge1xuICAgICAgICB0aGlzLmxpc3QuX3JlbG9hZFZpc2libGVFbGVtZW50cyA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5saXN0Ll9zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3Quc3RhcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0LnNldEluZGV4KDAsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0Ll9pbmRleCA+PSB0aGlzLmxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zZXRJbmRleCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxpc3QudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblJlbW92ZShpdGVtLCBpbmRleCkge1xuICAgICAgICBzdXBlci5vblJlbW92ZShpdGVtLCBpbmRleCk7XG4gICAgICAgIGxldCByaSA9IHRoaXMubGlzdC5yZWFsSW5kZXg7XG4gICAgICAgIGlmIChyaSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChyaSA9PT0gdGhpcy5saXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zZXRJbmRleChyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmkgPiBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5saXN0LnNldEluZGV4KHJpIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxpc3QuX3JlbG9hZFZpc2libGVFbGVtZW50cyA9IHRydWU7XG4gICAgfVxuXG4gICAgb25TZXQoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgc3VwZXIub25TZXQoaXRlbSwgaW5kZXgpO1xuICAgICAgICB0aGlzLmNoZWNrU3RhcnRlZChpbmRleCk7XG4gICAgfVxuXG4gICAgb25TeW5jKHJlbW92ZWQsIGFkZGVkLCBvcmRlcikge1xuICAgICAgICBzdXBlci5vblN5bmMocmVtb3ZlZCwgYWRkZWQsIG9yZGVyKTtcbiAgICAgICAgdGhpcy5jaGVja1N0YXJ0ZWQoMCk7XG4gICAgfVxuXG4gICAgZ2V0IF9zaWduYWxQcm94eSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59XG5cbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdHJlZS9VdGlscy5tanNcIjtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4uL2FwcGxpY2F0aW9uL0NvbXBvbmVudC5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU21vb3RoU2NhbGVDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIENvbnRlbnRXcmFwOiB7cmVuZGVyT2Zmc2NyZWVuOiB0cnVlLCBmb3JjZVpJbmRleENvbnRleHQ6IHRydWUsIG9uQWZ0ZXJVcGRhdGU6IFNtb290aFNjYWxlQ29tcG9uZW50Ll91cGRhdGVEaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIENvbnRlbnQ6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgU2NhbGU6IHt2aXNpYmxlOiBmYWxzZX1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcblxuICAgICAgICB0aGlzLl9zbW9vdGhTY2FsZSA9IDE7XG4gICAgICAgIHRoaXMuX2l0ZXJhdGlvbnMgPSAwO1xuICAgIH1cblxuICAgIGdldCBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcoJ0NvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBzZXQgY29udGVudCh2KSB7XG4gICAgICAgIHRoaXMudGFnKCdDb250ZW50JykucGF0Y2godiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IHNtb290aFNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc21vb3RoU2NhbGU7XG4gICAgfVxuXG4gICAgc2V0IHNtb290aFNjYWxlKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Ntb290aFNjYWxlICE9PSB2KSB7XG4gICAgICAgICAgICBsZXQgaXRzID0gMDtcbiAgICAgICAgICAgIHdoaWxlKHYgPCAwLjUgJiYgaXRzIDwgMTIpIHtcbiAgICAgICAgICAgICAgICBpdHMrKztcbiAgICAgICAgICAgICAgICB2ID0gdiAqIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSB2O1xuICAgICAgICAgICAgdGhpcy5fc2V0SXRlcmF0aW9ucyhpdHMpO1xuXG4gICAgICAgICAgICB0aGlzLl9zbW9vdGhTY2FsZSA9IHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0SXRlcmF0aW9ucyhpdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2l0ZXJhdGlvbnMgIT09IGl0cykge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVycyA9IHRoaXMuc2VsKFwiU2NhbGVcIikuY2hpbGRMaXN0O1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuc2VsKFwiQ29udGVudFdyYXBcIik7XG4gICAgICAgICAgICB3aGlsZSAoc2NhbGVycy5sZW5ndGggPCBpdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IHNjYWxlcnMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSAoZmlyc3QgPyBjb250ZW50LmdldFRleHR1cmUoKSA6IHNjYWxlcnMubGFzdC5nZXRUZXh0dXJlKCkpO1xuICAgICAgICAgICAgICAgIHNjYWxlcnMuYSh7cnR0OiB0cnVlLCByZW5kZXJPZmZzY3JlZW46IHRydWUsIHRleHR1cmU6IHRleHR1cmV9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgU21vb3RoU2NhbGVDb21wb25lbnQuX3VwZGF0ZURpbWVuc2lvbnModGhpcy50YWcoXCJDb250ZW50V3JhcFwiKSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHVzZVNjYWxlcnMgPSAoaXRzID4gMCk7XG4gICAgICAgICAgICB0aGlzLnBhdGNoKHtcbiAgICAgICAgICAgICAgICBDb250ZW50V3JhcDoge3JlbmRlclRvVGV4dHVyZTogdXNlU2NhbGVyc30sXG4gICAgICAgICAgICAgICAgU2NhbGU6IHt2aXNpYmxlOiB1c2VTY2FsZXJzfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gc2NhbGVycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzY2FsZXJzLmdldEF0KGkpLnBhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogaSA8IGl0cyxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyT2Zmc2NyZWVuOiBpICE9PSBpdHMgLSAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pdGVyYXRpb25zID0gaXRzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIF91cGRhdGVEaW1lbnNpb25zKGNvbnRlbnRXcmFwLCBmb3JjZSkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gY29udGVudFdyYXAuY2hpbGRyZW5bMF07XG4gICAgICAgIGxldCB3ID0gY29udGVudC5yZW5kZXJXaWR0aDtcbiAgICAgICAgbGV0IGggPSBjb250ZW50LnJlbmRlckhlaWdodDtcbiAgICAgICAgaWYgKHcgIT09IGNvbnRlbnRXcmFwLncgfHwgaCAhPT0gY29udGVudFdyYXAuaCB8fCBmb3JjZSkge1xuICAgICAgICAgICAgY29udGVudFdyYXAudyA9IHc7XG4gICAgICAgICAgICBjb250ZW50V3JhcC5oID0gaDtcblxuICAgICAgICAgICAgY29uc3Qgc2NhbGVycyA9IGNvbnRlbnRXcmFwLnBhcmVudC50YWcoXCJTY2FsZVwiKS5jaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gc2NhbGVycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB3ID0gdyAqIDAuNTtcbiAgICAgICAgICAgICAgICBoID0gaCAqIDAuNTtcbiAgICAgICAgICAgICAgICBzY2FsZXJzW2ldLncgPSB3O1xuICAgICAgICAgICAgICAgIHNjYWxlcnNbaV0uaCA9IGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgX3NpZ25hbFByb3h5KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBCYXNlIGZyb20gXCIuLi90cmVlL0Jhc2UubWpzXCI7XG5pbXBvcnQgTGF5b3V0IGZyb20gXCIuL2xheW91dC9GbGV4TGF5b3V0Lm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGbGV4Q29udGFpbmVyIHtcblxuXG4gICAgY29uc3RydWN0b3IoaXRlbSkge1xuICAgICAgICB0aGlzLl9pdGVtID0gaXRlbTtcblxuICAgICAgICB0aGlzLl9sYXlvdXQgPSBuZXcgTGF5b3V0KHRoaXMpO1xuICAgICAgICB0aGlzLl9ob3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmV2ZXJzZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl93cmFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2FsaWduSXRlbXMgPSAnc3RyZXRjaCc7XG4gICAgICAgIHRoaXMuX2p1c3RpZnlDb250ZW50ID0gJ2ZsZXgtc3RhcnQnO1xuICAgICAgICB0aGlzLl9hbGlnbkNvbnRlbnQgPSAnZmxleC1zdGFydCc7XG5cbiAgICAgICAgdGhpcy5fcGFkZGluZ0xlZnQgPSAwO1xuICAgICAgICB0aGlzLl9wYWRkaW5nVG9wID0gMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1JpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IGl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtO1xuICAgIH1cblxuICAgIF9jaGFuZ2VkRGltZW5zaW9ucygpIHtcbiAgICAgICAgdGhpcy5faXRlbS5jaGFuZ2VkRGltZW5zaW9ucygpO1xuICAgIH1cblxuICAgIF9jaGFuZ2VkQ29udGVudHMoKSB7XG4gICAgICAgIHRoaXMuX2l0ZW0uY2hhbmdlZENvbnRlbnRzKCk7XG4gICAgfVxuXG4gICAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9ob3Jpem9udGFsID8gXCJyb3dcIiA6IFwiY29sdW1uXCIpICsgKHRoaXMuX3JldmVyc2UgPyBcIi1yZXZlcnNlXCIgOiBcIlwiKTtcbiAgICB9XG5cbiAgICBzZXQgZGlyZWN0aW9uKGYpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSBmKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5faG9yaXpvbnRhbCA9IChmID09PSAncm93JyB8fCBmID09PSAncm93LXJldmVyc2UnKTtcbiAgICAgICAgdGhpcy5fcmV2ZXJzZSA9IChmID09PSAncm93LXJldmVyc2UnIHx8IGYgPT09ICdjb2x1bW4tcmV2ZXJzZScpO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZWRDb250ZW50cygpO1xuICAgIH1cblxuICAgIHNldCB3cmFwKHYpIHtcbiAgICAgICAgdGhpcy5fd3JhcCA9IHY7XG4gICAgICAgIHRoaXMuX2NoYW5nZWRDb250ZW50cygpO1xuICAgIH1cblxuICAgIGdldCB3cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcDtcbiAgICB9XG5cbiAgICBnZXQgYWxpZ25JdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsaWduSXRlbXM7XG4gICAgfVxuXG4gICAgc2V0IGFsaWduSXRlbXModikge1xuICAgICAgICBpZiAodGhpcy5fYWxpZ25JdGVtcyA9PT0gdikgcmV0dXJuO1xuICAgICAgICBpZiAoRmxleENvbnRhaW5lci5BTElHTl9JVEVNUy5pbmRleE9mKHYpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhbGlnbkl0ZW1zLCBvcHRpb25zOiBcIiArIEZsZXhDb250YWluZXIuQUxJR05fSVRFTVMuam9pbihcIixcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FsaWduSXRlbXMgPSB2O1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZWRDb250ZW50cygpO1xuICAgIH1cblxuICAgIGdldCBhbGlnbkNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGlnbkNvbnRlbnQ7XG4gICAgfVxuXG4gICAgc2V0IGFsaWduQ29udGVudCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9hbGlnbkNvbnRlbnQgPT09IHYpIHJldHVybjtcbiAgICAgICAgaWYgKEZsZXhDb250YWluZXIuQUxJR05fQ09OVEVOVC5pbmRleE9mKHYpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhbGlnbkNvbnRlbnQsIG9wdGlvbnM6IFwiICsgRmxleENvbnRhaW5lci5BTElHTl9DT05URU5ULmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbGlnbkNvbnRlbnQgPSB2O1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZWRDb250ZW50cygpO1xuICAgIH1cblxuICAgIGdldCBqdXN0aWZ5Q29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3RpZnlDb250ZW50O1xuICAgIH1cblxuICAgIHNldCBqdXN0aWZ5Q29udGVudCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9qdXN0aWZ5Q29udGVudCA9PT0gdikgcmV0dXJuO1xuXG4gICAgICAgIGlmIChGbGV4Q29udGFpbmVyLkpVU1RJRllfQ09OVEVOVC5pbmRleE9mKHYpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBqdXN0aWZ5Q29udGVudCwgb3B0aW9uczogXCIgKyBGbGV4Q29udGFpbmVyLkpVU1RJRllfQ09OVEVOVC5qb2luKFwiLFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fanVzdGlmeUNvbnRlbnQgPSB2O1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZWRDb250ZW50cygpO1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nKHYpIHtcbiAgICAgICAgdGhpcy5wYWRkaW5nTGVmdCA9IHY7XG4gICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHY7XG4gICAgICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gdjtcbiAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gdjtcbiAgICB9XG5cbiAgICBnZXQgcGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFkZGluZ0xlZnQ7XG4gICAgfVxuICAgIFxuICAgIHNldCBwYWRkaW5nTGVmdCh2KSB7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdMZWZ0ID0gdjtcbiAgICAgICAgdGhpcy5fY2hhbmdlZERpbWVuc2lvbnMoKTtcbiAgICB9XG4gICAgXG4gICAgZ2V0IHBhZGRpbmdMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFkZGluZ0xlZnQ7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmdUb3Aodikge1xuICAgICAgICB0aGlzLl9wYWRkaW5nVG9wID0gdjtcbiAgICAgICAgdGhpcy5fY2hhbmdlZERpbWVuc2lvbnMoKTtcbiAgICB9XG5cbiAgICBnZXQgcGFkZGluZ1RvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmdUb3A7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmdSaWdodCh2KSB7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdSaWdodCA9IHY7XG4gICAgICAgIHRoaXMuX2NoYW5nZWREaW1lbnNpb25zKCk7XG4gICAgfVxuXG4gICAgZ2V0IHBhZGRpbmdSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmdSaWdodDtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZ0JvdHRvbSh2KSB7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdCb3R0b20gPSB2O1xuICAgICAgICB0aGlzLl9jaGFuZ2VkRGltZW5zaW9ucygpO1xuICAgIH1cblxuICAgIGdldCBwYWRkaW5nQm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFkZGluZ0JvdHRvbTtcbiAgICB9XG5cbiAgICBwYXRjaChzZXR0aW5ncykge1xuICAgICAgICBCYXNlLnBhdGNoT2JqZWN0KHRoaXMsIHNldHRpbmdzKTtcbiAgICB9XG5cbn1cblxuRmxleENvbnRhaW5lci5BTElHTl9JVEVNUyA9IFtcImZsZXgtc3RhcnRcIiwgXCJmbGV4LWVuZFwiLCBcImNlbnRlclwiLCBcInN0cmV0Y2hcIl07XG5GbGV4Q29udGFpbmVyLkFMSUdOX0NPTlRFTlQgPSBbXCJmbGV4LXN0YXJ0XCIsIFwiZmxleC1lbmRcIiwgXCJjZW50ZXJcIiwgXCJzcGFjZS1iZXR3ZWVuXCIsIFwic3BhY2UtYXJvdW5kXCIsIFwic3BhY2UtZXZlbmx5XCIsIFwic3RyZXRjaFwiXTtcbkZsZXhDb250YWluZXIuSlVTVElGWV9DT05URU5UID0gW1wiZmxleC1zdGFydFwiLCBcImZsZXgtZW5kXCIsIFwiY2VudGVyXCIsIFwic3BhY2UtYmV0d2VlblwiLCBcInNwYWNlLWFyb3VuZFwiLCBcInNwYWNlLWV2ZW5seVwiXTtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBCYXNlIGZyb20gXCIuLi90cmVlL0Jhc2UubWpzXCI7XG5pbXBvcnQgRmxleFV0aWxzIGZyb20gXCIuL0ZsZXhVdGlscy5tanNcIjtcbmltcG9ydCBGbGV4Q29udGFpbmVyIGZyb20gXCIuL0ZsZXhDb250YWluZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZsZXhJdGVtIHtcblxuICAgIGNvbnN0cnVjdG9yKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fY3RyID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXRlbSA9IGl0ZW07XG4gICAgICAgIHRoaXMuX2dyb3cgPSAwO1xuICAgICAgICB0aGlzLl9zaHJpbmsgPSBGbGV4SXRlbS5TSFJJTktfQVVUTztcbiAgICAgICAgdGhpcy5fYWxpZ25TZWxmID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9taW5XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX21pbkhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuX21heFdpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fbWF4SGVpZ2h0ID0gMDtcblxuICAgICAgICB0aGlzLl9tYXJnaW5MZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5fbWFyZ2luVG9wID0gMDtcbiAgICAgICAgdGhpcy5fbWFyZ2luUmlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9tYXJnaW5Cb3R0b20gPSAwO1xuICAgIH1cblxuICAgIGdldCBpdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbTtcbiAgICB9XG5cbiAgICBnZXQgZ3JvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3c7XG4gICAgfVxuXG4gICAgc2V0IGdyb3codikge1xuICAgICAgICBpZiAodGhpcy5fZ3JvdyA9PT0gdikgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2dyb3cgPSBwYXJzZUludCh2KSB8fCAwO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9XG5cbiAgICBnZXQgc2hyaW5rKCkge1xuICAgICAgICBpZiAodGhpcy5fc2hyaW5rID09PSBGbGV4SXRlbS5TSFJJTktfQVVUTykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldERlZmF1bHRTaHJpbmsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2hyaW5rO1xuICAgIH1cblxuICAgIF9nZXREZWZhdWx0U2hyaW5rKCkge1xuICAgICAgICBpZiAodGhpcy5pdGVtLmlzRmxleEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBbGwgbm9uLWZsZXggY29udGFpbmVycyBhcmUgYWJzb2x1dGVseSBwb3NpdGlvbmVkIGl0ZW1zIHdpdGggZml4ZWQgZGltZW5zaW9ucywgYW5kIGJ5IGRlZmF1bHQgbm90IHNocmlua2FibGUuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCBzaHJpbmsodikge1xuICAgICAgICBpZiAodGhpcy5fc2hyaW5rID09PSB2KSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5fc2hyaW5rID0gcGFyc2VJbnQodikgfHwgMDtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgZ2V0IGFsaWduU2VsZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsaWduU2VsZjtcbiAgICB9XG5cbiAgICBzZXQgYWxpZ25TZWxmKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FsaWduU2VsZiA9PT0gdikgcmV0dXJuO1xuXG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FsaWduU2VsZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChGbGV4Q29udGFpbmVyLkFMSUdOX0lURU1TLmluZGV4T2YodikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhbGlnblNlbGYsIG9wdGlvbnM6IFwiICsgRmxleENvbnRhaW5lci5BTElHTl9JVEVNUy5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hbGlnblNlbGYgPSB2O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH1cblxuICAgIGdldCBtaW5XaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbldpZHRoO1xuICAgIH1cblxuICAgIHNldCBtaW5XaWR0aCh2KSB7XG4gICAgICAgIHRoaXMuX21pbldpZHRoID0gTWF0aC5tYXgoMCwgdik7XG4gICAgICAgIHRoaXMuX2l0ZW0uY2hhbmdlZERpbWVuc2lvbnModHJ1ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGdldCBtaW5IZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taW5IZWlnaHQ7XG4gICAgfVxuXG4gICAgc2V0IG1pbkhlaWdodCh2KSB7XG4gICAgICAgIHRoaXMuX21pbkhlaWdodCA9IE1hdGgubWF4KDAsIHYpO1xuICAgICAgICB0aGlzLl9pdGVtLmNoYW5nZWREaW1lbnNpb25zKGZhbHNlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBnZXQgbWF4V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhXaWR0aDtcbiAgICB9XG5cbiAgICBzZXQgbWF4V2lkdGgodikge1xuICAgICAgICB0aGlzLl9tYXhXaWR0aCA9IE1hdGgubWF4KDAsIHYpO1xuICAgICAgICB0aGlzLl9pdGVtLmNoYW5nZWREaW1lbnNpb25zKHRydWUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBnZXQgbWF4SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4SGVpZ2h0O1xuICAgIH1cblxuICAgIHNldCBtYXhIZWlnaHQodikge1xuICAgICAgICB0aGlzLl9tYXhIZWlnaHQgPSBNYXRoLm1heCgwLCB2KTtcbiAgICAgICAgdGhpcy5faXRlbS5jaGFuZ2VkRGltZW5zaW9ucyhmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5vdGUgbWFyZ2lucyBiZWhhdmUgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gaW4gSFRNTCB3aXRoIHJlZ2FyZCB0byBzaHJpbmtpbmcuXG4gICAgICogSW4gSFRNTCwgKG91dGVyKSBtYXJnaW5zIGNhbiBiZSByZW1vdmVkIHdoZW4gc2hyaW5raW5nLiBJbiB0aGlzIGVuZ2luZSwgdGhleSB3aWxsIG5vdCBzaHJpbmsgYXQgYWxsLlxuICAgICAqL1xuICAgIHNldCBtYXJnaW4odikge1xuICAgICAgICB0aGlzLm1hcmdpbkxlZnQgPSB2O1xuICAgICAgICB0aGlzLm1hcmdpblRvcCA9IHY7XG4gICAgICAgIHRoaXMubWFyZ2luUmlnaHQgPSB2O1xuICAgICAgICB0aGlzLm1hcmdpbkJvdHRvbSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IG1hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFyZ2luTGVmdDtcbiAgICB9XG5cbiAgICBzZXQgbWFyZ2luTGVmdCh2KSB7XG4gICAgICAgIHRoaXMuX21hcmdpbkxlZnQgPSB2O1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgZ2V0IG1hcmdpbkxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJnaW5MZWZ0O1xuICAgIH1cblxuICAgIHNldCBtYXJnaW5Ub3Aodikge1xuICAgICAgICB0aGlzLl9tYXJnaW5Ub3AgPSB2O1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgZ2V0IG1hcmdpblRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmdpblRvcDtcbiAgICB9XG5cbiAgICBzZXQgbWFyZ2luUmlnaHQodikge1xuICAgICAgICB0aGlzLl9tYXJnaW5SaWdodCA9IHY7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9XG5cbiAgICBnZXQgbWFyZ2luUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJnaW5SaWdodDtcbiAgICB9XG5cbiAgICBzZXQgbWFyZ2luQm90dG9tKHYpIHtcbiAgICAgICAgdGhpcy5fbWFyZ2luQm90dG9tID0gdjtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH1cblxuICAgIGdldCBtYXJnaW5Cb3R0b20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJnaW5Cb3R0b207XG4gICAgfVxuICAgIFxuICAgIF9jaGFuZ2VkKCkge1xuICAgICAgICBpZiAodGhpcy5jdHIpIHRoaXMuY3RyLl9jaGFuZ2VkQ29udGVudHMoKTtcbiAgICB9XG5cbiAgICBzZXQgY3RyKHYpIHtcbiAgICAgICAgdGhpcy5fY3RyID0gdjtcbiAgICB9XG5cbiAgICBnZXQgY3RyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3RyO1xuICAgIH1cblxuICAgIHBhdGNoKHNldHRpbmdzKSB7XG4gICAgICAgIEJhc2UucGF0Y2hPYmplY3QodGhpcywgc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIF9yZXNldExheW91dFNpemUoKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0SG9yaXpvbnRhbEF4aXNMYXlvdXRTaXplKCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0VmVydGljYWxBeGlzTGF5b3V0U2l6ZSgpO1xuICAgIH1cblxuICAgIF9yZXNldENyb3NzQXhpc0xheW91dFNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN0ci5faG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRWZXJ0aWNhbEF4aXNMYXlvdXRTaXplKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldEhvcml6b250YWxBeGlzTGF5b3V0U2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3Jlc2V0SG9yaXpvbnRhbEF4aXNMYXlvdXRTaXplKCkge1xuICAgICAgICBsZXQgdyA9IEZsZXhVdGlscy5nZXRSZWxBeGlzU2l6ZSh0aGlzLml0ZW0sIHRydWUpO1xuICAgICAgICBpZiAodGhpcy5fbWluV2lkdGgpIHtcbiAgICAgICAgICAgIHcgPSBNYXRoLm1heCh0aGlzLl9taW5XaWR0aCwgdyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21heFdpZHRoKSB7XG4gICAgICAgICAgICB3ID0gTWF0aC5taW4odGhpcy5fbWF4V2lkdGgsIHcpO1xuICAgICAgICB9XG4gICAgICAgIEZsZXhVdGlscy5zZXRBeGlzTGF5b3V0U2l6ZSh0aGlzLml0ZW0sIHRydWUsIHcpO1xuICAgIH1cblxuICAgIF9yZXNldFZlcnRpY2FsQXhpc0xheW91dFNpemUoKSB7XG4gICAgICAgIGxldCBoID0gRmxleFV0aWxzLmdldFJlbEF4aXNTaXplKHRoaXMuaXRlbSwgZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5fbWluSGVpZ2h0KSB7XG4gICAgICAgICAgICBoID0gTWF0aC5tYXgodGhpcy5fbWluSGVpZ2h0LCBoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICBoID0gTWF0aC5taW4odGhpcy5fbWF4SGVpZ2h0LCBoKTtcbiAgICAgICAgfVxuICAgICAgICBGbGV4VXRpbHMuc2V0QXhpc0xheW91dFNpemUodGhpcy5pdGVtLCBmYWxzZSwgaCk7XG4gICAgfVxuXG4gICAgX2dldENyb3NzQXhpc01pblNpemVTZXR0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWluU2l6ZVNldHRpbmcoIXRoaXMuY3RyLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfZ2V0Q3Jvc3NBeGlzTWF4U2l6ZVNldHRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRNYXhTaXplU2V0dGluZyghdGhpcy5jdHIuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9nZXRNYWluQXhpc01heFNpemVTZXR0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWF4U2l6ZVNldHRpbmcodGhpcy5jdHIuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9nZXRNaW5TaXplU2V0dGluZyhob3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWluV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWluSGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldE1heFNpemVTZXR0aW5nKGhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXhXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXhIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0TWFpbkF4aXNNaW5TaXplKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldEF4aXNNaW5TaXplKHRoaXMuaXRlbSwgdGhpcy5jdHIuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9nZXRDcm9zc0F4aXNNaW5TaXplKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldEF4aXNNaW5TaXplKHRoaXMuaXRlbSwgIXRoaXMuY3RyLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfZ2V0TWFpbkF4aXNMYXlvdXRTaXplKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldEF4aXNMYXlvdXRTaXplKHRoaXMuaXRlbSwgdGhpcy5jdHIuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9nZXRNYWluQXhpc0xheW91dFBvcygpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRBeGlzTGF5b3V0UG9zKHRoaXMuaXRlbSwgdGhpcy5jdHIuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9zZXRNYWluQXhpc0xheW91dFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5zZXRBeGlzTGF5b3V0UG9zKHRoaXMuaXRlbSwgdGhpcy5jdHIuX2hvcml6b250YWwsIHBvcyk7XG4gICAgfVxuXG4gICAgX3NldENyb3NzQXhpc0xheW91dFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5zZXRBeGlzTGF5b3V0UG9zKHRoaXMuaXRlbSwgIXRoaXMuY3RyLl9ob3Jpem9udGFsLCBwb3MpO1xuICAgIH1cblxuICAgIF9nZXRDcm9zc0F4aXNMYXlvdXRTaXplKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldEF4aXNMYXlvdXRTaXplKHRoaXMuaXRlbSwgIXRoaXMuY3RyLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfcmVzaXplQ3Jvc3NBeGlzKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5yZXNpemVBeGlzKHRoaXMuaXRlbSwgIXRoaXMuY3RyLl9ob3Jpem9udGFsLCBzaXplKTtcbiAgICB9XG5cbiAgICBfcmVzaXplTWFpbkF4aXMoc2l6ZSkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLnJlc2l6ZUF4aXModGhpcy5pdGVtLCB0aGlzLmN0ci5faG9yaXpvbnRhbCwgc2l6ZSk7XG4gICAgfVxuXG4gICAgX2dldE1haW5BeGlzUGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRUb3RhbFBhZGRpbmcodGhpcy5pdGVtLCB0aGlzLmN0ci5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX2dldENyb3NzQXhpc1BhZGRpbmcoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0VG90YWxQYWRkaW5nKHRoaXMuaXRlbSwgIXRoaXMuY3RyLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfZ2V0TWFpbkF4aXNNYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0VG90YWxNYXJnaW4odGhpcy5pdGVtLCB0aGlzLmN0ci5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX2dldENyb3NzQXhpc01hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRUb3RhbE1hcmdpbih0aGlzLml0ZW0sICF0aGlzLmN0ci5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX2dldEhvcml6b250YWxNYXJnaW5PZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0TWFyZ2luT2Zmc2V0KHRoaXMuaXRlbSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgX2dldFZlcnRpY2FsTWFyZ2luT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldE1hcmdpbk9mZnNldCh0aGlzLml0ZW0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBfZ2V0TWFpbkF4aXNNaW5TaXplV2l0aFBhZGRpbmdBbmRNYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRNYWluQXhpc01pblNpemUoKSArIHRoaXMuX2dldE1haW5BeGlzUGFkZGluZygpICsgdGhpcy5fZ2V0TWFpbkF4aXNNYXJnaW4oKTtcbiAgICB9XG5cbiAgICBfZ2V0Q3Jvc3NBeGlzTWluU2l6ZVdpdGhQYWRkaW5nQW5kTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q3Jvc3NBeGlzTWluU2l6ZSgpICsgdGhpcy5fZ2V0Q3Jvc3NBeGlzUGFkZGluZygpICsgdGhpcy5fZ2V0Q3Jvc3NBeGlzTWFyZ2luKCk7XG4gICAgfVxuXG4gICAgX2dldE1haW5BeGlzTGF5b3V0U2l6ZVdpdGhQYWRkaW5nQW5kTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWFpbkF4aXNMYXlvdXRTaXplKCkgKyB0aGlzLl9nZXRNYWluQXhpc1BhZGRpbmcoKSArIHRoaXMuX2dldE1haW5BeGlzTWFyZ2luKCk7XG4gICAgfVxuXG4gICAgX2dldENyb3NzQXhpc0xheW91dFNpemVXaXRoUGFkZGluZ0FuZE1hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENyb3NzQXhpc0xheW91dFNpemUoKSArIHRoaXMuX2dldENyb3NzQXhpc1BhZGRpbmcoKSArIHRoaXMuX2dldENyb3NzQXhpc01hcmdpbigpO1xuICAgIH1cblxuICAgIF9oYXNGaXhlZENyb3NzQXhpc1NpemUoKSB7XG4gICAgICAgIHJldHVybiAhRmxleFV0aWxzLmlzWmVyb0F4aXNTaXplKHRoaXMuaXRlbSwgIXRoaXMuY3RyLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfaGFzUmVsQ3Jvc3NBeGlzU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuY3RyLl9ob3Jpem9udGFsID8gdGhpcy5pdGVtLmZ1bmNIIDogdGhpcy5pdGVtLmZ1bmNXKTtcbiAgICB9XG5cbn1cblxuXG5GbGV4SXRlbS5TSFJJTktfQVVUTyA9IC0xO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IEZsZXhDb250YWluZXIgZnJvbSBcIi4vRmxleENvbnRhaW5lci5tanNcIjtcbmltcG9ydCBGbGV4SXRlbSBmcm9tIFwiLi9GbGV4SXRlbS5tanNcIjtcbmltcG9ydCBGbGV4VXRpbHMgZnJvbSBcIi4vRmxleFV0aWxzLm1qc1wiO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbm5lY3Rpb24gYmV0d2VlbiB0aGUgcmVuZGVyIHRyZWUgd2l0aCB0aGUgbGF5b3V0IHRyZWUgb2YgdGhpcyBmbGV4IGNvbnRhaW5lci9pdGVtLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGbGV4VGFyZ2V0IHtcblxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvc3NpYmxlIHZhbHVlcyAob25seSBpbiBjYXNlIG9mIGNvbnRhaW5lcik6XG4gICAgICAgICAqIGJpdCAwOiBoYXMgY2hhbmdlZCBvciBjb250YWlucyBpdGVtcyB3aXRoIGNoYW5nZXNcbiAgICAgICAgICogYml0IDE6IHdpZHRoIGNoYW5nZWRcbiAgICAgICAgICogYml0IDI6IGhlaWdodCBjaGFuZ2VkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZWNhbGMgPSAwO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgIHRoaXMudyA9IDA7XG4gICAgICAgIHRoaXMuaCA9IDA7XG5cbiAgICAgICAgdGhpcy5fb3JpZ2luYWxYID0gMDtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxZID0gMDtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsSGVpZ2h0ID0gMDtcblxuICAgICAgICB0aGlzLl9mbGV4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmxleEl0ZW0gPSBudWxsO1xuICAgICAgICB0aGlzLl9mbGV4SXRlbURpc2FibGVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5faXRlbXMgPSBudWxsO1xuICAgIH1cblxuICAgIGdldCBmbGV4TGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGV4ID8gdGhpcy5mbGV4Ll9sYXlvdXQgOiBudWxsO1xuICAgIH1cblxuICAgIGxheW91dEZsZXhUcmVlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0ZsZXhFbmFibGVkKCkgJiYgdGhpcy5pc0NoYW5nZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5mbGV4TGF5b3V0LmxheW91dFRyZWUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB0YXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XG4gICAgfVxuXG4gICAgZ2V0IGZsZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mbGV4O1xuICAgIH1cblxuICAgIHNldCBmbGV4KHYpIHtcbiAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZsZXhFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlRmxleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRmxleEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuYWJsZUZsZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZsZXgucGF0Y2godik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZmxleEl0ZW0oKSB7XG4gICAgICAgIGlmICh0aGlzLl9mbGV4SXRlbURpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5zdXJlRmxleEl0ZW0oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsZXhJdGVtO1xuICAgIH1cblxuICAgIHNldCBmbGV4SXRlbSh2KSB7XG4gICAgICAgIGlmICh2ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9mbGV4SXRlbURpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5mbGV4UGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZsZXhJdGVtRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrRW5hYmxlZCgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Ll9jbGVhckZsZXhJdGVtc0NhY2hlKCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGFuZ2VkQ29udGVudHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9lbnN1cmVGbGV4SXRlbSgpO1xuXG4gICAgICAgICAgICB0aGlzLl9mbGV4SXRlbS5wYXRjaCh2KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZsZXhJdGVtRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mbGV4SXRlbURpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tFbmFibGVkKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5mbGV4UGFyZW50O1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Ll9jbGVhckZsZXhJdGVtc0NhY2hlKCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGFuZ2VkQ29udGVudHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZW5hYmxlRmxleCgpIHtcbiAgICAgICAgdGhpcy5fZmxleCA9IG5ldyBGbGV4Q29udGFpbmVyKHRoaXMpO1xuICAgICAgICB0aGlzLl9jaGVja0VuYWJsZWQoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkRGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLl9lbmFibGVDaGlsZHJlbkFzRmxleEl0ZW1zKCk7XG4gICAgfVxuXG4gICAgX2Rpc2FibGVGbGV4KCkge1xuICAgICAgICB0aGlzLmNoYW5nZWREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuX2ZsZXggPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGVja0VuYWJsZWQoKTtcbiAgICAgICAgdGhpcy5fZGlzYWJsZUNoaWxkcmVuQXNGbGV4SXRlbXMoKTtcbiAgICB9XG5cbiAgICBfZW5hYmxlQ2hpbGRyZW5Bc0ZsZXhJdGVtcygpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl90YXJnZXQuX2NoaWxkcmVuO1xuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjaGlsZC5sYXlvdXQuX2VuYWJsZUZsZXhJdGVtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZGlzYWJsZUNoaWxkcmVuQXNGbGV4SXRlbXMoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fdGFyZ2V0Ll9jaGlsZHJlbjtcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGQubGF5b3V0Ll9kaXNhYmxlRmxleEl0ZW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9lbmFibGVGbGV4SXRlbSgpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlRmxleEl0ZW0oKTtcbiAgICAgICAgY29uc3QgZmxleFBhcmVudCA9IHRoaXMuX3RhcmdldC5fcGFyZW50Ll9sYXlvdXQ7XG4gICAgICAgIHRoaXMuX2ZsZXhJdGVtLmN0ciA9IGZsZXhQYXJlbnQuX2ZsZXg7XG4gICAgICAgIGZsZXhQYXJlbnQuY2hhbmdlZENvbnRlbnRzKCk7XG4gICAgICAgIHRoaXMuX2NoZWNrRW5hYmxlZCgpO1xuICAgIH1cblxuICAgIF9kaXNhYmxlRmxleEl0ZW0oKSB7XG4gICAgICAgIGlmICh0aGlzLl9mbGV4SXRlbSkge1xuICAgICAgICAgICAgdGhpcy5fZmxleEl0ZW0uY3RyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGtlZXAgdGhlIGZsZXhJdGVtIG9iamVjdCBiZWNhdXNlIGl0IG1heSBjb250YWluIGN1c3RvbSBzZXR0aW5ncy5cbiAgICAgICAgdGhpcy5fY2hlY2tFbmFibGVkKCk7XG5cbiAgICAgICAgLy8gT2Zmc2V0cyBoYXZlIGJlZW4gY2hhbmdlZC4gV2UgY2FuJ3QgcmVjb3ZlciB0aGVtLCBzbyB3ZSdsbCBqdXN0IGNsZWFyIHRoZW0gaW5zdGVhZC5cbiAgICAgICAgdGhpcy5fcmVzZXRPZmZzZXRzKCk7XG4gICAgfVxuXG4gICAgX3Jlc2V0T2Zmc2V0cygpIHtcbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICB9XG5cbiAgICBfZW5zdXJlRmxleEl0ZW0oKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmxleEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsZXhJdGVtID0gbmV3IEZsZXhJdGVtKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NoZWNrRW5hYmxlZCgpIHtcbiAgICAgICAgY29uc3QgZW5hYmxlZCA9IHRoaXMuaXNFbmFibGVkKCk7XG4gICAgICAgIGlmICh0aGlzLl9lbmFibGVkICE9PSBlbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuYWJsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBfZW5hYmxlKCkge1xuICAgICAgICB0aGlzLl9zZXR1cFRhcmdldEZvckZsZXgoKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmVuYWJsZUZsZXhMYXlvdXQoKTtcbiAgICB9XG5cbiAgICBfZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5fcmVzdG9yZVRhcmdldFRvTm9uRmxleCgpO1xuICAgICAgICB0aGlzLl90YXJnZXQuZGlzYWJsZUZsZXhMYXlvdXQoKTtcbiAgICB9XG5cbiAgICBpc0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRmxleEVuYWJsZWQoKSB8fCB0aGlzLmlzRmxleEl0ZW1FbmFibGVkKCk7XG4gICAgfVxuXG4gICAgaXNGbGV4RW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsZXggIT09IG51bGw7XG4gICAgfVxuXG4gICAgaXNGbGV4SXRlbUVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsZXhQYXJlbnQgIT09IG51bGw7XG4gICAgfVxuXG4gICAgX3Jlc3RvcmVUYXJnZXRUb05vbkZsZXgoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3RhcmdldDtcbiAgICAgICAgdGFyZ2V0LnggPSB0aGlzLl9vcmlnaW5hbFg7XG4gICAgICAgIHRhcmdldC55ID0gdGhpcy5fb3JpZ2luYWxZO1xuICAgICAgICB0YXJnZXQuc2V0RGltZW5zaW9ucyh0aGlzLl9vcmlnaW5hbFdpZHRoLCB0aGlzLl9vcmlnaW5hbEhlaWdodCk7XG4gICAgfVxuXG4gICAgX3NldHVwVGFyZ2V0Rm9yRmxleCgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgICB0aGlzLl9vcmlnaW5hbFggPSB0YXJnZXQuX3g7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsWSA9IHRhcmdldC5feTtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxXaWR0aCA9IHRhcmdldC5fdztcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxIZWlnaHQgPSB0YXJnZXQuX2g7XG4gICAgfVxuICAgIFxuICAgIHNldFBhcmVudChmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSAmJiBmcm9tLmlzRmxleENvbnRhaW5lcigpKSB7XG4gICAgICAgICAgICBmcm9tLl9sYXlvdXQuX2NoYW5nZWRDaGlsZHJlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvICYmIHRvLmlzRmxleENvbnRhaW5lcigpKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVGbGV4SXRlbSgpO1xuICAgICAgICAgICAgdG8uX2xheW91dC5fY2hhbmdlZENoaWxkcmVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hlY2tFbmFibGVkKCk7XG4gICAgfVxuXG4gICAgZ2V0IGZsZXhQYXJlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9mbGV4SXRlbURpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3RhcmdldC5fcGFyZW50O1xuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5pc0ZsZXhDb250YWluZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5fbGF5b3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHNldFZpc2libGUodikge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZsZXhQYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5fY2hhbmdlZENoaWxkcmVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zID0gdGhpcy5fZ2V0RmxleEl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zO1xuICAgIH1cblxuICAgIF9nZXRGbGV4SXRlbXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fdGFyZ2V0Ll9jaGlsZHJlbjtcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmlzRmxleEl0ZW0oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtLmxheW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIF9jaGFuZ2VkQ2hpbGRyZW4oKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyRmxleEl0ZW1zQ2FjaGUoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkQ29udGVudHMoKTtcbiAgICB9XG5cbiAgICBfY2xlYXJGbGV4SXRlbXNDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBudWxsO1xuICAgIH1cblxuICAgIHNldExheW91dCh4LCB5LCB3LCBoKSB7XG4gICAgICAgIGxldCBvcmlnaW5hbFggPSB0aGlzLl9vcmlnaW5hbFg7XG4gICAgICAgIGxldCBvcmlnaW5hbFkgPSB0aGlzLl9vcmlnaW5hbFk7XG4gICAgICAgIGlmICh0aGlzLmZ1bmNYKSB7XG4gICAgICAgICAgICBvcmlnaW5hbFggPSB0aGlzLmZ1bmNYKEZsZXhVdGlscy5nZXRQYXJlbnRBeGlzU2l6ZVdpdGhQYWRkaW5nKHRoaXMsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mdW5jWSkge1xuICAgICAgICAgICAgb3JpZ2luYWxZID0gdGhpcy5mdW5jWShGbGV4VXRpbHMuZ2V0UGFyZW50QXhpc1NpemVXaXRoUGFkZGluZyh0aGlzLCBmYWxzZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNGbGV4SXRlbUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuc2V0TGF5b3V0KHggKyBvcmlnaW5hbFgsIHkgKyBvcmlnaW5hbFksIHcsIGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmV1c2UgdGhlIHgseSAnc2V0dGluZ3MnLlxuICAgICAgICAgICAgdGhpcy50YXJnZXQuc2V0TGF5b3V0KG9yaWdpbmFsWCwgb3JpZ2luYWxZLCB3LCBoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoYW5nZWREaW1lbnNpb25zKGNoYW5nZVdpZHRoID0gdHJ1ZSwgY2hhbmdlSGVpZ2h0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVSZWNhbGMoY2hhbmdlV2lkdGgsIGNoYW5nZUhlaWdodCk7XG4gICAgfVxuXG4gICAgY2hhbmdlZENvbnRlbnRzKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVSZWNhbGMoKTtcbiAgICB9XG5cbiAgICBmb3JjZUxheW91dCgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUmVjYWxjKCk7XG4gICAgfVxuXG4gICAgaXNDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjYWxjID4gMDtcbiAgICB9XG5cbiAgICBfdXBkYXRlUmVjYWxjKGNoYW5nZUV4dGVybmFsV2lkdGggPSBmYWxzZSwgY2hhbmdlRXh0ZXJuYWxIZWlnaHQgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5pc0ZsZXhFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxheW91dCA9IHRoaXMuX2ZsZXguX2xheW91dDtcblxuICAgICAgICAgICAgLy8gV2hlbiBzb21ldGhpbmcgaW50ZXJuYWwgY2hhbmdlcywgaXQgY2FuIGhhdmUgZWZmZWN0IG9uIHRoZSBleHRlcm5hbCBkaW1lbnNpb25zLlxuICAgICAgICAgICAgY2hhbmdlRXh0ZXJuYWxXaWR0aCA9IGNoYW5nZUV4dGVybmFsV2lkdGggfHwgbGF5b3V0LmlzQXhpc0ZpdFRvQ29udGVudHModHJ1ZSk7XG4gICAgICAgICAgICBjaGFuZ2VFeHRlcm5hbEhlaWdodCA9IGNoYW5nZUV4dGVybmFsSGVpZ2h0IHx8IGxheW91dC5pc0F4aXNGaXRUb0NvbnRlbnRzKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlY2FsYyA9IDEgKyAoY2hhbmdlRXh0ZXJuYWxXaWR0aCA/IDIgOiAwKSArIChjaGFuZ2VFeHRlcm5hbEhlaWdodCA/IDQgOiAwKTtcbiAgICAgICAgY29uc3QgbmV3UmVjYWxjRmxhZ3MgPSB0aGlzLmdldE5ld1JlY2FsY0ZsYWdzKHJlY2FsYyk7XG4gICAgICAgIHRoaXMuX3JlY2FsYyB8PSByZWNhbGM7XG4gICAgICAgIGlmIChuZXdSZWNhbGNGbGFncyA+IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZsZXhQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZsZXhQYXJlbnQuX3VwZGF0ZVJlY2FsY0JvdHRvbVVwKHJlY2FsYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldC50cmlnZ2VyTGF5b3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQudHJpZ2dlckxheW91dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TmV3UmVjYWxjRmxhZ3MoZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuICg3IC0gdGhpcy5fcmVjYWxjKSAmIGZsYWdzO1xuICAgIH1cblxuICAgIF91cGRhdGVSZWNhbGNCb3R0b21VcChjaGlsZFJlY2FsYykge1xuICAgICAgICBjb25zdCBuZXdSZWNhbGMgPSB0aGlzLl9nZXRSZWNhbGNGcm9tQ2hhbmdlZENoaWxkUmVjYWxjKGNoaWxkUmVjYWxjKTtcbiAgICAgICAgY29uc3QgbmV3UmVjYWxjRmxhZ3MgPSB0aGlzLmdldE5ld1JlY2FsY0ZsYWdzKG5ld1JlY2FsYyk7XG4gICAgICAgIHRoaXMuX3JlY2FsYyB8PSBuZXdSZWNhbGM7XG4gICAgICAgIGlmIChuZXdSZWNhbGNGbGFncyA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsZXhQYXJlbnQgPSB0aGlzLmZsZXhQYXJlbnQ7XG4gICAgICAgICAgICBpZiAoZmxleFBhcmVudCkge1xuICAgICAgICAgICAgICAgIGZsZXhQYXJlbnQuX3VwZGF0ZVJlY2FsY0JvdHRvbVVwKG5ld1JlY2FsYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldC50cmlnZ2VyTGF5b3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQudHJpZ2dlckxheW91dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFJlY2FsY0Zyb21DaGFuZ2VkQ2hpbGRSZWNhbGMoY2hpbGRSZWNhbGMpIHtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gdGhpcy5fZmxleC5fbGF5b3V0O1xuXG4gICAgICAgIGNvbnN0IG1haW5BeGlzUmVjYWxjRmxhZyA9IGxheW91dC5faG9yaXpvbnRhbCA/IDEgOiAyO1xuICAgICAgICBjb25zdCBjcm9zc0F4aXNSZWNhbGNGbGFnID0gbGF5b3V0Ll9ob3Jpem9udGFsID8gMiA6IDE7XG5cbiAgICAgICAgY29uc3QgY3Jvc3NBeGlzRGltZW5zaW9uc0NoYW5nZWRJbkNoaWxkID0gKGNoaWxkUmVjYWxjICYgY3Jvc3NBeGlzUmVjYWxjRmxhZyk7XG4gICAgICAgIGlmICghY3Jvc3NBeGlzRGltZW5zaW9uc0NoYW5nZWRJbkNoaWxkKSB7XG4gICAgICAgICAgICBjb25zdCBtYWluQXhpc0RpbWVuc2lvbnNDaGFuZ2VkSW5DaGlsZCA9IChjaGlsZFJlY2FsYyAmIG1haW5BeGlzUmVjYWxjRmxhZyk7XG4gICAgICAgICAgICBpZiAobWFpbkF4aXNEaW1lbnNpb25zQ2hhbmdlZEluQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYWluQXhpc0lzV3JhcHBpbmcgPSBsYXlvdXQuaXNXcmFwcGluZygpO1xuICAgICAgICAgICAgICAgIGlmIChtYWluQXhpc0lzV3JhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Jvc3NBeGlzSXNGaXRUb0NvbnRlbnRzID0gbGF5b3V0LmlzQ3Jvc3NBeGlzRml0VG9Db250ZW50cygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Jvc3NBeGlzSXNGaXRUb0NvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IGR1ZSB0byB3cmFwcGluZywgdGhlIGNyb3NzIGF4aXMgc2l6ZSBtYXkgYmUgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkUmVjYWxjICs9IGNyb3NzQXhpc1JlY2FsY0ZsYWc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXNXaWR0aER5bmFtaWMgPSBsYXlvdXQuaXNBeGlzRml0VG9Db250ZW50cyh0cnVlKTtcbiAgICAgICAgbGV0IGlzSGVpZ2h0RHluYW1pYyA9IGxheW91dC5pc0F4aXNGaXRUb0NvbnRlbnRzKGZhbHNlKTtcblxuICAgICAgICBpZiAobGF5b3V0LnNocnVuaykge1xuICAgICAgICAgICAgLy8gSWYgZHVyaW5nIHByZXZpb3VzIGxheW91dCB0aGlzIGNvbnRhaW5lciB3YXMgJ3NocnVuaycsIGFueSBjaGFuZ2VzIG1heSBjaGFuZ2UgdGhlICdtaW4gYXhpcyBzaXplJyBvZiB0aGVcbiAgICAgICAgICAgIC8vIGNvbnRlbnRzLCBsZWFkaW5nIHRvIGEgZGlmZmVyZW50IGF4aXMgc2l6ZSBvbiB0aGlzIGNvbnRhaW5lciBldmVuIHdoZW4gaXQgd2FzIG5vdCAnZml0IHRvIGNvbnRlbnRzJy5cbiAgICAgICAgICAgIGlmIChsYXlvdXQuX2hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBpc1dpZHRoRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzSGVpZ2h0RHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2NhbFJlY2FsYyA9IDEgKyAoaXNXaWR0aER5bmFtaWMgPyAyIDogMCkgKyAoaXNIZWlnaHREeW5hbWljID8gNCA6IDApO1xuXG4gICAgICAgIGNvbnN0IGNvbWJpbmVkUmVjYWxjID0gY2hpbGRSZWNhbGMgJiBsb2NhbFJlY2FsYztcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkUmVjYWxjO1xuICAgIH1cblxuICAgIGdldCByZWNhbGMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWNhbGM7XG4gICAgfVxuXG4gICAgY2xlYXJSZWNhbGNGbGFnKCkge1xuICAgICAgICB0aGlzLl9yZWNhbGMgPSAwO1xuICAgIH1cblxuICAgIGVuYWJsZUxvY2FsUmVjYWxjRmxhZygpIHtcbiAgICAgICAgdGhpcy5fcmVjYWxjID0gMTtcbiAgICB9XG5cbiAgICBnZXQgb3JpZ2luYWxYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxYO1xuICAgIH1cblxuICAgIHNldE9yaWdpbmFsWFdpdGhvdXRVcGRhdGluZ0xheW91dCh2KSB7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsWCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IG9yaWdpbmFsWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsWTtcbiAgICB9XG5cbiAgICBzZXRPcmlnaW5hbFlXaXRob3V0VXBkYXRpbmdMYXlvdXQodikge1xuICAgICAgICB0aGlzLl9vcmlnaW5hbFkgPSB2O1xuICAgIH1cblxuICAgIGdldCBvcmlnaW5hbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxXaWR0aDtcbiAgICB9XG5cbiAgICBzZXQgb3JpZ2luYWxXaWR0aCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9vcmlnaW5hbFdpZHRoICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFdpZHRoID0gdjtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZERpbWVuc2lvbnModHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IG9yaWdpbmFsSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxIZWlnaHQ7XG4gICAgfVxuXG4gICAgc2V0IG9yaWdpbmFsSGVpZ2h0KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29yaWdpbmFsSGVpZ2h0ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbEhlaWdodCA9IHY7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWREaW1lbnNpb25zKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBmdW5jWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldC5mdW5jWDtcbiAgICB9XG5cbiAgICBnZXQgZnVuY1koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQuZnVuY1k7XG4gICAgfVxuXG4gICAgZ2V0IGZ1bmNXKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0LmZ1bmNXO1xuICAgIH1cblxuICAgIGdldCBmdW5jSCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldC5mdW5jSDtcbiAgICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGbGV4VXRpbHMge1xuXG4gICAgc3RhdGljIGdldFBhcmVudEF4aXNTaXplV2l0aFBhZGRpbmcoaXRlbSwgaG9yaXpvbnRhbCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpdGVtLnRhcmdldDtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGFyZ2V0LmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmbGV4UGFyZW50ID0gaXRlbS5mbGV4UGFyZW50O1xuICAgICAgICAgICAgaWYgKGZsZXhQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgcGVuZGluZyBsYXlvdXQgc2l6ZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBeGlzTGF5b3V0U2l6ZShmbGV4UGFyZW50LCBob3Jpem9udGFsKSArIHRoaXMuZ2V0VG90YWxQYWRkaW5nKGZsZXhQYXJlbnQsIGhvcml6b250YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgJ2Fic29sdXRlJyBzaXplLlxuICAgICAgICAgICAgICAgIHJldHVybiBob3Jpem9udGFsID8gcGFyZW50LncgOiBwYXJlbnQuaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRSZWxBeGlzU2l6ZShpdGVtLCBob3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5mdW5jVykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hbGxvd1JlbEF4aXNTaXplRnVuY3Rpb24oaXRlbSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZnVuY1codGhpcy5nZXRQYXJlbnRBeGlzU2l6ZVdpdGhQYWRkaW5nKGl0ZW0sIHRydWUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLm9yaWdpbmFsV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5mdW5jSCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hbGxvd1JlbEF4aXNTaXplRnVuY3Rpb24oaXRlbSwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmZ1bmNIKHRoaXMuZ2V0UGFyZW50QXhpc1NpemVXaXRoUGFkZGluZyhpdGVtLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ub3JpZ2luYWxIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgX2FsbG93UmVsQXhpc1NpemVGdW5jdGlvbihpdGVtLCBob3Jpem9udGFsKSB7XG4gICAgICAgIGNvbnN0IGZsZXhQYXJlbnQgPSBpdGVtLmZsZXhQYXJlbnQ7XG4gICAgICAgIGlmIChmbGV4UGFyZW50ICYmIGZsZXhQYXJlbnQuX2ZsZXguX2xheW91dC5pc0F4aXNGaXRUb0NvbnRlbnRzKGhvcml6b250YWwpKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBhbGxvdyByZWxhdGl2ZSB3aWR0aCBvbiBmaXQtdG8tY29udGVudHMgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mbGljdHMuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzWmVyb0F4aXNTaXplKGl0ZW0sIGhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHJldHVybiAhaXRlbS5vcmlnaW5hbFdpZHRoICYmICFpdGVtLmZ1bmNXO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICFpdGVtLm9yaWdpbmFsSGVpZ2h0ICYmICFpdGVtLmZ1bmNIO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEF4aXNMYXlvdXRQb3MoaXRlbSwgaG9yaXpvbnRhbCkge1xuICAgICAgICByZXR1cm4gaG9yaXpvbnRhbCA/IGl0ZW0ueCA6IGl0ZW0ueTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0QXhpc0xheW91dFNpemUoaXRlbSwgaG9yaXpvbnRhbCkge1xuICAgICAgICByZXR1cm4gaG9yaXpvbnRhbCA/IGl0ZW0udyA6IGl0ZW0uaDtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2V0QXhpc0xheW91dFBvcyhpdGVtLCBob3Jpem9udGFsLCBwb3MpIHtcbiAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGl0ZW0ueCA9IHBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0ueSA9IHBvcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBzZXRBeGlzTGF5b3V0U2l6ZShpdGVtLCBob3Jpem9udGFsLCBzaXplKSB7XG4gICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICBpdGVtLncgPSBzaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5oID0gc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRBeGlzTWluU2l6ZShpdGVtLCBob3Jpem9udGFsKSB7XG4gICAgICAgIGxldCBtaW5TaXplID0gdGhpcy5nZXRQbGFpbkF4aXNNaW5TaXplKGl0ZW0sIGhvcml6b250YWwpO1xuXG4gICAgICAgIGxldCBmbGV4SXRlbU1pblNpemUgPSAwO1xuICAgICAgICBpZiAoaXRlbS5pc0ZsZXhJdGVtRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBmbGV4SXRlbU1pblNpemUgPSBpdGVtLl9mbGV4SXRlbS5fZ2V0TWluU2l6ZVNldHRpbmcoaG9yaXpvbnRhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoYXNMaW1pdGVkTWluU2l6ZSA9IChmbGV4SXRlbU1pblNpemUgPiAwKTtcbiAgICAgICAgaWYgKGhhc0xpbWl0ZWRNaW5TaXplKSB7XG4gICAgICAgICAgICBtaW5TaXplID0gTWF0aC5tYXgobWluU2l6ZSwgZmxleEl0ZW1NaW5TaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0UGxhaW5BeGlzTWluU2l6ZShpdGVtLCBob3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChpdGVtLmlzRmxleEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uX2ZsZXguX2xheW91dC5nZXRBeGlzTWluU2l6ZShob3Jpem9udGFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlzU2hyaW5rYWJsZSA9IChpdGVtLmZsZXhJdGVtLnNocmluayAhPT0gMCk7XG4gICAgICAgICAgICBpZiAoaXNTaHJpbmthYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlbEF4aXNTaXplKGl0ZW0sIGhvcml6b250YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHJlc2l6ZUF4aXMoaXRlbSwgaG9yaXpvbnRhbCwgc2l6ZSkge1xuICAgICAgICBpZiAoaXRlbS5pc0ZsZXhFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTWFpbkF4aXMgPSAoaXRlbS5fZmxleC5faG9yaXpvbnRhbCA9PT0gaG9yaXpvbnRhbCk7XG4gICAgICAgICAgICBpZiAoaXNNYWluQXhpcykge1xuICAgICAgICAgICAgICAgIGl0ZW0uX2ZsZXguX2xheW91dC5yZXNpemVNYWluQXhpcyhzaXplKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5fZmxleC5fbGF5b3V0LnJlc2l6ZUNyb3NzQXhpcyhzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXhpc0xheW91dFNpemUoaXRlbSwgaG9yaXpvbnRhbCwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHN0YXRpYyBnZXRQYWRkaW5nT2Zmc2V0KGl0ZW0sIGhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGl0ZW0uaXNGbGV4RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBmbGV4ID0gaXRlbS5fZmxleDtcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsZXgucGFkZGluZ0xlZnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbGV4LnBhZGRpbmdUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRUb3RhbFBhZGRpbmcoaXRlbSwgaG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaXRlbS5pc0ZsZXhFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsZXggPSBpdGVtLl9mbGV4O1xuICAgICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxleC5wYWRkaW5nUmlnaHQgKyBmbGV4LnBhZGRpbmdMZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxleC5wYWRkaW5nVG9wICsgZmxleC5wYWRkaW5nQm90dG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0TWFyZ2luT2Zmc2V0KGl0ZW0sIGhvcml6b250YWwpIHtcbiAgICAgICAgY29uc3QgZmxleEl0ZW0gPSBpdGVtLmZsZXhJdGVtO1xuICAgICAgICBpZiAoZmxleEl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsZXhJdGVtLm1hcmdpbkxlZnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbGV4SXRlbS5tYXJnaW5Ub3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRUb3RhbE1hcmdpbihpdGVtLCBob3Jpem9udGFsKSB7XG4gICAgICAgIGNvbnN0IGZsZXhJdGVtID0gaXRlbS5mbGV4SXRlbTtcbiAgICAgICAgaWYgKGZsZXhJdGVtKSB7XG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbGV4SXRlbS5tYXJnaW5SaWdodCArIGZsZXhJdGVtLm1hcmdpbkxlZnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbGV4SXRlbS5tYXJnaW5Ub3AgKyBmbGV4SXRlbS5tYXJnaW5Cb3R0b207XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFNwYWNpbmdDYWxjdWxhdG9yIGZyb20gXCIuL1NwYWNpbmdDYWxjdWxhdG9yLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZW50QWxpZ25lciB7XG5cbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICB0aGlzLl90b3RhbENyb3NzQXhpc1NpemUgPSAwO1xuICAgIH1cblxuICAgIGdldCBfbGluZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQuX2xpbmVzO1xuICAgIH1cblxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuX3RvdGFsQ3Jvc3NBeGlzU2l6ZSA9IHRoaXMuX2dldFRvdGFsQ3Jvc3NBeGlzU2l6ZSgpO1xuICAgIH1cblxuICAgIGFsaWduKCkge1xuICAgICAgICBjb25zdCBjcm9zc0F4aXNTaXplID0gdGhpcy5fbGF5b3V0LmNyb3NzQXhpc1NpemU7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ1NwYWNlID0gY3Jvc3NBeGlzU2l6ZSAtIHRoaXMuX3RvdGFsQ3Jvc3NBeGlzU2l6ZTtcblxuICAgICAgICBjb25zdCB7c3BhY2luZ0JlZm9yZSwgc3BhY2luZ0JldHdlZW59ID0gdGhpcy5fZ2V0U3BhY2luZyhyZW1haW5pbmdTcGFjZSk7XG5cbiAgICAgICAgY29uc3QgbGluZXMgPSB0aGlzLl9saW5lcztcblxuICAgICAgICBjb25zdCBtb2RlID0gdGhpcy5fbGF5b3V0Ll9mbGV4Q29udGFpbmVyLmFsaWduQ29udGVudDtcbiAgICAgICAgbGV0IGdyb3dTaXplID0gMDtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwic3RyZXRjaFwiICYmIGxpbmVzLmxlbmd0aCAmJiAocmVtYWluaW5nU3BhY2UgPiAwKSkge1xuICAgICAgICAgICAgZ3Jvd1NpemUgPSByZW1haW5pbmdTcGFjZSAvIGxpbmVzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gc3BhY2luZ0JlZm9yZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBsaW5lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNyb3NzQXhpc0xheW91dE9mZnNldCA9IGN1cnJlbnRQb3M7XG4gICAgICAgICAgICBjb25zdCBhbGlnbmVyID0gbGluZXNbaV0uY3JlYXRlSXRlbUFsaWduZXIoKTtcblxuICAgICAgICAgICAgbGV0IGZpbmFsQ3Jvc3NBeGlzTGF5b3V0U2l6ZSA9IGxpbmVzW2ldLmNyb3NzQXhpc0xheW91dFNpemUgKyBncm93U2l6ZTtcblxuICAgICAgICAgICAgYWxpZ25lci5zZXRDcm9zc0F4aXNMYXlvdXRTaXplKGZpbmFsQ3Jvc3NBeGlzTGF5b3V0U2l6ZSk7XG4gICAgICAgICAgICBhbGlnbmVyLnNldENyb3NzQXhpc0xheW91dE9mZnNldChjcm9zc0F4aXNMYXlvdXRPZmZzZXQpO1xuXG4gICAgICAgICAgICBhbGlnbmVyLmFsaWduKCk7XG5cbiAgICAgICAgICAgIGlmIChhbGlnbmVyLnJlY3Vyc2l2ZVJlc2l6ZU9jY3VyZWQpIHtcbiAgICAgICAgICAgICAgICBsaW5lc1tpXS5zZXRJdGVtUG9zaXRpb25zKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gZmluYWxDcm9zc0F4aXNMYXlvdXRTaXplO1xuICAgICAgICAgICAgY3VycmVudFBvcyArPSBzcGFjaW5nQmV0d2VlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB0b3RhbENyb3NzQXhpc1NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbENyb3NzQXhpc1NpemU7XG4gICAgfVxuXG4gICAgX2dldFRvdGFsQ3Jvc3NBeGlzU2l6ZSgpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSB0aGlzLl9saW5lcztcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBsaW5lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIHRvdGFsICs9IGxpbmUuY3Jvc3NBeGlzTGF5b3V0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuXG4gICAgX2dldFNwYWNpbmcocmVtYWluaW5nU3BhY2UpIHtcbiAgICAgICAgY29uc3QgbW9kZSA9IHRoaXMuX2xheW91dC5fZmxleENvbnRhaW5lci5hbGlnbkNvbnRlbnQ7XG4gICAgICAgIGNvbnN0IG51bWJlck9mSXRlbXMgPSB0aGlzLl9saW5lcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBTcGFjaW5nQ2FsY3VsYXRvci5nZXRTcGFjaW5nKG1vZGUsIG51bWJlck9mSXRlbXMsIHJlbWFpbmluZ1NwYWNlKTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDb250ZW50QWxpZ25lciBmcm9tIFwiLi9Db250ZW50QWxpZ25lci5tanNcIjtcbmltcG9ydCBGbGV4VXRpbHMgZnJvbSBcIi4uL0ZsZXhVdGlscy5tanNcIjtcbmltcG9ydCBMaW5lTGF5b3V0ZXIgZnJvbSBcIi4vTGluZUxheW91dGVyLm1qc1wiO1xuaW1wb3J0IEl0ZW1Db29yZGluYXRlc1VwZGF0ZXIgZnJvbSBcIi4vSXRlbUNvb3JkaW5hdGVzVXBkYXRlci5tanNcIjtcblxuLyoqXG4gKiBMYXlvdXRzIGEgZmxleCBjb250YWluZXIgKGFuZCBkZXNjZW5kYW50cykuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZsZXhMYXlvdXQge1xuXG4gICAgY29uc3RydWN0b3IoZmxleENvbnRhaW5lcikge1xuICAgICAgICB0aGlzLl9mbGV4Q29udGFpbmVyID0gZmxleENvbnRhaW5lcjtcblxuICAgICAgICB0aGlzLl9saW5lTGF5b3V0ZXIgPSBuZXcgTGluZUxheW91dGVyKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX3Jlc2l6aW5nTWFpbkF4aXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVzaXppbmdDcm9zc0F4aXMgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9jYWNoZWRNYWluQXhpc1NpemVBZnRlckxheW91dCA9IDA7XG4gICAgICAgIHRoaXMuX2NhY2hlZENyb3NzQXhpc1NpemVBZnRlckxheW91dCA9IDA7XG5cbiAgICAgICAgdGhpcy5fc2hydW5rID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IHNocnVuaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NocnVuaztcbiAgICB9XG5cbiAgICBnZXQgcmVjYWxjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtLnJlY2FsYztcbiAgICB9XG5cbiAgICBsYXlvdXRUcmVlKCkge1xuICAgICAgICBjb25zdCBpc1N1YlRyZWUgPSAodGhpcy5pdGVtLmZsZXhQYXJlbnQgIT09IG51bGwpO1xuICAgICAgICBpZiAoaXNTdWJUcmVlKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGRpbWVuc2lvbnMgc2V0IGJ5IHRoZSBwYXJlbnQgZmxleCB0cmVlLlxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3ViVHJlZUxheW91dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmVlTGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVJdGVtQ29vcmRzKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlVHJlZUxheW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVjYWxjKSB7XG4gICAgICAgICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlTGF5b3V0VHJlZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGVyZm9ybVVwZGF0ZUxheW91dFRyZWVGcm9tQ2FjaGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9wZXJmb3JtVXBkYXRlTGF5b3V0VHJlZSgpIHtcbiAgICAgICAgdGhpcy5fc2V0SW5pdGlhbEF4aXNTaXplcygpO1xuICAgICAgICB0aGlzLl9sYXlvdXRBeGVzKCk7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hMYXlvdXRDYWNoZSgpO1xuICAgIH1cblxuICAgIF9yZWZyZXNoTGF5b3V0Q2FjaGUoKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZE1haW5BeGlzU2l6ZUFmdGVyTGF5b3V0ID0gdGhpcy5tYWluQXhpc1NpemU7XG4gICAgICAgIHRoaXMuX2NhY2hlZENyb3NzQXhpc1NpemVBZnRlckxheW91dCA9IHRoaXMuY3Jvc3NBeGlzU2l6ZTtcbiAgICB9XG5cbiAgICBfcGVyZm9ybVVwZGF0ZUxheW91dFRyZWVGcm9tQ2FjaGUoKSB7XG4gICAgICAgIGNvbnN0IHNpemVNaWdodEhhdmVDaGFuZ2VkID0gKHRoaXMuaXRlbS5mdW5jVyB8fCB0aGlzLml0ZW0uZnVuY0gpO1xuICAgICAgICBpZiAoc2l6ZU1pZ2h0SGF2ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhZnRlciBhbGwuXG4gICAgICAgICAgICB0aGlzLml0ZW0uZW5hYmxlTG9jYWxSZWNhbGNGbGFnKCk7XG4gICAgICAgICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlTGF5b3V0VHJlZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluQXhpc1NpemUgPSB0aGlzLl9jYWNoZWRNYWluQXhpc1NpemVBZnRlckxheW91dDtcbiAgICAgICAgICAgIHRoaXMuY3Jvc3NBeGlzU2l6ZSA9IHRoaXMuX2NhY2hlZENyb3NzQXhpc1NpemVBZnRlckxheW91dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUl0ZW1Db29yZHMoKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZXIgPSBuZXcgSXRlbUNvb3JkaW5hdGVzVXBkYXRlcih0aGlzKTtcbiAgICAgICAgdXBkYXRlci5maW5hbGl6ZSgpO1xuICAgIH1cblxuICAgIF91cGRhdGVTdWJUcmVlTGF5b3V0KCkge1xuICAgICAgICAvLyBUaGUgZGltZW5zaW9ucyBvZiB0aGlzIGNvbnRhaW5lciBhcmUgZ3VhcmFudGVlZCBub3QgdG8gaGF2ZSBjaGFuZ2VkLlxuICAgICAgICAvLyBUaGF0J3Mgd2h5IHdlIGNhbiBzYWZlbHkgJ3JldXNlJyB0aG9zZSBhbmQgcmUtbGF5b3V0IHRoZSBjb250ZW50cy5cbiAgICAgICAgY29uc3QgY3Jvc3NBeGlzU2l6ZSA9IHRoaXMuY3Jvc3NBeGlzU2l6ZTtcbiAgICAgICAgdGhpcy5fbGF5b3V0TWFpbkF4aXMoKTtcbiAgICAgICAgdGhpcy5wZXJmb3JtUmVzaXplQ3Jvc3NBeGlzKGNyb3NzQXhpc1NpemUpO1xuICAgIH1cblxuICAgIF9zZXRJbml0aWFsQXhpc1NpemVzKCkge1xuICAgICAgICBpZiAodGhpcy5pdGVtLmlzRmxleEl0ZW1FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbS5mbGV4SXRlbS5fcmVzZXRMYXlvdXRTaXplKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW5BeGlzU2l6ZSA9IHRoaXMuX2dldE1haW5BeGlzQmFzaXMoKTtcbiAgICAgICAgICAgIHRoaXMuY3Jvc3NBeGlzU2l6ZSA9IHRoaXMuX2dldENyb3NzQXhpc0Jhc2lzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzaXppbmdNYWluQXhpcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXNpemluZ0Nyb3NzQXhpcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zaHJ1bmsgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfbGF5b3V0QXhlcygpIHtcbiAgICAgICAgdGhpcy5fbGF5b3V0TWFpbkF4aXMoKTtcbiAgICAgICAgdGhpcy5fbGF5b3V0Q3Jvc3NBeGlzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByZSBtYWluQXhpc1NpemUgc2hvdWxkIGV4Y2x1ZGUgcGFkZGluZy5cbiAgICAgKi9cbiAgICBfbGF5b3V0TWFpbkF4aXMoKSB7XG4gICAgICAgIHRoaXMuX2xheW91dExpbmVzKCk7XG4gICAgICAgIHRoaXMuX2ZpdE1haW5BeGlzU2l6ZVRvQ29udGVudHMoKTtcbiAgICB9XG5cbiAgICBfbGF5b3V0TGluZXMoKSB7XG4gICAgICAgIHRoaXMuX2xpbmVMYXlvdXRlci5sYXlvdXRMaW5lcygpO1xuICAgIH1cblxuICAgIGdldCBfbGluZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lTGF5b3V0ZXIubGluZXM7XG4gICAgfVxuXG4gICAgX2ZpdE1haW5BeGlzU2l6ZVRvQ29udGVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVzaXppbmdNYWluQXhpcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNNYWluQXhpc0ZpdFRvQ29udGVudHMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbkF4aXNTaXplID0gdGhpcy5fbGluZUxheW91dGVyLm1haW5BeGlzQ29udGVudFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJlIGNyb3NzQXhpc1NpemUgc2hvdWxkIGV4Y2x1ZGUgcGFkZGluZy5cbiAgICAgKi9cbiAgICBfbGF5b3V0Q3Jvc3NBeGlzKCkge1xuICAgICAgICBjb25zdCBhbGlnbmVyID0gbmV3IENvbnRlbnRBbGlnbmVyKHRoaXMpO1xuICAgICAgICBhbGlnbmVyLmluaXQoKTtcbiAgICAgICAgdGhpcy5fdG90YWxDcm9zc0F4aXNTaXplID0gYWxpZ25lci50b3RhbENyb3NzQXhpc1NpemU7XG4gICAgICAgIHRoaXMuX2ZpdENyb3NzQXhpc1NpemVUb0NvbnRlbnRzKCk7XG4gICAgICAgIGFsaWduZXIuYWxpZ24oKTtcbiAgICB9XG5cbiAgICBfZml0Q3Jvc3NBeGlzU2l6ZVRvQ29udGVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVzaXppbmdDcm9zc0F4aXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ3Jvc3NBeGlzRml0VG9Db250ZW50cygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcm9zc0F4aXNTaXplID0gdGhpcy5fdG90YWxDcm9zc0F4aXNTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNXcmFwcGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsZXhDb250YWluZXIud3JhcDtcbiAgICB9XG5cbiAgICBpc0F4aXNGaXRUb0NvbnRlbnRzKGhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hvcml6b250YWwgPT09IGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzTWFpbkF4aXNGaXRUb0NvbnRlbnRzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Nyb3NzQXhpc0ZpdFRvQ29udGVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzTWFpbkF4aXNGaXRUb0NvbnRlbnRzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNXcmFwcGluZygpICYmICF0aGlzLl9oYXNGaXhlZE1haW5BeGlzQmFzaXMoKTtcbiAgICB9XG5cbiAgICBpc0Nyb3NzQXhpc0ZpdFRvQ29udGVudHMoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5faGFzRml4ZWRDcm9zc0F4aXNCYXNpcygpO1xuICAgIH1cblxuICAgIF9oYXNGaXhlZE1haW5BeGlzQmFzaXMoKSB7XG4gICAgICAgIHJldHVybiAhRmxleFV0aWxzLmlzWmVyb0F4aXNTaXplKHRoaXMuaXRlbSwgdGhpcy5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX2hhc0ZpeGVkQ3Jvc3NBeGlzQmFzaXMoKSB7XG4gICAgICAgIHJldHVybiAhRmxleFV0aWxzLmlzWmVyb0F4aXNTaXplKHRoaXMuaXRlbSwgIXRoaXMuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIGdldEF4aXNNaW5TaXplKGhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hvcml6b250YWwgPT09IGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRNYWluQXhpc01pblNpemUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDcm9zc0F4aXNNaW5TaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0TWFpbkF4aXNNaW5TaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZUxheW91dGVyLm1haW5BeGlzTWluU2l6ZTtcbiAgICB9XG5cbiAgICBfZ2V0Q3Jvc3NBeGlzTWluU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVMYXlvdXRlci5jcm9zc0F4aXNNaW5TaXplO1xuICAgIH1cblxuICAgIHJlc2l6ZU1haW5BeGlzKHNpemUpIHtcbiAgICAgICAgaWYgKHRoaXMubWFpbkF4aXNTaXplICE9PSBzaXplKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWNhbGMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtUmVzaXplTWFpbkF4aXMoc2l6ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGVja1ZhbGlkQ2FjaGVNYWluQXhpc1Jlc2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbkF4aXNTaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZml0Q3Jvc3NBeGlzU2l6ZVRvQ29udGVudHMoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSBtaXNzLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW0uZW5hYmxlTG9jYWxSZWNhbGNGbGFnKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybVJlc2l6ZU1haW5BeGlzKHNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jaGVja1ZhbGlkQ2FjaGVNYWluQXhpc1Jlc2l6ZShzaXplKSB7XG4gICAgICAgIGNvbnN0IGlzRmluYWxNYWluQXhpc1NpemUgPSAoc2l6ZSA9PT0gdGhpcy50YXJnZXRNYWluQXhpc1NpemUpO1xuICAgICAgICBpZiAoaXNGaW5hbE1haW5BeGlzU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuSWdub3JlQ2FjaGVNaXNzID0gIXRoaXMuaXNDcm9zc0F4aXNGaXRUb0NvbnRlbnRzKCk7XG4gICAgICAgIGlmIChjYW5JZ25vcmVDYWNoZU1pc3MpIHtcbiAgICAgICAgICAgIC8vIEFsbG93IG90aGVyIG1haW4gYXhpcyByZXNpemVzIGFuZCBjaGVjayBpZiBmaW5hbCByZXNpemUgbWF0Y2hlcyB0aGUgdGFyZ2V0IG1haW4gYXhpcyBzaXplXG4gICAgICAgICAgICAvLyAgKEl0ZW1Db29yZGluYXRlc1VwZGF0ZXIpLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHBlcmZvcm1SZXNpemVNYWluQXhpcyhzaXplKSB7XG4gICAgICAgIGNvbnN0IGlzU2hyaW5raW5nID0gKHNpemUgPCB0aGlzLm1haW5BeGlzU2l6ZSk7XG4gICAgICAgIHRoaXMuX3NocnVuayA9IGlzU2hyaW5raW5nO1xuXG4gICAgICAgIHRoaXMubWFpbkF4aXNTaXplID0gc2l6ZTtcblxuICAgICAgICB0aGlzLl9yZXNpemluZ01haW5BeGlzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbGF5b3V0QXhlcygpO1xuICAgICAgICB0aGlzLl9yZXNpemluZ01haW5BeGlzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzaXplQ3Jvc3NBeGlzKHNpemUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Jvc3NBeGlzU2l6ZSAhPT0gc2l6ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVjYWxjID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybVJlc2l6ZUNyb3NzQXhpcyhzaXplKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcm9zc0F4aXNTaXplID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBlcmZvcm1SZXNpemVDcm9zc0F4aXMoc2l6ZSkge1xuICAgICAgICB0aGlzLmNyb3NzQXhpc1NpemUgPSBzaXplO1xuXG4gICAgICAgIHRoaXMuX3Jlc2l6aW5nQ3Jvc3NBeGlzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbGF5b3V0Q3Jvc3NBeGlzKCk7XG4gICAgICAgIHRoaXMuX3Jlc2l6aW5nQ3Jvc3NBeGlzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IHRhcmdldE1haW5BeGlzU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvcml6b250YWwgPyB0aGlzLml0ZW0udGFyZ2V0LncgOiB0aGlzLml0ZW0udGFyZ2V0Lmg7XG4gICAgfVxuXG4gICAgZ2V0IHRhcmdldENyb3NzQXhpc1NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ob3Jpem9udGFsID8gdGhpcy5pdGVtLnRhcmdldC5oIDogdGhpcy5pdGVtLnRhcmdldC53O1xuICAgIH1cblxuICAgIGdldFBhcmVudEZsZXhDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW0uaXNGbGV4SXRlbUVuYWJsZWQoKSA/IHRoaXMuaXRlbS5mbGV4SXRlbS5jdHIgOiBudWxsO1xuICAgIH1cblxuICAgIF9nZXRIb3Jpem9udGFsUGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRUb3RhbFBhZGRpbmcodGhpcy5pdGVtLCB0cnVlKTtcbiAgICB9XG5cbiAgICBfZ2V0VmVydGljYWxQYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldFRvdGFsUGFkZGluZyh0aGlzLml0ZW0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBfZ2V0SG9yaXpvbnRhbFBhZGRpbmdPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0UGFkZGluZ09mZnNldCh0aGlzLml0ZW0sIHRydWUpO1xuICAgIH1cblxuICAgIF9nZXRWZXJ0aWNhbFBhZGRpbmdPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0UGFkZGluZ09mZnNldCh0aGlzLml0ZW0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBfZ2V0TWFpbkF4aXNCYXNpcygpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRSZWxBeGlzU2l6ZSh0aGlzLml0ZW0sIHRoaXMuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9nZXRDcm9zc0F4aXNCYXNpcygpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRSZWxBeGlzU2l6ZSh0aGlzLml0ZW0sICF0aGlzLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBnZXQgX2hvcml6b250YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mbGV4Q29udGFpbmVyLl9ob3Jpem9udGFsO1xuICAgIH1cblxuICAgIGdldCBfcmV2ZXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsZXhDb250YWluZXIuX3JldmVyc2U7XG4gICAgfVxuXG4gICAgZ2V0IGl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mbGV4Q29udGFpbmVyLml0ZW07XG4gICAgfVxuXG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtLml0ZW1zO1xuICAgIH1cblxuICAgIGdldCByZXNpemluZ01haW5BeGlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzaXppbmdNYWluQXhpcztcbiAgICB9XG5cbiAgICBnZXQgcmVzaXppbmdDcm9zc0F4aXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNpemluZ0Nyb3NzQXhpcztcbiAgICB9XG5cbiAgICBnZXQgbnVtYmVyT2ZJdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGdldCBtYWluQXhpc1NpemUoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0QXhpc0xheW91dFNpemUodGhpcy5pdGVtLCB0aGlzLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBnZXQgY3Jvc3NBeGlzU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRBeGlzTGF5b3V0U2l6ZSh0aGlzLml0ZW0sICF0aGlzLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBzZXQgbWFpbkF4aXNTaXplKHYpIHtcbiAgICAgICAgRmxleFV0aWxzLnNldEF4aXNMYXlvdXRTaXplKHRoaXMuaXRlbSwgdGhpcy5faG9yaXpvbnRhbCwgdik7XG4gICAgfVxuXG4gICAgc2V0IGNyb3NzQXhpc1NpemUodikge1xuICAgICAgICBGbGV4VXRpbHMuc2V0QXhpc0xheW91dFNpemUodGhpcy5pdGVtLCAhdGhpcy5faG9yaXpvbnRhbCwgdik7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRmxleFV0aWxzIGZyb20gXCIuLi9GbGV4VXRpbHMubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEl0ZW1Db29yZGluYXRlc1VwZGF0ZXIge1xuXG4gICAgY29uc3RydWN0b3IobGF5b3V0KSB7XG4gICAgICAgIHRoaXMuX2xheW91dCA9IGxheW91dDtcbiAgICAgICAgdGhpcy5faXNSZXZlcnNlID0gdGhpcy5fZmxleENvbnRhaW5lci5fcmV2ZXJzZTtcbiAgICAgICAgdGhpcy5faG9yaXpvbnRhbFBhZGRpbmdPZmZzZXQgPSB0aGlzLl9sYXlvdXQuX2dldEhvcml6b250YWxQYWRkaW5nT2Zmc2V0KCk7XG4gICAgICAgIHRoaXMuX3ZlcnRpY2FsUGFkZGluZ09mZnNldCA9IHRoaXMuX2xheW91dC5fZ2V0VmVydGljYWxQYWRkaW5nT2Zmc2V0KCk7XG4gICAgfVxuXG4gICAgZ2V0IF9mbGV4Q29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0Ll9mbGV4Q29udGFpbmVyO1xuICAgIH1cblxuICAgIGZpbmFsaXplKCkge1xuICAgICAgICBjb25zdCBwYXJlbnRGbGV4ID0gdGhpcy5fbGF5b3V0LmdldFBhcmVudEZsZXhDb250YWluZXIoKTtcbiAgICAgICAgaWYgKHBhcmVudEZsZXgpIHtcbiAgICAgICAgICAgIC8vIFdlIG11c3QgdXBkYXRlIGl0IGZyb20gdGhlIHBhcmVudCB0byBzZXQgcGFkZGluZyBvZmZzZXRzIGFuZCByZXZlcnNlIHBvc2l0aW9uLlxuICAgICAgICAgICAgY29uc3QgdXBkYXRlciA9IG5ldyBJdGVtQ29vcmRpbmF0ZXNVcGRhdGVyKHBhcmVudEZsZXguX2xheW91dCk7XG4gICAgICAgICAgICB1cGRhdGVyLl9maW5hbGl6ZUl0ZW1BbmRDaGlsZHJlbih0aGlzLl9mbGV4Q29udGFpbmVyLml0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmluYWxpemVSb290KCk7XG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6ZUl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZmluYWxpemVSb290KCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fZmxleENvbnRhaW5lci5pdGVtO1xuICAgICAgICBsZXQgeCA9IEZsZXhVdGlscy5nZXRBeGlzTGF5b3V0UG9zKGl0ZW0sIHRydWUpO1xuICAgICAgICBsZXQgeSA9IEZsZXhVdGlscy5nZXRBeGlzTGF5b3V0UG9zKGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgbGV0IHcgPSBGbGV4VXRpbHMuZ2V0QXhpc0xheW91dFNpemUoaXRlbSwgdHJ1ZSk7XG4gICAgICAgIGxldCBoID0gRmxleFV0aWxzLmdldEF4aXNMYXlvdXRTaXplKGl0ZW0sIGZhbHNlKTtcblxuICAgICAgICB3ICs9IHRoaXMuX2xheW91dC5fZ2V0SG9yaXpvbnRhbFBhZGRpbmcoKTtcbiAgICAgICAgaCArPSB0aGlzLl9sYXlvdXQuX2dldFZlcnRpY2FsUGFkZGluZygpO1xuXG4gICAgICAgIGl0ZW0uY2xlYXJSZWNhbGNGbGFnKCk7XG5cbiAgICAgICAgaXRlbS5zZXRMYXlvdXQoeCwgeSwgdywgaCk7XG4gICAgfVxuXG4gICAgX2ZpbmFsaXplSXRlbXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGF5b3V0Lml0ZW1zO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsaWRDYWNoZSA9IHRoaXMuX3ZhbGlkYXRlSXRlbUNhY2hlKGl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBOb3RpY2UgdGhhdCB3ZSBtdXN0IGFsc28gZmluYWxpemUgYSBjYWNoZWQgaXRlbXMsIGFzIGl0J3MgY29vcmRpbmF0ZXMgbWF5IGhhdmUgY2hhbmdlZC5cbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXplSXRlbShpdGVtKTtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZENhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmluYWxpemVJdGVtQ2hpbGRyZW4oaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdmFsaWRhdGVJdGVtQ2FjaGUoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5yZWNhbGMgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmlzRmxleEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxheW91dCA9IGl0ZW0uX2ZsZXguX2xheW91dDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbnNNYXRjaFByZXZpb3VzUmVzdWx0ID0gKGl0ZW0udyA9PT0gaXRlbS50YXJnZXQudyAmJiBpdGVtLmggPT09IGl0ZW0udGFyZ2V0LmgpO1xuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25zTWF0Y2hQcmV2aW91c1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Jvc3NBeGlzU2l6ZSA9IGxheW91dC5jcm9zc0F4aXNTaXplO1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXQucGVyZm9ybVJlc2l6ZU1haW5BeGlzKGxheW91dC5tYWluQXhpc1NpemUpO1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXQucGVyZm9ybVJlc2l6ZUNyb3NzQXhpcyhjcm9zc0F4aXNTaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIF9maW5hbGl6ZUl0ZW1BbmRDaGlsZHJlbihpdGVtKSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fZmluYWxpemVJdGVtQ2hpbGRyZW4oaXRlbSk7XG4gICAgfVxuXG4gICAgX2ZpbmFsaXplSXRlbShpdGVtKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1JldmVyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3JldmVyc2VNYWluQXhpc0xheW91dFBvcyhpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB4ID0gRmxleFV0aWxzLmdldEF4aXNMYXlvdXRQb3MoaXRlbSwgdHJ1ZSk7XG4gICAgICAgIGxldCB5ID0gRmxleFV0aWxzLmdldEF4aXNMYXlvdXRQb3MoaXRlbSwgZmFsc2UpO1xuICAgICAgICBsZXQgdyA9IEZsZXhVdGlscy5nZXRBeGlzTGF5b3V0U2l6ZShpdGVtLCB0cnVlKTtcbiAgICAgICAgbGV0IGggPSBGbGV4VXRpbHMuZ2V0QXhpc0xheW91dFNpemUoaXRlbSwgZmFsc2UpO1xuXG4gICAgICAgIHggKz0gdGhpcy5faG9yaXpvbnRhbFBhZGRpbmdPZmZzZXQ7XG4gICAgICAgIHkgKz0gdGhpcy5fdmVydGljYWxQYWRkaW5nT2Zmc2V0O1xuXG4gICAgICAgIGNvbnN0IGZsZXggPSBpdGVtLmZsZXg7XG4gICAgICAgIGlmIChmbGV4KSB7XG4gICAgICAgICAgICB3ICs9IGl0ZW0uX2ZsZXguX2xheW91dC5fZ2V0SG9yaXpvbnRhbFBhZGRpbmcoKTtcbiAgICAgICAgICAgIGggKz0gaXRlbS5fZmxleC5fbGF5b3V0Ll9nZXRWZXJ0aWNhbFBhZGRpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZsZXhJdGVtID0gaXRlbS5mbGV4SXRlbTtcbiAgICAgICAgaWYgKGZsZXhJdGVtKSB7XG4gICAgICAgICAgICB4ICs9IGZsZXhJdGVtLl9nZXRIb3Jpem9udGFsTWFyZ2luT2Zmc2V0KCk7XG4gICAgICAgICAgICB5ICs9IGZsZXhJdGVtLl9nZXRWZXJ0aWNhbE1hcmdpbk9mZnNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbS5jbGVhclJlY2FsY0ZsYWcoKTtcbiAgICAgICAgaXRlbS5zZXRMYXlvdXQoeCwgeSwgdywgaCk7XG4gICAgfVxuXG4gICAgX2ZpbmFsaXplSXRlbUNoaWxkcmVuKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgZmxleCA9IGl0ZW0uX2ZsZXg7XG4gICAgICAgIGlmIChmbGV4KSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVyID0gbmV3IEl0ZW1Db29yZGluYXRlc1VwZGF0ZXIoZmxleC5fbGF5b3V0KTtcbiAgICAgICAgICAgIHVwZGF0ZXIuX2ZpbmFsaXplSXRlbXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZXZlcnNlTWFpbkF4aXNMYXlvdXRQb3MoaXRlbSkge1xuICAgICAgICBjb25zdCBlbmRQb3MgPSAoaXRlbS5mbGV4SXRlbS5fZ2V0TWFpbkF4aXNMYXlvdXRQb3MoKSArIGl0ZW0uZmxleEl0ZW0uX2dldE1haW5BeGlzTGF5b3V0U2l6ZVdpdGhQYWRkaW5nQW5kTWFyZ2luKCkpO1xuICAgICAgICBjb25zdCByZXZlcnNlZFBvcyA9IHRoaXMuX2xheW91dC5tYWluQXhpc1NpemUgLSBlbmRQb3M7XG4gICAgICAgIGl0ZW0uZmxleEl0ZW0uX3NldE1haW5BeGlzTGF5b3V0UG9zKHJldmVyc2VkUG9zKTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBMaW5lTGF5b3V0IGZyb20gXCIuL2xpbmUvTGluZUxheW91dC5tanNcIjtcblxuLyoqXG4gKiBEaXN0cmlidXRlcyBpdGVtcyBvdmVyIGxheW91dCBsaW5lcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUxheW91dGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgICAgICB0aGlzLl9sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIHRoaXMuX21haW5BeGlzTWluU2l6ZSA9IC0xO1xuICAgICAgICB0aGlzLl9jcm9zc0F4aXNNaW5TaXplID0gLTE7XG4gICAgICAgIHRoaXMuX21haW5BeGlzQ29udGVudFNpemUgPSAwO1xuICAgIH1cblxuICAgIGdldCBsaW5lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzO1xuICAgIH1cblxuICAgIGdldCBtYWluQXhpc01pblNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYWluQXhpc01pblNpemUgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWluQXhpc01pblNpemUgPSB0aGlzLl9nZXRNYWluQXhpc01pblNpemUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbWFpbkF4aXNNaW5TaXplO1xuICAgIH1cblxuICAgIGdldCBjcm9zc0F4aXNNaW5TaXplKCkge1xuICAgICAgICBpZiAodGhpcy5fY3Jvc3NBeGlzTWluU2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nyb3NzQXhpc01pblNpemUgPSB0aGlzLl9nZXRDcm9zc0F4aXNNaW5TaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nyb3NzQXhpc01pblNpemU7XG4gICAgfVxuXG4gICAgZ2V0IG1haW5BeGlzQ29udGVudFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWluQXhpc0NvbnRlbnRTaXplO1xuICAgIH1cblxuICAgIGxheW91dExpbmVzKCkge1xuICAgICAgICB0aGlzLl9zZXR1cCgpO1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xheW91dC5pdGVtcztcbiAgICAgICAgY29uc3Qgd3JhcCA9IHRoaXMuX2xheW91dC5pc1dyYXBwaW5nKCk7XG5cbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgICAgICB0aGlzLl9sYXlvdXRGbGV4SXRlbShpdGVtKTtcblxuICAgICAgICAgICAgLy8gR2V0IHByZWRpY3RlZCBtYWluIGF4aXMgc2l6ZS5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1NYWluQXhpc1NpemUgPSBpdGVtLmZsZXhJdGVtLl9nZXRNYWluQXhpc0xheW91dFNpemVXaXRoUGFkZGluZ0FuZE1hcmdpbigpO1xuXG4gICAgICAgICAgICBpZiAod3JhcCAmJiAoaSA+IHN0YXJ0SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNPdmVyZmxvd2luZyA9ICh0aGlzLl9jdXJNYWluQXhpc1BvcyArIGl0ZW1NYWluQXhpc1NpemUgPiB0aGlzLl9tYWluQXhpc1NpemUpO1xuICAgICAgICAgICAgICAgIGlmIChpc092ZXJmbG93aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dExpbmUoc3RhcnRJbmRleCwgaSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJNYWluQXhpc1BvcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fYWRkVG9NYWluQXhpc1BvcyhpdGVtTWFpbkF4aXNTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydEluZGV4IDwgaSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0TGluZShzdGFydEluZGV4LCBpIC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfbGF5b3V0RmxleEl0ZW0oaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5pc0ZsZXhFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGl0ZW0uZmxleExheW91dC51cGRhdGVUcmVlTGF5b3V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLmZsZXhJdGVtLl9yZXNldExheW91dFNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXR1cCgpIHtcbiAgICAgICAgdGhpcy5fbWFpbkF4aXNTaXplID0gdGhpcy5fbGF5b3V0Lm1haW5BeGlzU2l6ZTtcbiAgICAgICAgdGhpcy5fY3VyTWFpbkF4aXNQb3MgPSAwO1xuICAgICAgICB0aGlzLl9tYXhNYWluQXhpc1BvcyA9IDA7XG4gICAgICAgIHRoaXMuX2xpbmVzID0gW107XG5cbiAgICAgICAgdGhpcy5fbWFpbkF4aXNNaW5TaXplID0gLTE7XG4gICAgICAgIHRoaXMuX2Nyb3NzQXhpc01pblNpemUgPSAtMTtcbiAgICAgICAgdGhpcy5fbWFpbkF4aXNDb250ZW50U2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgX2FkZFRvTWFpbkF4aXNQb3MoaXRlbU1haW5BeGlzU2l6ZSkge1xuICAgICAgICB0aGlzLl9jdXJNYWluQXhpc1BvcyArPSBpdGVtTWFpbkF4aXNTaXplO1xuICAgICAgICBpZiAodGhpcy5fY3VyTWFpbkF4aXNQb3MgPiB0aGlzLl9tYXhNYWluQXhpc1Bvcykge1xuICAgICAgICAgICAgdGhpcy5fbWF4TWFpbkF4aXNQb3MgPSB0aGlzLl9jdXJNYWluQXhpc1BvcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9sYXlvdXRMaW5lKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVNwYWNlID0gdGhpcy5fZ2V0QXZhaWxhYmxlTWFpbkF4aXNMYXlvdXRTcGFjZSgpO1xuICAgICAgICBjb25zdCBsaW5lID0gbmV3IExpbmVMYXlvdXQodGhpcy5fbGF5b3V0LCBzdGFydEluZGV4LCBlbmRJbmRleCwgYXZhaWxhYmxlU3BhY2UpO1xuICAgICAgICBsaW5lLnBlcmZvcm1MYXlvdXQoKTtcbiAgICAgICAgdGhpcy5fbGluZXMucHVzaChsaW5lKTtcblxuICAgICAgICBpZiAodGhpcy5fbWFpbkF4aXNDb250ZW50U2l6ZSA9PT0gMCB8fCAodGhpcy5fY3VyTWFpbkF4aXNQb3MgPiB0aGlzLl9tYWluQXhpc0NvbnRlbnRTaXplKSkge1xuICAgICAgICAgICAgdGhpcy5fbWFpbkF4aXNDb250ZW50U2l6ZSA9IHRoaXMuX2N1ck1haW5BeGlzUG9zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldEF2YWlsYWJsZU1haW5BeGlzTGF5b3V0U3BhY2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbGF5b3V0LnJlc2l6aW5nTWFpbkF4aXMgJiYgdGhpcy5fbGF5b3V0LmlzTWFpbkF4aXNGaXRUb0NvbnRlbnRzKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21haW5BeGlzU2l6ZSAtIHRoaXMuX2N1ck1haW5BeGlzUG9zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldENyb3NzQXhpc01pblNpemUoKSB7XG4gICAgICAgIGxldCBjcm9zc0F4aXNNaW5TaXplID0gMDtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9sYXlvdXQuaXRlbXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICBjb25zdCBpdGVtQ3Jvc3NBeGlzTWluU2l6ZSA9IGl0ZW0uZmxleEl0ZW0uX2dldENyb3NzQXhpc01pblNpemVXaXRoUGFkZGluZ0FuZE1hcmdpbigpO1xuICAgICAgICAgICAgY3Jvc3NBeGlzTWluU2l6ZSA9IE1hdGgubWF4KGNyb3NzQXhpc01pblNpemUsIGl0ZW1Dcm9zc0F4aXNNaW5TaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3Jvc3NBeGlzTWluU2l6ZTtcbiAgICB9XG5cbiAgICBfZ2V0TWFpbkF4aXNNaW5TaXplKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZXNbMF0uZ2V0TWFpbkF4aXNNaW5TaXplKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXcmFwcGluZyBsaW5lczogc3BlY2lmaWVkIHdpZHRoIGlzIHVzZWQgYXMgbWluIHdpZHRoIChpbiBhY2NvcmRhbmNlIHRvIFczQyBmbGV4Ym94KS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQubWFpbkF4aXNTaXplO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGFjaW5nQ2FsY3VsYXRvciB7XG5cbiAgICBzdGF0aWMgZ2V0U3BhY2luZyhtb2RlLCBudW1iZXJPZkl0ZW1zLCByZW1haW5pbmdTcGFjZSkge1xuICAgICAgICBjb25zdCBpdGVtR2FwcyA9IChudW1iZXJPZkl0ZW1zIC0gMSk7XG4gICAgICAgIGxldCBzcGFjZVBlckdhcDtcblxuICAgICAgICBsZXQgc3BhY2luZ0JlZm9yZSwgc3BhY2luZ0JldHdlZW47XG5cbiAgICAgICAgc3dpdGNoKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmbGV4LXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgc3BhY2luZ0JlZm9yZSA9IDA7XG4gICAgICAgICAgICAgICAgc3BhY2luZ0JldHdlZW4gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZsZXgtZW5kXCI6XG4gICAgICAgICAgICAgICAgc3BhY2luZ0JlZm9yZSA9IHJlbWFpbmluZ1NwYWNlO1xuICAgICAgICAgICAgICAgIHNwYWNpbmdCZXR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgICAgICAgICAgICBzcGFjaW5nQmVmb3JlID0gcmVtYWluaW5nU3BhY2UgLyAyO1xuICAgICAgICAgICAgICAgIHNwYWNpbmdCZXR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzcGFjZS1iZXR3ZWVuXCI6XG4gICAgICAgICAgICAgICAgc3BhY2luZ0JlZm9yZSA9IDA7XG4gICAgICAgICAgICAgICAgc3BhY2luZ0JldHdlZW4gPSBNYXRoLm1heCgwLCByZW1haW5pbmdTcGFjZSkgLyBpdGVtR2FwcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzcGFjZS1hcm91bmRcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nU3BhY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNwYWNpbmcoXCJjZW50ZXJcIiwgbnVtYmVyT2ZJdGVtcywgcmVtYWluaW5nU3BhY2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlUGVyR2FwID0gcmVtYWluaW5nU3BhY2UgLyAoaXRlbUdhcHMgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2luZ0JlZm9yZSA9IDAuNSAqIHNwYWNlUGVyR2FwO1xuICAgICAgICAgICAgICAgICAgICBzcGFjaW5nQmV0d2VlbiA9IHNwYWNlUGVyR2FwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzcGFjZS1ldmVubHlcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nU3BhY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNwYWNpbmcoXCJjZW50ZXJcIiwgbnVtYmVyT2ZJdGVtcywgcmVtYWluaW5nU3BhY2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlUGVyR2FwID0gcmVtYWluaW5nU3BhY2UgLyAoaXRlbUdhcHMgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2luZ0JlZm9yZSA9IHNwYWNlUGVyR2FwO1xuICAgICAgICAgICAgICAgICAgICBzcGFjaW5nQmV0d2VlbiA9IHNwYWNlUGVyR2FwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzdHJldGNoXCI6XG4gICAgICAgICAgICAgICAgc3BhY2luZ0JlZm9yZSA9IDA7XG4gICAgICAgICAgICAgICAgc3BhY2luZ0JldHdlZW4gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG1vZGU6IFwiICsgbW9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge3NwYWNpbmdCZWZvcmUsIHNwYWNpbmdCZXR3ZWVufVxuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSXRlbUFsaWduZXIge1xuXG4gICAgY29uc3RydWN0b3IobGluZSkge1xuICAgICAgICB0aGlzLl9saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5fY3Jvc3NBeGlzTGF5b3V0U2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX2Nyb3NzQXhpc0xheW91dE9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuX2FsaWduSXRlbXNTZXR0aW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlUmVzaXplT2NjdXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0Nyb3NzQXhpc0ZpdFRvQ29udGVudHMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgX2xheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmUuX2xheW91dDtcbiAgICB9XG5cbiAgICBnZXQgX2ZsZXhDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQuX2ZsZXhDb250YWluZXI7XG4gICAgfVxuXG4gICAgc2V0Q3Jvc3NBeGlzTGF5b3V0U2l6ZShzaXplKSB7XG4gICAgICAgIHRoaXMuX2Nyb3NzQXhpc0xheW91dFNpemUgPSBzaXplO1xuICAgIH1cblxuICAgIHNldENyb3NzQXhpc0xheW91dE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fY3Jvc3NBeGlzTGF5b3V0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cblxuICAgIGFsaWduKCkge1xuICAgICAgICB0aGlzLl9hbGlnbkl0ZW1zU2V0dGluZyA9IHRoaXMuX2ZsZXhDb250YWluZXIuYWxpZ25JdGVtcztcblxuICAgICAgICB0aGlzLl9pc0Nyb3NzQXhpc0ZpdFRvQ29udGVudHMgPSB0aGlzLl9sYXlvdXQuaXNBeGlzRml0VG9Db250ZW50cyghdGhpcy5fZmxleENvbnRhaW5lci5faG9yaXpvbnRhbCk7XG5cbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlUmVzaXplT2NjdXJlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xpbmUuaXRlbXM7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9saW5lLnN0YXJ0SW5kZXg7IGkgPD0gdGhpcy5fbGluZS5lbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICB0aGlzLl9hbGlnbkl0ZW0oaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcmVjdXJzaXZlUmVzaXplT2NjdXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Vyc2l2ZVJlc2l6ZU9jY3VyZWQ7XG4gICAgfVxuXG4gICAgX2FsaWduSXRlbShpdGVtKSB7XG4gICAgICAgIGNvbnN0IGZsZXhJdGVtID0gaXRlbS5mbGV4SXRlbTtcbiAgICAgICAgbGV0IGFsaWduID0gZmxleEl0ZW0uYWxpZ25TZWxmIHx8IHRoaXMuX2FsaWduSXRlbXNTZXR0aW5nO1xuXG4gICAgICAgIGlmIChhbGlnbiA9PT0gXCJzdHJldGNoXCIgJiYgdGhpcy5fcHJldmVudFN0cmV0Y2goZmxleEl0ZW0pKSB7XG4gICAgICAgICAgICBhbGlnbiA9IFwiZmxleC1zdGFydFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsaWduICE9PSBcInN0cmV0Y2hcIiAmJiAhdGhpcy5faXNDcm9zc0F4aXNGaXRUb0NvbnRlbnRzKSB7XG4gICAgICAgICAgICBpZiAoZmxleEl0ZW0uX2hhc1JlbENyb3NzQXhpc1NpemUoKSkge1xuICAgICAgICAgICAgICAgIC8vIEFzIGNyb3NzIGF4aXMgc2l6ZSBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIG5lZWQgdG8gcmVjYWxjIHRoZSByZWxhdGl2ZSBmbGV4IGl0ZW0ncyBzaXplLlxuICAgICAgICAgICAgICAgIGZsZXhJdGVtLl9yZXNldENyb3NzQXhpc0xheW91dFNpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaChhbGlnbikge1xuICAgICAgICAgICAgY2FzZSBcImZsZXgtc3RhcnRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGlnbkl0ZW1GbGV4U3RhcnQoZmxleEl0ZW0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZsZXgtZW5kXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxpZ25JdGVtRmxleEVuZChmbGV4SXRlbSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxpZ25JdGVtRmxleENlbnRlcihmbGV4SXRlbSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RyZXRjaFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FsaWduSXRlbVN0cmV0Y2goZmxleEl0ZW0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2FsaWduSXRlbUZsZXhTdGFydChmbGV4SXRlbSkge1xuICAgICAgICBmbGV4SXRlbS5fc2V0Q3Jvc3NBeGlzTGF5b3V0UG9zKHRoaXMuX2Nyb3NzQXhpc0xheW91dE9mZnNldCk7XG4gICAgfVxuXG4gICAgX2FsaWduSXRlbUZsZXhFbmQoZmxleEl0ZW0pIHtcbiAgICAgICAgY29uc3QgaXRlbUNyb3NzQXhpc1NpemUgPSBmbGV4SXRlbS5fZ2V0Q3Jvc3NBeGlzTGF5b3V0U2l6ZVdpdGhQYWRkaW5nQW5kTWFyZ2luKCk7XG4gICAgICAgIGZsZXhJdGVtLl9zZXRDcm9zc0F4aXNMYXlvdXRQb3ModGhpcy5fY3Jvc3NBeGlzTGF5b3V0T2Zmc2V0ICsgKHRoaXMuX2Nyb3NzQXhpc0xheW91dFNpemUgLSBpdGVtQ3Jvc3NBeGlzU2l6ZSkpO1xuICAgIH1cblxuICAgIF9hbGlnbkl0ZW1GbGV4Q2VudGVyKGZsZXhJdGVtKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1Dcm9zc0F4aXNTaXplID0gZmxleEl0ZW0uX2dldENyb3NzQXhpc0xheW91dFNpemVXaXRoUGFkZGluZ0FuZE1hcmdpbigpO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSAodGhpcy5fY3Jvc3NBeGlzTGF5b3V0U2l6ZSAtIGl0ZW1Dcm9zc0F4aXNTaXplKSAvIDI7XG4gICAgICAgIGZsZXhJdGVtLl9zZXRDcm9zc0F4aXNMYXlvdXRQb3ModGhpcy5fY3Jvc3NBeGlzTGF5b3V0T2Zmc2V0ICsgY2VudGVyKTtcbiAgICB9XG5cbiAgICBfYWxpZ25JdGVtU3RyZXRjaChmbGV4SXRlbSkge1xuICAgICAgICBmbGV4SXRlbS5fc2V0Q3Jvc3NBeGlzTGF5b3V0UG9zKHRoaXMuX2Nyb3NzQXhpc0xheW91dE9mZnNldCk7XG5cbiAgICAgICAgY29uc3QgbWFpbkF4aXNMYXlvdXRTaXplQmVmb3JlUmVzaXplID0gZmxleEl0ZW0uX2dldE1haW5BeGlzTGF5b3V0U2l6ZSgpO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuX2Nyb3NzQXhpc0xheW91dFNpemUgLSBmbGV4SXRlbS5fZ2V0Q3Jvc3NBeGlzTWFyZ2luKCkgLSBmbGV4SXRlbS5fZ2V0Q3Jvc3NBeGlzUGFkZGluZygpO1xuXG4gICAgICAgIGNvbnN0IGNyb3NzQXhpc01pblNpemVTZXR0aW5nID0gZmxleEl0ZW0uX2dldENyb3NzQXhpc01pblNpemVTZXR0aW5nKCk7XG4gICAgICAgIGlmIChjcm9zc0F4aXNNaW5TaXplU2V0dGluZyA+IDApIHtcbiAgICAgICAgICAgIHNpemUgPSBNYXRoLm1heChzaXplLCBjcm9zc0F4aXNNaW5TaXplU2V0dGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjcm9zc0F4aXNNYXhTaXplU2V0dGluZyA9IGZsZXhJdGVtLl9nZXRDcm9zc0F4aXNNYXhTaXplU2V0dGluZygpO1xuICAgICAgICBjb25zdCBjcm9zc0F4aXNNYXhTaXplU2V0dGluZ0VuYWJsZWQgPSAoY3Jvc3NBeGlzTWF4U2l6ZVNldHRpbmcgPiAwKTtcbiAgICAgICAgaWYgKGNyb3NzQXhpc01heFNpemVTZXR0aW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUsIGNyb3NzQXhpc01heFNpemVTZXR0aW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsZXhJdGVtLl9yZXNpemVDcm9zc0F4aXMoc2l6ZSk7XG4gICAgICAgIGNvbnN0IG1haW5BeGlzTGF5b3V0U2l6ZUFmdGVyUmVzaXplID0gZmxleEl0ZW0uX2dldE1haW5BeGlzTGF5b3V0U2l6ZSgpO1xuXG4gICAgICAgIGNvbnN0IHJlY3Vyc2l2ZVJlc2l6ZSA9IChtYWluQXhpc0xheW91dFNpemVBZnRlclJlc2l6ZSAhPT0gbWFpbkF4aXNMYXlvdXRTaXplQmVmb3JlUmVzaXplKTtcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZVJlc2l6ZSkge1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlIHJlc2l6ZSBjYW4gaGFwcGVuIHdoZW4gdGhpcyBmbGV4IGl0ZW0gaGFzIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gdGhhbiB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICAvLyBhbmQgaXMgd3JhcHBpbmcgYW5kIGF1dG8tc2l6aW5nLiBEdWUgdG8gaXRlbS9jb250ZW50IHN0cmV0Y2hpbmcgdGhlIG1haW4gYXhpcyBzaXplIG9mIHRoZSBmbGV4XG4gICAgICAgICAgICAvLyBpdGVtIG1heSBkZWNyZWFzZS4gSWYgaXQgZG9lcyBzbywgd2UgbXVzdCByZS1qdXN0aWZ5LWNvbnRlbnQgdGhlIGNvbXBsZXRlIGxpbmUuXG4gICAgICAgICAgICAvLyBOb3RpY2UgdGhhdCB3ZSBkb24ndCBhY2NvdW50IGZvciBjaGFuZ2VzIHRvIHRoZSAoaWYgYXV0b3NpemVkKSBtYWluIGF4aXMgc2l6ZSBjYXVzZWQgYnkgcmVjdXJzaXZlXG4gICAgICAgICAgICAvLyByZXNpemUsIHdoaWNoIG1heSBjYXVzZSB0aGUgY29udGFpbmVyJ3MgbWFpbiBheGlzIHRvIG5vdCBzaHJpbmsgdG8gdGhlIGNvbnRlbnRzIHByb3Blcmx5LlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBieSBkZXNpZ24sIGJlY2F1c2UgaWYgd2UgaGFkIHJlLXJ1biB0aGUgbWFpbiBheGlzIGxheW91dCwgd2UgY291bGQgcnVuIGludG8gaXNzdWVzIHN1Y2hcbiAgICAgICAgICAgIC8vIGFzIHNsb3cgbGF5b3V0IG9yIGVuZGxlc3MgbG9vcHMuXG4gICAgICAgICAgICB0aGlzLl9yZWN1cnNpdmVSZXNpemVPY2N1cmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9wcmV2ZW50U3RyZXRjaChmbGV4SXRlbSkge1xuICAgICAgICBjb25zdCBoYXNGaXhlZENyb3NzQXhpc1NpemUgPSBmbGV4SXRlbS5faGFzRml4ZWRDcm9zc0F4aXNTaXplKCk7XG4gICAgICAgIGNvbnN0IGZvcmNlU3RyZXRjaCA9IChmbGV4SXRlbS5hbGlnblNlbGYgPT09IFwic3RyZXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGhhc0ZpeGVkQ3Jvc3NBeGlzU2l6ZSAmJiAhZm9yY2VTdHJldGNoO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFNwYWNpbmdDYWxjdWxhdG9yIGZyb20gXCIuLi9TcGFjaW5nQ2FsY3VsYXRvci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSXRlbVBvc2l0aW9uZXIge1xuXG4gICAgY29uc3RydWN0b3IobGluZUxheW91dCkge1xuICAgICAgICB0aGlzLl9saW5lID0gbGluZUxheW91dDtcbiAgICB9XG5cbiAgICBnZXQgX2xheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmUuX2xheW91dDtcbiAgICB9XG5cbiAgICBwb3NpdGlvbigpIHtcbiAgICAgICAgY29uc3Qge3NwYWNpbmdCZWZvcmUsIHNwYWNpbmdCZXR3ZWVufSA9IHRoaXMuX2dldFNwYWNpbmcoKTtcblxuICAgICAgICBsZXQgY3VycmVudFBvcyA9IHNwYWNpbmdCZWZvcmU7XG5cbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9saW5lLml0ZW1zO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fbGluZS5zdGFydEluZGV4OyBpIDw9IHRoaXMuX2xpbmUuZW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgICAgICBpdGVtLmZsZXhJdGVtLl9zZXRNYWluQXhpc0xheW91dFBvcyhjdXJyZW50UG9zKTtcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gaXRlbS5mbGV4SXRlbS5fZ2V0TWFpbkF4aXNMYXlvdXRTaXplV2l0aFBhZGRpbmdBbmRNYXJnaW4oKTtcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gc3BhY2luZ0JldHdlZW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0U3BhY2luZygpIHtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nU3BhY2UgPSB0aGlzLl9saW5lLl9hdmFpbGFibGVTcGFjZTtcbiAgICAgICAgbGV0IG1vZGUgPSB0aGlzLl9sYXlvdXQuX2ZsZXhDb250YWluZXIuanVzdGlmeUNvbnRlbnQ7XG4gICAgICAgIGNvbnN0IG51bWJlck9mSXRlbXMgPSB0aGlzLl9saW5lLm51bWJlck9mSXRlbXM7XG5cbiAgICAgICAgcmV0dXJuIFNwYWNpbmdDYWxjdWxhdG9yLmdldFNwYWNpbmcobW9kZSwgbnVtYmVyT2ZJdGVtcywgcmVtYWluaW5nU3BhY2UpO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFNpemVTaHJpbmtlciBmcm9tIFwiLi9TaXplU2hyaW5rZXIubWpzXCI7XG5pbXBvcnQgU2l6ZUdyb3dlciBmcm9tIFwiLi9TaXplR3Jvd2VyLm1qc1wiO1xuaW1wb3J0IEl0ZW1Qb3NpdGlvbmVyIGZyb20gXCIuL0l0ZW1Qb3NpdGlvbmVyLm1qc1wiO1xuaW1wb3J0IEl0ZW1BbGlnbmVyIGZyb20gXCIuL0l0ZW1BbGlnbmVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lTGF5b3V0IHtcblxuICAgIGNvbnN0cnVjdG9yKGxheW91dCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIGF2YWlsYWJsZVNwYWNlKSB7XG4gICAgICAgIHRoaXMuX2xheW91dCA9IGxheW91dDtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGxheW91dC5pdGVtcztcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICB0aGlzLl9hdmFpbGFibGVTcGFjZSA9IGF2YWlsYWJsZVNwYWNlO1xuICAgIH1cblxuICAgIHBlcmZvcm1MYXlvdXQoKSB7XG4gICAgICAgIHRoaXMuX3NldEl0ZW1TaXplcygpO1xuICAgICAgICB0aGlzLnNldEl0ZW1Qb3NpdGlvbnMoKTtcbiAgICAgICAgdGhpcy5fY2FsY0xheW91dEluZm8oKTtcbiAgICB9XG5cbiAgICBfc2V0SXRlbVNpemVzKCkge1xuICAgICAgICBpZiAodGhpcy5fYXZhaWxhYmxlU3BhY2UgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9ncm93SXRlbVNpemVzKHRoaXMuX2F2YWlsYWJsZVNwYWNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9hdmFpbGFibGVTcGFjZSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Nocmlua0l0ZW1TaXplcygtdGhpcy5fYXZhaWxhYmxlU3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dyb3dJdGVtU2l6ZXMoYW1vdW50KSB7XG4gICAgICAgIGNvbnN0IGdyb3dlciA9IG5ldyBTaXplR3Jvd2VyKHRoaXMpO1xuICAgICAgICBncm93ZXIuZ3JvdyhhbW91bnQpO1xuICAgICAgICB0aGlzLl9hdmFpbGFibGVTcGFjZSAtPSBncm93ZXIuZ2V0R3Jvd25TaXplKCk7XG4gICAgfVxuXG4gICAgX3Nocmlua0l0ZW1TaXplcyhhbW91bnQpIHtcbiAgICAgICAgY29uc3Qgc2hyaW5rZXIgPSBuZXcgU2l6ZVNocmlua2VyKHRoaXMpO1xuICAgICAgICBzaHJpbmtlci5zaHJpbmsoYW1vdW50KTtcbiAgICAgICAgdGhpcy5fYXZhaWxhYmxlU3BhY2UgKz0gc2hyaW5rZXIuZ2V0U2hydW5rU2l6ZSgpO1xuICAgIH1cblxuICAgIHNldEl0ZW1Qb3NpdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uZXIgPSBuZXcgSXRlbVBvc2l0aW9uZXIodGhpcyk7XG4gICAgICAgIHBvc2l0aW9uZXIucG9zaXRpb24oKTtcbiAgICB9XG5cbiAgICBjcmVhdGVJdGVtQWxpZ25lcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVtQWxpZ25lcih0aGlzKTtcbiAgICB9XG5cbiAgICBfY2FsY0xheW91dEluZm8oKSB7XG4gICAgICAgIHRoaXMuX2NhbGNDcm9zc0F4aXNNYXhMYXlvdXRTaXplKCk7XG4gICAgfVxuXG4gICAgZ2V0TWFpbkF4aXNNaW5TaXplKCkge1xuICAgICAgICBsZXQgbWFpbkF4aXNNaW5TaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhcnRJbmRleDsgaSA8PSB0aGlzLmVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuICAgICAgICAgICAgbWFpbkF4aXNNaW5TaXplICs9IGl0ZW0uZmxleEl0ZW0uX2dldE1haW5BeGlzTWluU2l6ZVdpdGhQYWRkaW5nQW5kTWFyZ2luKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1haW5BeGlzTWluU2l6ZTtcbiAgICB9XG4gICAgXG4gICAgZ2V0IG51bWJlck9mSXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZEluZGV4IC0gdGhpcy5zdGFydEluZGV4ICsgMTtcbiAgICB9XG5cbiAgICBnZXQgY3Jvc3NBeGlzTGF5b3V0U2l6ZSgpIHtcbiAgICAgICAgY29uc3Qgbm9TcGVjaWZpZWRDcm9zc0F4aXNTaXplID0gKHRoaXMuX2xheW91dC5pc0Nyb3NzQXhpc0ZpdFRvQ29udGVudHMoKSAmJiAhdGhpcy5fbGF5b3V0LnJlc2l6aW5nQ3Jvc3NBeGlzKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkRml0VG9Db250ZW50cyA9ICh0aGlzLl9sYXlvdXQuaXNXcmFwcGluZygpIHx8IG5vU3BlY2lmaWVkQ3Jvc3NBeGlzU2l6ZSk7XG4gICAgICAgIGlmIChzaG91bGRGaXRUb0NvbnRlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3Jvc3NBeGlzTWF4TGF5b3V0U2l6ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQuY3Jvc3NBeGlzU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jYWxjQ3Jvc3NBeGlzTWF4TGF5b3V0U2l6ZSgpIHtcbiAgICAgICAgdGhpcy5fY3Jvc3NBeGlzTWF4TGF5b3V0U2l6ZSA9IHRoaXMuX2dldENyb3NzQXhpc01heExheW91dFNpemUoKTtcbiAgICB9XG5cbiAgICBfZ2V0Q3Jvc3NBeGlzTWF4TGF5b3V0U2l6ZSgpIHtcbiAgICAgICAgbGV0IGNyb3NzQXhpc01heFNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGFydEluZGV4OyBpIDw9IHRoaXMuZW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXNbaV07XG4gICAgICAgICAgICBjcm9zc0F4aXNNYXhTaXplID0gTWF0aC5tYXgoY3Jvc3NBeGlzTWF4U2l6ZSwgaXRlbS5mbGV4SXRlbS5fZ2V0Q3Jvc3NBeGlzTGF5b3V0U2l6ZVdpdGhQYWRkaW5nQW5kTWFyZ2luKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcm9zc0F4aXNNYXhTaXplO1xuICAgIH1cblxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaXplR3Jvd2VyIHtcblxuICAgIGNvbnN0cnVjdG9yKGxpbmUpIHtcbiAgICAgICAgdGhpcy5fbGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuX2Ftb3VudFJlbWFpbmluZyA9IDA7XG4gICAgICAgIHRoaXMuX2dyb3duU2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgZ3JvdyhhbW91bnQpIHtcbiAgICAgICAgdGhpcy5fZ3Jvd25TaXplID0gMDtcblxuICAgICAgICB0aGlzLl9hbW91bnRSZW1haW5pbmcgPSBhbW91bnQ7XG4gICAgICAgIGxldCB0b3RhbEdyb3dBbW91bnQgPSB0aGlzLl9nZXRUb3RhbEdyb3dBbW91bnQoKTtcbiAgICAgICAgaWYgKHRvdGFsR3Jvd0Ftb3VudCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9saW5lLml0ZW1zO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxldCBhbW91bnRQZXJHcm93ID0gdGhpcy5fYW1vdW50UmVtYWluaW5nIC8gdG90YWxHcm93QW1vdW50O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9saW5lLnN0YXJ0SW5kZXg7IGkgPD0gdGhpcy5fbGluZS5lbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxleEl0ZW0gPSBpdGVtLmZsZXhJdGVtO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBncm93QW1vdW50ID0gZmxleEl0ZW0uZ3JvdztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNHcm93YWJsZUl0ZW0gPSAoZ3Jvd0Ftb3VudCA+IDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNHcm93YWJsZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBncm93ID0gZ3Jvd0Ftb3VudCAqIGFtb3VudFBlckdyb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhTaXplID0gZmxleEl0ZW0uX2dldE1haW5BeGlzTWF4U2l6ZVNldHRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBmbGV4SXRlbS5fZ2V0TWFpbkF4aXNMYXlvdXRTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4U2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+PSBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgZnVsbHkgZ3Jvd24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3cgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heEdyb3cgPSBtYXhTaXplIC0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNGdWxseUdyb3duID0gKGdyb3cgPj0gbWF4R3Jvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bGx5R3Jvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3cgPSBtYXhHcm93O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXN0cmlidXRlIHJlbWFpbmluZyBhbW91bnQgb3ZlciB0aGUgb3RoZXIgZmxleCBpdGVtcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsR3Jvd0Ftb3VudCAtPSBncm93QW1vdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5hbFNpemUgPSBzaXplICsgZ3JvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGV4SXRlbS5fcmVzaXplTWFpbkF4aXMoZmluYWxTaXplKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyb3duU2l6ZSArPSBncm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Ftb3VudFJlbWFpbmluZyAtPSBncm93O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX2Ftb3VudFJlbWFpbmluZykgPCAxMGUtNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSh0b3RhbEdyb3dBbW91bnQgJiYgKE1hdGguYWJzKHRoaXMuX2Ftb3VudFJlbWFpbmluZykgPiAxMGUtNikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFRvdGFsR3Jvd0Ftb3VudCgpIHtcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9saW5lLml0ZW1zO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fbGluZS5zdGFydEluZGV4OyBpIDw9IHRoaXMuX2xpbmUuZW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgY29uc3QgZmxleEl0ZW0gPSBpdGVtLmZsZXhJdGVtO1xuXG4gICAgICAgICAgICBpZiAoZmxleEl0ZW0uZ3Jvdykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFNpemUgPSBmbGV4SXRlbS5fZ2V0TWFpbkF4aXNNYXhTaXplU2V0dGluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBmbGV4SXRlbS5fZ2V0TWFpbkF4aXNMYXlvdXRTaXplKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIHRob3NlIGFscmVhZHkgZnVsbHkgZ3Jvd24uXG4gICAgICAgICAgICAgICAgaWYgKG1heFNpemUgPT09IDAgfHwgc2l6ZSA8IG1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gZmxleEl0ZW0uZ3JvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cblxuICAgIGdldEdyb3duU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3duU2l6ZTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpemVTaHJpbmtlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihsaW5lKSB7XG4gICAgICAgIHRoaXMuX2xpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLl9hbW91bnRSZW1haW5pbmcgPSAwO1xuICAgICAgICB0aGlzLl9zaHJ1bmtTaXplID0gMDtcbiAgICB9XG5cbiAgICBzaHJpbmsoYW1vdW50KSB7XG4gICAgICAgIHRoaXMuX3NocnVua1NpemUgPSAwO1xuXG4gICAgICAgIHRoaXMuX2Ftb3VudFJlbWFpbmluZyA9IGFtb3VudDtcbiAgICAgICAgbGV0IHRvdGFsU2hyaW5rQW1vdW50ID0gdGhpcy5fZ2V0VG90YWxTaHJpbmtBbW91bnQoKTtcbiAgICAgICAgaWYgKHRvdGFsU2hyaW5rQW1vdW50KSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xpbmUuaXRlbXM7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IGFtb3VudFBlclNocmluayA9IHRoaXMuX2Ftb3VudFJlbWFpbmluZyAvIHRvdGFsU2hyaW5rQW1vdW50O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9saW5lLnN0YXJ0SW5kZXg7IGkgPD0gdGhpcy5fbGluZS5lbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxleEl0ZW0gPSBpdGVtLmZsZXhJdGVtO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaHJpbmtBbW91bnQgPSBmbGV4SXRlbS5zaHJpbms7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzU2hyaW5rYWJsZUl0ZW0gPSAoc2hyaW5rQW1vdW50ID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Nocmlua2FibGVJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2hyaW5rID0gc2hyaW5rQW1vdW50ICogYW1vdW50UGVyU2hyaW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluU2l6ZSA9IGZsZXhJdGVtLl9nZXRNYWluQXhpc01pblNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBmbGV4SXRlbS5fZ2V0TWFpbkF4aXNMYXlvdXRTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IG1pblNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhTaHJpbmsgPSBzaXplIC0gbWluU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0Z1bGx5U2hydW5rID0gKHNocmluayA+PSBtYXhTaHJpbmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bGx5U2hydW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNocmluayA9IG1heFNocmluaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXN0cmlidXRlIHJlbWFpbmluZyBhbW91bnQgb3ZlciB0aGUgb3RoZXIgZmxleCBpdGVtcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxTaHJpbmtBbW91bnQgLT0gc2hyaW5rQW1vdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsU2l6ZSA9IHNpemUgLSBzaHJpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxleEl0ZW0uX3Jlc2l6ZU1haW5BeGlzKGZpbmFsU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaHJ1bmtTaXplICs9IHNocmluaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbW91bnRSZW1haW5pbmcgLT0gc2hyaW5rO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX2Ftb3VudFJlbWFpbmluZykgPCAxMGUtNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSh0b3RhbFNocmlua0Ftb3VudCAmJiAoTWF0aC5hYnModGhpcy5fYW1vdW50UmVtYWluaW5nKSA+IDEwZS02KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0VG90YWxTaHJpbmtBbW91bnQoKSB7XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGluZS5pdGVtcztcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2xpbmUuc3RhcnRJbmRleDsgaSA8PSB0aGlzLl9saW5lLmVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGZsZXhJdGVtID0gaXRlbS5mbGV4SXRlbTtcblxuICAgICAgICAgICAgaWYgKGZsZXhJdGVtLnNocmluaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pblNpemUgPSBmbGV4SXRlbS5fZ2V0TWFpbkF4aXNNaW5TaXplKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGZsZXhJdGVtLl9nZXRNYWluQXhpc0xheW91dFNpemUoKTtcblxuICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgdGhvc2UgYWxyZWFkeSBmdWxseSBzaHJ1bmsuXG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPiBtaW5TaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IGZsZXhJdGVtLnNocmluaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cblxuICAgIGdldFNocnVua1NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaHJ1bmtTaXplO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IEFwcGxpY2F0aW9uIGZyb20gXCIuL2FwcGxpY2F0aW9uL0FwcGxpY2F0aW9uLm1qc1wiO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9hcHBsaWNhdGlvbi9Db21wb25lbnQubWpzXCI7XG5pbXBvcnQgQmFzZSBmcm9tIFwiLi90cmVlL0Jhc2UubWpzXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4vdHJlZS9VdGlscy5tanNcIjtcbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcbmltcG9ydCBFbGVtZW50IGZyb20gXCIuL3RyZWUvRWxlbWVudC5tanNcIjtcbmltcG9ydCBFbGVtZW50Q29yZSBmcm9tIFwiLi90cmVlL2NvcmUvRWxlbWVudENvcmUubWpzXCI7XG5pbXBvcnQgRWxlbWVudFRleHR1cml6ZXIgZnJvbSBcIi4vdHJlZS9jb3JlL0VsZW1lbnRUZXh0dXJpemVyLm1qc1wiO1xuaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4vdHJlZS9UZXh0dXJlLm1qc1wiO1xuXG5pbXBvcnQgVG9vbHMgZnJvbSBcIi4vdG9vbHMvVG9vbHMubWpzXCI7XG5pbXBvcnQgT2JqTWVyZ2VyIGZyb20gXCIuL3Rvb2xzL09iak1lcmdlci5tanNcIjtcbmltcG9ydCBPYmplY3RMaXN0UHJveHkgZnJvbSBcIi4vdG9vbHMvT2JqZWN0TGlzdFByb3h5Lm1qc1wiO1xuaW1wb3J0IE9iamVjdExpc3RXcmFwcGVyIGZyb20gXCIuL3Rvb2xzL09iamVjdExpc3RXcmFwcGVyLm1qc1wiO1xuXG5pbXBvcnQgUmVjdGFuZ2xlVGV4dHVyZSBmcm9tIFwiLi90ZXh0dXJlcy9SZWN0YW5nbGVUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IE5vaXNlVGV4dHVyZSBmcm9tIFwiLi90ZXh0dXJlcy9Ob2lzZVRleHR1cmUubWpzXCI7XG5pbXBvcnQgVGV4dFRleHR1cmUgZnJvbSBcIi4vdGV4dHVyZXMvVGV4dFRleHR1cmUubWpzXCI7XG5pbXBvcnQgSW1hZ2VUZXh0dXJlIGZyb20gXCIuL3RleHR1cmVzL0ltYWdlVGV4dHVyZS5tanNcIjtcbmltcG9ydCBIdG1sVGV4dHVyZSBmcm9tIFwiLi90ZXh0dXJlcy9IdG1sVGV4dHVyZS5tanNcIjtcbmltcG9ydCBTdGF0aWNUZXh0dXJlIGZyb20gXCIuL3RleHR1cmVzL1N0YXRpY1RleHR1cmUubWpzXCI7XG5pbXBvcnQgU3RhdGljQ2FudmFzVGV4dHVyZSBmcm9tIFwiLi90ZXh0dXJlcy9TdGF0aWNDYW52YXNUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IFNvdXJjZVRleHR1cmUgZnJvbSBcIi4vdGV4dHVyZXMvU291cmNlVGV4dHVyZS5tanNcIjtcblxuaW1wb3J0IExpc3RDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50cy9MaXN0Q29tcG9uZW50Lm1qc1wiO1xuaW1wb3J0IEZhc3RCbHVyQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudHMvRmFzdEJsdXJDb21wb25lbnQubWpzXCI7XG5pbXBvcnQgQmxvb21Db21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50cy9CbG9vbUNvbXBvbmVudC5tanNcIjtcbmltcG9ydCBTbW9vdGhTY2FsZUNvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRzL1Ntb290aFNjYWxlQ29tcG9uZW50Lm1qc1wiO1xuaW1wb3J0IEJvcmRlckNvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRzL0JvcmRlckNvbXBvbmVudC5tanNcIjtcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIi4vRXZlbnRFbWl0dGVyLm1qc1wiO1xuXG5pbXBvcnQgV2ViR0xTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvV2ViR0xTaGFkZXIubWpzXCI7XG5pbXBvcnQgV2ViR0xEZWZhdWx0U2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvRGVmYXVsdFNoYWRlci5tanNcIjtcbmltcG9ydCB7IFdlYkdMR3JheXNjYWxlU2hhZGVyIH0gZnJvbSBcIi4vcmVuZGVyZXIvY29tbW9uL3NoYWRlcnMvR3JheXNjYWxlU2hhZGVyLm1qc1wiO1xuaW1wb3J0IEJveEJsdXJTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9Cb3hCbHVyU2hhZGVyLm1qc1wiO1xuaW1wb3J0IERpdGhlcmluZ1NoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0RpdGhlcmluZ1NoYWRlci5tanNcIjtcbmltcG9ydCBDaXJjdWxhclB1c2hTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9DaXJjdWxhclB1c2hTaGFkZXIubWpzXCI7XG5pbXBvcnQgSW52ZXJzaW9uU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvSW52ZXJzaW9uU2hhZGVyLm1qc1wiO1xuaW1wb3J0IExpbmVhckJsdXJTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9MaW5lYXJCbHVyU2hhZGVyLm1qc1wiO1xuaW1wb3J0IE91dGxpbmVTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9PdXRsaW5lU2hhZGVyLm1qc1wiO1xuaW1wb3J0IFBpeGVsYXRlU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvUGl4ZWxhdGVTaGFkZXIubWpzXCI7XG5pbXBvcnQgUmFkaWFsRmlsdGVyU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvUmFkaWFsRmlsdGVyU2hhZGVyLm1qc1wiO1xuaW1wb3J0IFJvdW5kZWRSZWN0YW5nbGVTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9Sb3VuZGVkUmVjdGFuZ2xlU2hhZGVyLm1qc1wiO1xuaW1wb3J0IEZhZGVPdXRTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9GYWRlT3V0U2hhZGVyLm1qc1wiO1xuaW1wb3J0IFZpZ25ldHRlU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvVmlnbmV0dGVTaGFkZXIubWpzXCI7XG5pbXBvcnQgU3Bpbm5lclNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1NwaW5uZXJTaGFkZXIubWpzXCI7XG5pbXBvcnQgSG9sZVNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0hvbGVTaGFkZXIubWpzXCI7XG5pbXBvcnQgUmFkaWFsR3JhZGllbnRTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9SYWRpYWxHcmFkaWVudFNoYWRlci5tanNcIjtcbmltcG9ydCBMaWdodDNkU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvTGlnaHQzZFNoYWRlci5tanNcIjtcbmltcG9ydCBQZXJzcGVjdGl2ZVNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1BlcnNwZWN0aXZlU2hhZGVyLm1qc1wiO1xuaW1wb3J0IE1hZ25pZmllclNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL01hZ25pZmllclNoYWRlci5tanNcIjtcblxuaW1wb3J0IEMyZFNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci9jMmQvQzJkU2hhZGVyLm1qc1wiO1xuaW1wb3J0IEMyZERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvYzJkL3NoYWRlcnMvRGVmYXVsdFNoYWRlci5tanNcIjtcbmltcG9ydCB7IEMyZEdyYXlzY2FsZVNoYWRlciB9IGZyb20gXCIuL3JlbmRlcmVyL2NvbW1vbi9zaGFkZXJzL0dyYXlzY2FsZVNoYWRlci5tanNcIjtcbmltcG9ydCBDMmRCbHVyU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL2MyZC9zaGFkZXJzL0JsdXJTaGFkZXIubWpzXCI7XG5cbmltcG9ydCBTdGFnZSBmcm9tIFwiLi90cmVlL1N0YWdlLm1qc1wiO1xuaW1wb3J0IFNwaW5uZXJTaGFkZXIyIGZyb20gJy4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9TcGlubmVyU2hhZGVyMi5tanMnO1xuXG5jb25zdCBsaWdodG5pbmcgPSB7XG4gICAgQXBwbGljYXRpb24sXG4gICAgQ29tcG9uZW50LFxuICAgIEJhc2UsXG4gICAgVXRpbHMsXG4gICAgU3RhZ2VVdGlscyxcbiAgICBFbGVtZW50LFxuICAgIFRvb2xzLFxuICAgIFN0YWdlLFxuICAgIEVsZW1lbnRDb3JlLFxuICAgIEVsZW1lbnRUZXh0dXJpemVyLFxuICAgIFRleHR1cmUsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIHNoYWRlcnM6IHtcbiAgICAgICAgR3JheXNjYWxlOiBXZWJHTEdyYXlzY2FsZVNoYWRlcixcbiAgICAgICAgQm94Qmx1cjogQm94Qmx1clNoYWRlcixcbiAgICAgICAgRGl0aGVyaW5nOiBEaXRoZXJpbmdTaGFkZXIsXG4gICAgICAgIENpcmN1bGFyUHVzaDogQ2lyY3VsYXJQdXNoU2hhZGVyLFxuICAgICAgICBJbnZlcnNpb246IEludmVyc2lvblNoYWRlcixcbiAgICAgICAgTGluZWFyQmx1cjogTGluZWFyQmx1clNoYWRlcixcbiAgICAgICAgT3V0bGluZTogT3V0bGluZVNoYWRlcixcbiAgICAgICAgUGl4ZWxhdGU6IFBpeGVsYXRlU2hhZGVyLFxuICAgICAgICBSYWRpYWxGaWx0ZXI6IFJhZGlhbEZpbHRlclNoYWRlcixcbiAgICAgICAgUm91bmRlZFJlY3RhbmdsZTogUm91bmRlZFJlY3RhbmdsZVNoYWRlcixcbiAgICAgICAgU3Bpbm5lcjI6IFNwaW5uZXJTaGFkZXIyLFxuICAgICAgICBGYWRlT3V0OiBGYWRlT3V0U2hhZGVyLFxuICAgICAgICBIb2xlOiBIb2xlU2hhZGVyLFxuICAgICAgICBWaWduZXR0ZTogVmlnbmV0dGVTaGFkZXIsXG4gICAgICAgIFNwaW5uZXI6IFNwaW5uZXJTaGFkZXIsXG4gICAgICAgIFJhZGlhbEdyYWRpZW50OiBSYWRpYWxHcmFkaWVudFNoYWRlcixcbiAgICAgICAgTGlnaHQzZDogTGlnaHQzZFNoYWRlcixcbiAgICAgICAgUGVyc3BlY3RpdmU6IFBlcnNwZWN0aXZlU2hhZGVyLFxuICAgICAgICBNYWduaWZpZXI6IE1hZ25pZmllclNoYWRlcixcbiAgICAgICAgV2ViR0xTaGFkZXIsXG4gICAgICAgIFdlYkdMRGVmYXVsdFNoYWRlcixcbiAgICAgICAgQzJkU2hhZGVyLFxuICAgICAgICBDMmREZWZhdWx0U2hhZGVyLFxuICAgICAgICBjMmQ6IHtcbiAgICAgICAgICAgIEdyYXlzY2FsZTogQzJkR3JheXNjYWxlU2hhZGVyLFxuICAgICAgICAgICAgQmx1cjogQzJkQmx1clNoYWRlclxuICAgICAgICB9XG4gICAgfSxcbiAgICB0ZXh0dXJlczoge1xuICAgICAgICBSZWN0YW5nbGVUZXh0dXJlLFxuICAgICAgICBOb2lzZVRleHR1cmUsXG4gICAgICAgIFRleHRUZXh0dXJlLFxuICAgICAgICBJbWFnZVRleHR1cmUsXG4gICAgICAgIEh0bWxUZXh0dXJlLFxuICAgICAgICBTdGF0aWNUZXh0dXJlLFxuICAgICAgICBTdGF0aWNDYW52YXNUZXh0dXJlLFxuICAgICAgICBTb3VyY2VUZXh0dXJlXG4gICAgfSxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEZhc3RCbHVyQ29tcG9uZW50LFxuICAgICAgICBCbG9vbUNvbXBvbmVudCxcbiAgICAgICAgU21vb3RoU2NhbGVDb21wb25lbnQsXG4gICAgICAgIEJvcmRlckNvbXBvbmVudCxcbiAgICAgICAgTGlzdENvbXBvbmVudFxuICAgIH0sXG4gICAgdG9vbHM6IHtcbiAgICAgICAgT2JqTWVyZ2VyLFxuICAgICAgICBPYmplY3RMaXN0UHJveHksXG4gICAgICAgIE9iamVjdExpc3RXcmFwcGVyXG4gICAgfVxufTtcblxuaWYgKFV0aWxzLmlzV2ViKSB7XG4gICAgd2luZG93LmxuZyA9IGxpZ2h0bmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlnaHRuaW5nO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFdlYlBsYXRmb3JtIGZyb20gXCIuL2Jyb3dzZXIvV2ViUGxhdGZvcm0ubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBsYXRmb3JtTG9hZGVyIHtcbiAgICBzdGF0aWMgbG9hZChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnBsYXRmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5wbGF0Zm9ybTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBXZWJQbGF0Zm9ybTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEltYWdlV29ya2VyIHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLl9pdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faWQgPSAwO1xuXG4gICAgICAgIHRoaXMuX2luaXRXb3JrZXIoKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5fd29ya2VyKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfaW5pdFdvcmtlcigpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGAoJHtjcmVhdGVXb3JrZXIudG9TdHJpbmcoKX0pKClgO1xuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2NvZGUucmVwbGFjZSgnXCJ1c2Ugc3RyaWN0XCI7JywgJycpXSk7IC8vIGZpcmVmb3ggYWRkcyBcInVzZSBzdHJpY3RcIjsgdG8gYW55IGZ1bmN0aW9uIHdoaWNoIG1pZ2h0IGJsb2NrIHdvcmtlciBleGVjdXRpb24gc28ga25vY2sgaXQgb2ZmXG4gICAgICAgIGNvbnN0IGJsb2JVUkwgPSAod2luZG93LlVSTCA/IFVSTCA6IHdlYmtpdFVSTCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IsIHtcbiAgICAgICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0OyBjaGFyc2V0PXV0Zi04J1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gbmV3IFdvcmtlcihibG9iVVJMKTtcblxuICAgICAgICB0aGlzLl93b3JrZXIucG9zdE1lc3NhZ2Uoe3R5cGU6ICdjb25maWcnLCBjb25maWc6IHtwYXRoOiB3aW5kb3cubG9jYXRpb24uaHJlZiwgcHJvdG9jb2w6IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbH19KTtcblxuICAgICAgICB0aGlzLl93b3JrZXIub25tZXNzYWdlID0gKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLmRhdGEgJiYgZS5kYXRhLmlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBlLmRhdGEuaWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zLmdldChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2goaXRlbSwgZS5kYXRhLmluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihpdGVtLCBlLmRhdGEuaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGlkID0gKyt0aGlzLl9pZDtcbiAgICAgICAgY29uc3QgaXRlbSA9IG5ldyBJbWFnZVdvcmtlckltYWdlKHRoaXMsIGlkLCBzcmMpO1xuICAgICAgICB0aGlzLl9pdGVtcy5zZXQoaWQsIGl0ZW0pO1xuICAgICAgICB0aGlzLl93b3JrZXIucG9zdE1lc3NhZ2Uoe3R5cGU6IFwiYWRkXCIsIGlkOiBpZCwgc3JjOiBzcmN9KTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgY2FuY2VsKGltYWdlKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTogXCJjYW5jZWxcIiwgaWQ6IGltYWdlLmlkfSk7XG4gICAgICAgIHRoaXMuX2l0ZW1zLmRlbGV0ZShpbWFnZS5pZCk7XG4gICAgfVxuXG4gICAgZXJyb3IoaW1hZ2UsIGluZm8pIHtcbiAgICAgICAgaW1hZ2UuZXJyb3IoaW5mbyk7XG4gICAgICAgIHRoaXMuX2l0ZW1zLmRlbGV0ZShpbWFnZS5pZCk7XG4gICAgfVxuXG4gICAgZmluaXNoKGltYWdlLCBpbmZvKSB7XG4gICAgICAgIGltYWdlLmxvYWQoaW5mbyk7XG4gICAgICAgIHRoaXMuX2l0ZW1zLmRlbGV0ZShpbWFnZS5pZCk7XG4gICAgfVxuXG59XG5cbmNsYXNzIEltYWdlV29ya2VySW1hZ2Uge1xuXG4gICAgY29uc3RydWN0b3IobWFuYWdlciwgaWQsIHNyYykge1xuICAgICAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgdGhpcy5fc3JjID0gc3JjO1xuICAgICAgICB0aGlzLl9vbkVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb25Mb2FkID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG5cbiAgICBnZXQgc3JjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3JjO1xuICAgIH1cblxuICAgIHNldCBvbkVycm9yKGYpIHtcbiAgICAgICAgdGhpcy5fb25FcnJvciA9IGY7XG4gICAgfVxuXG4gICAgc2V0IG9uTG9hZChmKSB7XG4gICAgICAgIHRoaXMuX29uTG9hZCA9IGY7XG4gICAgfVxuXG4gICAgY2FuY2VsKCkge1xuICAgICAgICB0aGlzLl9tYW5hZ2VyLmNhbmNlbCh0aGlzKTtcbiAgICB9XG5cbiAgICBsb2FkKGluZm8pIHtcbiAgICAgICAgaWYgKHRoaXMuX29uTG9hZCkge1xuICAgICAgICAgICAgdGhpcy5fb25Mb2FkKGluZm8pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXJyb3IoaW5mbykge1xuICAgICAgICBpZiAodGhpcy5fb25FcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvcihpbmZvKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG4vKipcbiAqIE5vdGljZSB0aGF0LCB3aXRoaW4gdGhlIGNyZWF0ZVdvcmtlciBmdW5jdGlvbiwgd2UgbXVzdCBvbmx5IHVzZSBFUzUgY29kZSB0byBrZWVwIGl0IEVTNS12YWxpZCBhZnRlciBiYWJlbGlmeWluZywgYXNcbiAqICB0aGUgY29udmVydGVkIGNvZGUgb2YgdGhpcyBzZWN0aW9uIGlzIGNvbnZlcnRlZCB0byBhIGJsb2IgYW5kIHVzZWQgYXMgdGhlIGpzIG9mIHRoZSB3ZWIgd29ya2VyIHRocmVhZC5cbiAqL1xuY29uc3QgY3JlYXRlV29ya2VyID0gZnVuY3Rpb24oKSB7XG5cbiAgICBmdW5jdGlvbiBJbWFnZVdvcmtlclNlcnZlcigpIHtcblxuICAgICAgICB0aGlzLml0ZW1zID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgb25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdC5fcmVjZWl2ZU1lc3NhZ2UoZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIEltYWdlV29ya2VyU2VydmVyLmlzUGF0aEFic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gL14oPzpcXC98W2Etel0rOlxcL1xcLykvLnRlc3QocGF0aCkgfHwgcGF0aC5zdWJzdHIoMCwgNSkgPT0gJ2RhdGE6JztcbiAgICB9O1xuXG4gICAgSW1hZ2VXb3JrZXJTZXJ2ZXIucHJvdG90eXBlLl9yZWNlaXZlTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnY29uZmlnJykge1xuICAgICAgICAgICAgdGhpcy5jb25maWcgPSBlLmRhdGEuY29uZmlnO1xuXG4gICAgICAgICAgICB2YXIgYmFzZSA9IHRoaXMuY29uZmlnLnBhdGg7XG4gICAgICAgICAgICAvLyB0aGUgY29uc3RydWN0aW5nIG9mIHRoZSBiYXNlcGF0aCBmYWlsc1xuICAgICAgICAgICAgLy8gaWYgbG9jYXRpb24uaGFzaCBjb250YWlucyBhIHNsYXNoXG4gICAgICAgICAgICB2YXIgaGFzSGFzaFBhdGggPSAvIy4qP1xcLy87XG4gICAgICAgICAgICBpZihoYXNIYXNoUGF0aC50ZXN0KGJhc2UpKXtcbiAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKC8jLiokLywnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGJhc2Uuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9yZWxhdGl2ZUJhc2UgPSBwYXJ0cy5qb2luKFwiL1wiKSArIFwiL1wiO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLnR5cGUgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChlLmRhdGEuaWQsIGUuZGF0YS5zcmMpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS50eXBlID09PSAnY2FuY2VsJykge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwoZS5kYXRhLmlkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbWFnZVdvcmtlclNlcnZlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaWQsIHNyYykge1xuICAgICAgICAvLyBDb252ZXJ0IHJlbGF0aXZlIFVSTHMuXG4gICAgICAgIGlmICghSW1hZ2VXb3JrZXJTZXJ2ZXIuaXNQYXRoQWJzb2x1dGUoc3JjKSkge1xuICAgICAgICAgICAgc3JjID0gdGhpcy5fcmVsYXRpdmVCYXNlICsgc3JjO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNyYy5zdWJzdHIoMCwyKSA9PT0gXCIvL1wiKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGRvZXNuJ3Qgd29yayBmb3IgaW1hZ2Ugd29ya2Vycy5cbiAgICAgICAgICAgIHNyYyA9IHRoaXMuY29uZmlnLnByb3RvY29sICsgc3JjO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW0gPSBuZXcgSW1hZ2VXb3JrZXJTZXJ2ZXJJdGVtKGlkLCBzcmMpO1xuICAgICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICAgIGl0ZW0ub25GaW5pc2ggPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIHQuZmluaXNoKGl0ZW0sIHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIGl0ZW0ub25FcnJvciA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgICAgIHQuZXJyb3IoaXRlbSwgaW5mbyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXRlbXMuc2V0KGlkLCBpdGVtKTtcbiAgICAgICAgaXRlbS5zdGFydCgpO1xuICAgIH07XG5cbiAgICBJbWFnZVdvcmtlclNlcnZlci5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zLmdldChpZCk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgSW1hZ2VXb3JrZXJTZXJ2ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKGl0ZW0sIHtpbWFnZUJpdG1hcCwgaGFzQWxwaGFDaGFubmVsfSkge1xuICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBcImRhdGFcIixcbiAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgIGltYWdlQml0bWFwLFxuICAgICAgICAgICAgICAgIGhhc0FscGhhQ2hhbm5lbFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbaW1hZ2VCaXRtYXBdKTtcbiAgICAgICAgdGhpcy5pdGVtcy5kZWxldGUoaXRlbS5pZCk7XG4gICAgfTtcblxuICAgIEltYWdlV29ya2VyU2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKGl0ZW0sIHt0eXBlLCBtZXNzYWdlfSkge1xuICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaXRlbXMuZGVsZXRlKGl0ZW0uaWQpO1xuICAgIH07XG5cbiAgICBJbWFnZVdvcmtlclNlcnZlci5pc1dQRUJyb3dzZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJXUEVcIikgIT09IC0xKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSW1hZ2VXb3JrZXJTZXJ2ZXJJdGVtKGlkLCBzcmMpIHtcblxuICAgICAgICB0aGlzLl9vbkVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9vbkZpbmlzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgdGhpcy5fc3JjID0gc3JjO1xuICAgICAgICB0aGlzLl94aHIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX21pbWVUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEltYWdlV29ya2VyU2VydmVySXRlbS5wcm90b3R5cGUsICdpZCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEltYWdlV29ya2VyU2VydmVySXRlbS5wcm90b3R5cGUsICdvbkZpbmlzaCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbkZpbmlzaDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCA9IGY7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbWFnZVdvcmtlclNlcnZlckl0ZW0ucHJvdG90eXBlLCAnb25FcnJvcicsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbkVycm9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IgPSBmO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBJbWFnZVdvcmtlclNlcnZlckl0ZW0ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3hociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB0aGlzLl94aHIub3BlbihcIkdFVFwiLCB0aGlzLl9zcmMsIHRydWUpO1xuICAgICAgICB0aGlzLl94aHIucmVzcG9uc2VUeXBlID0gXCJibG9iXCI7XG5cbiAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICB0aGlzLl94aHIub25lcnJvciA9IGZ1bmN0aW9uKG9FdmVudCkge1xuICAgICAgICAgICAgdC5lcnJvcih7dHlwZTogXCJjb25uZWN0aW9uXCIsIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiBlcnJvclwifSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5feGhyLm9ubG9hZCA9IGZ1bmN0aW9uKG9FdmVudCkge1xuICAgICAgICAgICAgdmFyIGJsb2IgPSB0Ll94aHIucmVzcG9uc2U7XG4gICAgICAgICAgICB0Ll9taW1lVHlwZSA9IGJsb2IudHlwZTtcblxuICAgICAgICAgICAgdC5fY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5feGhyLnNlbmQoKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VXb3JrZXJTZXJ2ZXJJdGVtLnByb3RvdHlwZS5fY3JlYXRlSW1hZ2VCaXRtYXAgPSBmdW5jdGlvbihibG9iKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYiwge3ByZW11bHRpcGx5QWxwaGE6ICdwcmVtdWx0aXBseScsIGNvbG9yU3BhY2VDb252ZXJzaW9uOiAnbm9uZScsIGltYWdlT3JpZW50YXRpb246ICdub25lJ30pLnRoZW4oZnVuY3Rpb24oaW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICAgIHQuZmluaXNoKHtcbiAgICAgICAgICAgICAgICBpbWFnZUJpdG1hcCxcbiAgICAgICAgICAgICAgICBoYXNBbHBoYUNoYW5uZWw6IHQuX2hhc0FscGhhQ2hhbm5lbCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdC5lcnJvcih7dHlwZTogXCJwYXJzZVwiLCBtZXNzYWdlOiBcIkVycm9yIHBhcnNpbmcgaW1hZ2UgZGF0YVwifSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBJbWFnZVdvcmtlclNlcnZlckl0ZW0ucHJvdG90eXBlLl9oYXNBbHBoYUNoYW5uZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKEltYWdlV29ya2VyU2VydmVyLmlzV1BFQnJvd3NlcigpKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHVzaW5nIHVuYWNjZWxlcmF0ZWQgcmVuZGVyaW5nIGltYWdlIChodHRwczovL2dpdGh1Yi5jb20vV2ViUGxhdGZvcm1Gb3JFbWJlZGRlZC9XUEVXZWJLaXQvYmxvYi93cGUtMjAxNzA3MjgvU291cmNlL1dlYkNvcmUvaHRtbC9JbWFnZUJpdG1hcC5jcHAjTDUyKSxcbiAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgaW5jbHVkaW5nIEpQRyBpbWFnZXMgYXJlIGluIFJHQkEgZm9ybWF0LiBVcGxvYWQgaXMgd2F5IGZhc3RlciB3aGVuIHVzaW5nIGFuIGFscGhhIGNoYW5uZWwuXG4gICAgICAgICAgICAvLyBAdG9kbzogYWZ0ZXIgaGFyZHdhcmUgYWNjZWxlcmF0aW9uIGlzIGZpeGVkIGFuZCByZS1lbmFibGVkLCBKUEcgc2hvdWxkIGJlIHVwbG9hZGVkIGluIFJHQiB0byBnZXQgdGhlIGJlc3QgcG9zc2libGUgcGVyZm9ybWFuY2UgYW5kIG1lbW9yeSB1c2FnZS5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9taW1lVHlwZS5pbmRleE9mKFwiaW1hZ2UvcG5nXCIpICE9PSAtMSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW1hZ2VXb3JrZXJTZXJ2ZXJJdGVtLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbmNlbGVkKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl94aHIpIHtcbiAgICAgICAgICAgIHRoaXMuX3hoci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbmNlbGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgSW1hZ2VXb3JrZXJTZXJ2ZXJJdGVtLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYW5jZWxlZCAmJiB0aGlzLl9vbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKHt0eXBlLCBtZXNzYWdlfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW1hZ2VXb3JrZXJTZXJ2ZXJJdGVtLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FuY2VsZWQgJiYgdGhpcy5fb25GaW5pc2gpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKGluZm8pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB3b3JrZXIgPSBuZXcgSW1hZ2VXb3JrZXJTZXJ2ZXIoKTtcbn07XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uLy4uL3RyZWUvVXRpbHMubWpzXCI7XG5pbXBvcnQgSW1hZ2VXb3JrZXIgZnJvbSBcIi4vSW1hZ2VXb3JrZXIubWpzXCI7XG5cbi8qKlxuICogUGxhdGZvcm0tc3BlY2lmaWMgZnVuY3Rpb25hbGl0eS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViUGxhdGZvcm0ge1xuXG4gICAgaW5pdChzdGFnZSkge1xuICAgICAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG4gICAgICAgIHRoaXMuX2xvb3BpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYXdhaXRpbmdMb29wID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhZ2UuZ2V0T3B0aW9uKFwidXNlSW1hZ2VXb3JrZXJcIikpIHtcbiAgICAgICAgICAgIGlmICghd2luZG93LmNyZWF0ZUltYWdlQml0bWFwIHx8ICF3aW5kb3cuV29ya2VyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0xpZ2h0bmluZ10gQ2FuJ3QgdXNlIGltYWdlIHdvcmtlciBiZWNhdXNlIGJyb3dzZXIgZG9lcyBub3QgaGF2ZSBjcmVhdGVJbWFnZUJpdG1hcCBhbmQgV2ViIFdvcmtlciBzdXBwb3J0XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZVdvcmtlciA9IG5ldyBJbWFnZVdvcmtlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ltYWdlV29ya2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9pbWFnZVdvcmtlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3ZlS2V5SGFuZGxlcigpO1xuICAgICAgICB0aGlzLl9yZW1vdmVDbGlja0hhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlSG92ZXJIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNjcm9sbFdoZWVsSGFuZGxlcigpO1xuICAgIH1cblxuICAgIHN0YXJ0TG9vcCgpIHtcbiAgICAgICAgdGhpcy5fbG9vcGluZyA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5fYXdhaXRpbmdMb29wKSB7XG4gICAgICAgICAgICB0aGlzLmxvb3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3BMb29wKCkge1xuICAgICAgICB0aGlzLl9sb29waW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbG9vcCgpIHtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgbHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX2F3YWl0aW5nTG9vcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNlbGYuX2xvb3BpbmcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnN0YWdlLmRyYXdGcmFtZSgpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShscCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fYXdhaXRpbmdMb29wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobHApO1xuICAgIH1cblxuICAgIHVwbG9hZEdsVGV4dHVyZShnbCwgdGV4dHVyZVNvdXJjZSwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBJbWFnZURhdGEgfHwgc291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCBzb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50IHx8ICh3aW5kb3cuSW1hZ2VCaXRtYXAgJiYgc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApKSB7XG4gICAgICAgICAgICAvLyBXZWItc3BlY2lmaWMgZGF0YSB0eXBlcy5cbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCwgb3B0aW9ucy5mb3JtYXQsIG9wdGlvbnMudHlwZSwgc291cmNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3Igc29tZSBicm93c2VycyAoZS5nLiBUaXplbikgYXMgdGhleSBkbyBub3QgY29udmVydCBjYW52YXMgZGF0YSB0byB0ZXh0dXJlIGNvcnJlY3RseSwgc29tZXRpbWVzIGNhdXNpbmcgYXJ0aWZhY3RzLlxuICAgICAgICAgICAgY29uc3QgY3R4ID0gc291cmNlLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQsIHRleHR1cmVTb3VyY2UudywgdGV4dHVyZVNvdXJjZS5oLCAwLCBvcHRpb25zLmZvcm1hdCwgb3B0aW9ucy50eXBlLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZFNyY1RleHR1cmUoe3NyYywgaGFzQWxwaGF9LCBjYikge1xuICAgICAgICBsZXQgY2FuY2VsQ2IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBpc1BuZyA9IChzcmMuaW5kZXhPZihcIi5wbmdcIikgPj0gMCkgfHwgc3JjLnN1YnN0cigwLCAyMSkgPT0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCc7XG4gICAgICAgIGlmICh0aGlzLl9pbWFnZVdvcmtlcikge1xuICAgICAgICAgICAgLy8gV1BFLXNwZWNpZmljIGltYWdlIHBhcnNlci5cbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5faW1hZ2VXb3JrZXIuY3JlYXRlKHNyYyk7XG4gICAgICAgICAgICBpbWFnZS5vbkVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKFwiSW1hZ2UgbG9hZCBlcnJvclwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWFnZS5vbkxvYWQgPSBmdW5jdGlvbih7aW1hZ2VCaXRtYXAsIGhhc0FscGhhQ2hhbm5lbH0pIHtcbiAgICAgICAgICAgICAgICBjYihudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogaW1hZ2VCaXRtYXAsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckluZm86IHtzcmM6IHNyY30sXG4gICAgICAgICAgICAgICAgICAgIGhhc0FscGhhOiBoYXNBbHBoYUNoYW5uZWwsXG4gICAgICAgICAgICAgICAgICAgIHByZW11bHRpcGx5QWxwaGE6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYW5jZWxDYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGltYWdlLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGltYWdlID0gbmV3IEltYWdlKCk7XG5cbiAgICAgICAgICAgIC8vIE9uIHRoZSBQUzQgcGxhdGZvcm0gc2V0dGluZyB0aGUgYGNyb3NzT3JpZ2luYCBhdHRyaWJ1dGUgb25cbiAgICAgICAgICAgIC8vIGltYWdlcyBjYW4gY2F1c2UgQ09SUyBmYWlsdXJlcy5cbiAgICAgICAgICAgIGlmICghKHNyYy5zdWJzdHIoMCw1KSA9PSBcImRhdGE6XCIpICYmICFVdGlscy5pc1BTNCkge1xuICAgICAgICAgICAgICAgIC8vIEJhc2U2NC5cbiAgICAgICAgICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yIG1lc3NhZ2Ugd2hlbiBjYW5jZWxsZWQuXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLnNyYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoXCJJbWFnZSBsb2FkIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjYihudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckluZm86IHtzcmM6IHNyY30sXG4gICAgICAgICAgICAgICAgICAgIGhhc0FscGhhOiBpc1BuZyB8fCBoYXNBbHBoYVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltYWdlLnNyYyA9IHNyYztcblxuICAgICAgICAgICAgY2FuY2VsQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGltYWdlLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FuY2VsQ2I7XG4gICAgfVxuXG4gICAgY3JlYXRlV2ViR0xDb250ZXh0KHcsIGgpIHtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc3RhZ2UuZ2V0T3B0aW9uKCdjYW52YXMnKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgICAgICBpZiAodyAmJiBoKSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB3O1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGg7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3B0cyA9IHtcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcbiAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgb3B0cykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG9wdHMpO1xuICAgICAgICBpZiAoIWdsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHdlYkdMLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsO1xuICAgIH1cblxuICAgIGNyZWF0ZUNhbnZhc0NvbnRleHQodywgaCkge1xuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5zdGFnZS5nZXRPcHRpb24oJ2NhbnZhcycpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgICAgIGlmICh3ICYmIGgpIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHc7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjMmQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKCFjMmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgMmQgY2FudmFzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGMyZDtcbiAgICB9XG5cbiAgICBnZXRIclRpbWUoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2UgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIGdldERyYXdpbmdDYW52YXMoKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHJldXNlIHRoaXMgY2FudmFzIGJlY2F1c2UgdGV4dHVyZXMgbWF5IGxvYWQgYXN5bmMuXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9XG5cbiAgICBnZXRUZXh0dXJlT3B0aW9uc0ZvckRyYXdpbmdDYW52YXMoY2FudmFzKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0ge307XG4gICAgICAgIG9wdGlvbnMuc291cmNlID0gY2FudmFzO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBuZXh0RnJhbWUoY2hhbmdlcykge1xuICAgICAgICAvKiBXZWJHTCBibGl0cyBhdXRvbWF0aWNhbGx5ICovXG4gICAgfVxuXG4gICAgcmVnaXN0ZXJLZXlkb3duSGFuZGxlcihrZXloYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2tleWRvd25MaXN0ZW5lciA9IChlKSA9PiB7XG4gICAgICAgICAgICBrZXloYW5kbGVyKGUpO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleWRvd25MaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJLZXl1cEhhbmRsZXIoa2V5aGFuZGxlcikge1xuICAgICAgICB0aGlzLl9rZXl1cExpc3RlbmVyID0gKGUpID0+IHtcbiAgICAgICAgICAgIGtleWhhbmRsZXIoZSk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX2tleXVwTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIF9yZW1vdmVLZXlIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fa2V5ZG93bkxpc3RlbmVyKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleWRvd25MaXN0ZW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fa2V5dXBMaXN0ZW5lcikge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fa2V5dXBMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWdpc3RlckNsaWNrSGFuZGxlcihjbGlja0hhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fY2xpY2tMaXN0ZW5lciA9IGUgPT4ge1xuICAgICAgICAgICAgY2xpY2tIYW5kbGVyKGUpO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fY2xpY2tMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgX3JlbW92ZUNsaWNrSGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9jbGlja0xpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVySG92ZXJIYW5kbGVyKGhvdmVySGFuZGxlcikge1xuICAgICAgICB0aGlzLl9ob3Zlckxpc3RlbmVyID0gZSA9PiB7XG4gICAgICAgICAgICBob3ZlckhhbmRsZXIoZSk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9ob3Zlckxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlSG92ZXJIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5faG92ZXJMaXN0ZW5lcikge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hvdmVyTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJTY3JvbGxXaGVlbEhhbmRsZXIocmVnaXN0ZXJTY3JvbGxXaGVlbEhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsV2hlZWxMaXN0ZW5lciA9IGUgPT4ge1xuICAgICAgICAgICAgcmVnaXN0ZXJTY3JvbGxXaGVlbEhhbmRsZXIoZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fc2Nyb2xsV2hlZWxMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgX3JlbW92ZVNjcm9sbFdoZWVsSGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbFdoZWVsTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX3Njcm9sbFdoZWVsTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRTaGFkZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZ2MoYWdncmVzc2l2ZSkge1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgfVxuXG4gICAgZ2V0RGVmYXVsdFNoYWRlcihjdHggPSB0aGlzLnN0YWdlLmN0eCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RlZmF1bHRTaGFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRTaGFkZXIgPSB0aGlzLl9jcmVhdGVEZWZhdWx0U2hhZGVyKGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRTaGFkZXI7XG4gICAgfVxuXG4gICAgX2NyZWF0ZURlZmF1bHRTaGFkZXIoY3R4KSB7XG4gICAgfVxuXG4gICAgaXNWYWxpZFNoYWRlclR5cGUoc2hhZGVyVHlwZSkge1xuICAgICAgICByZXR1cm4gKHNoYWRlclR5cGUucHJvdG90eXBlIGluc3RhbmNlb2YgdGhpcy5fZ2V0U2hhZGVyQmFzZVR5cGUoKSk7XG4gICAgfVxuXG4gICAgY3JlYXRlU2hhZGVyKGN0eCwgc2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3Qgc2hhZGVyVHlwZSA9IHNldHRpbmdzLnR5cGU7XG4gICAgICAgIC8vIElmIHNoYWRlciB0eXBlIGlzIG5vdCBjb3JyZWN0LCB1c2UgYSBkaWZmZXJlbnQgcGxhdGZvcm0uXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkU2hhZGVyVHlwZShzaGFkZXJUeXBlKSkge1xuICAgICAgICAgICAgY29uc3QgY29udmVydGVkU2hhZGVyVHlwZSA9IHRoaXMuX2dldFNoYWRlckFsdGVybmF0aXZlKHNoYWRlclR5cGUpO1xuICAgICAgICAgICAgaWYgKCFjb252ZXJ0ZWRTaGFkZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0xpZ2h0bmluZ10gU2hhZGVyIGhhcyBubyBpbXBsZW1lbnRhdGlvbiBmb3IgcmVuZGVyIHRhcmdldDogXCIgKyBzaGFkZXJUeXBlLm5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVEZWZhdWx0U2hhZGVyKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvbnZlcnRlZFNoYWRlclR5cGUoY3R4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlciA9IG5ldyBzaGFkZXJUeXBlKGN0eCk7XG4gICAgICAgICAgICBCYXNlLnBhdGNoT2JqZWN0KHRoaXMsIHNldHRpbmdzKTtcbiAgICAgICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0U2hhZGVyQmFzZVR5cGUoKSB7XG4gICAgfVxuXG4gICAgX2dldFNoYWRlckFsdGVybmF0aXZlKHNoYWRlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFNoYWRlcigpO1xuICAgIH1cblxuICAgIGNvcHlSZW5kZXJUZXh0dXJlKHJlbmRlclRleHR1cmUsIG5hdGl2ZVRleHR1cmUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbTGlnaHRuaW5nXSBjb3B5UmVuZGVyVGV4dHVyZSBub3Qgc3VwcG9ydGVkIGJ5IHJlbmRlcmVyJyk7XG4gICAgfVxufVxuXG5pbXBvcnQgQmFzZSBmcm9tIFwiLi4vdHJlZS9CYXNlLm1qc1wiO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IENvcmVRdWFkTGlzdCBmcm9tIFwiLi4vLi4vdHJlZS9jb3JlL0NvcmVRdWFkTGlzdC5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQzJkQ29yZVF1YWRMaXN0IGV4dGVuZHMgQ29yZVF1YWRMaXN0IHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICBzdXBlcihjdHgpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyQ29udGV4dHMgPSBbXTtcbiAgICAgICAgdGhpcy5tb2RlcyA9IFtdO1xuICAgIH1cblxuICAgIHNldFJlbmRlckNvbnRleHQoaW5kZXgsIHYpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDb250ZXh0c1tpbmRleF0gPSB2O1xuICAgIH1cblxuICAgIHNldFNpbXBsZVRjKGluZGV4LCB2KSB7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVzW2luZGV4XSB8PSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2Rlc1tpbmRleF0gLT0gKHRoaXMubW9kZXNbaW5kZXhdICYgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRXaGl0ZShpbmRleCwgdikge1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgdGhpcy5tb2Rlc1tpbmRleF0gfD0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kZXNbaW5kZXhdIC09ICh0aGlzLm1vZGVzW2luZGV4XSAmIDIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UmVuZGVyQ29udGV4dChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDb250ZXh0c1tpbmRleF07XG4gICAgfVxuXG4gICAgZ2V0U2ltcGxlVGMoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZGVzW2luZGV4XSAmIDEpO1xuICAgIH1cblxuICAgIGdldFdoaXRlKGluZGV4KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5tb2Rlc1tpbmRleF0gJiAyKTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDb3JlUXVhZE9wZXJhdGlvbiBmcm9tIFwiLi4vLi4vdHJlZS9jb3JlL0NvcmVRdWFkT3BlcmF0aW9uLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDMmRDb3JlUXVhZE9wZXJhdGlvbiBleHRlbmRzIENvcmVRdWFkT3BlcmF0aW9uIHtcblxuICAgIGdldFJlbmRlckNvbnRleHQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZHMuZ2V0UmVuZGVyQ29udGV4dCh0aGlzLmluZGV4ICsgaW5kZXgpO1xuICAgIH1cblxuICAgIGdldFNpbXBsZVRjKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRzLmdldFNpbXBsZVRjKHRoaXMuaW5kZXggKyBpbmRleCk7XG4gICAgfVxuXG4gICAgZ2V0V2hpdGUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZHMuZ2V0V2hpdGUodGhpcy5pbmRleCArIGluZGV4KTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDb3JlUmVuZGVyRXhlY3V0b3IgZnJvbSBcIi4uLy4uL3RyZWUvY29yZS9Db3JlUmVuZGVyRXhlY3V0b3IubWpzXCI7XG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi4vLi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi8uLi90cmVlL1V0aWxzLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDMmRDb3JlUmVuZGVyRXhlY3V0b3IgZXh0ZW5kcyBDb3JlUmVuZGVyRXhlY3V0b3Ige1xuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5fbWFpblJlbmRlclRleHR1cmUgPSB0aGlzLmN0eC5zdGFnZS5nZXRDYW52YXMoKTtcbiAgICB9XG5cbiAgICBfcmVuZGVyUXVhZE9wZXJhdGlvbihvcCkge1xuICAgICAgICBsZXQgc2hhZGVyID0gb3Auc2hhZGVyO1xuXG4gICAgICAgIGlmIChvcC5sZW5ndGggfHwgb3Auc2hhZGVyLmFkZEVtcHR5KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3JlbmRlclRleHR1cmUgfHwgdGhpcy5fbWFpblJlbmRlclRleHR1cmU7XG4gICAgICAgICAgICBzaGFkZXIuYmVmb3JlRHJhdyhvcCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHNoYWRlci5kcmF3KG9wLCB0YXJnZXQpO1xuICAgICAgICAgICAgc2hhZGVyLmFmdGVyRHJhdyhvcCwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jbGVhclJlbmRlclRleHR1cmUoKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldENvbnRleHQoKTtcblxuICAgICAgICBsZXQgY2xlYXJDb2xvciA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgaWYgKHRoaXMuX21haW5SZW5kZXJUZXh0dXJlLmN0eCA9PT0gY3R4KSB7XG4gICAgICAgICAgICBjbGVhckNvbG9yID0gdGhpcy5jdHguc3RhZ2UuZ2V0Q2xlYXJDb2xvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVuZGVyVGV4dHVyZSA9IGN0eC5jYW52YXM7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIGlmICghY2xlYXJDb2xvclswXSAmJiAhY2xlYXJDb2xvclsxXSAmJiAhY2xlYXJDb2xvclsyXSAmJiAhY2xlYXJDb2xvclszXSkge1xuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCByZW5kZXJUZXh0dXJlLndpZHRoLCByZW5kZXJUZXh0dXJlLmhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nRnJvbUFycmF5KGNsZWFyQ29sb3IpO1xuICAgICAgICAgICAgLy8gRG8gbm90IHVzZSBmaWxsUmVjdCBiZWNhdXNlIGl0IHByb2R1Y2VzIGFydGlmYWN0cy5cbiAgICAgICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVjdCgwLCAwLCByZW5kZXJUZXh0dXJlLndpZHRoLCByZW5kZXJUZXh0dXJlLmhlaWdodCk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgX2dldENvbnRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyVGV4dHVyZS5jdHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFpblJlbmRlclRleHR1cmUuY3R4O1xuICAgICAgICB9IFxuICAgIH1cblxuICAgIF9yZXN0b3JlQ29udGV4dCgpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0Q29udGV4dCgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguX3NjaXNzb3IgPSBudWxsO1xuICAgIH1cblxuICAgIF9zZXRTY2lzc29yKGFyZWEpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0Q29udGV4dCgpO1xuXG4gICAgICAgIGlmICghQzJkQ29yZVJlbmRlckV4ZWN1dG9yLl9lcXVhbFNjaXNzb3JBcmVhcyhjdHguY2FudmFzLCBjdHguX3NjaXNzb3IsIGFyZWEpKSB7XG4gICAgICAgICAgICAvLyBDbGlwcGluZyBpcyBzdG9yZWQgaW4gdGhlIGNhbnZhcyBjb250ZXh0IHN0YXRlLlxuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgcmVzZXQgY2xpcHBpbmcgYWxvbmUgc28gd2UgbmVlZCB0byByZXN0b3JlIHRoZSBmdWxsIGNvbnRleHQuXG4gICAgICAgICAgICB0aGlzLl9yZXN0b3JlQ29udGV4dCgpO1xuXG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gdGhpcy5jdHguc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKCk7XG4gICAgICAgICAgICBpZiAoYXJlYSkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVjdChNYXRoLnJvdW5kKGFyZWFbMF0gKiBwcmVjaXNpb24pLCBNYXRoLnJvdW5kKGFyZWFbMV0gKiBwcmVjaXNpb24pLCBNYXRoLnJvdW5kKGFyZWFbMl0gKiBwcmVjaXNpb24pLCBNYXRoLnJvdW5kKGFyZWFbM10gKiBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5fc2Npc3NvciA9IGFyZWE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgX2VxdWFsU2Npc3NvckFyZWFzKGNhbnZhcywgYXJlYSwgY3VycmVudCkge1xuICAgICAgICBpZiAoIWFyZWEpIHtcbiAgICAgICAgICAgIGFyZWEgPSBbMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0XVxuICAgICAgICB9XG4gICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgY3VycmVudCA9IFswLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHRdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFV0aWxzLmVxdWFsVmFsdWVzKGFyZWEsIGN1cnJlbnQpXG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQzJkQ29yZVF1YWRMaXN0IGZyb20gXCIuL0MyZENvcmVRdWFkTGlzdC5tanNcIjtcbmltcG9ydCBDMmRDb3JlUXVhZE9wZXJhdGlvbiBmcm9tIFwiLi9DMmRDb3JlUXVhZE9wZXJhdGlvbi5tanNcIjtcbmltcG9ydCBDMmRDb3JlUmVuZGVyRXhlY3V0b3IgZnJvbSBcIi4vQzJkQ29yZVJlbmRlckV4ZWN1dG9yLm1qc1wiO1xuaW1wb3J0IENvcmVSZW5kZXJTdGF0ZSBmcm9tIFwiLi4vLi4vdHJlZS9jb3JlL0NvcmVSZW5kZXJTdGF0ZS5tanNcIjtcbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL3NoYWRlcnMvRGVmYXVsdFNoYWRlci5tanNcIjtcbmltcG9ydCBDMmRTaGFkZXIgZnJvbSBcIi4vQzJkU2hhZGVyLm1qc1wiO1xuaW1wb3J0IFJlbmRlcmVyIGZyb20gXCIuLi9SZW5kZXJlci5tanNcIjtcbmltcG9ydCBUZXh0dXJlVGludE1hbmFnZXIgZnJvbSBcIi4vQzJkVGV4dHVyZVRpbnRNYW5hZ2VyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDMmRSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcblxuICAgICAgICB0aGlzLnRpbnRNYW5hZ2VyID0gbmV3IFRleHR1cmVUaW50TWFuYWdlcihzdGFnZSk7XG5cbiAgICAgICAgdGhpcy5zZXR1cEMyZCh0aGlzLnN0YWdlLmMyZC5jYW52YXMpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudGludE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIF9jcmVhdGVEZWZhdWx0U2hhZGVyKGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRTaGFkZXIoY3R4KTtcbiAgICB9XG5cbiAgICBfZ2V0U2hhZGVyQmFzZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBDMmRTaGFkZXJcbiAgICB9XG5cbiAgICBfZ2V0U2hhZGVyQWx0ZXJuYXRpdmUoc2hhZGVyVHlwZSkge1xuICAgICAgICByZXR1cm4gc2hhZGVyVHlwZS5nZXRDMmQgJiYgc2hhZGVyVHlwZS5nZXRDMmQoKTtcbiAgICB9XG5cbiAgICBjcmVhdGVDb3JlUXVhZExpc3QoY3R4KSB7XG4gICAgICAgIHJldHVybiBuZXcgQzJkQ29yZVF1YWRMaXN0KGN0eCk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ29yZVF1YWRPcGVyYXRpb24oY3R4LCBzaGFkZXIsIHNoYWRlck93bmVyLCByZW5kZXJUZXh0dXJlSW5mbywgc2Npc3NvciwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDMmRDb3JlUXVhZE9wZXJhdGlvbihjdHgsIHNoYWRlciwgc2hhZGVyT3duZXIsIHJlbmRlclRleHR1cmVJbmZvLCBzY2lzc29yLCBpbmRleCk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ29yZVJlbmRlckV4ZWN1dG9yKGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IEMyZENvcmVSZW5kZXJFeGVjdXRvcihjdHgpO1xuICAgIH1cbiAgICBcbiAgICBjcmVhdGVDb3JlUmVuZGVyU3RhdGUoY3R4KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29yZVJlbmRlclN0YXRlKGN0eCk7XG4gICAgfVxuXG4gICAgY3JlYXRlUmVuZGVyVGV4dHVyZSh3LCBoLCBwdywgcGgpIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHB3O1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcGg7XG4gICAgICAgIHRoaXMuc2V0dXBDMmQoY2FudmFzKTtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG4gICAgXG4gICAgZnJlZVJlbmRlclRleHR1cmUobmF0aXZlVGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRpbnRNYW5hZ2VyLmRlbGV0ZShuYXRpdmVUZXh0dXJlKTtcbiAgICB9XG5cbiAgICBnYyhhZ2dyZXNzaXZlKSB7XG4gICAgICAgIHRoaXMudGludE1hbmFnZXIuZ2MoYWdncmVzc2l2ZSk7XG4gICAgfVxuXG4gICAgdXBsb2FkVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIEZvciBjYW52YXMsIHdlIGRvIG5vdCBuZWVkIHRvIHVwbG9hZC5cbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlLmJ1ZmZlcikge1xuICAgICAgICAgICAgLy8gQ29udmVydCBSR0JBIGJ1ZmZlciB0byBjYW52YXMuXG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IG9wdGlvbnMudztcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmg7XG5cbiAgICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IG5ldyBJbWFnZURhdGEobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG9wdGlvbnMuc291cmNlLmJ1ZmZlciksIG9wdGlvbnMudywgb3B0aW9ucy5oKTtcbiAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25zLnNvdXJjZTtcbiAgICB9XG5cbiAgICBmcmVlVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlKSB7XG4gICAgICAgIHRoaXMudGludE1hbmFnZXIuZGVsZXRlKHRleHR1cmVTb3VyY2UubmF0aXZlVGV4dHVyZSk7XG4gICAgfVxuXG4gICAgYWRkUXVhZChyZW5kZXJTdGF0ZSwgcXVhZHMsIGluZGV4KSB7XG4gICAgICAgIC8vIFJlbmRlciBjb250ZXh0IGNoYW5nZXMgd2hpbGUgdHJhdmVyc2luZyBzbyB3ZSBzYXZlIGl0IGJ5IHJlZi5cbiAgICAgICAgY29uc3QgZWxlbWVudENvcmUgPSBxdWFkcy5xdWFkRWxlbWVudHNbaW5kZXhdO1xuICAgICAgICBxdWFkcy5zZXRSZW5kZXJDb250ZXh0KGluZGV4LCBlbGVtZW50Q29yZS5fcmVuZGVyQ29udGV4dCk7XG4gICAgICAgIHF1YWRzLnNldFdoaXRlKGluZGV4LCBlbGVtZW50Q29yZS5pc1doaXRlKCkpO1xuICAgICAgICBxdWFkcy5zZXRTaW1wbGVUYyhpbmRleCwgZWxlbWVudENvcmUuaGFzU2ltcGxlVGV4Q29vcmRzKCkpO1xuICAgIH1cblxuICAgIGlzUmVuZGVyVGV4dHVyZVJldXNhYmxlKHJlbmRlclN0YXRlLCByZW5kZXJUZXh0dXJlSW5mbykge1xuICAgICAgICAvLyBAdG9kbzogY2hlY2sgcmVuZGVyIGNvb3Jkcy9tYXRyaXgsIG1heWJlIG1vdmUgdGhpcyB0byBjb3JlP1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZmluaXNoUmVuZGVyU3RhdGUocmVuZGVyU3RhdGUpIHtcbiAgICB9XG5cbiAgICBzZXR1cEMyZChjYW52YXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGNhbnZhcy5jdHggPSBjdHg7XG5cbiAgICAgICAgY3R4Ll9zY2lzc29yID0gbnVsbDtcblxuICAgICAgICAvLyBTYXZlIGJhc2Ugc3RhdGUgc28gd2UgY2FuIHJlc3RvcmUgdGhlIGRlZmF1bHRzIGxhdGVyLlxuICAgICAgICBjYW52YXMuY3R4LnNhdmUoKTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTaGFkZXIgZnJvbSBcIi4uLy4uL3RyZWUvU2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDMmRTaGFkZXIgZXh0ZW5kcyBTaGFkZXIge1xuXG4gICAgYmVmb3JlRHJhdyhvcGVyYXRpb24pIHtcbiAgICB9XG5cbiAgICBkcmF3KG9wZXJhdGlvbikge1xuICAgIH1cblxuICAgIGFmdGVyRHJhdyhvcGVyYXRpb24pIHtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEMyZFRleHR1cmVUaW50TWFuYWdlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG4gICAgICAgIHRoaXMuX3VzZWRNZW1vcnkgPSAwO1xuICAgICAgICB0aGlzLl9jYWNoZWROYXRpdmVUZXh0dXJlcyA9IG5ldyBTZXQoKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmdjKHRydWUpO1xuICAgIH1cblxuICAgIF9hZGRNZW1vcnlVc2FnZShkZWx0YSkge1xuICAgICAgICB0aGlzLl91c2VkTWVtb3J5ICs9IGRlbHRhO1xuXG4gICAgICAgIHRoaXMuc3RhZ2UuYWRkTWVtb3J5VXNhZ2UoZGVsdGEpO1xuICAgIH1cblxuICAgIGRlbGV0ZShuYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgIC8vIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBuYXRpdmUgdGV4dHVyZSBpcyBjbGVhbmVkIHVwLlxuICAgICAgICBpZiAodGhpcy5faGFzQ2FjaGUobmF0aXZlVGV4dHVyZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fZ2V0Q2FjaGUobmF0aXZlVGV4dHVyZSk7XG4gICAgICAgICAgICBjb25zdCBwcmV2TWVtVXNhZ2UgPSBjYWNoZS5tZW1vcnlVc2FnZTtcbiAgICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWROYXRpdmVUZXh0dXJlcy5kZWxldGUobmF0aXZlVGV4dHVyZSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRNZW1vcnlVc2FnZShjYWNoZS5tZW1vcnlVc2FnZSAtIHByZXZNZW1Vc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRUaW50VGV4dHVyZShuYXRpdmVUZXh0dXJlLCBjb2xvcikge1xuICAgICAgICBjb25zdCBmcmFtZSA9IHRoaXMuc3RhZ2UuZnJhbWVDb3VudGVyO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlZE5hdGl2ZVRleHR1cmVzLmFkZChuYXRpdmVUZXh0dXJlKTtcblxuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2dldENhY2hlKG5hdGl2ZVRleHR1cmUpO1xuXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBjYWNoZS5nZXQoY29sb3IpO1xuICAgICAgICBpdGVtLmxmID0gZnJhbWU7XG5cbiAgICAgICAgaWYgKGl0ZW0udHgpIHtcbiAgICAgICAgICAgIGlmIChuYXRpdmVUZXh0dXJlLnVwZGF0ZSA+IGl0ZW0udSkge1xuICAgICAgICAgICAgICAgIC8vIE5hdGl2ZSB0ZXh0dXJlIHdhcyB1cGRhdGVkIGluIHRoZSBtZWFuIHRpbWU6IHJlbmV3LlxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbnRUZXh0dXJlKGl0ZW0udHgsIG5hdGl2ZVRleHR1cmUsIGNvbG9yKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXRlbS50eDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IGNhY2hlLm1lbW9yeVVzYWdlO1xuXG4gICAgICAgICAgICAvLyBGaW5kIGJsYW5jbyB0aW50IHRleHR1cmUuXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gY2FjaGUucmV1c2VUZXh0dXJlKGZyYW1lKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuY3R4LmNsZWFyUmVjdCgwLCAwLCB0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBbGxvY2F0ZSBuZXcuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LndpZHRoID0gbmF0aXZlVGV4dHVyZS53O1xuICAgICAgICAgICAgICAgIHRhcmdldC5oZWlnaHQgPSBuYXRpdmVUZXh0dXJlLmg7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmN0eCA9IHRhcmdldC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90aW50VGV4dHVyZSh0YXJnZXQsIG5hdGl2ZVRleHR1cmUsIGNvbG9yKTtcbiAgICAgICAgICAgIGNhY2hlLnNldChjb2xvciwgdGFyZ2V0LCBmcmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFmdGVyID0gY2FjaGUubWVtb3J5VXNhZ2U7XG5cbiAgICAgICAgICAgIGlmIChhZnRlciAhPT0gYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVtb3J5VXNhZ2UoYWZ0ZXIgLSBiZWZvcmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3RpbnRUZXh0dXJlKHRhcmdldCwgc291cmNlLCBjb2xvcikge1xuICAgICAgICBsZXQgY29sID0gY29sb3IudG9TdHJpbmcoMTYpO1xuICAgICAgICB3aGlsZSAoY29sLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgIGNvbCA9IFwiMFwiICsgY29sO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5jdHguZmlsbFN0eWxlID0gJyMnICsgY29sO1xuICAgICAgICB0YXJnZXQuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICAgICAgdGFyZ2V0LmN0eC5maWxsUmVjdCgwLCAwLCBzb3VyY2Uudywgc291cmNlLmgpO1xuICAgICAgICB0YXJnZXQuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XG4gICAgICAgIHRhcmdldC5jdHguZHJhd0ltYWdlKHNvdXJjZSwgMCwgMCwgc291cmNlLncsIHNvdXJjZS5oLCAwLCAwLCB0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHQpO1xuXG4gICAgICAgIC8vIEFscGhhLW1peCB0aGUgdGV4dHVyZS5cbiAgICAgICAgdGFyZ2V0LmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24taW4nO1xuICAgICAgICB0YXJnZXQuY3R4LmRyYXdJbWFnZShzb3VyY2UsIDAsIDAsIHNvdXJjZS53LCBzb3VyY2UuaCwgMCwgMCwgdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBfaGFzQ2FjaGUobmF0aXZlVGV4dHVyZSkge1xuICAgICAgICByZXR1cm4gISFuYXRpdmVUZXh0dXJlLl90aW50Q2FjaGU7XG4gICAgfVxuXG4gICAgX2dldENhY2hlKG5hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgaWYgKCFuYXRpdmVUZXh0dXJlLl90aW50Q2FjaGUpIHtcbiAgICAgICAgICAgIG5hdGl2ZVRleHR1cmUuX3RpbnRDYWNoZSA9IG5ldyBDMmRUaW50Q2FjaGUobmF0aXZlVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZVRleHR1cmUuX3RpbnRDYWNoZTtcbiAgICB9XG5cbiAgICBnYyhhZ2dyZXNzaXZlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSB0aGlzLnN0YWdlLmZyYW1lQ291bnRlcjtcbiAgICAgICAgbGV0IGRlbHRhID0gMDtcbiAgICAgICAgdGhpcy5fY2FjaGVkTmF0aXZlVGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fZ2V0Q2FjaGUodGV4dHVyZSk7XG4gICAgICAgICAgICBpZiAoYWdncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgIGRlbHRhICs9IGNhY2hlLm1lbW9yeVVzYWdlO1xuICAgICAgICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IGNhY2hlLm1lbW9yeVVzYWdlO1xuICAgICAgICAgICAgICAgIGNhY2hlLmNsZWFudXAoZnJhbWUpO1xuICAgICAgICAgICAgICAgIGNhY2hlLnJlbGVhc2VCbGFuY29UZXh0dXJlcygpO1xuICAgICAgICAgICAgICAgIGRlbHRhICs9IChjYWNoZS5tZW1vcnlVc2FnZSAtIGJlZm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChhZ2dyZXNzaXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWROYXRpdmVUZXh0dXJlcy5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRNZW1vcnlVc2FnZShkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuY2xhc3MgQzJkVGludENhY2hlIHtcblxuICAgIGNvbnN0cnVjdG9yKG5hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fdHggPSBuYXRpdmVUZXh0dXJlO1xuICAgICAgICB0aGlzLl9jb2xvcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2JsYW5jb1RleHR1cmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdENsZWFudXBGcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuX21lbVRleHR1cmVzID0gMDtcbiAgICB9XG5cbiAgICBnZXQgbWVtb3J5VXNhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZW1UZXh0dXJlcyAqIHRoaXMuX3R4LncgKiB0aGlzLl90eC5oO1xuICAgIH1cblxuICAgIHJlbGVhc2VCbGFuY29UZXh0dXJlcygpIHtcbiAgICAgICAgdGhpcy5fbWVtVGV4dHVyZXMgLT0gdGhpcy5fYmxhbmNvVGV4dHVyZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLl9ibGFuY29UZXh0dXJlcyA9IFtdO1xuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICAvLyBEZXJlZmVyZW5jZSB0aGUgdGV4dHVyZXMuXG4gICAgICAgIHRoaXMuX2JsYW5jb1RleHR1cmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29sb3JzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX21lbVRleHR1cmVzID0gMDtcbiAgICB9XG5cbiAgICBnZXQoY29sb3IpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLl9jb2xvcnMuZ2V0KGNvbG9yKTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICBpdGVtID0ge2xmOiAtMSwgdHg6IHVuZGVmaW5lZCwgdTogLTF9O1xuICAgICAgICAgICAgdGhpcy5fY29sb3JzLnNldChjb2xvciwgaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgc2V0KGNvbG9yLCB0ZXh0dXJlLCBmcmFtZSkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5nZXQoY29sb3IpO1xuICAgICAgICBpdGVtLmxmID0gZnJhbWU7XG4gICAgICAgIGl0ZW0udHggPSB0ZXh0dXJlO1xuICAgICAgICBpdGVtLnUgPSBmcmFtZTtcbiAgICAgICAgdGhpcy5fbWVtVGV4dHVyZXMrKztcbiAgICB9XG5cbiAgICBjbGVhbnVwKGZyYW1lKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBjbGVhbiB1cCBvbmNlIHBlciBmcmFtZS5cbiAgICAgICAgaWYgKHRoaXMuX2xhc3RDbGVhbnVwRnJhbWUgIT09IGZyYW1lKSB7XG5cbiAgICAgICAgICAgIC8vIFdlIGxpbWl0IGJsYW5jbyB0ZXh0dXJlcyByZXVzZSB0byBvbmUgZnJhbWUgb25seSB0byBwcmV2ZW50IG1lbW9yeSB1c2FnZSBncm93dGguXG4gICAgICAgICAgICB0aGlzLl9ibGFuY29UZXh0dXJlcyA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLl9jb2xvcnMuZm9yRWFjaCgoaXRlbSwgY29sb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBlbnRyaWVzIHRoYXQgd2VyZSBub3QgdXNlZCBsYXN0IGZyYW1lLlxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmxmIDwgZnJhbWUgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGFzIHJldXNhYmxlIGJsYW5jbyB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxhbmNvVGV4dHVyZXMucHVzaChpdGVtLnR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xvcnMuZGVsZXRlKGNvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fbGFzdENsZWFudXBGcmFtZSA9IGZyYW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV1c2VUZXh0dXJlKGZyYW1lKSB7XG4gICAgICAgIC8vIFRyeSB0byByZXVzZSB0ZXh0dXJlcywgYmVjYXVzZSBjcmVhdGluZyB0aGVtIGV2ZXJ5IGZyYW1lIGlzIGV4cGVuc2l2ZS5cbiAgICAgICAgdGhpcy5jbGVhbnVwKGZyYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuX2JsYW5jb1RleHR1cmVzICYmIHRoaXMuX2JsYW5jb1RleHR1cmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fbWVtVGV4dHVyZXMtLTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ibGFuY29UZXh0dXJlcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCbHVyU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9rZXJuZWxSYWRpdXMgPSAxO1xuICAgIH1cblxuICAgIGdldCBrZXJuZWxSYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXJuZWxSYWRpdXM7XG4gICAgfVxuXG4gICAgc2V0IGtlcm5lbFJhZGl1cyh2KSB7XG4gICAgICAgIHRoaXMuX2tlcm5lbFJhZGl1cyA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ftb3VudCA9PT0gMDtcbiAgICB9XG5cbiAgICBfYmVmb3JlRHJhd0VsKHt0YXJnZXR9KSB7XG4gICAgICAgIHRhcmdldC5jdHguZmlsdGVyID0gXCJibHVyKFwiICsgdGhpcy5fa2VybmVsUmFkaXVzICsgXCJweClcIjtcbiAgICB9XG5cbiAgICBfYWZ0ZXJEcmF3RWwoe3RhcmdldH0pIHtcbiAgICAgICAgdGFyZ2V0LmN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG5cbn1cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IEMyZFNoYWRlciBmcm9tIFwiLi4vQzJkU2hhZGVyLm1qc1wiO1xuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4uLy4uLy4uL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmYXVsdFNoYWRlciBleHRlbmRzIEMyZFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVjdGFuZ2xlVGV4dHVyZSA9IGN0eC5zdGFnZS5yZWN0YW5nbGVUZXh0dXJlLnNvdXJjZS5uYXRpdmVUZXh0dXJlO1xuICAgICAgICB0aGlzLl90aW50TWFuYWdlciA9IHRoaXMuY3R4LnN0YWdlLnJlbmRlcmVyLnRpbnRNYW5hZ2VyO1xuICAgIH1cblxuICAgIGRyYXcob3BlcmF0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGFyZ2V0LmN0eDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IG9wZXJhdGlvbi5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gb3BlcmF0aW9uLmdldFRleHR1cmUoaSk7XG4gICAgICAgICAgICBjb25zdCB2YyA9IG9wZXJhdGlvbi5nZXRFbGVtZW50Q29yZShpKTtcbiAgICAgICAgICAgIGNvbnN0IHJjID0gb3BlcmF0aW9uLmdldFJlbmRlckNvbnRleHQoaSk7XG4gICAgICAgICAgICBjb25zdCB3aGl0ZSA9IG9wZXJhdGlvbi5nZXRXaGl0ZShpKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YyA9IG9wZXJhdGlvbi5nZXRTaW1wbGVUYyhpKTtcblxuICAgICAgICAgICAgLy9AdG9kbzogdHJ5IHRvIG9wdGltaXplIG91dCBwZXItZHJhdyB0cmFuc2Zvcm0gc2V0dGluZy4gc3BsaXQgdHJhbnNsYXRlLCB0cmFuc2Zvcm0uXG4gICAgICAgICAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLmN0eC5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKTtcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0ocmMudGEgKiBwcmVjaXNpb24sIHJjLnRjICogcHJlY2lzaW9uLCByYy50YiAqIHByZWNpc2lvbiwgcmMudGQgKiBwcmVjaXNpb24sIHJjLnB4ICogcHJlY2lzaW9uLCByYy5weSAqIHByZWNpc2lvbik7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSAodHggPT09IHRoaXMuX3JlY3RhbmdsZVRleHR1cmUpO1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtvcGVyYXRpb24sIHRhcmdldCwgaW5kZXg6IGksIHJlY3R9O1xuXG4gICAgICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBncmFkaWVudC5cbiAgICAgICAgICAgICAgICBpZiAod2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29sb3JHcmFkaWVudChjdHgsIHZjKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSByYy5hbHBoYTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVEcmF3RWwoaW5mbyk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHZjLncsIHZjLmgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FmdGVyRHJhd0VsKGluZm8pO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEuMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQHRvZG86IHNldCBpbWFnZSBzbW9vdGhpbmcgYmFzZWQgb24gdGhlIHRleHR1cmUuXG5cbiAgICAgICAgICAgICAgICAvLyBAdG9kbzogb3B0aW1pemUgYnkgcmVnaXN0ZXJpbmcgd2hldGhlciBpZGVudGl0eSB0ZXhjb29yZHMgYXJlIHVzZWQuXG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gcmMuYWxwaGE7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVmb3JlRHJhd0VsKGluZm8pO1xuXG4gICAgICAgICAgICAgICAgLy8gQHRvZG86IHRlc3QgaWYgcm91bmRpbmcgeWllbGRzIGJldHRlciBwZXJmb3JtYW5jZS5cblxuICAgICAgICAgICAgICAgIC8vIE5vdGljZSB0aGF0IHNpbXBsZSB0ZXh0dXJlIGNvb3JkcyBjYW4gYmUgdHVybmVkIG9uIGV2ZW4gdGhvdWdoIHZjLl91bHggZXRjIGFyZSBub3Qgc2ltcGxlLCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gIHdlIGFyZSByZW5kZXJpbmcgYSByZW5kZXItdG8tdGV4dHVyZSAodGV4Y29vcmRzIHdlcmUgc3Rhc2hlZCkuIFNhbWUgaXMgdHJ1ZSBmb3IgJ3doaXRlJyBjb2xvciBidHcuXG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlWCA9IHN0YyA/IDAgOiAodmMuX3VseCAqIHR4LncpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVkgPSBzdGMgPyAwIDogKHZjLl91bHkgKiB0eC5oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VXID0gKHN0YyA/IDEgOiAodmMuX2JyeCAtIHZjLl91bHgpKSAqIHR4Lnc7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlSCA9IChzdGMgPyAxIDogKHZjLl9icnkgLSB2Yy5fdWx5KSkgKiB0eC5oO1xuXG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yaXplID0gIXdoaXRlO1xuICAgICAgICAgICAgICAgIGlmIChjb2xvcml6ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdG9kbzogY2FjaGUgdGhlIHRpbnQgdGV4dHVyZSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIERyYXcgdG8gaW50ZXJtZWRpYXRlIHRleHR1cmUgd2l0aCBiYWNrZ3JvdW5kIGNvbG9yL2dyYWRpZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHVzIGZyb20gaGF2aW5nIHRvIGNyZWF0ZSBhIGxvdCBvZiByZW5kZXIgdGV4dHVyZSBjYW52YXNlcy5cblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RpY2UgdGhhdCB3ZSBkb24ndCBzdXBwb3J0IChub24tcmVjdCkgZ3JhZGllbnRzLCBvbmx5IGNvbG9yIHRpbnRpbmcgZm9yIGMyZC4gV2UnbGwganVzdCB0YWtlIHRoZSBhdmVyYWdlIGNvbG9yLlxuICAgICAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSB2Yy5fY29sb3JVbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZjLl9jb2xvclVsICE9PSB2Yy5fY29sb3JVciB8fCB2Yy5fY29sb3JVciAhPT0gdmMuX2NvbG9yQmwgfHwgdmMuX2NvbG9yQnIgIT09IHZjLl9jb2xvckJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IFN0YWdlVXRpbHMubWVyZ2VNdWx0aUNvbG9yc0VxdWFsKFt2Yy5fY29sb3JVbCwgdmMuX2NvbG9yVXIsIHZjLl9jb2xvckJsLCB2Yy5fY29sb3JCcl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxwaGEgPSAoKGNvbG9yIC8gMTY3NzcyMTYpIHwgMCkgLyAyNTUuMDtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IGFscGhhO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJnYiA9IGNvbG9yICYgMHgwMEZGRkZGRjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGludFRleHR1cmUgPSB0aGlzLl90aW50TWFuYWdlci5nZXRUaW50VGV4dHVyZSh0eCwgcmdiKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSBkcmF3IHJlc3VsdC5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGludFRleHR1cmUsIHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVcsIHNvdXJjZUgsIDAsIDAsIHZjLncsIHZjLmgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKHR4LCBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VXLCBzb3VyY2VILCAwLCAwLCB2Yy53LCB2Yy5oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYWZ0ZXJEcmF3RWwoaW5mbyk7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NldENvbG9yR3JhZGllbnQoY3R4LCB2YywgdyA9IHZjLncsIGggPSB2Yy5oLCB0cmFuc3BhcmVuY3kgPSB0cnVlKSB7XG4gICAgICAgIGxldCBjb2xvciA9IHZjLl9jb2xvclVsO1xuICAgICAgICBsZXQgZ3JhZGllbnQ7XG4gICAgICAgIC8vQHRvZG86IHF1aWNrIHNpbmdsZSBjb2xvciBjaGVjay5cbiAgICAgICAgLy9AdG9kbzogY2FjaGUgZ3JhZGllbnQvZmlsbCBzdHlsZSAoaWYgcG9zc2libGUsIHByb2JhYmx5IGNvbnRleHQtc3BlY2lmaWMpLlxuXG4gICAgICAgIGlmICh2Yy5fY29sb3JVbCA9PT0gdmMuX2NvbG9yVXIpIHtcbiAgICAgICAgICAgIGlmICh2Yy5fY29sb3JCbCA9PT0gdmMuX2NvbG9yQnIpIHtcbiAgICAgICAgICAgICAgICBpZiAodmMuX2NvbG9yVWwgPT09IHZjLmNvbG9yQmwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luZ2xlIGNvbG9yLlxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcnRpY2FsIGdyYWRpZW50LlxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zcGFyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyh2Yy5fY29sb3JVbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyh2Yy5fY29sb3JCbCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIFN0YWdlVXRpbHMuZ2V0UmdiU3RyaW5nKHZjLl9jb2xvclVsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgU3RhZ2VVdGlscy5nZXRSZ2JTdHJpbmcodmMuX2NvbG9yQmwpKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3Qgc3VwcG9ydGVkIGdyYWRpZW50LlxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZjLl9jb2xvclVsID09PSB2Yy5fY29sb3JCbCAmJiB2Yy5fY29sb3JVciA9PT0gdmMuX2NvbG9yQnIpIHtcbiAgICAgICAgICAgICAgICAvLyBIb3Jpem9udGFsIGdyYWRpZW50LlxuICAgICAgICAgICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHcsIDApO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BhcmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyh2Yy5fY29sb3JVbCkpO1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKHZjLl9jb2xvckJyKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIFN0YWdlVXRpbHMuZ2V0UmdiU3RyaW5nKHZjLl9jb2xvclVsKSk7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBTdGFnZVV0aWxzLmdldFJnYlN0cmluZyh2Yy5fY29sb3JCcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncmFkaWVudCkge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRyYW5zcGFyZW5jeSA/IFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyhjb2xvcikgOiBTdGFnZVV0aWxzLmdldFJnYlN0cmluZyhjb2xvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfYmVmb3JlRHJhd0VsKGluZm8pIHtcbiAgICB9XG5cbiAgICBfYWZ0ZXJEcmF3RWwoaW5mbykge1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IEMyZERlZmF1bHRTaGFkZXIgZnJvbSBcIi4uLy4uL2MyZC9zaGFkZXJzL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5pbXBvcnQgV2ViR0xEZWZhdWx0U2hhZGVyIGZyb20gXCIuLi8uLi93ZWJnbC9zaGFkZXJzL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEdyYXlzY2FsZVNoYWRlciBleHRlbmRzIFdlYkdMRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9hbW91bnQgPSAxO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRDMmQoKSB7XG4gICAgICAgIHJldHVybiBDMmRHcmF5c2NhbGVTaGFkZXI7XG4gICAgfVxuXG5cbiAgICBzZXQgYW1vdW50KHYpIHtcbiAgICAgICAgdGhpcy5fYW1vdW50ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgYW1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1vdW50O1xuICAgIH1cblxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbW91bnQgPT09IDA7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiYW1vdW50XCIsIHRoaXMuX2Ftb3VudCwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgIH1cblxufVxuXG5XZWJHTEdyYXlzY2FsZVNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHVuaWZvcm0gZmxvYXQgYW1vdW50O1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XG4gICAgICAgIGZsb2F0IGdyYXluZXNzID0gMC4yICogY29sb3IuciArIDAuNiAqIGNvbG9yLmcgKyAwLjIgKiBjb2xvci5iO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGFtb3VudCAqIHZlYzMoZ3JheW5lc3MsIGdyYXluZXNzLCBncmF5bmVzcykgKyAoMS4wIC0gYW1vdW50KSAqIGNvbG9yLnJnYiwgY29sb3IuYSk7XG4gICAgfVxuYDtcblxuZXhwb3J0IGNsYXNzIEMyZEdyYXlzY2FsZVNoYWRlciBleHRlbmRzIEMyZERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fYW1vdW50ID0gMTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0V2ViR0woKSB7XG4gICAgICAgIHJldHVybiBXZWJHTEdyYXlzY2FsZVNoYWRlcjtcbiAgICB9XG5cblxuICAgIHNldCBhbW91bnQodikge1xuICAgICAgICB0aGlzLl9hbW91bnQgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBhbW91bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbW91bnQ7XG4gICAgfVxuXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ftb3VudCA9PT0gMDtcbiAgICB9XG5cbiAgICBfYmVmb3JlRHJhd0VsKHt0YXJnZXR9KSB7XG4gICAgICAgIHRhcmdldC5jdHguZmlsdGVyID0gXCJncmF5c2NhbGUoXCIgKyB0aGlzLl9hbW91bnQgKyBcIilcIjtcbiAgICB9XG5cbiAgICBfYWZ0ZXJEcmF3RWwoe3RhcmdldH0pIHtcbiAgICAgICAgdGFyZ2V0LmN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBXZWJHTFJlbmRlcmVyIGZyb20gXCIuLi93ZWJnbC9XZWJHTFJlbmRlcmVyLm1qc1wiO1xuaW1wb3J0IFNwYXJrU2hhZGVyIGZyb20gXCIuL3NoYWRlcnMvU3BhcmtTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwYXJrUmVuZGVyZXIgZXh0ZW5kcyBXZWJHTFJlbmRlcmVyIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlRGVmYXVsdFNoYWRlcihjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTcGFya1NoYWRlcihjdHgpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNvcmVSZW5kZXJFeGVjdXRvcihjdHgpIHtcbiAgICAgICAgZ2xvYmFsLmJlZ2luRHJhd2luZygpO1xuICAgICAgICBsZXQgcmV0ID0gc3VwZXIuY3JlYXRlQ29yZVJlbmRlckV4ZWN1dG9yKGN0eCk7XG4gICAgICAgIGdsb2JhbC5lbmREcmF3aW5nKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFdlYkdMU2hhZGVyIGZyb20gXCIuLi8uLi93ZWJnbC9XZWJHTFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BhcmtTaGFkZXIgZXh0ZW5kcyBXZWJHTFNoYWRlciB7XG5cbiAgICBlbmFibGVBdHRyaWJzKCkge1xuICAgICAgICAvLyBFbmFibGVzIHRoZSBhdHRyaWJzIGluIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLl9hdHRyaWIoXCJhVmVydGV4UG9zaXRpb25cIiksIDIsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDApO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhVmVydGV4UG9zaXRpb25cIikpO1xuXG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWIoXCJhVGV4dHVyZUNvb3JkXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLl9hdHRyaWIoXCJhVGV4dHVyZUNvb3JkXCIpLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIwLCAyICogNCk7XG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhVGV4dHVyZUNvb3JkXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWIoXCJhQ29sb3JcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBTb21lIHNoYWRlcnMgbWF5IGlnbm9yZSB0aGUgY29sb3IuXG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYihcImFDb2xvclwiKSwgNCwgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgMjAsIDQgKiA0KTtcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFDb2xvclwiKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNhYmxlQXR0cmlicygpIHtcbiAgICAgICAgLy8gRGlzYWJsZXMgdGhlIGF0dHJpYnMgaW4gdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYVZlcnRleFBvc2l0aW9uXCIpKTtcblxuICAgICAgICBpZiAodGhpcy5fYXR0cmliKFwiYVRleHR1cmVDb29yZFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhVGV4dHVyZUNvb3JkXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWIoXCJhQ29sb3JcIikgIT09IC0xKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYUNvbG9yXCIpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJwcm9qZWN0aW9uXCIsIHRoaXMuX2dldFByb2plY3Rpb24ob3BlcmF0aW9uKSwgdGhpcy5nbC51bmlmb3JtMmZ2LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZHJhdyhvcGVyYXRpb24pIHtcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gb3BlcmF0aW9uLmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZ2xUZXh0dXJlID0gb3BlcmF0aW9uLmdldFRleHR1cmUoMCk7XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdHggPSBvcGVyYXRpb24uZ2V0VGV4dHVyZShpKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2xUZXh0dXJlICE9PSB0eCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xUZXh0dXJlLm9wdGlvbnMgJiYgZ2xUZXh0dXJlLm9wdGlvbnMuaW1hZ2VSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50UG9zdGlvbiA9IChpID4gMCkgPyAoaSAtIDEpIDogaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IHRoaXMuY3R4LnN0YWdlLmdldE9wdGlvbigncHJlY2lzaW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmMgPSBvcGVyYXRpb24uZ2V0RWxlbWVudENvcmUoZWxlbWVudFBvc3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguc3RhZ2UucGxhdGZvcm0ucGFpbnQoZ2wsIGdsVGV4dHVyZS5vcHRpb25zLmltYWdlUmVmLCB2Yy5fd29ybGRDb250ZXh0LnB4KnByZWNpc2lvbiwgdmMuX3dvcmxkQ29udGV4dC5weSpwcmVjaXNpb24sIHZjLl9jb2xvclVsLCB2Yyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBnbFRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiAqIChpIC0gcG9zKSwgZ2wuVU5TSUdORURfU0hPUlQsIChwb3MgKyBvcGVyYXRpb24uaW5kZXgpICogNiAqIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdsVGV4dHVyZSA9IHR4O1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2xUZXh0dXJlLm9wdGlvbnMgJiYgZ2xUZXh0dXJlLm9wdGlvbnMuaW1hZ2VSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gdGhpcy5jdHguc3RhZ2UuZ2V0T3B0aW9uKCdwcmVjaXNpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZjID0gb3BlcmF0aW9uLmdldEVsZW1lbnRDb3JlKHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnN0YWdlLnBsYXRmb3JtLnBhaW50KGdsLCBnbFRleHR1cmUub3B0aW9ucy5pbWFnZVJlZiwgdmMuX3dvcmxkQ29udGV4dC5weCpwcmVjaXNpb24sIHZjLl93b3JsZENvbnRleHQucHkqcHJlY2lzaW9uLCB2Yy5fY29sb3JVbCwgdmMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYgKiAobGVuZ3RoIC0gcG9zKSwgZ2wuVU5TSUdORURfU0hPUlQsIChwb3MgKyBvcGVyYXRpb24uaW5kZXgpICogNiAqIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5TcGFya1NoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG4gICAgYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xuICAgIHVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVZlcnRleFBvc2l0aW9uLnggKiBwcm9qZWN0aW9uLnggLSAxLjAsIGFWZXJ0ZXhQb3NpdGlvbi55ICogLWFicyhwcm9qZWN0aW9uLnkpICsgMS4wLCAwLjAsIDEuMCk7XG4gICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgPSAtc2lnbihwcm9qZWN0aW9uLnkpICogZ2xfUG9zaXRpb24ueTtcbiAgICB9XG5gO1xuXG5TcGFya1NoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvcjtcbiAgICB9XG5gO1xuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ29yZVF1YWRMaXN0IGZyb20gXCIuLi8uLi90cmVlL2NvcmUvQ29yZVF1YWRMaXN0Lm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTENvcmVRdWFkTGlzdCBleHRlbmRzIENvcmVRdWFkTGlzdCB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoY3R4KTtcblxuICAgICAgICAvLyBBbGxvY2F0ZSBhIGZhaXJseSBiaWcgY2h1bmsgb2YgbWVtb3J5IHRoYXQgc2hvdWxkIGJlIGVub3VnaCB0byBzdXBwb3J0IH4xMDAwMDAgKGRlZmF1bHQpIHF1YWRzLlxuICAgICAgICAvLyBXZSBkbyBub3QgKHdhbnQgdG8pIGhhbmRsZSBtZW1vcnkgb3ZlcmZsb3cuXG4gICAgICAgIGNvbnN0IGJ5dGVTaXplID0gY3R4LnN0YWdlLmdldE9wdGlvbignYnVmZmVyTWVtb3J5Jyk7XG5cbiAgICAgICAgdGhpcy5kYXRhTGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVNpemUpO1xuICAgICAgICB0aGlzLmZsb2F0cyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kYXRhKTtcbiAgICAgICAgdGhpcy51aW50cyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLmRhdGEpO1xuICAgIH1cblxuICAgIGdldEF0dHJpYnNEYXRhQnl0ZU9mZnNldChpbmRleCkge1xuICAgICAgICAvLyBXaGVyZSB0aGlzIHF1YWQgY2FuIGJlIGZvdW5kIGluIHRoZSBhdHRyaWJzIGJ1ZmZlci5cbiAgICAgICAgcmV0dXJuIGluZGV4ICogODA7XG4gICAgfVxuXG4gICAgZ2V0UXVhZENvbnRlbnRzKCkge1xuICAgICAgICAvLyBEZWJ1ZzogbG9nIGNvbnRlbnRzIG9mIHF1YWQgYnVmZmVyLlxuICAgICAgICBsZXQgZmxvYXRzID0gdGhpcy5mbG9hdHM7XG4gICAgICAgIGxldCB1aW50cyA9IHRoaXMudWludHM7XG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gJ2VudHJ5ICcgKyBpICsgJzogJztcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGIgPSBpICogMjAgKyBqICogNDtcbiAgICAgICAgICAgICAgICBzdHIgKz0gZmxvYXRzW2JdICsgJywnICsgZmxvYXRzW2IrMV0gKyAnOicgKyBmbG9hdHNbYisyXSArICcsJyArIGZsb2F0c1tiKzNdICsgJ1snICsgdWludHNbYis0XS50b1N0cmluZygxNikgKyAnXSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZXMucHVzaChzdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cblxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ29yZVF1YWRPcGVyYXRpb24gZnJvbSBcIi4uLy4uL3RyZWUvY29yZS9Db3JlUXVhZE9wZXJhdGlvbi5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xDb3JlUXVhZE9wZXJhdGlvbiBleHRlbmRzIENvcmVRdWFkT3BlcmF0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCwgc2hhZGVyLCBzaGFkZXJPd25lciwgcmVuZGVyVGV4dHVyZUluZm8sIHNjaXNzb3IsIGluZGV4KSB7XG4gICAgICAgIHN1cGVyKGN0eCwgc2hhZGVyLCBzaGFkZXJPd25lciwgcmVuZGVyVGV4dHVyZUluZm8sIHNjaXNzb3IsIGluZGV4KTtcblxuICAgICAgICB0aGlzLmV4dHJhQXR0cmlic0RhdGFCeXRlT2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBnZXRBdHRyaWJzRGF0YUJ5dGVPZmZzZXQoaW5kZXgpIHtcbiAgICAgICAgLy8gV2hlcmUgdGhpcyBxdWFkIGNhbiBiZSBmb3VuZCBpbiB0aGUgYXR0cmlicyBidWZmZXIuXG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRzLmdldEF0dHJpYnNEYXRhQnl0ZU9mZnNldCh0aGlzLmluZGV4ICsgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlbGF0aXZlIHBpeGVsIGNvb3JkaW5hdGVzIGluIHRoZSBzaGFkZXIgb3duZXIgdG8gZ2wgcG9zaXRpb24gY29vcmRpbmF0ZXMgaW4gdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICBnZXROb3JtYWxSZW5kZXJUZXh0dXJlQ29vcmRzKHgsIHkpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHRoaXMuc2hhZGVyT3duZXIuZ2V0UmVuZGVyVGV4dHVyZUNvb3Jkcyh4LCB5KTtcbiAgICAgICAgY29vcmRzWzBdIC89IHRoaXMuZ2V0UmVuZGVyV2lkdGgoKTtcbiAgICAgICAgY29vcmRzWzFdIC89IHRoaXMuZ2V0UmVuZGVySGVpZ2h0KCk7XG4gICAgICAgIGNvb3Jkc1swXSA9IGNvb3Jkc1swXSAqIDIgLSAxO1xuICAgICAgICBjb29yZHNbMV0gPSAxIC0gY29vcmRzWzFdICogMjtcbiAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9XG5cbiAgICBnZXRQcm9qZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJUZXh0dXJlSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3R4LnJlbmRlckV4ZWMuX3Byb2plY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJUZXh0dXJlSW5mby5uYXRpdmVUZXh0dXJlLnByb2plY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDb3JlUmVuZGVyRXhlY3V0b3IgZnJvbSBcIi4uLy4uL3RyZWUvY29yZS9Db3JlUmVuZGVyRXhlY3V0b3IubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMQ29yZVJlbmRlckV4ZWN1dG9yIGV4dGVuZHMgQ29yZVJlbmRlckV4ZWN1dG9yIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICBzdXBlcihjdHgpXG5cbiAgICAgICAgdGhpcy5nbCA9IHRoaXMuY3R4LnN0YWdlLmdsO1xuXG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIGluaXQoKSB7XG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBzaGFyYWJsZSBidWZmZXIgZm9yIHBhcmFtcy5cbiAgICAgICAgdGhpcy5fYXR0cmlic0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgICAgIGxldCBtYXhRdWFkcyA9IE1hdGguZmxvb3IodGhpcy5yZW5kZXJTdGF0ZS5xdWFkcy5kYXRhLmJ5dGVMZW5ndGggLyA4MCk7XG5cbiAgICAgICAgLy8gSW5pdCB3ZWJnbCBhcnJheXMuXG4gICAgICAgIGxldCBhbGxJbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KG1heFF1YWRzICogNik7XG5cbiAgICAgICAgLy8gZmlsbCB0aGUgaW5kaWNlcyB3aXRoIHRoZSBxdWFkcyB0byBkcmF3LlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBtYXhRdWFkczsgaSArPSA2LCBqICs9IDQpIHtcbiAgICAgICAgICAgIGFsbEluZGljZXNbaV0gPSBqO1xuICAgICAgICAgICAgYWxsSW5kaWNlc1tpICsgMV0gPSBqICsgMTtcbiAgICAgICAgICAgIGFsbEluZGljZXNbaSArIDJdID0gaiArIDI7XG4gICAgICAgICAgICBhbGxJbmRpY2VzW2kgKyAzXSA9IGo7XG4gICAgICAgICAgICBhbGxJbmRpY2VzW2kgKyA0XSA9IGogKyAyO1xuICAgICAgICAgICAgYWxsSW5kaWNlc1tpICsgNV0gPSBqICsgMztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBxdWFkcyBidWZmZXIgY2FuIGJlIChyZSl1c2VkIHRvIGRyYXcgYSByYW5nZSBvZiBxdWFkcy5cbiAgICAgICAgdGhpcy5fcXVhZHNCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5fcXVhZHNCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBhbGxJbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgICAgLy8gVGhlIG1hdHJpeCB0aGF0IGNhdXNlcyB0aGUgWzAsMCAtIFcsSF0gYm94IHRvIG1hcCB0byBbLTEsLTEgLSAxLDFdIGluIHRoZSBlbmQgcmVzdWx0cy5cbiAgICAgICAgdGhpcy5fcHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoWzIvdGhpcy5jdHguc3RhZ2UuY29vcmRzV2lkdGgsIC0yL3RoaXMuY3R4LnN0YWdlLmNvb3Jkc0hlaWdodF0pO1xuXG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLl9hdHRyaWJzQnVmZmVyKTtcbiAgICAgICAgdGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy5fcXVhZHNCdWZmZXIpO1xuICAgIH1cblxuICAgIF9yZXNldCgpIHtcbiAgICAgICAgc3VwZXIuX3Jlc2V0KCk7XG5cbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cbiAgICAgICAgdGhpcy5fc3RvcFNoYWRlclByb2dyYW0oKTtcbiAgICAgICAgdGhpcy5fc2V0dXBCdWZmZXJzKCk7XG4gICAgfVxuXG4gICAgX3NldHVwQnVmZmVycygpIHtcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5fcXVhZHNCdWZmZXIpO1xuICAgICAgICBsZXQgZWxlbWVudCA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5yZW5kZXJTdGF0ZS5xdWFkcy5kYXRhLCAwLCB0aGlzLnJlbmRlclN0YXRlLnF1YWRzLmRhdGFMZW5ndGgpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5fYXR0cmlic0J1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBlbGVtZW50LCBnbC5EWU5BTUlDX0RSQVcpO1xuICAgIH1cblxuICAgIF9zZXR1cFF1YWRPcGVyYXRpb24ocXVhZE9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5fc2V0dXBRdWFkT3BlcmF0aW9uKHF1YWRPcGVyYXRpb24pO1xuICAgICAgICB0aGlzLl91c2VTaGFkZXJQcm9ncmFtKHF1YWRPcGVyYXRpb24uc2hhZGVyLCBxdWFkT3BlcmF0aW9uKTtcbiAgICB9XG5cbiAgICBfcmVuZGVyUXVhZE9wZXJhdGlvbihvcCkge1xuICAgICAgICBsZXQgc2hhZGVyID0gb3Auc2hhZGVyO1xuXG4gICAgICAgIGlmIChvcC5sZW5ndGggfHwgb3Auc2hhZGVyLmFkZEVtcHR5KCkpIHtcbiAgICAgICAgICAgIHNoYWRlci5iZWZvcmVEcmF3KG9wKTtcbiAgICAgICAgICAgIHNoYWRlci5kcmF3KG9wKTtcbiAgICAgICAgICAgIHNoYWRlci5hZnRlckRyYXcob3ApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlcn0gc2hhZGVyO1xuICAgICAqIEBwYXJhbSB7Q29yZVF1YWRPcGVyYXRpb259IG9wZXJhdGlvbjtcbiAgICAgKi9cbiAgICBfdXNlU2hhZGVyUHJvZ3JhbShzaGFkZXIsIG9wZXJhdGlvbikge1xuICAgICAgICBpZiAoIXNoYWRlci5oYXNTYW1lUHJvZ3JhbSh0aGlzLl9jdXJyZW50U2hhZGVyUHJvZ3JhbSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50U2hhZGVyUHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTaGFkZXJQcm9ncmFtLnN0b3BQcm9ncmFtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaGFkZXIudXNlUHJvZ3JhbSgpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFNoYWRlclByb2dyYW0gPSBzaGFkZXI7XG4gICAgICAgIH1cbiAgICAgICAgc2hhZGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICB9XG5cbiAgICBfc3RvcFNoYWRlclByb2dyYW0oKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U2hhZGVyUHJvZ3JhbSkge1xuICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnRseSB1c2VkIHNoYWRlciBwcm9ncmFtIHNob3VsZCBiZSBzdG9wcGVkIGdyYWNlZnVsbHkuXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U2hhZGVyUHJvZ3JhbS5zdG9wUHJvZ3JhbSgpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFNoYWRlclByb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2JpbmRSZW5kZXJUZXh0dXJlKHJlbmRlclRleHR1cmUpIHtcbiAgICAgICAgc3VwZXIuX2JpbmRSZW5kZXJUZXh0dXJlKHJlbmRlclRleHR1cmUpO1xuXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsMCx0aGlzLmN0eC5zdGFnZS53LHRoaXMuY3R4LnN0YWdlLmgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLl9yZW5kZXJUZXh0dXJlLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsMCx0aGlzLl9yZW5kZXJUZXh0dXJlLncsIHRoaXMuX3JlbmRlclRleHR1cmUuaCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2xlYXJSZW5kZXJUZXh0dXJlKCkge1xuICAgICAgICBzdXBlci5fY2xlYXJSZW5kZXJUZXh0dXJlKCk7XG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgbGV0IGdsQ2xlYXJDb2xvciA9IHRoaXMuY3R4LnN0YWdlLmdldENsZWFyQ29sb3IoKTtcbiAgICAgICAgICAgIGlmIChnbENsZWFyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBnbC5jbGVhckNvbG9yKGdsQ2xlYXJDb2xvclswXSAqIGdsQ2xlYXJDb2xvclszXSwgZ2xDbGVhckNvbG9yWzFdICogZ2xDbGVhckNvbG9yWzNdLCBnbENsZWFyQ29sb3JbMl0gKiBnbENsZWFyQ29sb3JbM10sIGdsQ2xlYXJDb2xvclszXSk7XG4gICAgICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDbGVhciB0ZXh0dXJlLlxuICAgICAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NldFNjaXNzb3IoYXJlYSkge1xuICAgICAgICBzdXBlci5fc2V0U2Npc3NvcihhcmVhKTtcblxuICAgICAgICBpZiAodGhpcy5fc2Npc3NvciA9PT0gYXJlYSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NjaXNzb3IgPSBhcmVhO1xuXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGlmICghYXJlYSkge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gdGhpcy5jdHguc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKCk7XG4gICAgICAgICAgICBsZXQgeSA9IGFyZWFbMV07XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVuZGVyVGV4dHVyZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEZsaXAuXG4gICAgICAgICAgICAgICAgeSA9ICh0aGlzLmN0eC5zdGFnZS5oIC8gcHJlY2lzaW9uIC0gKGFyZWFbMV0gKyBhcmVhWzNdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC5zY2lzc29yKE1hdGgucm91bmQoYXJlYVswXSAqIHByZWNpc2lvbiksIE1hdGgucm91bmQoeSAqIHByZWNpc2lvbiksIE1hdGgucm91bmQoYXJlYVsyXSAqIHByZWNpc2lvbiksIE1hdGgucm91bmQoYXJlYVszXSAqIHByZWNpc2lvbikpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uLy4uL3RyZWUvVXRpbHMubWpzXCI7XG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi4vLi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuaW1wb3J0IFdlYkdMQ29yZVF1YWRMaXN0IGZyb20gXCIuL1dlYkdMQ29yZVF1YWRMaXN0Lm1qc1wiO1xuaW1wb3J0IFdlYkdMQ29yZVF1YWRPcGVyYXRpb24gZnJvbSBcIi4vV2ViR0xDb3JlUXVhZE9wZXJhdGlvbi5tanNcIjtcbmltcG9ydCBXZWJHTENvcmVSZW5kZXJFeGVjdXRvciBmcm9tIFwiLi9XZWJHTENvcmVSZW5kZXJFeGVjdXRvci5tanNcIjtcbmltcG9ydCBDb3JlUmVuZGVyU3RhdGUgZnJvbSBcIi4uLy4uL3RyZWUvY29yZS9Db3JlUmVuZGVyU3RhdGUubWpzXCI7XG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9zaGFkZXJzL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5pbXBvcnQgV2ViR0xTaGFkZXIgZnJvbSBcIi4vV2ViR0xTaGFkZXIubWpzXCI7XG5pbXBvcnQgUmVuZGVyZXIgZnJvbSBcIi4uL1JlbmRlcmVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuICAgICAgICB0aGlzLnNoYWRlclByb2dyYW1zID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2hhZGVyUHJvZ3JhbXMuZm9yRWFjaChzaGFkZXJQcm9ncmFtID0+IHNoYWRlclByb2dyYW0uZGVzdHJveSgpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlRGVmYXVsdFNoYWRlcihjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0U2hhZGVyKGN0eCk7XG4gICAgfVxuXG4gICAgX2dldFNoYWRlckJhc2VUeXBlKCkge1xuICAgICAgICByZXR1cm4gV2ViR0xTaGFkZXJcbiAgICB9XG5cbiAgICBfZ2V0U2hhZGVyQWx0ZXJuYXRpdmUoc2hhZGVyVHlwZSkge1xuICAgICAgICByZXR1cm4gc2hhZGVyVHlwZS5nZXRXZWJHTCAmJiBzaGFkZXJUeXBlLmdldFdlYkdMKCk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ29yZVF1YWRMaXN0KGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IFdlYkdMQ29yZVF1YWRMaXN0KGN0eCk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ29yZVF1YWRPcGVyYXRpb24oY3R4LCBzaGFkZXIsIHNoYWRlck93bmVyLCByZW5kZXJUZXh0dXJlSW5mbywgc2Npc3NvciwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJHTENvcmVRdWFkT3BlcmF0aW9uKGN0eCwgc2hhZGVyLCBzaGFkZXJPd25lciwgcmVuZGVyVGV4dHVyZUluZm8sIHNjaXNzb3IsIGluZGV4KTtcbiAgICB9XG5cbiAgICBjcmVhdGVDb3JlUmVuZGVyRXhlY3V0b3IoY3R4KSB7XG4gICAgICAgIHJldHVybiBuZXcgV2ViR0xDb3JlUmVuZGVyRXhlY3V0b3IoY3R4KTtcbiAgICB9XG4gICAgXG4gICAgY3JlYXRlQ29yZVJlbmRlclN0YXRlKGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IENvcmVSZW5kZXJTdGF0ZShjdHgpO1xuICAgIH1cblxuICAgIGNyZWF0ZVJlbmRlclRleHR1cmUodywgaCwgcHcsIHBoKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5zdGFnZS5nbDtcbiAgICAgICAgY29uc3QgZ2xUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBnbFRleHR1cmUpO1xuXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgcHcsIHBoLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblxuICAgICAgICBnbFRleHR1cmUucGFyYW1zID0ge307XG4gICAgICAgIGdsVGV4dHVyZS5wYXJhbXNbZ2wuVEVYVFVSRV9NQUdfRklMVEVSXSA9IGdsLkxJTkVBUjtcbiAgICAgICAgZ2xUZXh0dXJlLnBhcmFtc1tnbC5URVhUVVJFX01JTl9GSUxURVJdID0gZ2wuTElORUFSO1xuICAgICAgICBnbFRleHR1cmUucGFyYW1zW2dsLlRFWFRVUkVfV1JBUF9TXSA9IGdsLkNMQU1QX1RPX0VER0U7XG4gICAgICAgIGdsVGV4dHVyZS5wYXJhbXNbZ2wuVEVYVFVSRV9XUkFQX1RdID0gZ2wuQ0xBTVBfVE9fRURHRTtcbiAgICAgICAgZ2xUZXh0dXJlLm9wdGlvbnMgPSB7Zm9ybWF0OiBnbC5SR0JBLCBpbnRlcm5hbEZvcm1hdDogZ2wuUkdCQSwgdHlwZTogZ2wuVU5TSUdORURfQllURX07XG5cbiAgICAgICAgLy8gV2UgbmVlZCBhIHNwZWNpZmljIGZyYW1lYnVmZmVyIGZvciBldmVyeSByZW5kZXIgdGV4dHVyZS5cbiAgICAgICAgZ2xUZXh0dXJlLmZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgZ2xUZXh0dXJlLnByb2plY3Rpb24gPSBuZXcgRmxvYXQzMkFycmF5KFsyL3csIDIvaF0pO1xuXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2xUZXh0dXJlLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBnbFRleHR1cmUsIDApO1xuXG4gICAgICAgIHJldHVybiBnbFRleHR1cmU7XG4gICAgfVxuICAgIFxuICAgIGZyZWVSZW5kZXJUZXh0dXJlKGdsVGV4dHVyZSkge1xuICAgICAgICBsZXQgZ2wgPSB0aGlzLnN0YWdlLmdsO1xuICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihnbFRleHR1cmUuZnJhbWVidWZmZXIpO1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKGdsVGV4dHVyZSk7XG4gICAgfVxuXG4gICAgdXBsb2FkVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5zdGFnZS5nbDtcblxuICAgICAgICBjb25zdCBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcblxuICAgICAgICBjb25zdCBmb3JtYXQgPSB7XG4gICAgICAgICAgICBwcmVtdWx0aXBseUFscGhhOiB0cnVlLFxuICAgICAgICAgICAgaGFzQWxwaGE6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KCdwcmVtdWx0aXBseUFscGhhJykpIHtcbiAgICAgICAgICAgIGZvcm1hdC5wcmVtdWx0aXBseUFscGhhID0gb3B0aW9ucy5wcmVtdWx0aXBseUFscGhhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZmxpcEJsdWVSZWQnKSkge1xuICAgICAgICAgICAgZm9ybWF0LmZsaXBCbHVlUmVkID0gb3B0aW9ucy5mbGlwQmx1ZVJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2hhc0FscGhhJykpIHtcbiAgICAgICAgICAgIGZvcm1hdC5oYXNBbHBoYSA9IG9wdGlvbnMuaGFzQWxwaGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZvcm1hdC5oYXNBbHBoYSkge1xuICAgICAgICAgICAgZm9ybWF0LnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdC50ZXhQYXJhbXMgPSBvcHRpb25zLnRleFBhcmFtcyB8fCB7fVxuICAgICAgICBmb3JtYXQudGV4T3B0aW9ucyA9IG9wdGlvbnMudGV4T3B0aW9ucyB8fCB7fVxuXG4gICAgICAgIGxldCBnbFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSk7XG5cbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmb3JtYXQucHJlbXVsdGlwbHlBbHBoYSk7XG5cbiAgICAgICAgaWYgKFV0aWxzLmlzTm9kZSkge1xuICAgICAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfQkxVRV9SRUQsICEhZm9ybWF0LmZsaXBCbHVlUmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRleFBhcmFtcyA9IGZvcm1hdC50ZXhQYXJhbXM7XG4gICAgICAgIGlmICghdGV4UGFyYW1zW2dsLlRFWFRVUkVfTUFHX0ZJTFRFUl0pIHRleFBhcmFtc1tnbC5URVhUVVJFX01BR19GSUxURVJdID0gZ2wuTElORUFSO1xuICAgICAgICBpZiAoIXRleFBhcmFtc1tnbC5URVhUVVJFX01JTl9GSUxURVJdKSB0ZXhQYXJhbXNbZ2wuVEVYVFVSRV9NSU5fRklMVEVSXSA9IGdsLkxJTkVBUjtcbiAgICAgICAgaWYgKCF0ZXhQYXJhbXNbZ2wuVEVYVFVSRV9XUkFQX1NdKSB0ZXhQYXJhbXNbZ2wuVEVYVFVSRV9XUkFQX1NdID0gZ2wuQ0xBTVBfVE9fRURHRTtcbiAgICAgICAgaWYgKCF0ZXhQYXJhbXNbZ2wuVEVYVFVSRV9XUkFQX1RdKSB0ZXhQYXJhbXNbZ2wuVEVYVFVSRV9XUkFQX1RdID0gZ2wuQ0xBTVBfVE9fRURHRTtcblxuICAgICAgICBPYmplY3Qua2V5cyh0ZXhQYXJhbXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGV4UGFyYW1zW2tleV07XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIHBhcnNlSW50KGtleSksIHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdGV4T3B0aW9ucyA9IGZvcm1hdC50ZXhPcHRpb25zO1xuICAgICAgICB0ZXhPcHRpb25zLmZvcm1hdCA9IHRleE9wdGlvbnMuZm9ybWF0IHx8IChmb3JtYXQuaGFzQWxwaGEgPyBnbC5SR0JBIDogZ2wuUkdCKTtcbiAgICAgICAgdGV4T3B0aW9ucy50eXBlID0gdGV4T3B0aW9ucy50eXBlIHx8IGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgICAgIHRleE9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgPSB0ZXhPcHRpb25zLmludGVybmFsRm9ybWF0IHx8IHRleE9wdGlvbnMuZm9ybWF0O1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmltYWdlUmVmKSB7XG4gICAgICAgICAgICB0ZXhPcHRpb25zLmltYWdlUmVmID0gb3B0aW9ucy5pbWFnZVJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhZ2UucGxhdGZvcm0udXBsb2FkR2xUZXh0dXJlKGdsLCB0ZXh0dXJlU291cmNlLCBzb3VyY2UsIHRleE9wdGlvbnMpO1xuXG4gICAgICAgIGdsVGV4dHVyZS5wYXJhbXMgPSBVdGlscy5jbG9uZU9ialNoYWxsb3codGV4UGFyYW1zKTtcbiAgICAgICAgZ2xUZXh0dXJlLm9wdGlvbnMgPSBVdGlscy5jbG9uZU9ialNoYWxsb3codGV4T3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIGdsVGV4dHVyZTtcbiAgICB9XG5cbiAgICBmcmVlVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UuZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlU291cmNlLm5hdGl2ZVRleHR1cmUpO1xuICAgIH1cblxuICAgIGFkZFF1YWQocmVuZGVyU3RhdGUsIHF1YWRzLCBpbmRleCkge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gKGluZGV4ICogMjApO1xuICAgICAgICBjb25zdCBlbGVtZW50Q29yZSA9IHF1YWRzLnF1YWRFbGVtZW50c1tpbmRleF07XG5cbiAgICAgICAgbGV0IHIgPSBlbGVtZW50Q29yZS5fcmVuZGVyQ29udGV4dDtcblxuICAgICAgICBsZXQgZmxvYXRzID0gcmVuZGVyU3RhdGUucXVhZHMuZmxvYXRzO1xuICAgICAgICBsZXQgdWludHMgPSByZW5kZXJTdGF0ZS5xdWFkcy51aW50cztcbiAgICAgICAgY29uc3QgbWNhID0gU3RhZ2VVdGlscy5tZXJnZUNvbG9yQWxwaGE7XG5cbiAgICAgICAgaWYgKHIudGIgIT09IDAgfHwgci50YyAhPT0gMCkge1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IHIucHg7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gci5weTtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fdWx4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl91bHk7XG4gICAgICAgICAgICB1aW50c1tvZmZzZXQrK10gPSBtY2EoZWxlbWVudENvcmUuX2NvbG9yVWwsIHIuYWxwaGEpO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IHIucHggKyBlbGVtZW50Q29yZS5fdyAqIHIudGE7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gci5weSArIGVsZW1lbnRDb3JlLl93ICogci50YztcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fYnJ4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl91bHk7XG4gICAgICAgICAgICB1aW50c1tvZmZzZXQrK10gPSBtY2EoZWxlbWVudENvcmUuX2NvbG9yVXIsIHIuYWxwaGEpO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IHIucHggKyBlbGVtZW50Q29yZS5fdyAqIHIudGEgKyBlbGVtZW50Q29yZS5faCAqIHIudGI7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gci5weSArIGVsZW1lbnRDb3JlLl93ICogci50YyArIGVsZW1lbnRDb3JlLl9oICogci50ZDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fYnJ4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl9icnk7XG4gICAgICAgICAgICB1aW50c1tvZmZzZXQrK10gPSBtY2EoZWxlbWVudENvcmUuX2NvbG9yQnIsIHIuYWxwaGEpO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IHIucHggKyBlbGVtZW50Q29yZS5faCAqIHIudGI7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gci5weSArIGVsZW1lbnRDb3JlLl9oICogci50ZDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fdWx4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl9icnk7XG4gICAgICAgICAgICB1aW50c1tvZmZzZXRdID0gbWNhKGVsZW1lbnRDb3JlLl9jb2xvckJsLCByLmFscGhhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNpbXBsZS5cbiAgICAgICAgICAgIGxldCBjeCA9IHIucHggKyBlbGVtZW50Q29yZS5fdyAqIHIudGE7XG4gICAgICAgICAgICBsZXQgY3kgPSByLnB5ICsgZWxlbWVudENvcmUuX2ggKiByLnRkO1xuXG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gci5weDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSByLnB5O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl91bHg7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX3VseTtcbiAgICAgICAgICAgIHVpbnRzW29mZnNldCsrXSA9IG1jYShlbGVtZW50Q29yZS5fY29sb3JVbCwgci5hbHBoYSk7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gY3g7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gci5weTtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fYnJ4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl91bHk7XG4gICAgICAgICAgICB1aW50c1tvZmZzZXQrK10gPSBtY2EoZWxlbWVudENvcmUuX2NvbG9yVXIsIHIuYWxwaGEpO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGN4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGN5O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl9icng7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX2JyeTtcbiAgICAgICAgICAgIHVpbnRzW29mZnNldCsrXSA9IG1jYShlbGVtZW50Q29yZS5fY29sb3JCciwgci5hbHBoYSk7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gci5weDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBjeTtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fdWx4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl9icnk7XG4gICAgICAgICAgICB1aW50c1tvZmZzZXRdID0gbWNhKGVsZW1lbnRDb3JlLl9jb2xvckJsLCByLmFscGhhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzUmVuZGVyVGV4dHVyZVJldXNhYmxlKHJlbmRlclN0YXRlLCByZW5kZXJUZXh0dXJlSW5mbykge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gKHJlbmRlclN0YXRlLl9yZW5kZXJUZXh0dXJlSW5mby5vZmZzZXQgKiA4MCkgLyA0O1xuICAgICAgICBsZXQgZmxvYXRzID0gcmVuZGVyU3RhdGUucXVhZHMuZmxvYXRzO1xuICAgICAgICBsZXQgdWludHMgPSByZW5kZXJTdGF0ZS5xdWFkcy51aW50cztcbiAgICAgICAgcmV0dXJuICgoZmxvYXRzW29mZnNldF0gPT09IDApICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDFdID09PSAwKSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyAyXSA9PT0gMCkgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgM10gPT09IDApICYmXG4gICAgICAgICAgICAodWludHNbb2Zmc2V0ICsgNF0gPT09IDB4RkZGRkZGRkYpICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDVdID09PSByZW5kZXJUZXh0dXJlSW5mby53KSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyA2XSA9PT0gMCkgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgN10gPT09IDEpICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDhdID09PSAwKSAmJlxuICAgICAgICAgICAgKHVpbnRzW29mZnNldCArIDldID09PSAweEZGRkZGRkZGKSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyAxMF0gPT09IHJlbmRlclRleHR1cmVJbmZvLncpICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDExXSA9PT0gcmVuZGVyVGV4dHVyZUluZm8uaCkgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgMTJdID09PSAxKSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyAxM10gPT09IDEpICYmXG4gICAgICAgICAgICAodWludHNbb2Zmc2V0ICsgMTRdID09PSAweEZGRkZGRkZGKSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyAxNV0gPT09IDApICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDE2XSA9PT0gcmVuZGVyVGV4dHVyZUluZm8uaCkgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgMTddID09PSAwKSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyAxOF0gPT09IDEpICYmXG4gICAgICAgICAgICAodWludHNbb2Zmc2V0ICsgMTldID09PSAweEZGRkZGRkZGKSk7XG4gICAgfVxuXG4gICAgZmluaXNoUmVuZGVyU3RhdGUocmVuZGVyU3RhdGUpIHtcbiAgICAgICAgLy8gU2V0IGV4dHJhIHNoYWRlciBhdHRyaWJ1dGUgZGF0YS5cbiAgICAgICAgbGV0IG9mZnNldCA9IHJlbmRlclN0YXRlLmxlbmd0aCAqIDgwO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHJlbmRlclN0YXRlLnF1YWRPcGVyYXRpb25zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUucXVhZE9wZXJhdGlvbnNbaV0uZXh0cmFBdHRyaWJzRGF0YUJ5dGVPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBsZXQgZXh0cmEgPSByZW5kZXJTdGF0ZS5xdWFkT3BlcmF0aW9uc1tpXS5zaGFkZXIuZ2V0RXh0cmFBdHRyaWJCeXRlc1BlclZlcnRleCgpICogNCAqIHJlbmRlclN0YXRlLnF1YWRPcGVyYXRpb25zW2ldLmxlbmd0aDtcbiAgICAgICAgICAgIG9mZnNldCArPSBleHRyYTtcbiAgICAgICAgICAgIGlmIChleHRyYSkge1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnF1YWRPcGVyYXRpb25zW2ldLnNoYWRlci5zZXRFeHRyYUF0dHJpYnNJbkJ1ZmZlcihyZW5kZXJTdGF0ZS5xdWFkT3BlcmF0aW9uc1tpXSwgcmVuZGVyU3RhdGUucXVhZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlclN0YXRlLnF1YWRzLmRhdGFMZW5ndGggPSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgY29weVJlbmRlclRleHR1cmUocmVuZGVyVGV4dHVyZSwgbmF0aXZlVGV4dHVyZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuc3RhZ2UuZ2w7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG5hdGl2ZVRleHR1cmUpO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRleHR1cmUuZnJhbWVidWZmZXIpO1xuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSByZW5kZXJUZXh0dXJlLnByZWNpc2lvbjtcbiAgICAgICAgZ2wuY29weVRleFN1YkltYWdlMkQoXG4gICAgICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHByZWNpc2lvbiAqIChvcHRpb25zLnN4IHx8IDApLFxuICAgICAgICAgICAgcHJlY2lzaW9uICogKG9wdGlvbnMuc3kgfHwgMCksXG4gICAgICAgICAgICBwcmVjaXNpb24gKiAob3B0aW9ucy54IHx8IDApLFxuICAgICAgICAgICAgcHJlY2lzaW9uICogKG9wdGlvbnMueSB8fCAwKSxcbiAgICAgICAgICAgIHByZWNpc2lvbiAqIChvcHRpb25zLncgfHwgcmVuZGVyVGV4dHVyZS5vdyksXG4gICAgICAgICAgICBwcmVjaXNpb24gKiAob3B0aW9ucy5oIHx8IHJlbmRlclRleHR1cmUub2gpKTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBXZWJHTFNoYWRlclByb2dyYW0gZnJvbSBcIi4vV2ViR0xTaGFkZXJQcm9ncmFtLm1qc1wiO1xuaW1wb3J0IFNoYWRlciBmcm9tIFwiLi4vLi4vdHJlZS9TaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMU2hhZGVyIGV4dGVuZHMgU2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICBzdXBlcihjdHgpO1xuXG4gICAgICAgIGNvbnN0IHN0YWdlID0gY3R4LnN0YWdlO1xuXG4gICAgICAgIHRoaXMuX3Byb2dyYW0gPSBzdGFnZS5yZW5kZXJlci5zaGFkZXJQcm9ncmFtcy5nZXQodGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmICghdGhpcy5fcHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbSA9IG5ldyBXZWJHTFNoYWRlclByb2dyYW0odGhpcy5jb25zdHJ1Y3Rvci52ZXJ0ZXhTaGFkZXJTb3VyY2UsIHRoaXMuY29uc3RydWN0b3IuZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuXG4gICAgICAgICAgICAvLyBMZXQgdGhlIHZibyBjb250ZXh0IHBlcmZvcm0gZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgc3RhZ2UucmVuZGVyZXIuc2hhZGVyUHJvZ3JhbXMuc2V0KHRoaXMuY29uc3RydWN0b3IsIHRoaXMuX3Byb2dyYW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbCA9IHN0YWdlLmdsO1xuICAgIH1cblxuICAgIGdldCBnbFByb2dyYW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9ncmFtLmdsUHJvZ3JhbTtcbiAgICB9XG5cbiAgICBfaW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLl9wcm9ncmFtLmNvbXBpbGUodGhpcy5nbCk7XG4gICAgfVxuXG4gICAgZ2V0IGluaXRpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6ZWQ7XG4gICAgfVxuXG4gICAgX3VuaWZvcm0obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbS5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgfVxuXG4gICAgX2F0dHJpYihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9ncmFtLmdldEF0dHJpYkxvY2F0aW9uKG5hbWUpO1xuICAgIH1cblxuICAgIF9zZXRVbmlmb3JtKG5hbWUsIHZhbHVlLCBnbEZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuX3Byb2dyYW0uc2V0VW5pZm9ybVZhbHVlKG5hbWUsIHZhbHVlLCBnbEZ1bmN0aW9uKTtcbiAgICB9XG5cbiAgICB1c2VQcm9ncmFtKCkge1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLmdsUHJvZ3JhbSk7XG4gICAgICAgIHRoaXMuYmVmb3JlVXNhZ2UoKTtcbiAgICAgICAgdGhpcy5lbmFibGVBdHRyaWJzKCk7XG4gICAgfVxuXG4gICAgc3RvcFByb2dyYW0oKSB7XG4gICAgICAgIHRoaXMuYWZ0ZXJVc2FnZSgpO1xuICAgICAgICB0aGlzLmRpc2FibGVBdHRyaWJzKCk7XG4gICAgfVxuXG4gICAgaGFzU2FtZVByb2dyYW0ob3RoZXIpIHtcbiAgICAgICAgLy8gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIGZpcnN0IGNoZWNrIGZvciBpZGVudGljYWwgcmVmZXJlbmNlcy5cbiAgICAgICAgcmV0dXJuIChvdGhlciAmJiAoKG90aGVyID09PSB0aGlzKSB8fCAob3RoZXIuX3Byb2dyYW0gPT09IHRoaXMuX3Byb2dyYW0pKSk7XG4gICAgfVxuXG4gICAgYmVmb3JlVXNhZ2UoKSB7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRvIHNldCBzZXR0aW5ncyBvdGhlciB0aGFuIHRoZSBkZWZhdWx0IHNldHRpbmdzIChibGVuZCBtb2RlIGV0YykuXG4gICAgfVxuXG4gICAgYWZ0ZXJVc2FnZSgpIHtcbiAgICAgICAgLy8gQWxsIHNldHRpbmdzIGNoYW5nZWQgaW4gYmVmb3JlVXNhZ2Ugc2hvdWxkIGJlIHJlc2V0IGhlcmUuXG4gICAgfVxuXG4gICAgZW5hYmxlQXR0cmlicygpIHtcblxuICAgIH1cblxuICAgIGRpc2FibGVBdHRyaWJzKCkge1xuXG4gICAgfVxuXG4gICAgZ2V0RXh0cmFBdHRyaWJCeXRlc1BlclZlcnRleCgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZ2V0VmVydGV4QXR0cmliUG9pbnRlck9mZnNldChvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5leHRyYUF0dHJpYnNEYXRhQnl0ZU9mZnNldCAtIG9wZXJhdGlvbi5pbmRleCAqIDQgKiB0aGlzLmdldEV4dHJhQXR0cmliQnl0ZXNQZXJWZXJ0ZXgoKTtcbiAgICB9XG5cbiAgICBzZXRFeHRyYUF0dHJpYnNJbkJ1ZmZlcihvcGVyYXRpb24pIHtcbiAgICAgICAgLy8gU2V0IGV4dHJhIGF0dHJpYiBkYXRhIGluIGluIG9wZXJhdGlvbi5xdWFkcy5kYXRhL2Zsb2F0cy91aW50cywgc3RhcnRpbmcgZnJvbVxuICAgICAgICAvLyBvcGVyYXRpb24uZXh0cmFBdHRyaWJzQnVmZmVyQnl0ZU9mZnNldC5cbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICAvLyBTZXQgYWxsIHNoYWRlci1zcGVjaWZpYyB1bmlmb3Jtcy5cbiAgICAgICAgLy8gTm90aWNlIHRoYXQgYWxsIHVuaWZvcm1zIHNob3VsZCBiZSBzZXQsIGV2ZW4gaWYgdGhleSBoYXZlIG5vdCBiZWVuIGNoYW5nZWQgd2l0aGluIHRoaXMgc2hhZGVyIGluc3RhbmNlLlxuICAgICAgICAvLyBUaGUgdW5pZm9ybXMgYXJlIHNoYXJlZCBieSBhbGwgc2hhZGVycyB0aGF0IGhhdmUgdGhlIHNhbWUgdHlwZSAoYW5kIHNoYWRlciBwcm9ncmFtKS5cbiAgICB9XG5cbiAgICBfZ2V0UHJvamVjdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5nZXRQcm9qZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgZ2V0RmxpcFkob3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm9qZWN0aW9uKG9wZXJhdGlvbilbMV0gPCAwO1xuICAgIH1cblxuICAgIGJlZm9yZURyYXcob3BlcmF0aW9uKSB7XG4gICAgfVxuXG4gICAgZHJhdyhvcGVyYXRpb24pIHtcbiAgICB9XG5cbiAgICBhZnRlckRyYXcob3BlcmF0aW9uKSB7XG4gICAgfVxuXG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gUHJvZ3JhbSB0YWtlcyBsaXR0bGUgcmVzb3VyY2VzLCBzbyBpdCBpcyBvbmx5IGRlc3Ryb3llZCB3aGVuIHRoZSBmdWxsIHN0YWdlIGlzIGRlc3Ryb3llZC5cbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQmFzZSBmdW5jdGlvbmFsaXR5IGZvciBzaGFkZXIgc2V0dXAvZGVzdHJveS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xTaGFkZXJQcm9ncmFtIHtcblxuICAgIGNvbnN0cnVjdG9yKHZlcnRleFNoYWRlclNvdXJjZSwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpIHtcblxuICAgICAgICB0aGlzLnZlcnRleFNoYWRlclNvdXJjZSA9IHZlcnRleFNoYWRlclNvdXJjZTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGZyYWdtZW50U2hhZGVyU291cmNlO1xuXG4gICAgICAgIHRoaXMuX3Byb2dyYW0gPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3VuaWZvcm1Mb2NhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZUxvY2F0aW9ucyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLl9jdXJyZW50VW5pZm9ybVZhbHVlcyA9IHt9O1xuICAgIH1cblxuICAgIGNvbXBpbGUoZ2wpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyYW0pIHJldHVybjtcblxuICAgICAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAgICAgdGhpcy5fcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgICAgICBsZXQgZ2xWZXJ0U2hhZGVyID0gdGhpcy5fZ2xDb21waWxlKGdsLlZFUlRFWF9TSEFERVIsIHRoaXMudmVydGV4U2hhZGVyU291cmNlKTtcbiAgICAgICAgbGV0IGdsRnJhZ1NoYWRlciA9IHRoaXMuX2dsQ29tcGlsZShnbC5GUkFHTUVOVF9TSEFERVIsIHRoaXMuZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcih0aGlzLl9wcm9ncmFtLCBnbFZlcnRTaGFkZXIpO1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIodGhpcy5fcHJvZ3JhbSwgZ2xGcmFnU2hhZGVyKTtcbiAgICAgICAgZ2wubGlua1Byb2dyYW0odGhpcy5fcHJvZ3JhbSk7XG5cbiAgICAgICAgLy8gaWYgbGlua2luZyBmYWlscywgdGhlbiBsb2cgYW5kIGNsZWFudXBcbiAgICAgICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMuX3Byb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0xpZ2h0bmluZ10gRXJyb3I6IENvdWxkIG5vdCBpbml0aWFsaXplIHNoYWRlci4nKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tMaWdodG5pbmddIGdsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5fcHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTKSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbTGlnaHRuaW5nXSBnbC5nZXRFcnJvcigpJywgZ2wuZ2V0RXJyb3IoKSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgcHJvZ3JhbSBpbmZvIGxvZywgbG9nIGl0XG4gICAgICAgICAgICBpZiAoZ2wuZ2V0UHJvZ3JhbUluZm9Mb2codGhpcy5fcHJvZ3JhbSkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbTGlnaHRuaW5nXSBXYXJuaW5nOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2codGhpcy5fcHJvZ3JhbSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHRoaXMuX3Byb2dyYW0pO1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbiB1cCBzb21lIHNoYWRlcnNcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGdsVmVydFNoYWRlcik7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihnbEZyYWdTaGFkZXIpO1xuICAgIH1cblxuICAgIF9nbENvbXBpbGUodHlwZSwgc3JjKSB7XG4gICAgICAgIGxldCBzaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcblxuICAgICAgICB0aGlzLmdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNyYyk7XG4gICAgICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgICAgIGlmICghdGhpcy5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCB0aGlzLmdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0xpZ2h0bmluZ10nLCB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsICdUeXBlOiAnICsgKHR5cGUgPT09IHRoaXMuZ2wuVkVSVEVYX1NIQURFUiA/ICd2ZXJ0ZXggc2hhZGVyJyA6ICdmcmFnbWVudCBzaGFkZXInKSApO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0xpZ2h0bmluZ10nLCB0aGlzLmdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tMaWdodG5pbmddJywgXCI9PT09PT09PT09IHNvdXJjZSA9PT09PT09PT09XFxuXCIgKyBzcmMuc3BsaXQoXCJcXG5cIikubWFwKGxpbmUgPT4gXCJcIiArICgrK2lkeCkgKyBcIjogXCIgKyBsaW5lKS5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICB9XG5cbiAgICBnZXRVbmlmb3JtTG9jYXRpb24obmFtZSkge1xuICAgICAgICBsZXQgbG9jYXRpb24gPSB0aGlzLl91bmlmb3JtTG9jYXRpb25zLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGxvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgbmFtZSk7XG4gICAgICAgICAgICB0aGlzLl91bmlmb3JtTG9jYXRpb25zLnNldChuYW1lLCBsb2NhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfVxuXG4gICAgZ2V0QXR0cmliTG9jYXRpb24obmFtZSkge1xuICAgICAgICBsZXQgbG9jYXRpb24gPSB0aGlzLl9hdHRyaWJ1dGVMb2NhdGlvbnMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAobG9jYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sIG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlTG9jYXRpb25zLnNldChuYW1lLCBsb2NhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLl9wcm9ncmFtKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGdsUHJvZ3JhbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyYW07XG4gICAgfVxuXG4gICAgZ2V0IGNvbXBpbGVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9wcm9ncmFtO1xuICAgIH1cblxuICAgIF92YWx1ZUVxdWFscyh2MSwgdjIpIHtcbiAgICAgICAgLy8gVW5pZm9ybSB2YWx1ZSBpcyBlaXRoZXIgYSB0eXBlZCBhcnJheSBvciBhIG51bWVyaWMgdmFsdWUuXG4gICAgICAgIGlmICh2MS5sZW5ndGggJiYgdjIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHYxLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh2MVtpXSAhPT0gdjJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICh2MSA9PT0gdjIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3ZhbHVlQ2xvbmUodikge1xuICAgICAgICBpZiAodi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB2LnNsaWNlKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRVbmlmb3JtVmFsdWUobmFtZSwgdmFsdWUsIGdsRnVuY3Rpb24pIHtcbiAgICAgICAgbGV0IHYgPSB0aGlzLl9jdXJyZW50VW5pZm9ybVZhbHVlc1tuYW1lXTtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCAhdGhpcy5fdmFsdWVFcXVhbHModiwgdmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgY2xvbmVkVmFsdWUgPSB0aGlzLl92YWx1ZUNsb25lKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRVbmlmb3JtVmFsdWVzW25hbWVdID0gY2xvbmVkVmFsdWU7XG5cbiAgICAgICAgICAgIGxldCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICAgICAgICAgIGlmIChsb2MpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNNYXRyaXggPSAoZ2xGdW5jdGlvbiA9PT0gdGhpcy5nbC51bmlmb3JtTWF0cml4MmZ2IHx8IGdsRnVuY3Rpb24gPT09IHRoaXMuZ2wudW5pZm9ybU1hdHJpeDNmdiB8fCBnbEZ1bmN0aW9uID09PSB0aGlzLmdsLnVuaWZvcm1NYXRyaXg0ZnYpO1xuICAgICAgICAgICAgICAgIGlmIChpc01hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICBnbEZ1bmN0aW9uLmNhbGwodGhpcy5nbCwgbG9jLCBmYWxzZSwgY2xvbmVkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdsRnVuY3Rpb24uY2FsbCh0aGlzLmdsLCBsb2MsIGNsb25lZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbi8qKlxuICogNHg0IGJveCBibHVyIHNoYWRlciB3aGljaCB3b3JrcyBpbiBjb25qdW5jdGlvbiB3aXRoIGEgNTAlIHJlc2NhbGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJveEJsdXJTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgY29uc3QgZHggPSAxLjAgLyBvcGVyYXRpb24uZ2V0VGV4dHVyZVdpZHRoKDApO1xuICAgICAgICBjb25zdCBkeSA9IDEuMCAvIG9wZXJhdGlvbi5nZXRUZXh0dXJlSGVpZ2h0KDApO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwic3RlcFRleHR1cmVDb29yZFwiLCBuZXcgRmxvYXQzMkFycmF5KFtkeCwgZHldKSwgdGhpcy5nbC51bmlmb3JtMmZ2KTtcbiAgICB9XG5cbn1cblxuQm94Qmx1clNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdW5pZm9ybSB2ZWMyIHN0ZXBUZXh0dXJlQ29vcmQ7XG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG4gICAgYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xuICAgIHVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmRVbDtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZFVyO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkQmw7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmRCcjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhVmVydGV4UG9zaXRpb24ueCAqIHByb2plY3Rpb24ueCAtIDEuMCwgYVZlcnRleFBvc2l0aW9uLnkgKiAtYWJzKHByb2plY3Rpb24ueSkgKyAxLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgdlRleHR1cmVDb29yZFVsID0gYVRleHR1cmVDb29yZCAtIHN0ZXBUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZUZXh0dXJlQ29vcmRCciA9IGFUZXh0dXJlQ29vcmQgKyBzdGVwVGV4dHVyZUNvb3JkO1xuICAgICAgICB2VGV4dHVyZUNvb3JkVXIgPSB2ZWMyKHZUZXh0dXJlQ29vcmRCci54LCB2VGV4dHVyZUNvb3JkVWwueSk7XG4gICAgICAgIHZUZXh0dXJlQ29vcmRCbCA9IHZlYzIodlRleHR1cmVDb29yZFVsLngsIHZUZXh0dXJlQ29vcmRCci55KTtcbiAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xuICAgICAgICBnbF9Qb3NpdGlvbi55ID0gLXNpZ24ocHJvamVjdGlvbi55KSAqIGdsX1Bvc2l0aW9uLnk7XG4gICAgfVxuYDtcblxuQm94Qmx1clNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZFVsO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkVXI7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmRCbDtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZEJyO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICB2ZWM0IGNvbG9yID0gMC4yNSAqICh0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmRVbCkgKyB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmRVcikgKyB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmRCbCkgKyB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmRCcikpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAqIHZDb2xvcjtcbiAgICB9XG5gO1xuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uLy4uLy4uL3RyZWUvVXRpbHMubWpzXCI7XG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXJjdWxhclB1c2hTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICBzdXBlcihjdHgpO1xuXG4gICAgICAgIHRoaXMuX2lucHV0VmFsdWUgPSAwO1xuXG4gICAgICAgIHRoaXMuX21heERlcml2YXRpdmUgPSAwLjAxO1xuXG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRWYWx1ZSA9IDA7XG5cbiAgICAgICAgLy8gVGhlIG9mZnNldCBiZXR3ZWVuIGJ1Y2tldHMuIEEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAgICB0aGlzLl9vZmZzZXQgPSAwO1xuXG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IDAuMTtcblxuICAgICAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IDE7XG5cbiAgICAgICAgdGhpcy5fb2Zmc2V0WCA9IDA7XG5cbiAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IDA7XG5cbiAgICAgICAgdGhpcy5idWNrZXRzID0gMTAwO1xuICAgIH1cblxuICAgIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FzcGVjdFJhdGlvO1xuICAgIH1cblxuICAgIHNldCBhc3BlY3RSYXRpbyh2KSB7XG4gICAgICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgb2Zmc2V0WCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldFg7XG4gICAgfVxuXG4gICAgc2V0IG9mZnNldFgodikge1xuICAgICAgICB0aGlzLl9vZmZzZXRYID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgb2Zmc2V0WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldFk7XG4gICAgfVxuXG4gICAgc2V0IG9mZnNldFkodikge1xuICAgICAgICB0aGlzLl9vZmZzZXRZID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXQgYW1vdW50KHYpIHtcbiAgICAgICAgdGhpcy5fYW1vdW50ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgYW1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1vdW50O1xuICAgIH1cblxuICAgIHNldCBpbnB1dFZhbHVlKHYpIHtcbiAgICAgICAgdGhpcy5faW5wdXRWYWx1ZSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGlucHV0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dFZhbHVlO1xuICAgIH1cblxuICAgIHNldCBtYXhEZXJpdmF0aXZlKHYpIHtcbiAgICAgICAgdGhpcy5fbWF4RGVyaXZhdGl2ZSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IG1heERlcml2YXRpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhEZXJpdmF0aXZlO1xuICAgIH1cblxuICAgIHNldCBidWNrZXRzKHYpIHtcbiAgICAgICAgaWYgKHYgPiAxMDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltMaWdodG5pbmddIENpcmN1bGFyUHVzaFNoYWRlcjogc3VwcG9ydHMgbWF4IDEwMCBidWNrZXRzXCIpO1xuICAgICAgICAgICAgdiA9IDEwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIHNldCBiZWZvcmUgc3RhcnRpbmcuXG4gICAgICAgIHRoaXMuX2J1Y2tldHMgPSB2O1xuXG4gICAgICAgIC8vIEluaXQgdmFsdWVzIGFycmF5IGluIHRoZSBjb3JyZWN0IGxlbmd0aC5cbiAgICAgICAgdGhpcy5fdmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fZ2V0VmFsdWVzKHYpKTtcblxuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBidWNrZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVja2V0cztcbiAgICB9XG5cbiAgICBfZ2V0VmFsdWVzKG4pIHtcbiAgICAgICAgY29uc3QgdiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdi5wdXNoKHRoaXMuX2lucHV0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2dyZXNzZXMgdGhlIHNoYWRlciB3aXRoIHRoZSBzcGVjaWZpZWQgKGZyYWN0aW9uYWwpIG51bWJlciBvZiBidWNrZXRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvO1xuICAgICAqICAgQSBudW1iZXIgZnJvbSAwIHRvIDEgKDEgPSBhbGwgYnVja2V0cykuXG4gICAgICovXG4gICAgcHJvZ3Jlc3Mobykge1xuICAgICAgICB0aGlzLl9vZmZzZXQgKz0gbyAqIHRoaXMuX2J1Y2tldHM7XG4gICAgICAgIGNvbnN0IGZ1bGwgPSBNYXRoLmZsb29yKHRoaXMuX29mZnNldCk7XG4gICAgICAgIHRoaXMuX29mZnNldCAtPSBmdWxsO1xuICAgICAgICB0aGlzLl9zaGlmdEJ1Y2tldHMoZnVsbCk7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgX3NoaWZ0QnVja2V0cyhuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9idWNrZXRzIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEluZGV4ID0gaSAtIG47XG4gICAgICAgICAgICBpZiAodGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplZFZhbHVlID0gTWF0aC5taW4odGhpcy5fbm9ybWFsaXplZFZhbHVlICsgdGhpcy5fbWF4RGVyaXZhdGl2ZSwgTWF0aC5tYXgodGhpcy5fbm9ybWFsaXplZFZhbHVlIC0gdGhpcy5fbWF4RGVyaXZhdGl2ZSwgdGhpcy5faW5wdXRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpXSA9IDI1NSAqIHRoaXMuX25vcm1hbGl6ZWRWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2ldID0gdGhpcy5fdmFsdWVzW3RhcmdldEluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCBvZmZzZXQodikge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImFzcGVjdFJhdGlvXCIsIHRoaXMuX2FzcGVjdFJhdGlvLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJvZmZzZXRYXCIsIHRoaXMuX29mZnNldFgsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcIm9mZnNldFlcIiwgdGhpcy5fb2Zmc2V0WSwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiYW1vdW50XCIsIHRoaXMuX2Ftb3VudCwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwib2Zmc2V0XCIsIHRoaXMuX29mZnNldCwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiYnVja2V0c1wiLCB0aGlzLl9idWNrZXRzLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJ1VmFsdWVTYW1wbGVyXCIsIDEsIHRoaXMuZ2wudW5pZm9ybTFpKTtcbiAgICB9XG5cbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1vdW50ID09PSAwO1xuICAgIH1cblxuICAgIGJlZm9yZURyYXcob3BlcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gICAgICAgIGlmICghdGhpcy5fdmFsdWVzVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3ZhbHVlc1RleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfQkxVRV9SRUQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdmFsdWVzVGV4dHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGxvYWQgbmV3IHZhbHVlcy5cbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5BTFBIQSwgdGhpcy5fYnVja2V0cywgMSwgMCwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgIH1cblxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0aGlzLl92YWx1ZXNUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy5fdmFsdWVzVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuXG5DaXJjdWxhclB1c2hTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgIGF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzIgcHJvamVjdGlvbjtcbiAgICB1bmlmb3JtIGZsb2F0IG9mZnNldFg7XG4gICAgdW5pZm9ybSBmbG9hdCBvZmZzZXRZO1xuICAgIHVuaWZvcm0gZmxvYXQgYXNwZWN0UmF0aW87XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWMyIHZQb3M7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhVmVydGV4UG9zaXRpb24ueCAqIHByb2plY3Rpb24ueCAtIDEuMCwgYVZlcnRleFBvc2l0aW9uLnkgKiAtYWJzKHByb2plY3Rpb24ueSkgKyAxLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZQb3MgPSB2VGV4dHVyZUNvb3JkICogMi4wIC0gMS4wO1xuICAgICAgICB2UG9zLnkgPSB2UG9zLnkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgdlBvcy55ID0gdlBvcy55ICsgb2Zmc2V0WTtcbiAgICAgICAgdlBvcy54ID0gdlBvcy54ICsgb2Zmc2V0WDtcbiAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xuICAgICAgICBnbF9Qb3NpdGlvbi55ID0gLXNpZ24ocHJvamVjdGlvbi55KSAqIGdsX1Bvc2l0aW9uLnk7XG4gICAgfVxuYDtcblxuQ2lyY3VsYXJQdXNoU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdmFyeWluZyB2ZWMyIHZQb3M7XG4gICAgdW5pZm9ybSBmbG9hdCBhbW91bnQ7XG4gICAgdW5pZm9ybSBmbG9hdCBvZmZzZXQ7XG4gICAgdW5pZm9ybSBmbG9hdCB2YWx1ZXNbMTAwXTtcbiAgICB1bmlmb3JtIGZsb2F0IGJ1Y2tldHM7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVZhbHVlU2FtcGxlcjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGZsb2F0IGwgPSBsZW5ndGgodlBvcyk7XG4gICAgICAgIGZsb2F0IG0gPSAobCAqIGJ1Y2tldHMgKiAwLjY3OCAtIG9mZnNldCkgLyBidWNrZXRzO1xuICAgICAgICBmbG9hdCBmID0gdGV4dHVyZTJEKHVWYWx1ZVNhbXBsZXIsIHZlYzIobSwgMC4wKSkuYSAqIGFtb3VudDtcbiAgICAgICAgdmVjMiB1bml0ID0gdlBvcyAvIGw7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCAtIGYgKiB1bml0KSAqIHZDb2xvcjtcbiAgICB9XG5gO1xuXG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBXZWJHTFNoYWRlciBmcm9tIFwiLi4vV2ViR0xTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmF1bHRTaGFkZXIgZXh0ZW5kcyBXZWJHTFNoYWRlciB7XG5cbiAgICBlbmFibGVBdHRyaWJzKCkge1xuICAgICAgICAvLyBFbmFibGVzIHRoZSBhdHRyaWJzIGluIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLl9hdHRyaWIoXCJhVmVydGV4UG9zaXRpb25cIiksIDIsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDApO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhVmVydGV4UG9zaXRpb25cIikpO1xuXG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWIoXCJhVGV4dHVyZUNvb3JkXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLl9hdHRyaWIoXCJhVGV4dHVyZUNvb3JkXCIpLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIwLCAyICogNCk7XG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhVGV4dHVyZUNvb3JkXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWIoXCJhQ29sb3JcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBTb21lIHNoYWRlcnMgbWF5IGlnbm9yZSB0aGUgY29sb3IuXG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYihcImFDb2xvclwiKSwgNCwgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgMjAsIDQgKiA0KTtcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFDb2xvclwiKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNhYmxlQXR0cmlicygpIHtcbiAgICAgICAgLy8gRGlzYWJsZXMgdGhlIGF0dHJpYnMgaW4gdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYVZlcnRleFBvc2l0aW9uXCIpKTtcblxuICAgICAgICBpZiAodGhpcy5fYXR0cmliKFwiYVRleHR1cmVDb29yZFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhVGV4dHVyZUNvb3JkXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWIoXCJhQ29sb3JcIikgIT09IC0xKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYUNvbG9yXCIpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJwcm9qZWN0aW9uXCIsIHRoaXMuX2dldFByb2plY3Rpb24ob3BlcmF0aW9uKSwgdGhpcy5nbC51bmlmb3JtMmZ2LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZHJhdyhvcGVyYXRpb24pIHtcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gb3BlcmF0aW9uLmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZ2xUZXh0dXJlID0gb3BlcmF0aW9uLmdldFRleHR1cmUoMCk7XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdHggPSBvcGVyYXRpb24uZ2V0VGV4dHVyZShpKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2xUZXh0dXJlICE9PSB0eCkge1xuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBnbFRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2ICogKGkgLSBwb3MpLCBnbC5VTlNJR05FRF9TSE9SVCwgKHBvcyArIG9wZXJhdGlvbi5pbmRleCkgKiA2ICogMik7XG4gICAgICAgICAgICAgICAgICAgIGdsVGV4dHVyZSA9IHR4O1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBnbFRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYgKiAobGVuZ3RoIC0gcG9zKSwgZ2wuVU5TSUdORURfU0hPUlQsIChwb3MgKyBvcGVyYXRpb24uaW5kZXgpICogNiAqIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbkRlZmF1bHRTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgIGF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzIgcHJvamVjdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbi54ICogcHJvamVjdGlvbi54IC0gMS4wLCBhVmVydGV4UG9zaXRpb24ueSAqIC1hYnMocHJvamVjdGlvbi55KSArIDEuMCwgMC4wLCAxLjApO1xuICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xuICAgICAgICBnbF9Qb3NpdGlvbi55ID0gLXNpZ24ocHJvamVjdGlvbi55KSAqIGdsX1Bvc2l0aW9uLnk7XG4gICAgfVxuYDtcblxuRGVmYXVsdFNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvcjtcbiAgICB9XG5gO1xuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTm9pc2VUZXh0dXJlIGZyb20gXCIuLi8uLi8uLi90ZXh0dXJlcy9Ob2lzZVRleHR1cmUubWpzXCI7XG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG4vKipcbiAqIFRoaXMgc2hhZGVyIGNhbiBiZSB1c2VkIHRvIGZpeCBhIHByb2JsZW0gdGhhdCBpcyBrbm93biBhcyAnZ3JhZGllbnQgYmFuZGluZycuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpdGhlcmluZ1NoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKGN0eCk7XG5cbiAgICAgICAgdGhpcy5fbm9pc2VUZXh0dXJlID0gbmV3IE5vaXNlVGV4dHVyZShjdHguc3RhZ2UpO1xuXG4gICAgICAgIHRoaXMuX2dyYWluaW5nID0gMS8yNTY7XG5cbiAgICAgICAgdGhpcy5fcmFuZG9tID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2V0IGdyYWluaW5nKHYpIHtcbiAgICAgICAgdGhpcy5fZ3JhaW5pbmcgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldCByYW5kb20odikge1xuICAgICAgICB0aGlzLl9yYW5kb20gPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldEV4dHJhQXR0cmlic0luQnVmZmVyKG9wZXJhdGlvbikge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgbm9pc2UgdGV4dHVyZSBpcyB1cGxvYWRlZCB0byB0aGUgR1BVLlxuICAgICAgICB0aGlzLl9ub2lzZVRleHR1cmUubG9hZCgpO1xuXG4gICAgICAgIGxldCBvZmZzZXQgPSBvcGVyYXRpb24uZXh0cmFBdHRyaWJzRGF0YUJ5dGVPZmZzZXQgLyA0O1xuICAgICAgICBsZXQgZmxvYXRzID0gb3BlcmF0aW9uLnF1YWRzLmZsb2F0cztcblxuICAgICAgICBsZXQgbGVuZ3RoID0gb3BlcmF0aW9uLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBub2lzZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIHNvIHRoYXQgaXQgc3BhbnMgdGhlIGZ1bGwgZWxlbWVudC5cbiAgICAgICAgICAgIGxldCBicnggPSBvcGVyYXRpb24uZ2V0RWxlbWVudFdpZHRoKGkpIC8gdGhpcy5fbm9pc2VUZXh0dXJlLmdldFJlbmRlcldpZHRoKCk7XG4gICAgICAgICAgICBsZXQgYnJ5ID0gb3BlcmF0aW9uLmdldEVsZW1lbnRIZWlnaHQoaSkgLyB0aGlzLl9ub2lzZVRleHR1cmUuZ2V0UmVuZGVySGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIGxldCB1bHggPSAwO1xuICAgICAgICAgICAgbGV0IHVseSA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmFuZG9tKSB7XG4gICAgICAgICAgICAgICAgdWx4ID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgICAgICB1bHkgPSBNYXRoLnJhbmRvbSgpO1xuXG4gICAgICAgICAgICAgICAgYnJ4ICs9IHVseDtcbiAgICAgICAgICAgICAgICBicnkgKz0gdWx5O1xuXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmxpcCBmb3IgbW9yZSByYW5kb21uZXNzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gdWx4O1xuICAgICAgICAgICAgICAgICAgICB1bHggPSBicng7XG4gICAgICAgICAgICAgICAgICAgIGJyeCA9IHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmxpcCBmb3IgbW9yZSByYW5kb21uZXNzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gdWx5O1xuICAgICAgICAgICAgICAgICAgICB1bHkgPSBicnk7XG4gICAgICAgICAgICAgICAgICAgIGJyeSA9IHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTcGVjaWZ5IGFsbCBjb3JuZXIgcG9pbnRzLlxuICAgICAgICAgICAgZmxvYXRzW29mZnNldF0gPSB1bHg7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgMV0gPSB1bHk7XG5cbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyAyXSA9IGJyeDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyAzXSA9IHVseTtcblxuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDRdID0gYnJ4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDVdID0gYnJ5O1xuXG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgNl0gPSB1bHg7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgN10gPSBicnk7XG5cbiAgICAgICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYmVmb3JlRHJhdyhvcGVyYXRpb24pIHtcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLl9hdHRyaWIoXCJhTm9pc2VUZXh0dXJlQ29vcmRcIiksIDIsIGdsLkZMT0FULCBmYWxzZSwgOCwgdGhpcy5nZXRWZXJ0ZXhBdHRyaWJQb2ludGVyT2Zmc2V0KG9wZXJhdGlvbikpO1xuXG4gICAgICAgIGxldCBnbFRleHR1cmUgPSB0aGlzLl9ub2lzZVRleHR1cmUuc291cmNlLm5hdGl2ZVRleHR1cmU7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBnbFRleHR1cmUpO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICB9XG5cbiAgICBnZXRFeHRyYUF0dHJpYkJ5dGVzUGVyVmVydGV4KCkge1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJ1Tm9pc2VTYW1wbGVyXCIsIDEsIHRoaXMuZ2wudW5pZm9ybTFpKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImdyYWluaW5nXCIsIDIgKiB0aGlzLl9ncmFpbmluZywgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgIH1cblxuICAgIGVuYWJsZUF0dHJpYnMoKSB7XG4gICAgICAgIHN1cGVyLmVuYWJsZUF0dHJpYnMoKTtcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYU5vaXNlVGV4dHVyZUNvb3JkXCIpKTtcbiAgICB9XG5cbiAgICBkaXNhYmxlQXR0cmlicygpIHtcbiAgICAgICAgc3VwZXIuZGlzYWJsZUF0dHJpYnMoKTtcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFOb2lzZVRleHR1cmVDb29yZFwiKSk7XG4gICAgfVxuXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyYWluaW5nID09PSAwO1xuICAgIH1cblxuICAgIGFmdGVyRHJhdyhvcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX3JhbmRvbSkge1xuICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5EaXRoZXJpbmdTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFOb2lzZVRleHR1cmVDb29yZDtcbiAgICBhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XG4gICAgdW5pZm9ybSB2ZWMyIHByb2plY3Rpb247XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWMyIHZOb2lzZVRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbi54ICogcHJvamVjdGlvbi54IC0gMS4wLCBhVmVydGV4UG9zaXRpb24ueSAqIC1hYnMocHJvamVjdGlvbi55KSArIDEuMCwgMC4wLCAxLjApO1xuICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgdk5vaXNlVGV4dHVyZUNvb3JkID0gYU5vaXNlVGV4dHVyZUNvb3JkO1xuICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgPSAtc2lnbihwcm9qZWN0aW9uLnkpICogZ2xfUG9zaXRpb24ueTtcbiAgICB9XG5gO1xuXG5EaXRoZXJpbmdTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWMyIHZOb2lzZVRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVOb2lzZVNhbXBsZXI7XG4gICAgdW5pZm9ybSBmbG9hdCBncmFpbmluZztcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIHZlYzQgbm9pc2UgPSB0ZXh0dXJlMkQodU5vaXNlU2FtcGxlciwgdk5vaXNlVGV4dHVyZUNvb3JkKTtcbiAgICAgICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IChjb2xvciAqIHZDb2xvcikgKyBncmFpbmluZyAqIChub2lzZS5yIC0gMC41KTtcbiAgICB9XG5gO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSAnLi9EZWZhdWx0U2hhZGVyLm1qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhZGVPdXRTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9mYWRlID0gWzAsIDAsIDAsIDBdO1xuICAgIH1cblxuICAgIHNldCB0b3AobnVtKSB7XG4gICAgICAgIHRoaXMuX2ZhZGVbMF0gPSBudW07XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhZGVbMF07XG4gICAgfVxuXG4gICAgc2V0IHJpZ2h0KG51bSkge1xuICAgICAgICB0aGlzLl9mYWRlWzFdID0gbnVtO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhZGVbMV07XG4gICAgfVxuXG4gICAgc2V0IGJvdHRvbShudW0pIHtcbiAgICAgICAgdGhpcy5fZmFkZVsyXSA9IG51bTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgYm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFkZVsyXTtcbiAgICB9XG5cbiAgICBzZXQgbGVmdChudW0pIHtcbiAgICAgICAgdGhpcy5fZmFkZVszXSA9IG51bTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhZGVbM107XG4gICAgfVxuXG4gICAgc2V0IGZhZGUodikge1xuICAgICAgICBpZihBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICBpZih2Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZhZGUgPSBbdlswXSwgdlsxXSwgdlswXSwgdlsxXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHYubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmFkZSA9IFt2WzBdLCB2WzFdLCB2WzJdLCB0aGlzLl9mYWRlWzNdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHYubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmFkZSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYWRlID0gW3ZbMF0sIHZbMF0sIHZbMF0sIHZbMF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmFkZSA9IFt2LCB2LCB2LCB2XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBmYWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFkZTtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIGNvbnN0IG93bmVyID0gb3BlcmF0aW9uLnNoYWRlck93bmVyO1xuXG4gICAgICAgIGNvbnN0IHJlbmRlclByZWNpc2lvbiA9IHRoaXMuY3R4LnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpO1xuICAgICAgICBjb25zdCBmYWRlID0gdGhpcy5fZmFkZS5tYXAoKGYpID0+IGYgKiByZW5kZXJQcmVjaXNpb24pO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdmYWRlJywgIG5ldyBGbG9hdDMyQXJyYXkoZmFkZSksIHRoaXMuZ2wudW5pZm9ybTRmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3Jlc29sdXRpb24nLCBuZXcgRmxvYXQzMkFycmF5KFtvd25lci5fdyAqIHJlbmRlclByZWNpc2lvbiwgb3duZXIuX2ggKiByZW5kZXJQcmVjaXNpb25dKSwgdGhpcy5nbC51bmlmb3JtMmZ2KTtcbiAgICB9XG59XG5cbkZhZGVPdXRTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcbiAgICB1bmlmb3JtIHZlYzQgZmFkZTtcbiAgICBcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yO1xuICAgICAgICB2ZWMyIGhhbGZSZXMgPSAwLjUgKiByZXNvbHV0aW9uLnh5O1xuICAgICAgICB2ZWMyIHBvaW50ID0gdlRleHR1cmVDb29yZC54eSAqIHJlc29sdXRpb24ueHk7XG4gICAgICAgIFxuICAgICAgICB2ZWMyIHBvczE7XG4gICAgICAgIHZlYzIgcG9zMjtcbiAgICAgICAgdmVjMiBkO1xuICAgICAgICBmbG9hdCBjO1xuICAgICAgICBmbG9hdCB0ID0gMC4wO1xuICAgICAgICAgICAgIFxuICAgICAgICBpZihmYWRlWzBdID4gMC4wKSB7XG4gICAgICAgICAgICBwb3MxID0gdmVjMihwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgIHBvczIgPSB2ZWMyKHBvaW50LngsIHBvaW50LnkgKyBmYWRlWzBdKTtcbiAgICAgICAgICAgIGQgPSBwb3MyIC0gcG9zMTtcbiAgICAgICAgICAgIGMgPSBkb3QocG9zMSwgZCkgLyBkb3QoZCwgZCk7XG4gICAgICAgICAgICB0ID0gc21vb3Roc3RlcCgwLjAsIDEuMCwgY2xhbXAoYywgMC4wLCAxLjApKTtcbiAgICAgICAgICAgIGNvbG9yID0gbWl4KHZlYzQoMC4wKSwgY29sb3IsIHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihmYWRlWzFdID4gMC4wKSB7XG4gICAgICAgICAgICB2ZWMyIHBvczEgPSB2ZWMyKHBvaW50LnggLSByZXNvbHV0aW9uLnggLSBmYWRlWzFdLCB2VGV4dHVyZUNvb3JkLnkpO1xuICAgICAgICAgICAgdmVjMiBwb3MyID0gdmVjMihwb2ludC54IC0gcmVzb2x1dGlvbi54LCB2VGV4dHVyZUNvb3JkLnkpO1xuICAgICAgICAgICAgZCA9IHBvczEgLSBwb3MyO1xuICAgICAgICAgICAgYyA9IGRvdChwb3MyLCBkKSAvIGRvdChkLCBkKTtcbiAgICAgICAgICAgIHQgPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCBjbGFtcChjLCAwLjAsIDEuMCkpO1xuICAgICAgICAgICAgY29sb3IgPSBtaXgodmVjNCgwLjApLCBjb2xvciwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGZhZGVbMl0gPiAwLjApIHtcbiAgICAgICAgICAgIHZlYzIgcG9zMSA9IHZlYzIodlRleHR1cmVDb29yZC54LCBwb2ludC55IC0gcmVzb2x1dGlvbi55IC0gZmFkZVsyXSk7XG4gICAgICAgICAgICB2ZWMyIHBvczIgPSB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgcG9pbnQueSAtIHJlc29sdXRpb24ueSk7XG4gICAgICAgICAgICBkID0gcG9zMSAtIHBvczI7XG4gICAgICAgICAgICBjID0gZG90KHBvczIsIGQpIC8gZG90KGQsIGQpO1xuICAgICAgICAgICAgdCA9IHNtb290aHN0ZXAoMC4wLCAxLjAsIGNsYW1wKGMsIDAuMCwgMS4wKSk7XG4gICAgICAgICAgICBjb2xvciA9IG1peCh2ZWM0KDAuMCksIGNvbG9yLCB0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoZmFkZVszXSA+IDAuMCkge1xuICAgICAgICAgICAgcG9zMSA9IHZlYzIocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICBwb3MyID0gdmVjMihwb2ludC54ICsgZmFkZVszXSwgcG9pbnQueSk7XG4gICAgICAgICAgICBkID0gcG9zMiAtIHBvczE7XG4gICAgICAgICAgICBjID0gZG90KHBvczEsIGQpIC8gZG90KGQsIGQpO1xuICAgICAgICAgICAgdCA9IHNtb290aHN0ZXAoMC4wLCAxLjAsIGNsYW1wKGMsIDAuMCwgMS4wKSk7XG4gICAgICAgICAgICBjb2xvciA9IG1peCh2ZWM0KDAuMCksIGNvbG9yLCB0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG4gICAgfVxuYDtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhvbGVTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgICB0aGlzLl95ID0gMDtcbiAgICAgICAgdGhpcy5fdyA9IDA7XG4gICAgICAgIHRoaXMuX2ggPSAwO1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSAwO1xuICAgIH1cblxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9XG5cbiAgICBzZXQgeCh2KSB7XG4gICAgICAgIHRoaXMuX3ggPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9XG5cbiAgICBzZXQgeSh2KSB7XG4gICAgICAgIHRoaXMuX3kgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdztcbiAgICB9XG5cbiAgICBzZXQgdyh2KSB7XG4gICAgICAgIHRoaXMuX3cgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faDtcbiAgICB9XG5cbiAgICBzZXQgaCh2KSB7XG4gICAgICAgIHRoaXMuX2ggPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCByYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXM7XG4gICAgfVxuXG4gICAgc2V0IHJhZGl1cyh2KSB7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuXG4gICAgICAgIGNvbnN0IG93bmVyID0gb3BlcmF0aW9uLnNoYWRlck93bmVyO1xuICAgICAgICBjb25zdCByZW5kZXJQcmVjaXNpb24gPSB0aGlzLmN0eC5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKVxuXG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJ4XCIsIHRoaXMuX3ggKiByZW5kZXJQcmVjaXNpb24sIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInlcIiwgdGhpcy5feSAqIHJlbmRlclByZWNpc2lvbiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwid1wiLCB0aGlzLl93ICogcmVuZGVyUHJlY2lzaW9uLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJoXCIsIHRoaXMuX2ggKiByZW5kZXJQcmVjaXNpb24sIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncmFkaXVzJywgICh0aGlzLl9yYWRpdXMgKyAuNSkgKiByZW5kZXJQcmVjaXNpb24sIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncmVzb2x1dGlvbicsIG5ldyBGbG9hdDMyQXJyYXkoW293bmVyLl93ICogcmVuZGVyUHJlY2lzaW9uLCBvd25lci5faCAqIHJlbmRlclByZWNpc2lvbl0pLCB0aGlzLmdsLnVuaWZvcm0yZnYpO1xuICAgIH1cblxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5feCA9PT0gMCAmJiB0aGlzLl95ID09PSAwICYmIHRoaXMuX3cgPT09IDAgJiYgdGhpcy5faCA9PT0gMClcbiAgICB9XG59XG5cbkhvbGVTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gRGVmYXVsdFNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2U7XG5cbkhvbGVTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHVuaWZvcm0gZmxvYXQgeDtcbiAgICB1bmlmb3JtIGZsb2F0IHk7XG4gICAgdW5pZm9ybSBmbG9hdCB3O1xuICAgIHVuaWZvcm0gZmxvYXQgaDtcbiAgICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcbiAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcblxuICAgIGZsb2F0IHJvdW5kQm94KHZlYzIgcCwgdmVjMiBiLCBmbG9hdCByKSB7XG4gICAgICAgIGZsb2F0IGQgPSBsZW5ndGgobWF4KGFicyhwKS1iK3IsIDAuMSkpLXI7XG4gICAgICAgIHJldHVybiBzbW9vdGhzdGVwKDEuMCwgMC4wLCBkKTtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuICAgICAgICB2ZWMyIHBvcyA9IHZUZXh0dXJlQ29vcmQueHkgKiByZXNvbHV0aW9uIC0gdmVjMih4LCB5KSAtIHZlYzIodywgaCkgLyAyLjA7XG4gICAgICAgIHZlYzIgc2l6ZSA9IHZlYzIodywgaCkgLyAyLjA7XG4gICAgICAgIGZsb2F0IGIgPSByb3VuZEJveChwb3MsIHNpemUsIHJhZGl1cyk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IG1peChjb2xvciwgdmVjNCgwLjApLCBiKTtcbiAgICB9XG5gO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52ZXJzaW9uU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9hbW91bnQgPSAxO1xuICAgIH1cblxuICAgIHNldCBhbW91bnQodikge1xuICAgICAgICB0aGlzLl9hbW91bnQgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBhbW91bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbW91bnQ7XG4gICAgfVxuXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ftb3VudCA9PT0gMDtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJhbW91bnRcIiwgdGhpcy5fYW1vdW50LCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgfVxuXG59XG5cbkludmVyc2lvblNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHVuaWZvcm0gZmxvYXQgYW1vdW50O1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG4gICAgICAgIGNvbG9yLnJnYiA9IGNvbG9yLnJnYiAqICgxLjAgLSBhbW91bnQpICsgYW1vdW50ICogKDEuMCAqIGNvbG9yLmEgLSBjb2xvci5yZ2IpOyBcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiB2Q29sb3I7XG4gICAgfVxuYDtcblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlnaHQzZFNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKGN0eCk7XG5cbiAgICAgICAgdGhpcy5fc3RyZW5ndGggPSAwLjU7XG4gICAgICAgIHRoaXMuX2FtYmllbnQgPSAwLjU7XG4gICAgICAgIHRoaXMuX2Z1ZGdlID0gMC40O1xuXG4gICAgICAgIHRoaXMuX3J4ID0gMDtcbiAgICAgICAgdGhpcy5fcnkgPSAwO1xuXG4gICAgICAgIHRoaXMuX3ogPSAwO1xuICAgICAgICB0aGlzLl9waXZvdFggPSBOYU47XG4gICAgICAgIHRoaXMuX3Bpdm90WSA9IE5hTjtcbiAgICAgICAgdGhpcy5fcGl2b3RaID0gMDtcblxuICAgICAgICB0aGlzLl9saWdodFkgPSAwO1xuICAgICAgICB0aGlzLl9saWdodFogPSAwO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcblxuICAgICAgICBsZXQgdnIgPSBvcGVyYXRpb24uc2hhZGVyT3duZXI7XG4gICAgICAgIGxldCBlbGVtZW50ID0gdnIuZWxlbWVudDtcblxuICAgICAgICBsZXQgcGl2b3RYID0gaXNOYU4odGhpcy5fcGl2b3RYKSA/IGVsZW1lbnQucGl2b3RYICogdnIudyA6IHRoaXMuX3Bpdm90WDtcbiAgICAgICAgbGV0IHBpdm90WSA9IGlzTmFOKHRoaXMuX3Bpdm90WSkgPyBlbGVtZW50LnBpdm90WSAqIHZyLmggOiB0aGlzLl9waXZvdFk7XG4gICAgICAgIGxldCBjb29yZHMgPSB2ci5nZXRSZW5kZXJUZXh0dXJlQ29vcmRzKHBpdm90WCwgcGl2b3RZKTtcblxuICAgICAgICAvLyBDb3VudGVyIG5vcm1hbCByb3RhdGlvbi5cblxuICAgICAgICBsZXQgcnogPSAtTWF0aC5hdGFuMih2ci5fcmVuZGVyQ29udGV4dC50YywgdnIuX3JlbmRlckNvbnRleHQudGEpO1xuXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJwaXZvdFwiLCBuZXcgRmxvYXQzMkFycmF5KFtjb29yZHNbMF0sIGNvb3Jkc1sxXSwgdGhpcy5fcGl2b3RaXSksIGdsLnVuaWZvcm0zZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwicm90XCIsIG5ldyBGbG9hdDMyQXJyYXkoW3RoaXMuX3J4LCB0aGlzLl9yeSwgcnpdKSwgZ2wudW5pZm9ybTNmdik7XG5cbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInpcIiwgdGhpcy5feiwgZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImxpZ2h0WVwiLCB0aGlzLmxpZ2h0WSwgZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImxpZ2h0WlwiLCB0aGlzLmxpZ2h0WiwgZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInN0cmVuZ3RoXCIsIHRoaXMuX3N0cmVuZ3RoLCBnbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiYW1iaWVudFwiLCB0aGlzLl9hbWJpZW50LCBnbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiZnVkZ2VcIiwgdGhpcy5fZnVkZ2UsIGdsLnVuaWZvcm0xZik7XG4gICAgfVxuXG4gICAgc2V0IHN0cmVuZ3RoKHYpIHtcbiAgICAgICAgdGhpcy5fc3RyZW5ndGggPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBzdHJlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmVuZ3RoO1xuICAgIH1cblxuICAgIHNldCBhbWJpZW50KHYpIHtcbiAgICAgICAgdGhpcy5fYW1iaWVudCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGFtYmllbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbWJpZW50O1xuICAgIH1cblxuICAgIHNldCBmdWRnZSh2KSB7XG4gICAgICAgIHRoaXMuX2Z1ZGdlID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgZnVkZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mdWRnZTtcbiAgICB9XG5cbiAgICBnZXQgcngoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yeDtcbiAgICB9XG5cbiAgICBzZXQgcngodikge1xuICAgICAgICB0aGlzLl9yeCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnk7XG4gICAgfVxuXG4gICAgc2V0IHJ5KHYpIHtcbiAgICAgICAgdGhpcy5fcnkgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCB6KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fejtcbiAgICB9XG5cbiAgICBzZXQgeih2KSB7XG4gICAgICAgIHRoaXMuX3ogPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBwaXZvdFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXZvdFg7XG4gICAgfVxuXG4gICAgc2V0IHBpdm90WCh2KSB7XG4gICAgICAgIHRoaXMuX3Bpdm90WCA9IHYgKyAxO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBwaXZvdFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXZvdFk7XG4gICAgfVxuXG4gICAgc2V0IHBpdm90WSh2KSB7XG4gICAgICAgIHRoaXMuX3Bpdm90WSA9IHYgKyAxO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBsaWdodFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saWdodFk7XG4gICAgfVxuXG4gICAgc2V0IGxpZ2h0WSh2KSB7XG4gICAgICAgIHRoaXMuX2xpZ2h0WSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90WigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90WjtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3RaKHYpIHtcbiAgICAgICAgdGhpcy5fcGl2b3RaID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgbGlnaHRaKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlnaHRaO1xuICAgIH1cblxuICAgIHNldCBsaWdodFoodikge1xuICAgICAgICB0aGlzLl9saWdodFogPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fcnggPT09IDAgJiYgdGhpcy5fcnkgPT09IDAgJiYgdGhpcy5feiA9PT0gMCAmJiB0aGlzLl9zdHJlbmd0aCA9PT0gMCAmJiB0aGlzLl9hbWJpZW50ID09PSAxKTtcbiAgICB9XG5cbn1cblxuTGlnaHQzZFNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG4gICAgYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xuICAgIHVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbiAgICB1bmlmb3JtIGZsb2F0IGZ1ZGdlO1xuICAgIHVuaWZvcm0gZmxvYXQgc3RyZW5ndGg7XG4gICAgdW5pZm9ybSBmbG9hdCBhbWJpZW50O1xuICAgIHVuaWZvcm0gZmxvYXQgejtcbiAgICB1bmlmb3JtIGZsb2F0IGxpZ2h0WTtcbiAgICB1bmlmb3JtIGZsb2F0IGxpZ2h0WjtcbiAgICB1bmlmb3JtIHZlYzMgcGl2b3Q7XG4gICAgdW5pZm9ybSB2ZWMzIHJvdDtcbiAgICB2YXJ5aW5nIHZlYzMgcG9zO1xuXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcbiAgICAgICAgcG9zID0gdmVjMyhhVmVydGV4UG9zaXRpb24ueHksIHopO1xuICAgICAgICBcbiAgICAgICAgcG9zIC09IHBpdm90O1xuICAgICAgICBcbiAgICAgICAgLy8gVW5kbyBYWSByb3RhdGlvblxuICAgICAgICBtYXQyIGlSb3RYeSA9IG1hdDIoIGNvcyhyb3QueiksIHNpbihyb3QueiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLXNpbihyb3QueiksIGNvcyhyb3QueikpO1xuICAgICAgICBwb3MueHkgPSBpUm90WHkgKiBwb3MueHk7XG4gICAgICAgIFxuICAgICAgICAvLyBQZXJmb3JtIDNkIHJvdGF0aW9uc1xuICAgICAgICBnbF9Qb3NpdGlvbi54ID0gY29zKHJvdC54KSAqIHBvcy54IC0gc2luKHJvdC54KSAqIHBvcy56O1xuICAgICAgICBnbF9Qb3NpdGlvbi55ID0gcG9zLnk7XG4gICAgICAgIGdsX1Bvc2l0aW9uLnogPSBzaW4ocm90LngpICogcG9zLnggKyBjb3Mocm90LngpICogcG9zLno7XG4gICAgICAgIFxuICAgICAgICBwb3MueCA9IGdsX1Bvc2l0aW9uLng7XG4gICAgICAgIHBvcy55ID0gY29zKHJvdC55KSAqIGdsX1Bvc2l0aW9uLnkgLSBzaW4ocm90LnkpICogZ2xfUG9zaXRpb24uejtcbiAgICAgICAgcG9zLnogPSBzaW4ocm90LnkpICogZ2xfUG9zaXRpb24ueSArIGNvcyhyb3QueSkgKiBnbF9Qb3NpdGlvbi56O1xuICAgICAgICBcbiAgICAgICAgLy8gUmVkbyBYWSByb3RhdGlvblxuICAgICAgICBpUm90WHlbMF1bMV0gPSAtaVJvdFh5WzBdWzFdO1xuICAgICAgICBpUm90WHlbMV1bMF0gPSAtaVJvdFh5WzFdWzBdO1xuICAgICAgICBwb3MueHkgPSBpUm90WHkgKiBwb3MueHk7IFxuXG4gICAgICAgIC8vIFVuZG8gdHJhbnNsYXRlIHRvIHBpdm90IHBvc2l0aW9uXG4gICAgICAgIHBvcy54eXogKz0gcGl2b3Q7XG5cbiAgICAgICAgcG9zID0gdmVjMyhwb3MueCAqIHByb2plY3Rpb24ueCAtIDEuMCwgcG9zLnkgKiAtYWJzKHByb2plY3Rpb24ueSkgKyAxLjAsIHBvcy56ICogcHJvamVjdGlvbi54KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCBkZXB0aCBwZXJzcGVjdGl2ZVxuICAgICAgICBmbG9hdCBwZXJzcGVjdGl2ZSA9IDEuMCArIGZ1ZGdlICogcG9zLno7XG5cbiAgICAgICAgcG9zLnogKz0gbGlnaHRaICogcHJvamVjdGlvbi54O1xuXG4gICAgICAgIC8vIE1hcCBjb29yZHMgdG8gZ2wgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICAgICAgLy8gU2V0IHogdG8gMCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gcGVyZm9ybSB6LWNsaXBwaW5nXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIDAuMCwgcGVyc3BlY3RpdmUpO1xuXG4gICAgICAgIC8vIENvcnJlY3QgbGlnaHQgc291cmNlIHBvc2l0aW9uLlxuICAgICAgICBwb3MueSArPSBsaWdodFkgKiBhYnMocHJvamVjdGlvbi55KTtcblxuICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xuICAgICAgICBcbiAgICAgICAgZ2xfUG9zaXRpb24ueSA9IC1zaWduKHByb2plY3Rpb24ueSkgKiBnbF9Qb3NpdGlvbi55O1xuICAgIH1cbmA7XG5cbkxpZ2h0M2RTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB2YXJ5aW5nIHZlYzMgcG9zO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHVuaWZvcm0gZmxvYXQgYW1iaWVudDtcbiAgICB1bmlmb3JtIGZsb2F0IHN0cmVuZ3RoO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgdmVjNCByZ2JhID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcbiAgICAgICAgZmxvYXQgZCA9IGxlbmd0aChwb3MpO1xuICAgICAgICBmbG9hdCBuID0gMS4wIC8gbWF4KDAuMSwgZCk7XG4gICAgICAgIHJnYmEucmdiID0gcmdiYS5yZ2IgKiAoc3RyZW5ndGggKiBuICsgYW1iaWVudCk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHJnYmEgKiB2Q29sb3I7XG4gICAgfVxuYDtcblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZWFyQmx1clNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcblxuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAwXSk7XG4gICAgICAgIHRoaXMuX2tlcm5lbFJhZGl1cyA9IDE7XG4gICAgfVxuXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXJlY3Rpb25bMF07XG4gICAgfVxuXG4gICAgc2V0IHgodikge1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb25bMF0gPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uWzFdO1xuICAgIH1cblxuICAgIHNldCB5KHYpIHtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uWzFdID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQga2VybmVsUmFkaXVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2VybmVsUmFkaXVzO1xuICAgIH1cblxuICAgIHNldCBrZXJuZWxSYWRpdXModikge1xuICAgICAgICB0aGlzLl9rZXJuZWxSYWRpdXMgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9rZXJuZWxSYWRpdXMgPT09IDApO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImRpcmVjdGlvblwiLCB0aGlzLl9kaXJlY3Rpb24sIHRoaXMuZ2wudW5pZm9ybTJmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJrZXJuZWxSYWRpdXNcIiwgdGhpcy5fa2VybmVsUmFkaXVzLCB0aGlzLmdsLnVuaWZvcm0xaSk7XG5cbiAgICAgICAgY29uc3QgdyA9IG9wZXJhdGlvbi5nZXRSZW5kZXJXaWR0aCgpO1xuICAgICAgICBjb25zdCBoID0gb3BlcmF0aW9uLmdldFJlbmRlckhlaWdodCgpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwicmVzb2x1dGlvblwiLCBuZXcgRmxvYXQzMkFycmF5KFt3LCBoXSksIHRoaXMuZ2wudW5pZm9ybTJmdik7XG4gICAgfVxufVxuXG5MaW5lYXJCbHVyU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdW5pZm9ybSB2ZWMyIGRpcmVjdGlvbjtcbiAgICB1bmlmb3JtIGludCBrZXJuZWxSYWRpdXM7XG4gICAgXG4gICAgdmVjNCBibHVyMShzYW1wbGVyMkQgaW1hZ2UsIHZlYzIgdXYsIHZlYzIgcmVzb2x1dGlvbiwgdmVjMiBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcbiAgICAgICAgdmVjMiBvZmYxID0gdmVjMigxLjMzMzMzMzMzMzMzMzMzMzMpICogZGlyZWN0aW9uO1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2KSAqIDAuMjk0MTE3NjQ3MDU4ODIzNTQ7XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMzUyOTQxMTc2NDcwNTg4MjY7XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMzUyOTQxMTc2NDcwNTg4MjY7XG4gICAgICAgIHJldHVybiBjb2xvcjsgXG4gICAgfVxuICAgIFxuICAgIHZlYzQgYmx1cjIoc2FtcGxlcjJEIGltYWdlLCB2ZWMyIHV2LCB2ZWMyIHJlc29sdXRpb24sIHZlYzIgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XG4gICAgICAgIHZlYzIgb2ZmMSA9IHZlYzIoMS4zODQ2MTUzODQ2KSAqIGRpcmVjdGlvbjtcbiAgICAgICAgdmVjMiBvZmYyID0gdmVjMigzLjIzMDc2OTIzMDgpICogZGlyZWN0aW9uO1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2KSAqIDAuMjI3MDI3MDI3MDtcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4zMTYyMTYyMTYyO1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjMxNjIxNjIxNjI7XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMiAvIHJlc29sdXRpb24pKSAqIDAuMDcwMjcwMjcwMztcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYyIC8gcmVzb2x1dGlvbikpICogMC4wNzAyNzAyNzAzO1xuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIFxuICAgIHZlYzQgYmx1cjMoc2FtcGxlcjJEIGltYWdlLCB2ZWMyIHV2LCB2ZWMyIHJlc29sdXRpb24sIHZlYzIgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XG4gICAgICAgIHZlYzIgb2ZmMSA9IHZlYzIoMS40MTE3NjQ3MDU4ODIzNTMpICogZGlyZWN0aW9uO1xuICAgICAgICB2ZWMyIG9mZjIgPSB2ZWMyKDMuMjk0MTE3NjQ3MDU4ODIzNCkgKiBkaXJlY3Rpb247XG4gICAgICAgIHZlYzIgb2ZmMyA9IHZlYzIoNS4xNzY0NzA1ODgyMzUyOTQpICogZGlyZWN0aW9uO1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2KSAqIDAuMTk2NDgyNTUwMTUxMTQwNDtcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4yOTY5MDY5NjQ2NzI4MzQ0O1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjI5NjkwNjk2NDY3MjgzNDQ7XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMiAvIHJlc29sdXRpb24pKSAqIDAuMDk0NDcwMzk3ODUwNDQ3MzI7XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMiAvIHJlc29sdXRpb24pKSAqIDAuMDk0NDcwMzk3ODUwNDQ3MzI7XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMyAvIHJlc29sdXRpb24pKSAqIDAuMDEwMzgxMzYyNDAxMTQ4MDU3O1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjMgLyByZXNvbHV0aW9uKSkgKiAwLjAxMDM4MTM2MjQwMTE0ODA1NztcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH0gICAgXG5cbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGlmIChrZXJuZWxSYWRpdXMgPT0gMSkge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gYmx1cjEodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQsIHJlc29sdXRpb24sIGRpcmVjdGlvbikgKiB2Q29sb3I7XG4gICAgICAgIH0gZWxzZSBpZiAoa2VybmVsUmFkaXVzID09IDIpIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGJsdXIyKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkLCByZXNvbHV0aW9uLCBkaXJlY3Rpb24pICogdkNvbG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gYmx1cjModVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQsIHJlc29sdXRpb24sIGRpcmVjdGlvbikgKiB2Q29sb3I7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFnbmlmaWVyU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cdGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcblx0ICBzdXBlcihjb250ZXh0KTtcblx0ICB0aGlzLl94ID0gMDtcblx0ICB0aGlzLl95ID0gMDtcblx0ICB0aGlzLl93ID0gMDtcblx0ICB0aGlzLl9oID0gMDtcblx0ICB0aGlzLl9yYWRpdXMgPSAwO1xuXHQgIHRoaXMuX21hZ25pZmljYXRpb24gPSAwLjY7XG5cdH1cbiAgXG5cdGdldCB4KCkge1xuXHQgIHJldHVybiB0aGlzLl94O1xuXHR9XG4gIFxuXHRzZXQgeCh2KSB7XG5cdCAgdGhpcy5feCA9IHY7XG5cdCAgdGhpcy5yZWRyYXcoKTtcblx0fVxuICBcblx0Z2V0IHkoKSB7XG5cdCAgcmV0dXJuIHRoaXMuX3k7XG5cdH1cbiAgXG5cdHNldCB5KHYpIHtcblx0ICB0aGlzLl95ID0gdjtcblx0ICB0aGlzLnJlZHJhdygpO1xuXHR9XG4gIFxuXHRnZXQgdygpIHtcblx0ICByZXR1cm4gdGhpcy5fdztcblx0fVxuICBcblx0c2V0IHcodikge1xuXHQgIHRoaXMuX3cgPSB2O1xuXHQgIHRoaXMucmVkcmF3KCk7XG5cdH1cbiAgXG5cdGdldCBoKCkge1xuXHQgIHJldHVybiB0aGlzLl9oO1xuXHR9XG4gIFxuXHRzZXQgaCh2KSB7XG5cdCAgdGhpcy5faCA9IHY7XG5cdCAgdGhpcy5yZWRyYXcoKTtcblx0fVxuICBcblx0Z2V0IG1hZ25pZmljYXRpb24oKSB7XG5cdCAgcmV0dXJuIHRoaXMuX21hZ25pZmljYXRpb247XG5cdH1cbiAgXG5cdHNldCBtYWduaWZpY2F0aW9uKHYpIHtcblx0ICB0aGlzLl9tYWduaWZpY2F0aW9uID0gdjtcblx0ICB0aGlzLnJlZHJhdygpO1xuXHR9XG4gIFxuXHRnZXQgcmFkaXVzKCkge1xuXHQgIHJldHVybiB0aGlzLl9yYWRpdXM7XG5cdH1cbiAgXG5cdHNldCByYWRpdXModikge1xuXHQgIHRoaXMuX3JhZGl1cyA9IHY7XG5cdCAgdGhpcy5yZWRyYXcoKTtcblx0fVxuICBcblx0c2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcblx0ICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gIFxuXHQgIGNvbnN0IG93bmVyID0gb3BlcmF0aW9uLnNoYWRlck93bmVyO1xuXHQgIGNvbnN0IHJlbmRlclByZWNpc2lvbiA9IHRoaXMuY3R4LnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpO1xuXHQgIHRoaXMuX3NldFVuaWZvcm0oJ3gnLCB0aGlzLl94ICogcmVuZGVyUHJlY2lzaW9uLCB0aGlzLmdsLnVuaWZvcm0xZik7XG5cdCAgdGhpcy5fc2V0VW5pZm9ybSgneScsIHRoaXMuX3kgKiByZW5kZXJQcmVjaXNpb24sIHRoaXMuZ2wudW5pZm9ybTFmKTtcblx0ICB0aGlzLl9zZXRVbmlmb3JtKCd3JywgdGhpcy5fdyAqIHJlbmRlclByZWNpc2lvbiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuXHQgIHRoaXMuX3NldFVuaWZvcm0oJ2gnLCB0aGlzLl9oICogcmVuZGVyUHJlY2lzaW9uLCB0aGlzLmdsLnVuaWZvcm0xZik7XG5cdCAgdGhpcy5fc2V0VW5pZm9ybSgnbWFnbmlmaWNhdGlvbicsIHRoaXMuX21hZ25pZmljYXRpb24sIHRoaXMuZ2wudW5pZm9ybTFmKTtcblx0ICB0aGlzLl9zZXRVbmlmb3JtKFxuXHRcdCdyYWRpdXMnLFxuXHRcdCh0aGlzLl9yYWRpdXMgKyAwLjUpICogcmVuZGVyUHJlY2lzaW9uLFxuXHRcdHRoaXMuZ2wudW5pZm9ybTFmXG5cdCAgKTtcblx0ICB0aGlzLl9zZXRVbmlmb3JtKFxuXHRcdCdyZXNvbHV0aW9uJyxcblx0XHRuZXcgRmxvYXQzMkFycmF5KFtcblx0XHQgIG93bmVyLl93ICogcmVuZGVyUHJlY2lzaW9uLFxuXHRcdCAgb3duZXIuX2ggKiByZW5kZXJQcmVjaXNpb25cblx0XHRdKSxcblx0XHR0aGlzLmdsLnVuaWZvcm0yZnZcblx0ICApO1xuXHR9XG4gXG5cdHVzZURlZmF1bHQoKSB7XG5cdCAgcmV0dXJuIHRoaXMuX3cgPT09IDAgJiYgdGhpcy5faCA9PT0gMDtcblx0fVxuICB9XG4gIFxuICBNYWduaWZpZXJTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gRGVmYXVsdFNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2U7XG4gIFxuICBNYWduaWZpZXJTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG5cdCAgI2lmZGVmIEdMX0VTXG5cdFx0IyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblx0XHQjIGVsc2Vcblx0XHRwcmVjaXNpb24gbG93cCBmbG9hdDtcblx0XHQjIGVuZGlmXG5cdCAgI2VuZGlmXG5cblx0ICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcblx0ICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXHQgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuXHQgIHVuaWZvcm0gZmxvYXQgeDtcblx0ICB1bmlmb3JtIGZsb2F0IHk7XG5cdCAgdW5pZm9ybSBmbG9hdCB3O1xuXHQgIHVuaWZvcm0gZmxvYXQgaDtcblx0ICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcblx0ICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcblx0ICB1bmlmb3JtIGZsb2F0IG1hZ25pZmljYXRpb247XG4gIFxuXHQgIGZsb2F0IHJvdW5kQm94KHZlYzIgcCwgdmVjMiBiLCBmbG9hdCByKSB7XG5cdFx0ICBmbG9hdCBkID0gbGVuZ3RoKG1heChhYnMocCktYityLCAwLjEpKS1yO1xuXHRcdCAgcmV0dXJuIHNtb290aHN0ZXAoMS4wLCAwLjAsIGQpO1xuXHQgIH1cblxuXHQgIGZsb2F0IGluc2lkZSh2ZWMyIHYpIHtcblx0XHR2ZWMyIHMgPSBzdGVwKHZlYzIoMC4wLCAwLjApLCB2KSAtIHN0ZXAodmVjMigxLjAsIDEuMCksIHYpO1xuXHRcdHJldHVybiBzLnggKiBzLnk7ICAgXG4gICAgICB9XG4gIFxuXHQgIHZvaWQgbWFpbih2b2lkKSB7XG5cdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG5cdFx0dmVjMiBwb3MgPSB2VGV4dHVyZUNvb3JkLnh5ICogcmVzb2x1dGlvbiAtIHZlYzIoeCwgeSkgLSB2ZWMyKHcsIGgpIC8gMi4wO1xuXHRcdHZlYzIgc2l6ZSA9IHZlYzIodywgaCkgLyAyLjA7XG5cdFx0ZmxvYXQgYiA9IHJvdW5kQm94KHBvcywgc2l6ZSwgcmFkaXVzKTtcblx0XHR2ZWMyIHBvczIgPSAodlRleHR1cmVDb29yZC54eSAqIG1hZ25pZmljYXRpb24gKiByZXNvbHV0aW9uICsgdmVjMih4LCB5KSAqIG1hZ25pZmljYXRpb24pIC8gcmVzb2x1dGlvbjtcblx0XHRnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IsIHRleHR1cmUyRCh1U2FtcGxlciwgcG9zMikgKiBpbnNpZGUocG9zMiksIGIpICogdkNvbG9yO1xuXHQgIH1cbiAgYDtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuLi8uLi8uLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPdXRsaW5lU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoY3R4KTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSA1O1xuICAgICAgICB0aGlzLl9jb2wgPSAweEZGRkZGRkZGO1xuICAgICAgICB0aGlzLl9jb2xvciA9IFsxLDEsMSwxXTtcbiAgICB9XG5cbiAgICBzZXQgd2lkdGgodikge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sO1xuICAgIH1cblxuICAgIHNldCBjb2xvcih2KSB7XG4gICAgICAgIGlmICh0aGlzLl9jb2wgIT09IHYpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IFN0YWdlVXRpbHMuZ2V0UmdiYUNvbXBvbmVudHNOb3JtYWxpemVkKHYpO1xuICAgICAgICAgICAgY29sWzBdID0gY29sWzBdICogY29sWzNdO1xuICAgICAgICAgICAgY29sWzFdID0gY29sWzFdICogY29sWzNdO1xuICAgICAgICAgICAgY29sWzJdID0gY29sWzJdICogY29sWzNdO1xuXG4gICAgICAgICAgICB0aGlzLl9jb2xvciA9IGNvbDtcblxuICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcblxuICAgICAgICAgICAgdGhpcy5fY29sID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fd2lkdGggPT09IDAgfHwgdGhpcy5fY29sWzNdID09PSAwKTtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJjb2xvclwiLCBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX2NvbG9yKSwgZ2wudW5pZm9ybTRmdik7XG4gICAgfVxuXG4gICAgZW5hYmxlQXR0cmlicygpIHtcbiAgICAgICAgc3VwZXIuZW5hYmxlQXR0cmlicygpO1xuICAgICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFDb3JuZXJcIikpO1xuICAgIH1cblxuICAgIGRpc2FibGVBdHRyaWJzKCkge1xuICAgICAgICBzdXBlci5kaXNhYmxlQXR0cmlicygpO1xuICAgICAgICB0aGlzLmdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhQ29ybmVyXCIpKTtcbiAgICB9XG5cbiAgICBzZXRFeHRyYUF0dHJpYnNJbkJ1ZmZlcihvcGVyYXRpb24pIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IG9wZXJhdGlvbi5leHRyYUF0dHJpYnNEYXRhQnl0ZU9mZnNldCAvIDQ7XG4gICAgICAgIGxldCBmbG9hdHMgPSBvcGVyYXRpb24ucXVhZHMuZmxvYXRzO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSBvcGVyYXRpb24ubGVuZ3RoO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgY29uc3QgZWxlbWVudENvcmUgPSBvcGVyYXRpb24uZ2V0RWxlbWVudENvcmUoaSk7XG5cbiAgICAgICAgICAgIC8vIFdlIGFyZSBzZXR0aW5nIGF0dHJpYnV0ZXMgc3VjaCB0aGF0IGlmIHRoZSB2YWx1ZSBpcyA8IDAgb3IgPiAxLCBhIGJvcmRlciBzaG91bGQgYmUgZHJhd24uXG4gICAgICAgICAgICBjb25zdCBkZHcgPSB0aGlzLl93aWR0aCAvIGVsZW1lbnRDb3JlLnc7XG4gICAgICAgICAgICBjb25zdCBkdyA9IGRkdyAvICgxIC0gMiAqIGRkdyk7XG4gICAgICAgICAgICBjb25zdCBkZGggPSB0aGlzLl93aWR0aCAvIGVsZW1lbnRDb3JlLmg7XG4gICAgICAgICAgICBjb25zdCBkaCA9IGRkaCAvICgxIC0gMiAqIGRkaCk7XG5cbiAgICAgICAgICAgIC8vIFNwZWNpZnkgYWxsIGNvcm5lciBwb2ludHMuXG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0XSA9IC1kdztcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyAxXSA9IC1kaDtcblxuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDJdID0gMSArIGR3O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDNdID0gLWRoO1xuXG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgNF0gPSAxICsgZHc7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgNV0gPSAxICsgZGg7XG5cbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyA2XSA9IC1kdztcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyA3XSA9IDEgKyBkaDtcblxuICAgICAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBiZWZvcmVEcmF3KG9wZXJhdGlvbikge1xuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYihcImFDb3JuZXJcIiksIDIsIGdsLkZMT0FULCBmYWxzZSwgOCwgdGhpcy5nZXRWZXJ0ZXhBdHRyaWJQb2ludGVyT2Zmc2V0KG9wZXJhdGlvbikpO1xuICAgIH1cblxuICAgIGdldEV4dHJhQXR0cmliQnl0ZXNQZXJWZXJ0ZXgoKSB7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cblxufVxuXG5PdXRsaW5lU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICBhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XG4gICAgYXR0cmlidXRlIHZlYzIgYUNvcm5lcjtcbiAgICB1bmlmb3JtIHZlYzIgcHJvamVjdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzIgdkNvcm5lcjtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbi54ICogcHJvamVjdGlvbi54IC0gMS4wLCBhVmVydGV4UG9zaXRpb24ueSAqIC1hYnMocHJvamVjdGlvbi55KSArIDEuMCwgMC4wLCAxLjApO1xuICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgdkNvcm5lciA9IGFDb3JuZXI7XG4gICAgICAgIHZDb2xvciA9IGFDb2xvcjtcbiAgICAgICAgZ2xfUG9zaXRpb24ueSA9IC1zaWduKHByb2plY3Rpb24ueSkgKiBnbF9Qb3NpdGlvbi55O1xuICAgIH1cbmA7XG5cbk91dGxpbmVTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB2YXJ5aW5nIHZlYzIgdkNvcm5lcjtcbiAgICB1bmlmb3JtIHZlYzQgY29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICB2ZWMyIG0gPSBtaW4odkNvcm5lciwgMS4wIC0gdkNvcm5lcik7XG4gICAgICAgIGZsb2F0IHZhbHVlID0gc3RlcCgwLjAsIG1pbihtLngsIG0ueSkpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IsIHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3IsIHZhbHVlKTtcbiAgICB9XG5gO1xuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQZXJzcGVjdGl2ZVNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKGN0eCk7XG5cbiAgICAgICAgdGhpcy5fZnVkZ2UgPSAwLjI7XG4gICAgICAgIHRoaXMuX3J4ID0gMDtcbiAgICAgICAgdGhpcy5fcnkgPSAwO1xuICAgICAgICB0aGlzLl96ID0gMS4wO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcblxuICAgICAgICBjb25zdCB2ciA9IG9wZXJhdGlvbi5zaGFkZXJPd25lcjtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHZyLmVsZW1lbnQ7XG5cbiAgICAgICAgY29uc3QgcGl2b3RYID0gZWxlbWVudC5waXZvdFggKiB2ci53O1xuICAgICAgICBjb25zdCBwaXZvdFkgPSBlbGVtZW50LnBpdm90WSAqIHZyLmg7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IHZyLmdldFJlbmRlclRleHR1cmVDb29yZHMocGl2b3RYLCBwaXZvdFkpO1xuXG4gICAgICAgIC8vIENvdW50ZXIgbm9ybWFsIHJvdGF0aW9uLlxuICAgICAgICBjb25zdCByeiA9IC1NYXRoLmF0YW4yKHZyLl9yZW5kZXJDb250ZXh0LnRjLCB2ci5fcmVuZGVyQ29udGV4dC50YSk7XG5cbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwicGl2b3RcIiwgbmV3IEZsb2F0MzJBcnJheShbY29vcmRzWzBdLCBjb29yZHNbMV0sIDBdKSwgZ2wudW5pZm9ybTNmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJyb3RcIiwgbmV3IEZsb2F0MzJBcnJheShbdGhpcy5fcngsIHRoaXMuX3J5LCByel0pLCBnbC51bmlmb3JtM2Z2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInpcIiwgdGhpcy5feiwgZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImZ1ZGdlXCIsIHRoaXMuX2Z1ZGdlLCBnbC51bmlmb3JtMWYpO1xuICAgIH1cblxuICAgIHNldCBmdWRnZSh2KSB7XG4gICAgICAgIHRoaXMuX2Z1ZGdlID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgZnVkZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mdWRnZTtcbiAgICB9XG5cbiAgICBnZXQgcngoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yeDtcbiAgICB9XG5cbiAgICBzZXQgcngodikge1xuICAgICAgICB0aGlzLl9yeCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnk7XG4gICAgfVxuXG4gICAgc2V0IHJ5KHYpIHtcbiAgICAgICAgdGhpcy5fcnkgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCB6KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fejtcbiAgICB9XG5cbiAgICBzZXQgeih2KSB7XG4gICAgICAgIHRoaXMuX3ogPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fcnggPT09IDAgJiYgdGhpcy5fcnkgPT09IDAgJiYgdGhpcy5feiA9PT0gMCk7XG4gICAgfVxuXG59XG5cblBlcnNwZWN0aXZlU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICBhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XG4gICAgdW5pZm9ybSB2ZWMyIHByb2plY3Rpb247XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcblxuICAgIHVuaWZvcm0gZmxvYXQgejtcbiAgICB1bmlmb3JtIHZlYzMgcGl2b3Q7XG4gICAgdW5pZm9ybSB2ZWMzIHJvdDtcbiAgICB2YXJ5aW5nIHZlYzMgcG9zO1xuXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcbiAgICAgICAgcG9zID0gdmVjMyhhVmVydGV4UG9zaXRpb24ueHksIHopO1xuICAgICAgICBcbiAgICAgICAgcG9zIC09IHBpdm90O1xuICAgICAgICBcbiAgICAgICAgLy8gVW5kbyBYWSByb3RhdGlvblxuICAgICAgICBtYXQyIGlSb3RYeSA9IG1hdDIoIGNvcyhyb3QueiksIHNpbihyb3QueiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLXNpbihyb3QueiksIGNvcyhyb3QueikpO1xuICAgICAgICBwb3MueHkgPSBpUm90WHkgKiBwb3MueHk7XG4gICAgICAgIFxuICAgICAgICAvLyBQZXJmb3JtIDNkIHJvdGF0aW9uc1xuICAgICAgICBnbF9Qb3NpdGlvbi54ID0gY29zKHJvdC54KSAqIHBvcy54IC0gc2luKHJvdC54KSAqIHBvcy56O1xuICAgICAgICBnbF9Qb3NpdGlvbi55ID0gcG9zLnk7XG4gICAgICAgIGdsX1Bvc2l0aW9uLnogPSBzaW4ocm90LngpICogcG9zLnggKyBjb3Mocm90LngpICogcG9zLno7XG4gICAgICAgIFxuICAgICAgICBwb3MueCA9IGdsX1Bvc2l0aW9uLng7XG4gICAgICAgIHBvcy55ID0gY29zKHJvdC55KSAqIGdsX1Bvc2l0aW9uLnkgLSBzaW4ocm90LnkpICogZ2xfUG9zaXRpb24uejtcbiAgICAgICAgcG9zLnogPSBzaW4ocm90LnkpICogZ2xfUG9zaXRpb24ueSArIGNvcyhyb3QueSkgKiBnbF9Qb3NpdGlvbi56O1xuICAgICAgICBcbiAgICAgICAgLy8gUmVkbyBYWSByb3RhdGlvblxuICAgICAgICBpUm90WHlbMF1bMV0gPSAtaVJvdFh5WzBdWzFdO1xuICAgICAgICBpUm90WHlbMV1bMF0gPSAtaVJvdFh5WzFdWzBdO1xuICAgICAgICBwb3MueHkgPSBpUm90WHkgKiBwb3MueHk7IFxuXG4gICAgICAgIC8vIFVuZG8gdHJhbnNsYXRlIHRvIHBpdm90IHBvc2l0aW9uXG4gICAgICAgIHBvcy54eXogKz0gcGl2b3Q7XG5cbiAgICAgICAgcG9zID0gdmVjMyhwb3MueCAqIHByb2plY3Rpb24ueCAtIDEuMCwgcG9zLnkgKiAtYWJzKHByb2plY3Rpb24ueSkgKyAxLjAsIHBvcy56ICogcHJvamVjdGlvbi54KTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1hcCBjb29yZHMgdG8gZ2wgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICAgICAgLy8gU2V0IHogdG8gMCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gcGVyZm9ybSB6LWNsaXBwaW5nXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIDAuMCwgeik7XG5cbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZDb2xvciA9IGFDb2xvcjtcbiAgICAgICAgXG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgPSAtc2lnbihwcm9qZWN0aW9uLnkpICogZ2xfUG9zaXRpb24ueTtcbiAgICB9XG5gO1xuXG5QZXJzcGVjdGl2ZVNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuXG4gICAgdW5pZm9ybSB2ZWMzIHJvdDtcbiAgICB1bmlmb3JtIGZsb2F0IGZ1ZGdlO1xuXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcbiAgICAgICAgdmVjMiBjb29yZHMgPSB2VGV4dHVyZUNvb3JkO1xuXG4gICAgICAgIGNvb3Jkcy54eSAtPSB2ZWMyKDAuNSk7XG4gICAgICAgIGNvb3Jkcy55ID0gY29vcmRzLnkgKyAoc2lnbihyb3RbMF0pICogMC41IC0gY29vcmRzLngpICogc2luKHJvdFswXSkgKiBmdWRnZSAqIGNvb3Jkcy55O1xuICAgICAgICBjb29yZHMueCA9IGNvb3Jkcy54ICsgKHNpZ24ocm90WzFdKSAqIDAuNSAtIGNvb3Jkcy55KSAqIHNpbihyb3RbMV0pICogZnVkZ2UgKiBjb29yZHMueDtcbiAgICAgICAgY29vcmRzLnh5ICs9IHZlYzIoMC41KTtcblxuICAgICAgICBpZiAoY29vcmRzLnggPCAwLjAgfHwgY29vcmRzLnggPiAxLjAgfHwgY29vcmRzLnkgPCAwLjAgfHwgY29vcmRzLnkgPiAxLjApIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmRzKSAqIHZDb2xvcjtcbiAgICAgICAgfVxuICAgIH1cbmA7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLWZpbHRlcnMvdHJlZS9tYXN0ZXIvZmlsdGVycy9waXhlbGF0ZS9zcmNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGl4ZWxhdGVTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICBzdXBlcihjdHgpO1xuXG4gICAgICAgIHRoaXMuX3NpemUgPSBuZXcgRmxvYXQzMkFycmF5KFs0LCA0XSk7XG4gICAgfVxuXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplWzBdO1xuICAgIH1cblxuICAgIHNldCB4KHYpIHtcbiAgICAgICAgdGhpcy5fc2l6ZVswXSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplWzFdO1xuICAgIH1cblxuICAgIHNldCB5KHYpIHtcbiAgICAgICAgdGhpcy5fc2l6ZVsxXSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplWzBdO1xuICAgIH1cblxuICAgIHNldCBzaXplKHYpIHtcbiAgICAgICAgdGhpcy5fc2l6ZVswXSA9IHY7XG4gICAgICAgIHRoaXMuX3NpemVbMV0gPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMuX3NpemVbMF0gPT09IDApICYmICh0aGlzLl9zaXplWzFdID09PSAwKSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFdlYkdMSW1wbCgpIHtcbiAgICAgICAgcmV0dXJuIFdlYkdMUGl4ZWxhdGVTaGFkZXJJbXBsO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInNpemVcIiwgbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9zaXplKSwgZ2wudW5pZm9ybTJmdik7XG4gICAgfVxuXG4gICAgZ2V0RXh0cmFBdHRyaWJCeXRlc1BlclZlcnRleCgpIHtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxuXG4gICAgZW5hYmxlQXR0cmlicygpIHtcbiAgICAgICAgc3VwZXIuZW5hYmxlQXR0cmlicygpO1xuICAgICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFUZXh0dXJlUmVzXCIpKTtcbiAgICB9XG5cbiAgICBkaXNhYmxlQXR0cmlicygpIHtcbiAgICAgICAgc3VwZXIuZGlzYWJsZUF0dHJpYnMoKTtcbiAgICAgICAgdGhpcy5nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYVRleHR1cmVSZXNcIikpO1xuICAgIH1cblxuICAgIHNldEV4dHJhQXR0cmlic0luQnVmZmVyKG9wZXJhdGlvbikge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gb3BlcmF0aW9uLmV4dHJhQXR0cmlic0RhdGFCeXRlT2Zmc2V0IC8gNDtcbiAgICAgICAgbGV0IGZsb2F0cyA9IG9wZXJhdGlvbi5xdWFkcy5mbG9hdHM7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IG9wZXJhdGlvbi5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB3ID0gb3BlcmF0aW9uLnF1YWRzLmdldFRleHR1cmVXaWR0aChvcGVyYXRpb24uaW5kZXggKyBpKTtcbiAgICAgICAgICAgIGxldCBoID0gb3BlcmF0aW9uLnF1YWRzLmdldFRleHR1cmVIZWlnaHQob3BlcmF0aW9uLmluZGV4ICsgaSk7XG5cbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXRdID0gdztcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyAxXSA9IGg7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgMl0gPSB3O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDNdID0gaDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyA0XSA9IHc7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgNV0gPSBoO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDZdID0gdztcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyA3XSA9IGg7XG5cbiAgICAgICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYmVmb3JlRHJhdyhvcGVyYXRpb24pIHtcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLl9hdHRyaWIoXCJhVGV4dHVyZVJlc1wiKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCB0aGlzLmdldEV4dHJhQXR0cmliQnl0ZXNQZXJWZXJ0ZXgoKSwgdGhpcy5nZXRWZXJ0ZXhBdHRyaWJQb2ludGVyT2Zmc2V0KG9wZXJhdGlvbikpO1xuICAgIH1cbn1cblxuUGl4ZWxhdGVTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgIGF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZVJlcztcbiAgICB1bmlmb3JtIHZlYzIgcHJvamVjdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZVJlcztcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhVmVydGV4UG9zaXRpb24ueCAqIHByb2plY3Rpb24ueCAtIDEuMCwgYVZlcnRleFBvc2l0aW9uLnkgKiAtYWJzKHByb2plY3Rpb24ueSkgKyAxLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZDb2xvciA9IGFDb2xvcjtcbiAgICAgICAgdlRleHR1cmVSZXMgPSBhVGV4dHVyZVJlcztcbiAgICAgICAgZ2xfUG9zaXRpb24ueSA9IC1zaWduKHByb2plY3Rpb24ueSkgKiBnbF9Qb3NpdGlvbi55O1xuICAgIH1cbmA7XG5cblBpeGVsYXRlU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlUmVzO1xuXG4gICAgdW5pZm9ybSB2ZWMyIHNpemU7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgXG4gICAgdmVjMiBtYXBDb29yZCggdmVjMiBjb29yZCApXG4gICAge1xuICAgICAgICBjb29yZCAqPSB2VGV4dHVyZVJlcy54eTtcbiAgICAgICAgcmV0dXJuIGNvb3JkO1xuICAgIH1cbiAgICBcbiAgICB2ZWMyIHVubWFwQ29vcmQoIHZlYzIgY29vcmQgKVxuICAgIHtcbiAgICAgICAgY29vcmQgLz0gdlRleHR1cmVSZXMueHk7XG4gICAgICAgIHJldHVybiBjb29yZDtcbiAgICB9XG4gICAgXG4gICAgdmVjMiBwaXhlbGF0ZSh2ZWMyIGNvb3JkLCB2ZWMyIHNpemUpXG4gICAge1xuICAgICAgICByZXR1cm4gZmxvb3IoIGNvb3JkIC8gc2l6ZSApICogc2l6ZTtcbiAgICB9XG4gICAgXG4gICAgdm9pZCBtYWluKHZvaWQpXG4gICAge1xuICAgICAgICB2ZWMyIGNvb3JkID0gbWFwQ29vcmQodlRleHR1cmVDb29yZCk7XG4gICAgICAgIGNvb3JkID0gcGl4ZWxhdGUoY29vcmQsIHNpemUpO1xuICAgICAgICBjb29yZCA9IHVubWFwQ29vcmQoY29vcmQpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvb3JkKSAqIHZDb2xvcjtcbiAgICB9XG5gO1xuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpYWxGaWx0ZXJTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSAwO1xuICAgICAgICB0aGlzLl9jdXRvZmYgPSAxO1xuICAgIH1cblxuICAgIHNldCByYWRpdXModikge1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCByYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXM7XG4gICAgfVxuXG4gICAgc2V0IGN1dG9mZih2KSB7XG4gICAgICAgIHRoaXMuX2N1dG9mZiA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGN1dG9mZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1dG9mZjtcbiAgICB9XG4gICAgXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1cyA9PT0gMDtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIC8vIFdlIHN1YnN0cmFjdCBoYWxmIGEgcGl4ZWwgdG8gZ2V0IGEgYmV0dGVyIGN1dG9mZiBlZmZlY3QuXG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJyYWRpdXNcIiwgMiAqICh0aGlzLl9yYWRpdXMgLSAwLjUpIC8gb3BlcmF0aW9uLmdldFJlbmRlcldpZHRoKCksIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImN1dG9mZlwiLCAwLjUgKiBvcGVyYXRpb24uZ2V0UmVuZGVyV2lkdGgoKSAvIHRoaXMuX2N1dG9mZiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgIH1cblxufVxuXG5SYWRpYWxGaWx0ZXJTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgIGF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzIgcHJvamVjdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzIgcG9zO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVZlcnRleFBvc2l0aW9uLnggKiBwcm9qZWN0aW9uLnggLSAxLjAsIGFWZXJ0ZXhQb3NpdGlvbi55ICogLWFicyhwcm9qZWN0aW9uLnkpICsgMS4wLCAwLjAsIDEuMCk7XG4gICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgPSAtc2lnbihwcm9qZWN0aW9uLnkpICogZ2xfUG9zaXRpb24ueTtcbiAgICAgICAgcG9zID0gZ2xfUG9zaXRpb24ueHk7XG4gICAgfVxuYDtcblxuUmFkaWFsRmlsdGVyU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjMiBwb3M7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcbiAgICB1bmlmb3JtIGZsb2F0IGN1dG9mZjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuICAgICAgICBmbG9hdCBmID0gbWF4KDAuMCwgbWluKDEuMCwgMS4wIC0gKGxlbmd0aChwb3MpIC0gcmFkaXVzKSAqIGN1dG9mZikpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yICogZjtcbiAgICB9XG5gO1xuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4uLy4uLy4uL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaWFsR3JhZGllbnRTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9waXZvdCA9IFswLCAwXTtcbiAgICAgICAgdGhpcy5faWMgPSAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVkSUMgPSB0aGlzLl9nZXROb3JtYWxpemVkQ29sb3IodGhpcy5faWMpO1xuICAgICAgICB0aGlzLl9vYyA9IDB4MDBmZmZmZmY7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRPQyA9IHRoaXMuX2dldE5vcm1hbGl6ZWRDb2xvcih0aGlzLl9vYyk7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IDA7XG4gICAgfVxuXG4gICAgc2V0IHJhZGl1c1godikge1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHJhZGl1c1goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXM7XG4gICAgfVxuXG4gICAgc2V0IHJhZGl1c1kodikge1xuICAgICAgICB0aGlzLl9yYWRpdXNZID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcmFkaXVzWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1c1k7XG4gICAgfVxuXG4gICAgc2V0IHJhZGl1cyh2KSB7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0IGlubmVyQ29sb3IoYXJnYikge1xuICAgICAgICB0aGlzLl9pYyA9IGFyZ2I7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRJQyA9IHRoaXMuX2dldE5vcm1hbGl6ZWRDb2xvcihhcmdiKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgaW5uZXJDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ljO1xuICAgIH1cblxuICAgIHNldCBvdXRlckNvbG9yKGFyZ2IpIHtcbiAgICAgICAgdGhpcy5fb2MgPSBhcmdiO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVkT0MgPSB0aGlzLl9nZXROb3JtYWxpemVkQ29sb3IoYXJnYik7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yKGFyZ2IpIHtcbiAgICAgICAgdGhpcy5pbm5lckNvbG9yID0gYXJnYjtcbiAgICB9XG5cbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlubmVyQ29sb3I7XG4gICAgfVxuXG4gICAgZ2V0IG91dGVyQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pYztcbiAgICB9XG5cbiAgICBzZXQgeChmKSB7XG4gICAgICAgIHRoaXMuX3ggPSBmO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldCB5KGYpIHtcbiAgICAgICAgdGhpcy5feSA9IGY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0IHBpdm90KHYpIHtcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh2KSAmJiB2Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5fcGl2b3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgdGhpcy5fcGl2b3QgPSBbdlswXSwgdlsxXSB8fCB2WzBdXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90ID0gW3YsIHZdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RbMF07XG4gICAgfVxuXG4gICAgc2V0IHBpdm90WShmKSB7XG4gICAgICAgIHRoaXMuX3Bpdm90WzFdID0gZjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcGl2b3RZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RbMV07XG4gICAgfVxuXG4gICAgc2V0IHBpdm90WChmKSB7XG4gICAgICAgIHRoaXMuX3Bpdm90WzBdID0gZjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcGl2b3RYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RbMF07XG4gICAgfVxuXG4gICAgX2dldE5vcm1hbGl6ZWRDb2xvcihjb2xvcikge1xuICAgICAgICBjb25zdCBjb2wgPSBTdGFnZVV0aWxzLmdldFJnYmFDb21wb25lbnRzTm9ybWFsaXplZChjb2xvcik7XG4gICAgICAgIGNvbFswXSAqPSBjb2xbM107XG4gICAgICAgIGNvbFsxXSAqPSBjb2xbM107XG4gICAgICAgIGNvbFsyXSAqPSBjb2xbM107XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGNvbCk7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICBjb25zdCBvd25lciA9IG9wZXJhdGlvbi5zaGFkZXJPd25lcjtcblxuICAgICAgICBpZih0aGlzLl94KSB7XG4gICAgICAgICAgICB0aGlzLl9waXZvdFswXSA9IHRoaXMuX3ggLyBvd25lci53O1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuX3kpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90WzFdID0gdGhpcy5feSAvIG93bmVyLmg7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLl9yYWRpdXMgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IG93bmVyLncgKiAwLjU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdpbm5lckNvbG9yJywgdGhpcy5fbm9ybWFsaXplZElDLCB0aGlzLmdsLnVuaWZvcm00ZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdmaWxsJywgU3RhZ2VVdGlscy5nZXRSZ2JhQ29tcG9uZW50c05vcm1hbGl6ZWQodGhpcy5fb2MpWzNdLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ291dGVyQ29sb3InLCB0aGlzLl9ub3JtYWxpemVkT0MsIHRoaXMuZ2wudW5pZm9ybTRmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3Bpdm90JywgbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9waXZvdCksICB0aGlzLmdsLnVuaWZvcm0yZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdyZXNvbHV0aW9uJywgbmV3IEZsb2F0MzJBcnJheShbb3duZXIuX3csIG93bmVyLl9oXSksICB0aGlzLmdsLnVuaWZvcm0yZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdhbHBoYScsIG9wZXJhdGlvbi5nZXRFbGVtZW50Q29yZSgwKS5yZW5kZXJDb250ZXh0LmFscGhhLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3JhZGl1cycsICB0aGlzLl9yYWRpdXMsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncmFkaXVzWScsICAodGhpcy5fcmFkaXVzWSB8fCB0aGlzLl9yYWRpdXMpLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgfVxufVxuXG5SYWRpYWxHcmFkaWVudFNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICBcbiAgICAjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTlcbiAgICBcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gdmVjMiBwaXZvdDtcbiAgICB1bmlmb3JtIHZlYzQgaW5uZXJDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzQgb3V0ZXJDb2xvcjtcbiAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcbiAgICB1bmlmb3JtIGZsb2F0IHJhZGl1c1k7XG4gICAgdW5pZm9ybSBmbG9hdCBhbHBoYTtcbiAgICB1bmlmb3JtIGZsb2F0IGZpbGw7XG4gICAgdW5pZm9ybSBmbG9hdCBhc3BlY3RSYXRpbztcbiAgICBcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzIgcG9pbnQgPSB2VGV4dHVyZUNvb3JkLnh5ICogcmVzb2x1dGlvbjtcbiAgICAgICAgdmVjMiBwcm9qZWN0aW9uID0gdmVjMihwaXZvdC54ICogcmVzb2x1dGlvbi54LCBwaXZvdC55ICogcmVzb2x1dGlvbi55KTtcbiAgICAgICAgZmxvYXQgZCA9IGxlbmd0aCgocG9pbnQgLSBwcm9qZWN0aW9uKSAvIHZlYzIocmFkaXVzICogMi4wLCByYWRpdXNZICogMi4wKSk7XG4gICAgICAgIHZlYzQgY29sb3IgPSBtaXgodGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvciwgb3V0ZXJDb2xvciAqIGFscGhhLCBmaWxsKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gbWl4KGlubmVyQ29sb3IgKiBhbHBoYSwgY29sb3IsIHNtb290aHN0ZXAoMC4wLCAxLjAsIGQpKTtcbiAgICB9XG5gO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuLi8uLi8uLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdW5kZWRSZWN0YW5nbGVTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9ibGVuZCA9IDA7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IFsxLCAxLCAxLCAxXTtcbiAgICAgICAgdGhpcy5fc3Ryb2tlID0gMDtcbiAgICAgICAgdGhpcy5fZmMgPSAweDAwZmZmZmZmO1xuICAgICAgICB0aGlzLl9maWxsQ29sb3IgPSB0aGlzLl9nZXROb3JtYWxpemVkQ29sb3IoMHhmZmZmZmZmZik7XG4gICAgICAgIHRoaXMuX3N0cm9rZUNvbG9yID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvbG9yKDB4MDBmZmZmZmYpO1xuICAgIH1cblxuICAgIHNldCBibGVuZChwKSB7XG4gICAgICAgIHRoaXMuX2JsZW5kID0gTWF0aC5taW4oTWF0aC5tYXgocCwgMCksIDEpO1xuICAgIH1cblxuICAgIHNldCByYWRpdXModikge1xuICAgICAgICBpZihBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICBpZih2Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IFt2WzBdLCB2WzFdLCB2WzBdLCB2WzFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYodi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYWRpdXMgPSBbdlswXSwgdlsxXSwgdlsyXSwgdGhpcy5fcmFkaXVzWzNdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHYubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IFt2WzBdLCB2WzBdLCB2WzBdLCB2WzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IFt2LCB2LCB2LCB2XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCByYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXM7XG4gICAgfVxuXG4gICAgc2V0IHRvcExlZnQobnVtKSB7XG4gICAgICAgIHRoaXMuX3JhZGl1c1swXSA9IG51bTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgdG9wTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1c1swXTtcbiAgICB9XG5cbiAgICBzZXQgdG9wUmlnaHQobnVtKSB7XG4gICAgICAgIHRoaXMuX3JhZGl1c1sxXSA9IG51bTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgdG9wUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXNbMV07XG4gICAgfVxuXG4gICAgc2V0IGJvdHRvbVJpZ2h0KG51bSkge1xuICAgICAgICB0aGlzLl9yYWRpdXNbMl0gPSBudW07XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGJvdHRvbVJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzWzJdO1xuICAgIH1cblxuICAgIHNldCBib3R0b21MZWZ0KG51bSkge1xuICAgICAgICB0aGlzLl9yYWRpdXNbM10gPSBudW07XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGJvdHRvbUxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXNbNF07XG4gICAgfVxuXG4gICAgc2V0IHN0cm9rZUNvbG9yKGFyZ2IpIHtcbiAgICAgICAgdGhpcy5fc2MgPSBhcmdiO1xuICAgICAgICB0aGlzLl9zdHJva2VDb2xvciA9IHRoaXMuX2dldE5vcm1hbGl6ZWRDb2xvcihhcmdiKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgc3Ryb2tlQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zYztcbiAgICB9XG5cbiAgICBzZXQgZmlsbENvbG9yKGFyZ2IpIHtcbiAgICAgICAgdGhpcy5fZmMgPSBhcmdiO1xuICAgICAgICB0aGlzLl9maWxsQ29sb3IgPSB0aGlzLl9nZXROb3JtYWxpemVkQ29sb3IoYXJnYik7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGZpbGxDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZjO1xuICAgIH1cblxuICAgIHNldCBzdHJva2UobnVtKSB7XG4gICAgICAgIHRoaXMuX3N0cm9rZSA9IG51bTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgc3Ryb2tlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlO1xuICAgIH1cblxuICAgIF9nZXROb3JtYWxpemVkQ29sb3IoY29sb3IpIHtcbiAgICAgICAgY29uc3QgY29sID0gU3RhZ2VVdGlscy5nZXRSZ2JhQ29tcG9uZW50c05vcm1hbGl6ZWQoY29sb3IpO1xuICAgICAgICBjb2xbMF0gKj0gY29sWzNdO1xuICAgICAgICBjb2xbMV0gKj0gY29sWzNdO1xuICAgICAgICBjb2xbMl0gKj0gY29sWzNdO1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShjb2wpO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgY29uc3Qgb3duZXIgPSBvcGVyYXRpb24uc2hhZGVyT3duZXI7XG4gICAgICAgIGNvbnN0IHJlbmRlclByZWNpc2lvbiA9IHRoaXMuY3R4LnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpO1xuICAgICAgICBjb25zdCBfcmFkaXVzID0gdGhpcy5fcmFkaXVzLm1hcCgocikgPT4gKHIgKyAwLjUpICogcmVuZGVyUHJlY2lzaW9uKVxuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdyYWRpdXMnLCBuZXcgRmxvYXQzMkFycmF5KF9yYWRpdXMpLCB0aGlzLmdsLnVuaWZvcm00ZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdhbHBoYScsIG9wZXJhdGlvbi5nZXRFbGVtZW50Q29yZSgwKS5yZW5kZXJDb250ZXh0LmFscGhhLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2JsZW5kJywgdGhpcy5fYmxlbmQsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnc3Ryb2tlQ29sb3InLCB0aGlzLl9zdHJva2VDb2xvciwgdGhpcy5nbC51bmlmb3JtNGZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnZmlsbENvbG9yJywgdGhpcy5fZmlsbENvbG9yLCB0aGlzLmdsLnVuaWZvcm00ZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdzdHJva2UnLCAgdGhpcy5fc3Ryb2tlICogcmVuZGVyUHJlY2lzaW9uLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3Jlc29sdXRpb24nLCBuZXcgRmxvYXQzMkFycmF5KFtvd25lci5fdyAqIHJlbmRlclByZWNpc2lvbiwgb3duZXIuX2ggKiByZW5kZXJQcmVjaXNpb25dKSwgdGhpcy5nbC51bmlmb3JtMmZ2KTtcbiAgICB9XG59XG5cblJvdW5kZWRSZWN0YW5nbGVTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuXG4gICAgYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xuICAgIHVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhVmVydGV4UG9zaXRpb24ueCAqIHByb2plY3Rpb24ueCAtIDEuMCwgYVZlcnRleFBvc2l0aW9uLnkgKiAtYWJzKHByb2plY3Rpb24ueSkgKyAxLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZDb2xvciA9IGFDb2xvcjtcbiAgICAgICAgZ2xfUG9zaXRpb24ueSA9IC1zaWduKHByb2plY3Rpb24ueSkgKiBnbF9Qb3NpdGlvbi55O1xuICAgIH1cbmA7XG5cblJvdW5kZWRSZWN0YW5nbGVTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG5cbiAgICAjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTlcblxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcbiAgICB1bmlmb3JtIHZlYzQgcmFkaXVzO1xuICAgIHVuaWZvcm0gZmxvYXQgc3Ryb2tlO1xuICAgIHVuaWZvcm0gdmVjNCBzdHJva2VDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzQgZmlsbENvbG9yO1xuICAgIHVuaWZvcm0gZmxvYXQgYWxwaGE7XG4gICAgdW5pZm9ybSBmbG9hdCBmaWxsO1xuICAgIHVuaWZvcm0gZmxvYXQgYmxlbmQ7XG4gICAgXG4gICAgZmxvYXQgYm94RGlzdCh2ZWMyIHAsIHZlYzIgc2l6ZSwgZmxvYXQgcmFkaXVzKXtcbiAgICAgICAgc2l6ZSAtPSB2ZWMyKHJhZGl1cyk7XG4gICAgICAgIHZlYzIgZCA9IGFicyhwKSAtIHNpemU7XG4gICAgICAgIHJldHVybiBtaW4obWF4KGQueCwgZC55KSwgMC4wKSArIGxlbmd0aChtYXgoZCwgMC4wKSkgLSByYWRpdXM7XG4gICAgfVxuICAgIFxuICAgIGZsb2F0IGZpbGxNYXNrKGZsb2F0IGRpc3Qpe1xuICAgICAgICByZXR1cm4gY2xhbXAoLWRpc3QsIDAuMCwgMS4wKTtcbiAgICB9XG4gICAgXG4gICAgZmxvYXQgaW5uZXJCb3JkZXJNYXNrKGZsb2F0IGRpc3QsIGZsb2F0IHdpZHRoKXtcbiAgICAgICAgZmxvYXQgYWxwaGExID0gY2xhbXAoZGlzdCArIHdpZHRoLCAwLjAsIDEuMCk7XG4gICAgICAgIGZsb2F0IGFscGhhMiA9IGNsYW1wKGRpc3QsIDAuMCwgMS4wKTtcbiAgICAgICAgcmV0dXJuIGFscGhhMSAtIGFscGhhMjtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzIgaGFsZlJlcyA9IDAuNSAqIHJlc29sdXRpb24ueHk7XG4gICAgICAgIGZsb2F0IHIgPSAwLjA7XG4gICAgICAgIGlmICh2VGV4dHVyZUNvb3JkLnggPCAwLjUgJiYgdlRleHR1cmVDb29yZC55IDwgMC41KSB7XG4gICAgICAgICAgICByID0gcmFkaXVzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHZUZXh0dXJlQ29vcmQueCA+PSAwLjUgJiYgdlRleHR1cmVDb29yZC55IDwgMC41KSB7XG4gICAgICAgICAgICByID0gcmFkaXVzWzFdO1xuICAgICAgICB9IGVsc2UgaWYgKHZUZXh0dXJlQ29vcmQueCA+PSAwLjUgJiYgdlRleHR1cmVDb29yZC55ID49IDAuNSkge1xuICAgICAgICAgICAgciA9IHJhZGl1c1syXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHIgPSByYWRpdXNbM107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZsb2F0IGIgPSBib3hEaXN0KHZUZXh0dXJlQ29vcmQueHkgKiByZXNvbHV0aW9uIC0gaGFsZlJlcywgaGFsZlJlcyAtIDAuMDA1LCByKTtcbiAgICAgICAgdmVjNCB0ZXggPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yO1xuICAgICAgICB2ZWM0IGJsZW5kID0gbWl4KHZlYzQoMS4wKSAqIGFscGhhLCB0ZXgsIGJsZW5kKTsgICAgIFxuICAgICAgICB2ZWM0IGxheWVyMSA9IG1peCh2ZWM0KDAuMCksIHRleCAqIGZpbGxDb2xvciwgZmlsbE1hc2soYikpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBtaXgobGF5ZXIxLCBibGVuZCAqIHN0cm9rZUNvbG9yLCBpbm5lckJvcmRlck1hc2soYiwgc3Ryb2tlKSk7XG4gICAgfVxuYDtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tICcuLi8uLi8uLi90cmVlL1N0YWdlVXRpbHMubWpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGlubmVyU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoY3R4KTtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gMTAwO1xuICAgICAgICB0aGlzLl93aWR0aCA9IDUwO1xuICAgICAgICB0aGlzLl9wZXJpb2QgPSAxO1xuICAgICAgICB0aGlzLl9hbmdsZSA9IDAuNTtcbiAgICAgICAgdGhpcy5fc21vb3RoID0gMC4wMDU7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gMHhmZjAwMDAwMDtcbiAgICAgICAgdGhpcy5fdGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuXG4gICAgc2V0IHJhZGl1cyh2KSB7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0IHdpZHRoKHYpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldCBwZXJpb2Qodikge1xuICAgICAgICB0aGlzLl9wZXJpb2QgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldCBhbmdsZSh2KSB7XG4gICAgICAgIHRoaXMuX2FuZ2xlID0gdlxuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldCBzbW9vdGgodikge1xuICAgICAgICB0aGlzLl9zbW9vdGggPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldCBjb2xvcih2KSB7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXQgYmFja2dyb3VuZENvbG9yKHYpIHtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIGNvbnN0IG93bmVyID0gb3BlcmF0aW9uLnNoYWRlck93bmVyXG5cbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImlUaW1lXCIsIERhdGUubm93KCkgLSB0aGlzLl90aW1lLCB0aGlzLmdsLnVuaWZvcm0xZik7XG5cbiAgICAgICAgY29uc3QgcmVuZGVyUHJlY2lzaW9uID0gdGhpcy5jdHguc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKCk7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3JhZGl1cycsIHRoaXMuX3JhZGl1cyAqIHJlbmRlclByZWNpc2lvbiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCd3aWR0aCcsIHRoaXMuX3dpZHRoICogcmVuZGVyUHJlY2lzaW9uLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3BlcmlvZCcsIHRoaXMuX3BlcmlvZCwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdhbmdsZScsIHRoaXMuX2FuZ2xlLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3Ntb290aCcsIHRoaXMuX3Ntb290aCwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdjb2xvcicsIG5ldyBGbG9hdDMyQXJyYXkoU3RhZ2VVdGlscy5nZXRSZ2JhQ29tcG9uZW50c05vcm1hbGl6ZWQodGhpcy5fY29sb3IpKSwgdGhpcy5nbC51bmlmb3JtNGZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnYmFja2dyb3VuZENvbG9yJywgbmV3IEZsb2F0MzJBcnJheShTdGFnZVV0aWxzLmdldFJnYmFDb21wb25lbnRzTm9ybWFsaXplZCh0aGlzLl9iYWNrZ3JvdW5kQ29sb3IpKSwgdGhpcy5nbC51bmlmb3JtNGZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncmVzb2x1dGlvbicsIG5ldyBGbG9hdDMyQXJyYXkoW293bmVyLl93ICogcmVuZGVyUHJlY2lzaW9uLCBvd25lci5faCAqIHJlbmRlclByZWNpc2lvbl0pLCB0aGlzLmdsLnVuaWZvcm0yZnYpXG5cbiAgICAgICAgdGhpcy5yZWRyYXcoKVxuICAgIH1cbn1cblxuU3Bpbm5lclNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBEZWZhdWx0U2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZTtcblxuU3Bpbm5lclNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuXG4gICAgdW5pZm9ybSBmbG9hdCBpVGltZTtcbiAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcbiAgICB1bmlmb3JtIGZsb2F0IHdpZHRoO1xuICAgIHVuaWZvcm0gZmxvYXQgcGVyaW9kO1xuICAgIHVuaWZvcm0gZmxvYXQgYW5nbGU7XG4gICAgdW5pZm9ybSBmbG9hdCBzbW9vdGg7XG4gICAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG5cbiAgICB1bmlmb3JtIHZlYzQgY29sb3I7XG4gICAgdW5pZm9ybSB2ZWM0IGJhY2tncm91bmRDb2xvcjtcblxuICAgIGZsb2F0IHJhdGlvID0gcmVzb2x1dGlvbi55IC8gcmVzb2x1dGlvbi54O1xuXG4gICAgdmVjMiB0cmFuc3Bvc2VfcG9zKHZlYzIgcG9zKSB7XG4gICAgICAgIGlmIChyYXRpbyA8IDEuKSB7XG4gICAgICAgICAgICBmbG9hdCBkaWZmID0gMC41IC0gcG9zLng7XG4gICAgICAgICAgICBwb3MueCA9IDAuNSAtIGRpZmYgLyByYXRpbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsb2F0IGRpZmYgPSAwLjUgLSBwb3MueTtcbiAgICAgICAgICAgIHBvcy55ID0gMC41IC0gZGlmZiAqIHJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuXG4gICAgZmxvYXQgZ2V0X2FuZ2xlKHZlYzIgcG9zKSB7XG4gICAgICAgIHBvcyA9IHRyYW5zcG9zZV9wb3MocG9zKTtcbiAgICAgICAgZmxvYXQgYSA9IGF0YW4ocG9zLnkgLSAwLjUsIHBvcy54IC0gMC41KTtcbiAgICAgICAgYSA9ICgxLjArYS8zLjE0MTU5KS8yLjA7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmbG9hdCBkaXN0KHZlYzIgcG9zMSwgdmVjMiBwb3MyKSB7XG4gICAgICAgIHBvczEgPSB0cmFuc3Bvc2VfcG9zKHBvczEpO1xuICAgICAgICByZXR1cm4gZGlzdGFuY2UocG9zMSwgcG9zMik7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKClcbiAgICB7XG4gICAgICAgIHZlYzIgZnJhZ0Nvb3JkID0gdlRleHR1cmVDb29yZDtcbiAgICAgICAgdmVjNCBmcmFnQ29sb3IgPSB2Q29sb3I7XG4gICAgICAgIFxuICAgICAgICB2ZWMyIHN0ID0gdlRleHR1cmVDb29yZDtcbiAgICAgICAgZmxvYXQgcGN0ID0gZGlzdChzdCwgdmVjMigwLjUpKTtcblxuICAgICAgICBmbG9hdCBhID0gZ2V0X2FuZ2xlKHN0KTtcbiAgICAgICAgZmxvYXQgdCA9IGlUaW1lIC8gMTAwMC4wIC8gcGVyaW9kO1xuXG4gICAgICAgIGZsb2F0IGlubmVyID0gbWF4KChyYWRpdXMgLSB3aWR0aCkgLyByZXNvbHV0aW9uLngsIChyYWRpdXMgLSB3aWR0aCkgLyByZXNvbHV0aW9uLnkpO1xuICAgICAgICBmbG9hdCBvdXRlciA9IG1heChyYWRpdXMgLyByZXNvbHV0aW9uLngsIHJhZGl1cyAvIHJlc29sdXRpb24ueSk7XG5cbiAgICAgICAgZmxvYXQgeDEgPSBtb2QodCwgMS4wKTtcbiAgICAgICAgZmxvYXQgeDIgPSBtb2QodCArIGFuZ2xlLCAxLjApO1xuXG4gICAgICAgIGlmICh4MSA8IHgyKSB7XG4gICAgICAgICAgICBpZiAoYSA+IHgxICYmIGEgPCB4Mikge1xuICAgICAgICAgICAgICAgIGZsb2F0IHZhbCA9ICgxLjAgLSAoeDIgLSBhKSAvIGFuZ2xlKSAqIHNtb290aHN0ZXAoMC4wLCAzLiAqIHNtb290aCwgKHgyIC0gYSkpO1xuICAgICAgICAgICAgICAgIGZyYWdDb2xvciA9IG1peChiYWNrZ3JvdW5kQ29sb3IsIGNvbG9yLCB2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFnQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYSA8IHgyKSB7XG4gICAgICAgICAgICAgICAgZmxvYXQgdmFsID0gKDEuMCAtICh4MiAtIGEpIC8gYW5nbGUpICogc21vb3Roc3RlcCgwLjAsIDMuICogc21vb3RoLCAoeDIgLSBhKSk7XG4gICAgICAgICAgICAgICAgZnJhZ0NvbG9yID0gbWl4KGJhY2tncm91bmRDb2xvciwgY29sb3IsIHZhbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEgPiB4MSkge1xuICAgICAgICAgICAgICAgIGZsb2F0IHZhbCA9ICgxLjAgLSAoMS4wICsgeDIgLSBhKSAvIGFuZ2xlKSAqIHNtb290aHN0ZXAoMC4wLCAzLiAqIHNtb290aCwgKDEuMCArIHgyIC0gYSkpO1xuICAgICAgICAgICAgICAgIGZyYWdDb2xvciA9IG1peChiYWNrZ3JvdW5kQ29sb3IsIGNvbG9yLCB2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFnQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbG9hdCBzID0gc21vb3Roc3RlcChpbm5lciwgaW5uZXIgKyBzbW9vdGggKyAwLjAwMDAxLCBwY3QpICogKDEuMCAtIHNtb290aHN0ZXAob3V0ZXIsIG91dGVyICsgc21vb3RoICsgMC4wMDAwMSwgcGN0KSk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgZnJhZ0Nvb3JkKSAqIHZDb2xvciAqICgxLiAtIHMgKiBmcmFnQ29sb3IuYSkgKyBmcmFnQ29sb3IgKiBzO1xuICAgIH1cbmA7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4uLy4uLy4uL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3Bpbm5lclNoYWRlcjIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9wZXJpb2QgPSAxO1xuICAgICAgICB0aGlzLl9zdHJva2UgPSAwO1xuICAgICAgICB0aGlzLl9zaG93RG90ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2xvY2t3aXNlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYmMgPSAweGZmMDAwMDAwO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVkQkMgPSB0aGlzLl9nZXROb3JtYWxpemVkQ29sb3IodGhpcy5fYmMpO1xuICAgICAgICB0aGlzLl9jID0gMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplZEMgPSB0aGlzLl9nZXROb3JtYWxpemVkQ29sb3IodGhpcy5fYyk7XG4gICAgfVxuXG4gICAgc2V0IHJhZGl1cyh2KSB7XG4gICAgICAgIGlmKHYgPT09IDApIHtcbiAgICAgICAgICAgIHYgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHY7XG4gICAgfVxuXG4gICAgc2V0IHN0cm9rZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdHJva2UgPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IHN0cm9rZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cm9rZTtcbiAgICB9XG5cbiAgICBzZXQgY29sb3IoYXJnYikge1xuICAgICAgICB0aGlzLl9jID0gYXJnYjtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplZEMgPSB0aGlzLl9nZXROb3JtYWxpemVkQ29sb3IoYXJnYik7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYztcbiAgICB9XG5cbiAgICBzZXQgYmFja2dyb3VuZENvbG9yKGFyZ2IpIHtcbiAgICAgICAgdGhpcy5fYmMgPSBhcmdiO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVkQkMgPSB0aGlzLl9nZXROb3JtYWxpemVkQ29sb3IoYXJnYik7XG4gICAgfVxuXG4gICAgZ2V0IGJhY2tncm91bmRDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjO1xuICAgIH1cblxuICAgIHNldCBzaG93RG90KGJvb2wpIHtcbiAgICAgICAgdGhpcy5fc2hvd0RvdCA9IGJvb2w7XG4gICAgfVxuXG4gICAgZ2V0IHNob3dEb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93RG90O1xuICAgIH1cblxuICAgIHNldCBjbG9ja3dpc2UoYm9vbCkge1xuICAgICAgICB0aGlzLl9jbG9ja3dpc2UgPSBib29sO1xuICAgIH1cblxuICAgIGdldCBjbG9ja3dpc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9ja3dpc2U7XG4gICAgfVxuXG4gICAgc2V0IHBlcmlvZCh2KSB7XG4gICAgICAgIHRoaXMuX3BlcmlvZCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHBlcmlvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlcmlvZDtcbiAgICB9XG5cbiAgICBfZ2V0Tm9ybWFsaXplZENvbG9yKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IGNvbCA9IFN0YWdlVXRpbHMuZ2V0UmdiYUNvbXBvbmVudHNOb3JtYWxpemVkKGNvbG9yKTtcbiAgICAgICAgY29sWzBdICo9IGNvbFszXTtcbiAgICAgICAgY29sWzFdICo9IGNvbFszXTtcbiAgICAgICAgY29sWzJdICo9IGNvbFszXTtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoY29sKTtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIGNvbnN0IG93bmVyID0gb3BlcmF0aW9uLnNoYWRlck93bmVyO1xuICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLl9yYWRpdXMgfHwgKG93bmVyLl93IC8gMik7XG5cbiAgICAgICAgaWYodGhpcy5fc3Ryb2tlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2UgPSByYWRpdXMgKiAwLjMzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncmVzb2x1dGlvbicsIG5ldyBGbG9hdDMyQXJyYXkoW293bmVyLl93LCBvd25lci5faF0pLCAgdGhpcy5nbC51bmlmb3JtMmZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnY29sb3InLCB0aGlzLl9ub3JtYWxpemVkQywgdGhpcy5nbC51bmlmb3JtNGZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnYmFja2dyb3VuZENvbG9yJywgdGhpcy5fbm9ybWFsaXplZEJDLCB0aGlzLmdsLnVuaWZvcm00ZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdzdHJva2UnLCAgdGhpcy5fc3Ryb2tlLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3JhZGl1cycsICByYWRpdXMsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnZGlyZWN0aW9uJywgIHRoaXMuX2Nsb2Nrd2lzZSA/IC0xIDogMSwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdzaG93RG90JywgISF0aGlzLl9zaG93RG90LCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3RpbWUnLCBEYXRlLm5vdygpIC0gU3Bpbm5lclNoYWRlcjIuc3BpblN5bmMsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncGVyaW9kJywgdGhpcy5fcGVyaW9kLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2FscGhhJywgb3BlcmF0aW9uLmdldEVsZW1lbnRDb3JlKDApLnJlbmRlckNvbnRleHQuYWxwaGEsIHRoaXMuZ2wudW5pZm9ybTFmKTtcblxuICAgICAgICBpZih0aGlzLl9zYyAhPT0gdGhpcy5fYmMgfHwgdGhpcy5fc3Ryb2tlICE9PSByYWRpdXMgKiAwLjUpIHtcbiAgICAgICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblNwaW5uZXJTaGFkZXIyLnNwaW5TeW5jID0gRGF0ZS5ub3coKTtcblxuU3Bpbm5lclNoYWRlcjIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgXG4gICAgI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU5XG4gICAgXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICBcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcbiAgICB1bmlmb3JtIHZlYzQgY29sb3I7XG4gICAgdW5pZm9ybSB2ZWM0IGJhY2tncm91bmRDb2xvcjtcbiAgICB1bmlmb3JtIGZsb2F0IGRpcmVjdGlvbjtcbiAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcbiAgICB1bmlmb3JtIGZsb2F0IHRpbWU7XG4gICAgdW5pZm9ybSBmbG9hdCBzdHJva2U7XG4gICAgdW5pZm9ybSBmbG9hdCBzaG93RG90O1xuICAgIHVuaWZvcm0gZmxvYXQgcGVyaW9kO1xuICAgIHVuaWZvcm0gZmxvYXQgYWxwaGE7XG4gICAgXG4gICAgZmxvYXQgY2lyY2xlRGlzdCh2ZWMyIHAsIGZsb2F0IHJhZGl1cyl7XG4gICAgICAgIHJldHVybiBsZW5ndGgocCkgLSByYWRpdXM7XG4gICAgfVxuICAgIFxuICAgIGZsb2F0IGZpbGxNYXNrKGZsb2F0IGRpc3Qpe1xuICAgICAgICByZXR1cm4gY2xhbXAoLWRpc3QsIDAuMCwgMS4wKTtcbiAgICB9XG4gICAgXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWMyIGhhbGZSZXMgPSAwLjUgKiByZXNvbHV0aW9uLnh5O1xuICAgICAgICB2ZWMyIGNlbnRlciA9IHZUZXh0dXJlQ29vcmQueHkgKiByZXNvbHV0aW9uIC0gaGFsZlJlcztcbiAgICAgICAgXG4gICAgICAgIGZsb2F0IGMgPSBtYXgoLWNpcmNsZURpc3QoY2VudGVyLCByYWRpdXMgLSBzdHJva2UpLCBjaXJjbGVEaXN0KGNlbnRlciwgcmFkaXVzKSk7XG4gICAgICAgIGZsb2F0IHJvdCA9IC0odGltZSAvIDEwMDAuMCAvIHBlcmlvZCkgKiA2LjAgKiBkaXJlY3Rpb247XG4gICAgICAgIGNlbnRlciAqPSBtYXQyKGNvcyhyb3QpLCBzaW4ocm90KSwgLXNpbihyb3QpLCBjb3Mocm90KSk7XG4gICAgICAgIFxuICAgICAgICBmbG9hdCBhID0gZGlyZWN0aW9uICogYXRhbihjZW50ZXIueCwgY2VudGVyLnkpICogUEkgKiAwLjA1ICsgMC40NTtcbiAgICAgICAgXG4gICAgICAgIGZsb2F0IHN0cm9rZVJhZCA9IHN0cm9rZSAqIDAuNTtcbiAgICAgICAgYSA9IG1peChhLCBtYXgoYSwgZmlsbE1hc2soY2lyY2xlRGlzdCh2ZWMyKGNlbnRlci54LCBjZW50ZXIueSArIChyYWRpdXMgLSBzdHJva2VSYWQpKSwgc3Ryb2tlUmFkKSkpLCBzaG93RG90KTtcbiAgICAgICAgdmVjNCBiYXNlID0gbWl4KHZlYzQoMC4wKSwgYmFja2dyb3VuZENvbG9yICogYWxwaGEsIGZpbGxNYXNrKGMpKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gbWl4KGJhc2UsIGNvbG9yICogYWxwaGEsIGZpbGxNYXNrKGMpICogYSk7XG4gICAgfVxuYDtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZ25ldHRlU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fbWFnbml0dWRlID0gMS4zO1xuICAgICAgICB0aGlzLl9pbnRlbnNpdHkgPSAwLjc7XG4gICAgICAgIHRoaXMuX3Bpdm90ID0gWzAuNSwgMC41XTtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG5cbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcIm1hZ25pdHVkZVwiLCB0aGlzLl9tYWduaXR1ZGUgLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJpbnRlbnNpdHlcIiwgdGhpcy5faW50ZW5zaXR5LCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3Bpdm90JywgbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9waXZvdCksIHRoaXMuZ2wudW5pZm9ybTJmdik7XG4gICAgICAgIHRoaXMucmVkcmF3KClcbiAgICB9XG5cbiAgICBzZXQgcGl2b3Qodikge1xuICAgICAgICBpZihBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICB0aGlzLl9waXZvdCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9waXZvdCA9IFt2LCB2XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBwaXZvdFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXZvdFswXTtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3RYKHYpIHtcbiAgICAgICAgdGhpcy5fcGl2b3RbMF0gPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBwaXZvdFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXZvdFsxXTtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3RZKHYpIHtcbiAgICAgICAgdGhpcy5fcGl2b3RbMV0gPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBpbnRlbnNpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlbnNpdHk7XG4gICAgfVxuXG4gICAgc2V0IGludGVuc2l0eSh2KSB7XG4gICAgICAgIHRoaXMuX2ludGVuc2l0eSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IG1hZ25pdHVkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hZ25pdHVkZTtcblxuICAgIH1cblxuICAgIHNldCBtYWduaXR1ZGUodikge1xuICAgICAgICB0aGlzLl9tYWduaXR1ZGUgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cbn1cblxuVmlnbmV0dGVTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gRGVmYXVsdFNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2U7XG5cblZpZ25ldHRlU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG5cbiAgICB1bmlmb3JtIGZsb2F0IG1hZ25pdHVkZTtcbiAgICB1bmlmb3JtIGZsb2F0IGludGVuc2l0eTtcbiAgICB1bmlmb3JtIHZlYzIgcGl2b3Q7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzIgdXYgPSB2VGV4dHVyZUNvb3JkLnh5IC0gcGl2b3QgKyB2ZWMyKDAuNSk7XG4gICAgICAgIHV2LnggPSBjbGFtcCh1di54LCAwLjAsIDEuMCk7XG4gICAgICAgIHV2LnkgPSBjbGFtcCh1di55LCAwLjAsIDEuMCk7XG4gICBcbiAgICAgICAgdXYgKj0gIDEuMDAgLSB1di55eDtcbiAgICAgICAgZmxvYXQgdmlnID0gdXYueCAqIHV2LnkgKiAyNS4wICogaW50ZW5zaXR5O1xuICAgICAgICB2aWcgPSBwb3codmlnLCAwLjQ1ICogbWFnbml0dWRlKTtcbiAgICAgICAgdmVjNCBmcmFnQ29sb3IgPSB2ZWM0KHZpZykgKiB2Q29sb3I7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiBmcmFnQ29sb3I7XG5cbiAgICB9XG5gXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi4vdHJlZS9UZXh0dXJlLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIdG1sVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuICAgICAgICB0aGlzLl9odG1sRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2NhbGUgPSAxO1xuICAgIH1cblxuICAgIHNldCBodG1sRWxlbWVudCh2KSB7XG4gICAgICAgIHRoaXMuX2h0bWxFbGVtZW50ID0gdjtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH1cblxuICAgIGdldCBodG1sRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2h0bWxFbGVtZW50O1xuICAgIH1cblxuICAgIHNldCBzY2FsZSh2KSB7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gdjtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH1cblxuICAgIGdldCBzY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlO1xuICAgIH1cblxuICAgIHNldCBodG1sKHYpIHtcbiAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICB0aGlzLmh0bWxFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZC5pbm5lckhUTUwgPSBcIjxkaXY+XCIgKyB2ICsgXCI8L2Rpdj5cIjtcbiAgICAgICAgICAgIHRoaXMuaHRtbEVsZW1lbnQgPSBkLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGh0bWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9odG1sRWxlbWVudC5pbm5lckhUTUw7XG4gICAgfVxuXG4gICAgX2dldElzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0bWxFbGVtZW50O1xuICAgIH1cblxuICAgIF9nZXRMb29rdXBJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlICsgXCI6XCIgKyB0aGlzLl9odG1sRWxlbWVudC5pbm5lckhUTUw7XG4gICAgfVxuXG4gICAgX2dldFNvdXJjZUxvYWRlcigpIHtcbiAgICAgICAgY29uc3QgaHRtbEVsZW1lbnQgPSB0aGlzLl9odG1sRWxlbWVudDtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5odG1sMmNhbnZhcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoXCJQbGVhc2UgaW5jbHVkZSBodG1sMmNhbnZhcyAoaHR0cHM6Ly9odG1sMmNhbnZhcy5oZXJ0emVuLmNvbS8pXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYXJlYSA9IEh0bWxUZXh0dXJlLmdldFByZWxvYWRBcmVhKCk7XG4gICAgICAgICAgICBhcmVhLmFwcGVuZENoaWxkKGh0bWxFbGVtZW50KTtcblxuICAgICAgICAgICAgaHRtbDJjYW52YXMoaHRtbEVsZW1lbnQsIHtiYWNrZ3JvdW5kQ29sb3I6IG51bGwsIHNjYWxlOiBzY2FsZX0pLnRoZW4oZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgYXJlYS5yZW1vdmVDaGlsZChodG1sRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbnZhcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihcIkNhbnZhcyBoZWlnaHQgaXMgMFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNiKG51bGwsIHtzb3VyY2U6IGNhbnZhcywgd2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0fSk7XG4gICAgICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbTGlnaHRuaW5nXScsIGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0UHJlbG9hZEFyZWEoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJlbG9hZEFyZWEpIHtcbiAgICAgICAgICAgIC8vIFByZWxvYWQgYXJlYSBtdXN0IGJlIGluY2x1ZGVkIGluIGRvY3VtZW50IGJvZHkgYW5kIG11c3QgYmUgdmlzaWJsZSB0byB0cmlnZ2VyIGh0bWwgZWxlbWVudCByZW5kZXJpbmcuXG4gICAgICAgICAgICB0aGlzLl9wcmVsb2FkQXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZWxvYWRBcmVhLmF0dGFjaFNoYWRvdykge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBhIHNoYWRvdyBET00gaWYgcG9zc2libGUgdG8gcHJldmVudCBzdHlsaW5nIGZyb20gaW50ZXJmZXJpbmcuXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlbG9hZEFyZWEuYXR0YWNoU2hhZG93KHttb2RlOiAnY2xvc2VkJ30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJlbG9hZEFyZWEuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9wcmVsb2FkQXJlYS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5fcHJlbG9hZEFyZWEuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICAgICAgdGhpcy5fcHJlbG9hZEFyZWEuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0aGlzLl9wcmVsb2FkQXJlYS5zdHlsZS50b3AgPSAnMTAwdmgnO1xuICAgICAgICAgICAgdGhpcy5fcHJlbG9hZEFyZWEuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fcHJlbG9hZEFyZWEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVsb2FkQXJlYTtcbiAgICB9XG59XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBUZXh0dXJlIGZyb20gXCIuLi90cmVlL1RleHR1cmUubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEltYWdlVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuXG4gICAgICAgIHRoaXMuX3NyYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faGFzQWxwaGEgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgc3JjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3JjO1xuICAgIH1cblxuICAgIHNldCBzcmModikge1xuICAgICAgICBpZiAodGhpcy5fc3JjICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9zcmMgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGhhc0FscGhhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzQWxwaGE7XG4gICAgfVxuXG4gICAgc2V0IGhhc0FscGhhKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc0FscGhhICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNBbHBoYSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0SXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fc3JjO1xuICAgIH1cblxuICAgIF9nZXRMb29rdXBJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NyYztcbiAgICB9XG5cbiAgICBfZ2V0U291cmNlTG9hZGVyKCkge1xuICAgICAgICBsZXQgc3JjID0gdGhpcy5fc3JjO1xuICAgICAgICBsZXQgaGFzQWxwaGEgPSB0aGlzLl9oYXNBbHBoYTtcbiAgICAgICAgaWYgKHRoaXMuc3RhZ2UuZ2V0T3B0aW9uKCdzcmNCYXNlUGF0aCcpKSB7XG4gICAgICAgICAgICB2YXIgZmMgPSBzcmMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmICgoc3JjLmluZGV4T2YoXCIvL1wiKSA9PT0gLTEpICYmICgoZmMgPj0gNjUgJiYgZmMgPD0gOTApIHx8IChmYyA+PSA5NyAmJiBmYyA8PSAxMjIpIHx8IGZjID09IDQ2KSkge1xuICAgICAgICAgICAgICAgIC8vIEFscGhhYmV0aWNhbCBvciBkb3Q6IHByZXBlbmQgYmFzZSBwYXRoLlxuICAgICAgICAgICAgICAgIHNyYyA9IHRoaXMuc3RhZ2UuZ2V0T3B0aW9uKCdzcmNCYXNlUGF0aCcpICsgc3JjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChjYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhZ2UucGxhdGZvcm0ubG9hZFNyY1RleHR1cmUoe3NyYzogc3JjLCBoYXNBbHBoYTogaGFzQWxwaGF9LCBjYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXROb25EZWZhdWx0cygpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gc3VwZXIuZ2V0Tm9uRGVmYXVsdHMoKTtcbiAgICAgICAgaWYgKHRoaXMuX3NyYykge1xuICAgICAgICAgICAgb2JqLnNyYyA9IHRoaXMuX3NyYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxufVxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi4vdHJlZS9UZXh0dXJlLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb2lzZVRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuICAgIF9nZXRMb29rdXBJZCgpIHtcbiAgICAgICAgcmV0dXJuICdfX25vaXNlJztcbiAgICB9XG5cbiAgICBfZ2V0U291cmNlTG9hZGVyKCkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuc3RhZ2UuZ2w7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgY29uc3Qgbm9pc2UgPSBuZXcgVWludDhBcnJheSgxMjggKiAxMjggKiA0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI4ICogMTI4ICogNDsgaSs9NCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpO1xuICAgICAgICAgICAgICAgIG5vaXNlW2ldID0gdjtcbiAgICAgICAgICAgICAgICBub2lzZVtpKzFdID0gdjtcbiAgICAgICAgICAgICAgICBub2lzZVtpKzJdID0gdjtcbiAgICAgICAgICAgICAgICBub2lzZVtpKzNdID0gMjU1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGV4UGFyYW1zID0ge31cblxuICAgICAgICAgICAgaWYgKGdsKSB7XG4gICAgICAgICAgICAgICAgdGV4UGFyYW1zW2dsLlRFWFRVUkVfV1JBUF9TXSA9IGdsLlJFUEVBVDtcbiAgICAgICAgICAgICAgICB0ZXhQYXJhbXNbZ2wuVEVYVFVSRV9XUkFQX1RdID0gZ2wuUkVQRUFUO1xuICAgICAgICAgICAgICAgIHRleFBhcmFtc1tnbC5URVhUVVJFX01JTl9GSUxURVJdID0gZ2wuTkVBUkVTVDtcbiAgICAgICAgICAgICAgICB0ZXhQYXJhbXNbZ2wuVEVYVFVSRV9NQUdfRklMVEVSXSA9IGdsLk5FQVJFU1Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNiKG51bGwsIHtzb3VyY2U6IG5vaXNlLCB3OiAxMjgsIGg6IDEyOCwgdGV4UGFyYW1zOiB0ZXhQYXJhbXN9KTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4uL3RyZWUvVGV4dHVyZS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdGFuZ2xlVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG4gICAgX2dldExvb2t1cElkKCkge1xuICAgICAgICByZXR1cm4gJ19fd2hpdGVwaXgnO1xuICAgIH1cblxuICAgIF9nZXRTb3VyY2VMb2FkZXIoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgdmFyIHdoaXRlUGl4ZWwgPSBuZXcgVWludDhBcnJheShbMjU1LCAyNTUsIDI1NSwgMjU1XSk7XG4gICAgICAgICAgICBjYihudWxsLCB7c291cmNlOiB3aGl0ZVBpeGVsLCB3OiAxLCBoOiAxLCBwZXJtYW5lbnQ6IHRydWV9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzQXV0b3NpemVUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4uL3RyZWUvVGV4dHVyZS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU291cmNlVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuXG4gICAgICAgIHRoaXMuX3RleHR1cmVTb3VyY2UgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZ2V0IHRleHR1cmVTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlU291cmNlO1xuICAgIH1cblxuICAgIHNldCB0ZXh0dXJlU291cmNlKHYpIHtcbiAgICAgICAgaWYgKHYgIT09IHRoaXMuX3RleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICh2LmlzUmVzdWx0VGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgYSByZXN1bHQgdGV4dHVyZSwgYXV0b21hdGljYWxseSBpbmhlcml0IHRoZSBwcmVjaXNpb24uXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlY2lzaW9uID0gdGhpcy5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVTb3VyY2UgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFRleHR1cmVTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlU291cmNlO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4uL3RyZWUvVGV4dHVyZS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGljQ2FudmFzVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuICAgICAgICB0aGlzLl9mYWN0b3J5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9sb29rdXBJZCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBzZXQgY29udGVudCh7ZmFjdG9yeSwgbG9va3VwSWQgPSB1bmRlZmluZWR9KSB7XG4gICAgICAgIHRoaXMuX2ZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLl9sb29rdXBJZCA9IGxvb2t1cElkO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgX2dldElzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2ZhY3Rvcnk7XG4gICAgfVxuXG4gICAgX2dldExvb2t1cElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9va3VwSWQ7XG4gICAgfVxuXG4gICAgX2dldFNvdXJjZUxvYWRlcigpIHtcbiAgICAgICAgY29uc3QgZiA9IHRoaXMuX2ZhY3Rvcnk7XG4gICAgICAgIHJldHVybiAoY2IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmKChlcnIsIGNhbnZhcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNiKG51bGwsIHRoaXMuc3RhZ2UucGxhdGZvcm0uZ2V0VGV4dHVyZU9wdGlvbnNGb3JEcmF3aW5nQ2FudmFzKGNhbnZhcykpO1xuICAgICAgICAgICAgfSwgdGhpcy5zdGFnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBUZXh0dXJlIGZyb20gXCIuLi90cmVlL1RleHR1cmUubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRpY1RleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcblxuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICBzZXQgb3B0aW9ucyh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9XG5cbiAgICBfZ2V0SXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fb3B0aW9ucztcbiAgICB9XG5cbiAgICBfZ2V0U291cmNlTG9hZGVyKCkge1xuICAgICAgICByZXR1cm4gKGNiKSA9PiB7XG4gICAgICAgICAgICBjYihudWxsLCB0aGlzLl9vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBUZXh0dXJlIGZyb20gXCIuLi90cmVlL1RleHR1cmUubWpzXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3RyZWUvVXRpbHMubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHRUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG5cbiAgICAgICAgLy8gV2UgdXNlIHRoZSBzdGFnZSBwcmVjaXNpb24gYXMgdGhlIGRlZmF1bHQgcHJlY2lzaW9uIGluIGNhc2Ugb2YgYSB0ZXh0IHRleHR1cmUuXG4gICAgICAgIHRoaXMuX3ByZWNpc2lvbiA9IHRoaXMuc3RhZ2UuZ2V0T3B0aW9uKCdwcmVjaXNpb24nKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVuZGVyZXIoc3RhZ2UsIGNhbnZhcywgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuYWR2YW5jZWRSZW5kZXJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0VGV4dHVyZVJlbmRlcmVyQWR2YW5jZWQoc3RhZ2UsIGNhbnZhcywgc2V0dGluZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0VGV4dHVyZVJlbmRlcmVyKHN0YWdlLCBjYW52YXMsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICB9XG5cbiAgICBzZXQgdGV4dCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0ID0gXCJcIiArIHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3c7XG4gICAgfVxuXG4gICAgc2V0IHcodikge1xuICAgICAgICBpZiAodGhpcy5fdyAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fdyA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2g7XG4gICAgfVxuXG4gICAgc2V0IGgodikge1xuICAgICAgICBpZiAodGhpcy5faCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5faCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZm9udFN0eWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9udFN0eWxlO1xuICAgIH1cblxuICAgIHNldCBmb250U3R5bGUodikge1xuICAgICAgICBpZiAodGhpcy5fZm9udFN0eWxlICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9mb250U3R5bGUgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGZvbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9udFNpemU7XG4gICAgfVxuXG4gICAgc2V0IGZvbnRTaXplKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZvbnRTaXplICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9mb250U2l6ZSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZm9udEZhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250RmFjZTtcbiAgICB9XG5cbiAgICBzZXQgZm9udEZhY2Uodikge1xuICAgICAgICBpZiAodGhpcy5fZm9udEZhY2UgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRGYWNlID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB3b3JkV3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmRXcmFwO1xuICAgIH1cblxuICAgIHNldCB3b3JkV3JhcCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl93b3JkV3JhcCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fd29yZFdyYXAgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHdvcmRXcmFwV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93b3JkV3JhcFdpZHRoO1xuICAgIH1cblxuICAgIHNldCB3b3JkV3JhcFdpZHRoKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmRXcmFwV2lkdGggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmRXcmFwV2lkdGggPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHdvcmRCcmVhaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmRCcmVhaztcbiAgICB9XG5cbiAgICBzZXQgd29yZEJyZWFrKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmRCcmVhayAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fd29yZEJyZWFrID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB0ZXh0T3ZlcmZsb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0T3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgc2V0IHRleHRPdmVyZmxvdyh2KSB7XG4gICAgICAgIGlmICh2ICE9IHRoaXMuX3RleHRPdmVyZmxvdykge1xuICAgICAgICAgICAgdGhpcy5fdGV4dE92ZXJmbG93ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBsaW5lSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZUhlaWdodDtcbiAgICB9XG5cbiAgICBzZXQgbGluZUhlaWdodCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9saW5lSGVpZ2h0ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lSGVpZ2h0ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB0ZXh0QmFzZWxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0QmFzZWxpbmU7XG4gICAgfVxuXG4gICAgc2V0IHRleHRCYXNlbGluZSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0QmFzZWxpbmUgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHRCYXNlbGluZSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdGV4dEFsaWduKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEFsaWduO1xuICAgIH1cblxuICAgIHNldCB0ZXh0QWxpZ24odikge1xuICAgICAgICBpZiAodGhpcy5fdGV4dEFsaWduICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0QWxpZ24gPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHZlcnRpY2FsQWxpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJ0aWNhbEFsaWduO1xuICAgIH1cblxuICAgIHNldCB2ZXJ0aWNhbEFsaWduKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZlcnRpY2FsQWxpZ24gIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRpY2FsQWxpZ24gPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IG9mZnNldFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXRZO1xuICAgIH1cblxuICAgIHNldCBvZmZzZXRZKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29mZnNldFkgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldFkgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IG1heExpbmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4TGluZXM7XG4gICAgfVxuXG4gICAgc2V0IG1heExpbmVzKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX21heExpbmVzICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9tYXhMaW5lcyA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbWF4TGluZXNTdWZmaXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhMaW5lc1N1ZmZpeDtcbiAgICB9XG5cbiAgICBzZXQgbWF4TGluZXNTdWZmaXgodikge1xuICAgICAgICBpZiAodGhpcy5fbWF4TGluZXNTdWZmaXggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX21heExpbmVzU3VmZml4ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB0ZXh0Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0Q29sb3I7XG4gICAgfVxuXG4gICAgc2V0IHRleHRDb2xvcih2KSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0Q29sb3IgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHRDb2xvciA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcGFkZGluZ0xlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nTGVmdDtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZ0xlZnQodikge1xuICAgICAgICBpZiAodGhpcy5fcGFkZGluZ0xlZnQgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhZGRpbmdMZWZ0ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBwYWRkaW5nUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nUmlnaHQ7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmdSaWdodCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9wYWRkaW5nUmlnaHQgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhZGRpbmdSaWdodCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2hhZG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hhZG93O1xuICAgIH1cblxuICAgIHNldCBzaGFkb3codikge1xuICAgICAgICBpZiAodGhpcy5fc2hhZG93ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3cgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHNoYWRvd0NvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hhZG93Q29sb3I7XG4gICAgfVxuXG4gICAgc2V0IHNoYWRvd0NvbG9yKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NoYWRvd0NvbG9yICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dDb2xvciA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2hhZG93T2Zmc2V0WCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYWRvd09mZnNldFg7XG4gICAgfVxuXG4gICAgc2V0IHNoYWRvd09mZnNldFgodikge1xuICAgICAgICBpZiAodGhpcy5fc2hhZG93T2Zmc2V0WCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2hhZG93T2Zmc2V0WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYWRvd09mZnNldFk7XG4gICAgfVxuXG4gICAgc2V0IHNoYWRvd09mZnNldFkodikge1xuICAgICAgICBpZiAodGhpcy5fc2hhZG93T2Zmc2V0WSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2hhZG93Qmx1cigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYWRvd0JsdXI7XG4gICAgfVxuXG4gICAgc2V0IHNoYWRvd0JsdXIodikge1xuICAgICAgICBpZiAodGhpcy5fc2hhZG93Qmx1ciAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93Qmx1ciA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaGlnaGxpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlnaGxpZ2h0O1xuICAgIH1cblxuICAgIHNldCBoaWdobGlnaHQodikge1xuICAgICAgICBpZiAodGhpcy5faGlnaGxpZ2h0ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9oaWdobGlnaHQgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGhpZ2hsaWdodEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZ2hsaWdodEhlaWdodDtcbiAgICB9XG5cbiAgICBzZXQgaGlnaGxpZ2h0SGVpZ2h0KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hpZ2hsaWdodEhlaWdodCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0SGVpZ2h0ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBoaWdobGlnaHRDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZ2hsaWdodENvbG9yO1xuICAgIH1cblxuICAgIHNldCBoaWdobGlnaHRDb2xvcih2KSB7XG4gICAgICAgIGlmICh0aGlzLl9oaWdobGlnaHRDb2xvciAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0Q29sb3IgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGhpZ2hsaWdodE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZ2hsaWdodE9mZnNldDtcbiAgICB9XG5cbiAgICBzZXQgaGlnaGxpZ2h0T2Zmc2V0KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hpZ2hsaWdodE9mZnNldCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0T2Zmc2V0ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBoaWdobGlnaHRQYWRkaW5nTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZ2hsaWdodFBhZGRpbmdMZWZ0O1xuICAgIH1cblxuICAgIHNldCBoaWdobGlnaHRQYWRkaW5nTGVmdCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9oaWdobGlnaHRQYWRkaW5nTGVmdCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0UGFkZGluZ0xlZnQgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGhpZ2hsaWdodFBhZGRpbmdSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZ2hsaWdodFBhZGRpbmdSaWdodDtcbiAgICB9XG5cbiAgICBzZXQgaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hpZ2hsaWdodFBhZGRpbmdSaWdodCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0UGFkZGluZ1JpZ2h0ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjdXRTeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1dFN4O1xuICAgIH1cblxuICAgIHNldCBjdXRTeCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXRTeCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fY3V0U3ggPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGN1dEV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3V0RXg7XG4gICAgfVxuXG4gICAgc2V0IGN1dEV4KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1dEV4ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9jdXRFeCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY3V0U3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXRTeTtcbiAgICB9XG5cbiAgICBzZXQgY3V0U3kodikge1xuICAgICAgICBpZiAodGhpcy5fY3V0U3kgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1dFN5ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjdXRFeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1dEV5O1xuICAgIH1cblxuICAgIHNldCBjdXRFeSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXRFeSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fY3V0RXkgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGFkdmFuY2VkUmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZHZhbmNlZFJlbmRlcmVyO1xuICAgIH1cblxuICAgIHNldCBhZHZhbmNlZFJlbmRlcmVyKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FkdmFuY2VkUmVuZGVyZXIgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2VkUmVuZGVyZXIgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IGxldHRlclNwYWNpbmcodikge1xuICAgICAgICBpZiAodGhpcy5fbGV0dGVyU3BhY2luZyAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fbGV0dGVyU3BhY2luZyA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbGV0dGVyU3BhY2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xldHRlclNwYWNpbmc7XG4gICAgfVxuXG4gICAgc2V0IHRleHRJbmRlbnQodikge1xuICAgICAgICBpZiAodGhpcy5fdGV4dEluZGVudCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fdGV4dEluZGVudCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdGV4dEluZGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRJbmRlbnQ7XG4gICAgfVxuXG4gICAgZ2V0IHByZWNpc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnByZWNpc2lvbjtcbiAgICB9XG5cbiAgICBzZXQgcHJlY2lzaW9uKHYpIHtcbiAgICAgICAgLy8gV2UgYWN0dWFsbHkgZHJhdyBkaWZmZXJlbnRseSB3aGVuIHRoZSBwcmVjaXNpb24gY2hhbmdlcy5cbiAgICAgICAgaWYgKHRoaXMucHJlY2lzaW9uICE9PSB2KSB7XG4gICAgICAgICAgICBzdXBlci5wcmVjaXNpb24gPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldElzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMudGV4dDtcbiAgICB9XG5cbiAgICBfZ2V0TG9va3VwSWQoKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLncgIT09IDApIHBhcnRzLnB1c2goXCJ3IFwiICsgdGhpcy53KTtcbiAgICAgICAgaWYgKHRoaXMuaCAhPT0gMCkgcGFydHMucHVzaChcImggXCIgKyB0aGlzLmgpO1xuICAgICAgICBpZiAodGhpcy5mb250U3R5bGUgIT09IFwibm9ybWFsXCIpIHBhcnRzLnB1c2goXCJmU1wiICsgdGhpcy5mb250U3R5bGUpO1xuICAgICAgICBpZiAodGhpcy5mb250U2l6ZSAhPT0gNDApIHBhcnRzLnB1c2goXCJmc1wiICsgdGhpcy5mb250U2l6ZSk7XG4gICAgICAgIGlmICh0aGlzLmZvbnRGYWNlICE9PSBudWxsKSBwYXJ0cy5wdXNoKFwiZmZcIiArIChBcnJheS5pc0FycmF5KHRoaXMuZm9udEZhY2UpID8gdGhpcy5mb250RmFjZS5qb2luKFwiLFwiKSA6IHRoaXMuZm9udEZhY2UpKTtcbiAgICAgICAgaWYgKHRoaXMud29yZFdyYXAgIT09IHRydWUpIHBhcnRzLnB1c2goXCJ3clwiICsgKHRoaXMud29yZFdyYXAgPyAxIDogMCkpO1xuICAgICAgICBpZiAodGhpcy53b3JkV3JhcFdpZHRoICE9PSAwKSBwYXJ0cy5wdXNoKFwid3dcIiArIHRoaXMud29yZFdyYXBXaWR0aCk7XG4gICAgICAgIGlmICh0aGlzLndvcmRCcmVhayAhPT0gZmFsc2UpIHBhcnRzLnB1c2goXCJ3YlwiICsgdGhpcy53b3JkQnJlYWsgPyAxIDogMCk7XG4gICAgICAgIGlmICh0aGlzLnRleHRPdmVyZmxvdyAhPSBcIlwiKSBwYXJ0cy5wdXNoKFwidG9cIiArIHRoaXMudGV4dE92ZXJmbG93KTtcbiAgICAgICAgaWYgKHRoaXMubGluZUhlaWdodCAhPT0gbnVsbCkgcGFydHMucHVzaChcImxoXCIgKyB0aGlzLmxpbmVIZWlnaHQpO1xuICAgICAgICBpZiAodGhpcy50ZXh0QmFzZWxpbmUgIT09IFwiYWxwaGFiZXRpY1wiKSBwYXJ0cy5wdXNoKFwidGJcIiArIHRoaXMudGV4dEJhc2VsaW5lKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dEFsaWduICE9PSBcImxlZnRcIikgcGFydHMucHVzaChcInRhXCIgKyB0aGlzLnRleHRBbGlnbik7XG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2FsQWxpZ24gIT09IFwidG9wXCIpIHBhcnRzLnB1c2goXCJ2YVwiICsgdGhpcy52ZXJ0aWNhbEFsaWduKTtcbiAgICAgICAgaWYgKHRoaXMub2Zmc2V0WSAhPT0gbnVsbCkgcGFydHMucHVzaChcIm95XCIgKyB0aGlzLm9mZnNldFkpO1xuICAgICAgICBpZiAodGhpcy5tYXhMaW5lcyAhPT0gMCkgcGFydHMucHVzaChcIm1sXCIgKyB0aGlzLm1heExpbmVzKTtcbiAgICAgICAgaWYgKHRoaXMubWF4TGluZXNTdWZmaXggIT09IFwiLi5cIikgcGFydHMucHVzaChcIm1zXCIgKyB0aGlzLm1heExpbmVzU3VmZml4KTtcbiAgICAgICAgcGFydHMucHVzaChcInBjXCIgKyB0aGlzLnByZWNpc2lvbik7XG4gICAgICAgIGlmICh0aGlzLnRleHRDb2xvciAhPT0gMHhmZmZmZmZmZikgcGFydHMucHVzaChcImNvXCIgKyB0aGlzLnRleHRDb2xvci50b1N0cmluZygxNikpO1xuICAgICAgICBpZiAodGhpcy5wYWRkaW5nTGVmdCAhPT0gMCkgcGFydHMucHVzaChcInBsXCIgKyB0aGlzLnBhZGRpbmdMZWZ0KTtcbiAgICAgICAgaWYgKHRoaXMucGFkZGluZ1JpZ2h0ICE9PSAwKSBwYXJ0cy5wdXNoKFwicHJcIiArIHRoaXMucGFkZGluZ1JpZ2h0KTtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93ICE9PSBmYWxzZSkgcGFydHMucHVzaChcInNoXCIgKyAodGhpcy5zaGFkb3cgPyAxIDogMCkpO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dDb2xvciAhPT0gMHhmZjAwMDAwMCkgcGFydHMucHVzaChcInNjXCIgKyB0aGlzLnNoYWRvd0NvbG9yLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd09mZnNldFggIT09IDApIHBhcnRzLnB1c2goXCJzeFwiICsgdGhpcy5zaGFkb3dPZmZzZXRYKTtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93T2Zmc2V0WSAhPT0gMCkgcGFydHMucHVzaChcInN5XCIgKyB0aGlzLnNoYWRvd09mZnNldFkpO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dCbHVyICE9PSA1KSBwYXJ0cy5wdXNoKFwic2JcIiArIHRoaXMuc2hhZG93Qmx1cik7XG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodCAhPT0gZmFsc2UpIHBhcnRzLnB1c2goXCJoTFwiICsgKHRoaXMuaGlnaGxpZ2h0ID8gMSA6IDApKTtcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0SGVpZ2h0ICE9PSAwKSBwYXJ0cy5wdXNoKFwiaGhcIiArIHRoaXMuaGlnaGxpZ2h0SGVpZ2h0KTtcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0Q29sb3IgIT09IDB4ZmYwMDAwMDApIHBhcnRzLnB1c2goXCJoY1wiICsgdGhpcy5oaWdobGlnaHRDb2xvci50b1N0cmluZygxNikpO1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRPZmZzZXQgIT09IG51bGwpIHBhcnRzLnB1c2goXCJob1wiICsgdGhpcy5oaWdobGlnaHRPZmZzZXQpO1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRQYWRkaW5nTGVmdCAhPT0gbnVsbCkgcGFydHMucHVzaChcImhsXCIgKyB0aGlzLmhpZ2hsaWdodFBhZGRpbmdMZWZ0KTtcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0ICE9PSBudWxsKSBwYXJ0cy5wdXNoKFwiaHJcIiArIHRoaXMuaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0KTtcbiAgICAgICAgaWYgKHRoaXMubGV0dGVyU3BhY2luZyAhPT0gbnVsbCkgcGFydHMucHVzaChcImxzXCIgKyB0aGlzLmxldHRlclNwYWNpbmcpO1xuICAgICAgICBpZiAodGhpcy50ZXh0SW5kZW50ICE9PSBudWxsKSBwYXJ0cy5wdXNoKFwidGlcIiArIHRoaXMudGV4dEluZGVudCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY3V0U3gpIHBhcnRzLnB1c2goXCJjc3hcIiArIHRoaXMuY3V0U3gpO1xuICAgICAgICBpZiAodGhpcy5jdXRFeCkgcGFydHMucHVzaChcImNleFwiICsgdGhpcy5jdXRFeCk7XG4gICAgICAgIGlmICh0aGlzLmN1dFN5KSBwYXJ0cy5wdXNoKFwiY3N5XCIgKyB0aGlzLmN1dFN5KTtcbiAgICAgICAgaWYgKHRoaXMuY3V0RXkpIHBhcnRzLnB1c2goXCJjZXlcIiArIHRoaXMuY3V0RXkpO1xuXG4gICAgICAgIGlmICh0aGlzLmFkdmFuY2VkUmVuZGVyZXIpIHBhcnRzLnB1c2goXCJhUlwiICsgdGhpcy5hZHZhbmNlZFJlbmRlcmVyID8gMSA6IDApO1xuXG4gICAgICAgIGxldCBpZCA9IFwiVFgkXCIgKyBwYXJ0cy5qb2luKFwifFwiKSArIFwiOlwiICsgdGhpcy50ZXh0O1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgX2dldFNvdXJjZUxvYWRlcigpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuY2xvbmVBcmdzKCk7XG5cbiAgICAgICAgLy8gSW5oZXJpdCBmb250IGZhY2UgZnJvbSBzdGFnZS5cbiAgICAgICAgaWYgKGFyZ3MuZm9udEZhY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGFyZ3MuZm9udEZhY2UgPSB0aGlzLnN0YWdlLmdldE9wdGlvbignZGVmYXVsdEZvbnRGYWNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuc3RhZ2UuZ2w7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5zdGFnZS5wbGF0Zm9ybS5nZXREcmF3aW5nQ2FudmFzKCk7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IChhcmdzLmFkdmFuY2VkUmVuZGVyZXIpXG4gICAgICAgICAgICAgID8gbmV3IFRleHRUZXh0dXJlUmVuZGVyZXJBZHZhbmNlZCh0aGlzLnN0YWdlLCBjYW52YXMsIGFyZ3MpXG4gICAgICAgICAgICAgIDogbmV3IFRleHRUZXh0dXJlUmVuZGVyZXIodGhpcy5zdGFnZSwgY2FudmFzLCBhcmdzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcCA9IHJlbmRlcmVyLmRyYXcoKTtcblxuICAgICAgICAgICAgY29uc3QgdGV4UGFyYW1zID0ge307XG5cbiAgICAgICAgICAgIGNvbnN0IHNoYXJwQ2ZnID0gdGhpcy5zdGFnZS5nZXRPcHRpb24oJ2ZvbnRTaGFycCcpO1xuICAgICAgICAgICAgbGV0IHNoYXJwZW4gPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gUHJldmVudCB0ZXh0IGJsdXIgd2hlbiB0ZXh0IHRleHR1cmUgaXMgZG93bnNjYWxlZFxuICAgICAgICAgICAgaWYgKFV0aWxzLmlzQm9vbGVhbihzaGFycENmZykpIHtcbiAgICAgICAgICAgICAgICBzaGFycGVuID0gc2hhcnBDZmc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzT2JqZWN0KHNoYXJwQ2ZnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IHRoaXMuc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKCk7XG4gICAgICAgICAgICAgICAgc2hhcnBlbiA9IHByZWNpc2lvbiA8PSBzaGFycENmZy5wcmVjaXNpb24gJiYgYXJncy5mb250U2l6ZSA8PSBzaGFycENmZy5mb250U2l6ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdsICYmIHNoYXJwZW4pIHtcbiAgICAgICAgICAgICAgICB0ZXhQYXJhbXNbZ2wuVEVYVFVSRV9NQUdfRklMVEVSXSA9IGdsLk5FQVJFU1Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgcC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogRklYTUU6IG9uIHNvbWUgcGxhdGZvcm1zIChlLmcuIFJQSSksIHRocm90dGxpbmcgdGV4dCB0ZXh0dXJlcyBjYXVzZSBhcnRpZmFjdHMgKi9cbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJJbmZvOiByZW5kZXJlci5yZW5kZXJJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4UGFyYW1zOiB0ZXhQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuc3RhZ2UucGxhdGZvcm0uZ2V0VGV4dHVyZU9wdGlvbnNGb3JEcmF3aW5nQ2FudmFzKGNhbnZhcykpKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiKG51bGwsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJJbmZvOiByZW5kZXJlci5yZW5kZXJJbmZvLFxuICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleFBhcmFtczogdGV4UGFyYW1zLFxuICAgICAgICAgICAgICAgIH0sIHRoaXMuc3RhZ2UucGxhdGZvcm0uZ2V0VGV4dHVyZU9wdGlvbnNGb3JEcmF3aW5nQ2FudmFzKGNhbnZhcykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIGdldE5vbkRlZmF1bHRzKCkge1xuICAgICAgICBjb25zdCBub25EZWZhdWx0cyA9IHN1cGVyLmdldE5vbkRlZmF1bHRzKCk7XG4gICAgICAgIGlmICh0aGlzLnRleHQgIT09IFwiXCIpIG5vbkRlZmF1bHRzWyd0ZXh0J10gPSB0aGlzLnRleHQ7XG4gICAgICAgIGlmICh0aGlzLncgIT09IDApIG5vbkRlZmF1bHRzWyd3J10gPSB0aGlzLnc7XG4gICAgICAgIGlmICh0aGlzLmggIT09IDApIG5vbkRlZmF1bHRzWydoJ10gPSB0aGlzLmg7XG4gICAgICAgIGlmICh0aGlzLmZvbnRTdHlsZSAhPT0gXCJub3JtYWxcIikgbm9uRGVmYXVsdHNbJ2ZvbnRTdHlsZSddID0gdGhpcy5mb250U3R5bGU7XG4gICAgICAgIGlmICh0aGlzLmZvbnRTaXplICE9PSA0MCkgbm9uRGVmYXVsdHNbXCJmb250U2l6ZVwiXSA9IHRoaXMuZm9udFNpemU7XG4gICAgICAgIGlmICh0aGlzLmZvbnRGYWNlICE9PSBudWxsKSBub25EZWZhdWx0c1tcImZvbnRGYWNlXCJdID0gdGhpcy5mb250RmFjZTtcbiAgICAgICAgaWYgKHRoaXMud29yZFdyYXAgIT09IHRydWUpIG5vbkRlZmF1bHRzW1wid29yZFdyYXBcIl0gPSB0aGlzLndvcmRXcmFwO1xuICAgICAgICBpZiAodGhpcy53b3JkV3JhcFdpZHRoICE9PSAwKSBub25EZWZhdWx0c1tcIndvcmRXcmFwV2lkdGhcIl0gPSB0aGlzLndvcmRXcmFwV2lkdGg7XG4gICAgICAgIGlmICh0aGlzLndvcmRCcmVhayAhPT0gZmFsc2UpIG5vbkRlZmF1bHRzW1wid29yZEJyZWFrXCJdID0gdGhpcy53b3JkQnJlYWs7XG4gICAgICAgIGlmICh0aGlzLnRleHRPdmVyZmxvdyAhPSBcIlwiKSBub25EZWZhdWx0c1tcInRleHRPdmVyZmxvd1wiXSA9IHRoaXMudGV4dE92ZXJmbG93O1xuICAgICAgICBpZiAodGhpcy5saW5lSGVpZ2h0ICE9PSBudWxsKSBub25EZWZhdWx0c1tcImxpbmVIZWlnaHRcIl0gPSB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLnRleHRCYXNlbGluZSAhPT0gXCJhbHBoYWJldGljXCIpIG5vbkRlZmF1bHRzW1widGV4dEJhc2VsaW5lXCJdID0gdGhpcy50ZXh0QmFzZWxpbmU7XG4gICAgICAgIGlmICh0aGlzLnRleHRBbGlnbiAhPT0gXCJsZWZ0XCIpIG5vbkRlZmF1bHRzW1widGV4dEFsaWduXCJdID0gdGhpcy50ZXh0QWxpZ247XG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2FsQWxpZ24gIT09IFwidG9wXCIpIG5vbkRlZmF1bHRzW1widmVydGljYWxBbGlnblwiXSA9IHRoaXMudmVydGljYWxBbGlnbjtcbiAgICAgICAgaWYgKHRoaXMub2Zmc2V0WSAhPT0gbnVsbCkgbm9uRGVmYXVsdHNbXCJvZmZzZXRZXCJdID0gdGhpcy5vZmZzZXRZO1xuICAgICAgICBpZiAodGhpcy5tYXhMaW5lcyAhPT0gMCkgbm9uRGVmYXVsdHNbXCJtYXhMaW5lc1wiXSA9IHRoaXMubWF4TGluZXM7XG4gICAgICAgIGlmICh0aGlzLm1heExpbmVzU3VmZml4ICE9PSBcIi4uXCIpIG5vbkRlZmF1bHRzW1wibWF4TGluZXNTdWZmaXhcIl0gPSB0aGlzLm1heExpbmVzU3VmZml4O1xuICAgICAgICBpZiAodGhpcy5wcmVjaXNpb24gIT09IHRoaXMuc3RhZ2UuZ2V0T3B0aW9uKCdwcmVjaXNpb24nKSkgbm9uRGVmYXVsdHNbXCJwcmVjaXNpb25cIl0gPSB0aGlzLnByZWNpc2lvbjtcbiAgICAgICAgaWYgKHRoaXMudGV4dENvbG9yICE9PSAweGZmZmZmZmZmKSBub25EZWZhdWx0c1tcInRleHRDb2xvclwiXSA9IHRoaXMudGV4dENvbG9yO1xuICAgICAgICBpZiAodGhpcy5wYWRkaW5nTGVmdCAhPT0gMCkgbm9uRGVmYXVsdHNbXCJwYWRkaW5nTGVmdFwiXSA9IHRoaXMucGFkZGluZ0xlZnQ7XG4gICAgICAgIGlmICh0aGlzLnBhZGRpbmdSaWdodCAhPT0gMCkgbm9uRGVmYXVsdHNbXCJwYWRkaW5nUmlnaHRcIl0gPSB0aGlzLnBhZGRpbmdSaWdodDtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93ICE9PSBmYWxzZSkgbm9uRGVmYXVsdHNbXCJzaGFkb3dcIl0gPSB0aGlzLnNoYWRvdztcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93Q29sb3IgIT09IDB4ZmYwMDAwMDApIG5vbkRlZmF1bHRzW1wic2hhZG93Q29sb3JcIl0gPSB0aGlzLnNoYWRvd0NvbG9yO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dPZmZzZXRYICE9PSAwKSBub25EZWZhdWx0c1tcInNoYWRvd09mZnNldFhcIl0gPSB0aGlzLnNoYWRvd09mZnNldFg7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd09mZnNldFkgIT09IDApIG5vbkRlZmF1bHRzW1wic2hhZG93T2Zmc2V0WVwiXSA9IHRoaXMuc2hhZG93T2Zmc2V0WTtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93Qmx1ciAhPT0gNSkgbm9uRGVmYXVsdHNbXCJzaGFkb3dCbHVyXCJdID0gdGhpcy5zaGFkb3dCbHVyO1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHQgIT09IGZhbHNlKSBub25EZWZhdWx0c1tcImhpZ2hsaWdodFwiXSA9IHRoaXMuaGlnaGxpZ2h0O1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRIZWlnaHQgIT09IDApIG5vbkRlZmF1bHRzW1wiaGlnaGxpZ2h0SGVpZ2h0XCJdID0gdGhpcy5oaWdobGlnaHRIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodENvbG9yICE9PSAweGZmMDAwMDAwKSBub25EZWZhdWx0c1tcImhpZ2hsaWdodENvbG9yXCJdID0gdGhpcy5oaWdobGlnaHRDb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0T2Zmc2V0ICE9PSAwKSBub25EZWZhdWx0c1tcImhpZ2hsaWdodE9mZnNldFwiXSA9IHRoaXMuaGlnaGxpZ2h0T2Zmc2V0O1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRQYWRkaW5nTGVmdCAhPT0gMCkgbm9uRGVmYXVsdHNbXCJoaWdobGlnaHRQYWRkaW5nTGVmdFwiXSA9IHRoaXMuaGlnaGxpZ2h0UGFkZGluZ0xlZnQ7XG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodFBhZGRpbmdSaWdodCAhPT0gMCkgbm9uRGVmYXVsdHNbXCJoaWdobGlnaHRQYWRkaW5nUmlnaHRcIl0gPSB0aGlzLmhpZ2hsaWdodFBhZGRpbmdSaWdodDtcbiAgICAgICAgaWYgKHRoaXMubGV0dGVyU3BhY2luZyAhPT0gMCkgbm9uRGVmYXVsdHNbXCJsZXR0ZXJTcGFjaW5nXCJdID0gdGhpcy5sZXR0ZXJTcGFjaW5nO1xuICAgICAgICBpZiAodGhpcy50ZXh0SW5kZW50ICE9PSAwKSBub25EZWZhdWx0c1tcInRleHRJbmRlbnRcIl0gPSB0aGlzLnRleHRJbmRlbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuY3V0U3gpIG5vbkRlZmF1bHRzW1wiY3V0U3hcIl0gPSB0aGlzLmN1dFN4O1xuICAgICAgICBpZiAodGhpcy5jdXRFeCkgbm9uRGVmYXVsdHNbXCJjdXRFeFwiXSA9IHRoaXMuY3V0RXg7XG4gICAgICAgIGlmICh0aGlzLmN1dFN5KSBub25EZWZhdWx0c1tcImN1dFN5XCJdID0gdGhpcy5jdXRTeTtcbiAgICAgICAgaWYgKHRoaXMuY3V0RXkpIG5vbkRlZmF1bHRzW1wiY3V0RXlcIl0gPSB0aGlzLmN1dEV5O1xuXG4gICAgICAgIGlmICh0aGlzLmFkdmFuY2VkUmVuZGVyZXIpIG5vbkRlZmF1bHRzW1wicmVuZGVyZXJcIl0gPSB0aGlzLmFkdmFuY2VkUmVuZGVyZXI7XG4gICAgICAgIHJldHVybiBub25EZWZhdWx0cztcbiAgICB9XG5cbiAgICBjbG9uZUFyZ3MoKSB7XG4gICAgICAgIGxldCBvYmogPSB7fTtcbiAgICAgICAgb2JqLnRleHQgPSB0aGlzLl90ZXh0O1xuICAgICAgICBvYmoudyA9IHRoaXMuX3c7XG4gICAgICAgIG9iai5oID0gdGhpcy5faDtcbiAgICAgICAgb2JqLmZvbnRTdHlsZSA9IHRoaXMuX2ZvbnRTdHlsZTtcbiAgICAgICAgb2JqLmZvbnRTaXplID0gdGhpcy5fZm9udFNpemU7XG4gICAgICAgIG9iai5mb250RmFjZSA9IHRoaXMuX2ZvbnRGYWNlO1xuICAgICAgICBvYmoud29yZFdyYXAgPSB0aGlzLl93b3JkV3JhcDtcbiAgICAgICAgb2JqLndvcmRXcmFwV2lkdGggPSB0aGlzLl93b3JkV3JhcFdpZHRoO1xuICAgICAgICBvYmoud29yZEJyZWFrID0gdGhpcy5fd29yZEJyZWFrO1xuICAgICAgICBvYmoudGV4dE92ZXJmbG93ID0gdGhpcy5fdGV4dE92ZXJmbG93O1xuICAgICAgICBvYmoubGluZUhlaWdodCA9IHRoaXMuX2xpbmVIZWlnaHQ7XG4gICAgICAgIG9iai50ZXh0QmFzZWxpbmUgPSB0aGlzLl90ZXh0QmFzZWxpbmU7XG4gICAgICAgIG9iai50ZXh0QWxpZ24gPSB0aGlzLl90ZXh0QWxpZ247XG4gICAgICAgIG9iai52ZXJ0aWNhbEFsaWduID0gdGhpcy5fdmVydGljYWxBbGlnbjtcbiAgICAgICAgb2JqLm9mZnNldFkgPSB0aGlzLl9vZmZzZXRZO1xuICAgICAgICBvYmoubWF4TGluZXMgPSB0aGlzLl9tYXhMaW5lcztcbiAgICAgICAgb2JqLm1heExpbmVzU3VmZml4ID0gdGhpcy5fbWF4TGluZXNTdWZmaXg7XG4gICAgICAgIG9iai5wcmVjaXNpb24gPSB0aGlzLl9wcmVjaXNpb247XG4gICAgICAgIG9iai50ZXh0Q29sb3IgPSB0aGlzLl90ZXh0Q29sb3I7XG4gICAgICAgIG9iai5wYWRkaW5nTGVmdCA9IHRoaXMuX3BhZGRpbmdMZWZ0O1xuICAgICAgICBvYmoucGFkZGluZ1JpZ2h0ID0gdGhpcy5fcGFkZGluZ1JpZ2h0O1xuICAgICAgICBvYmouc2hhZG93ID0gdGhpcy5fc2hhZG93O1xuICAgICAgICBvYmouc2hhZG93Q29sb3IgPSB0aGlzLl9zaGFkb3dDb2xvcjtcbiAgICAgICAgb2JqLnNoYWRvd09mZnNldFggPSB0aGlzLl9zaGFkb3dPZmZzZXRYO1xuICAgICAgICBvYmouc2hhZG93T2Zmc2V0WSA9IHRoaXMuX3NoYWRvd09mZnNldFk7XG4gICAgICAgIG9iai5zaGFkb3dCbHVyID0gdGhpcy5fc2hhZG93Qmx1cjtcbiAgICAgICAgb2JqLmhpZ2hsaWdodCA9IHRoaXMuX2hpZ2hsaWdodDtcbiAgICAgICAgb2JqLmhpZ2hsaWdodEhlaWdodCA9IHRoaXMuX2hpZ2hsaWdodEhlaWdodDtcbiAgICAgICAgb2JqLmhpZ2hsaWdodENvbG9yID0gdGhpcy5faGlnaGxpZ2h0Q29sb3I7XG4gICAgICAgIG9iai5oaWdobGlnaHRPZmZzZXQgPSB0aGlzLl9oaWdobGlnaHRPZmZzZXQ7XG4gICAgICAgIG9iai5oaWdobGlnaHRQYWRkaW5nTGVmdCA9IHRoaXMuX2hpZ2hsaWdodFBhZGRpbmdMZWZ0O1xuICAgICAgICBvYmouaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0ID0gdGhpcy5faGlnaGxpZ2h0UGFkZGluZ1JpZ2h0O1xuICAgICAgICBvYmoubGV0dGVyU3BhY2luZyA9IHRoaXMuX2xldHRlclNwYWNpbmc7XG4gICAgICAgIG9iai50ZXh0SW5kZW50ID0gdGhpcy5fdGV4dEluZGVudDtcbiAgICAgICAgb2JqLmN1dFN4ID0gdGhpcy5fY3V0U3g7XG4gICAgICAgIG9iai5jdXRFeCA9IHRoaXMuX2N1dEV4O1xuICAgICAgICBvYmouY3V0U3kgPSB0aGlzLl9jdXRTeTtcbiAgICAgICAgb2JqLmN1dEV5ID0gdGhpcy5fY3V0RXk7XG4gICAgICAgIG9iai5hZHZhbmNlZFJlbmRlcmVyID0gdGhpcy5fYWR2YW5jZWRSZW5kZXJlcjtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cblxufVxuXG4vLyBCZWNhdXNlIHRoZXJlIGFyZSBzbyBtYW55IHByb3BlcnRpZXMsIHdlIHByZWZlciB0byB1c2UgdGhlIHByb3RvdHlwZSBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4vLyBUaGlzIGNhdXNlcyBhIGRlY3JlYXNlIGluIHBlcmZvcm1hbmNlLCBidXQgYWxzbyBhIGRlY3JlYXNlIGluIG1lbW9yeSB1c2FnZS5cbmxldCBwcm90byA9IFRleHRUZXh0dXJlLnByb3RvdHlwZTtcbnByb3RvLl90ZXh0ID0gXCJcIjtcbnByb3RvLl93ID0gMDtcbnByb3RvLl9oID0gMDtcbnByb3RvLl9mb250U3R5bGUgPSBcIm5vcm1hbFwiO1xucHJvdG8uX2ZvbnRTaXplID0gNDA7XG5wcm90by5fZm9udEZhY2UgPSBudWxsO1xucHJvdG8uX3dvcmRXcmFwID0gdHJ1ZTtcbnByb3RvLl93b3JkV3JhcFdpZHRoID0gMDtcbnByb3RvLl93b3JkQnJlYWsgPSBmYWxzZTtcbnByb3RvLl90ZXh0T3ZlcmZsb3cgPSBcIlwiO1xucHJvdG8uX2xpbmVIZWlnaHQgPSBudWxsO1xucHJvdG8uX3RleHRCYXNlbGluZSA9IFwiYWxwaGFiZXRpY1wiO1xucHJvdG8uX3RleHRBbGlnbiA9IFwibGVmdFwiO1xucHJvdG8uX3ZlcnRpY2FsQWxpZ24gPSBcInRvcFwiO1xucHJvdG8uX29mZnNldFkgPSBudWxsO1xucHJvdG8uX21heExpbmVzID0gMDtcbnByb3RvLl9tYXhMaW5lc1N1ZmZpeCA9IFwiLi5cIjtcbnByb3RvLl90ZXh0Q29sb3IgPSAweEZGRkZGRkZGO1xucHJvdG8uX3BhZGRpbmdMZWZ0ID0gMDtcbnByb3RvLl9wYWRkaW5nUmlnaHQgPSAwO1xucHJvdG8uX3NoYWRvdyA9IGZhbHNlO1xucHJvdG8uX3NoYWRvd0NvbG9yID0gMHhGRjAwMDAwMDtcbnByb3RvLl9zaGFkb3dPZmZzZXRYID0gMDtcbnByb3RvLl9zaGFkb3dPZmZzZXRZID0gMDtcbnByb3RvLl9zaGFkb3dCbHVyID0gNTtcbnByb3RvLl9oaWdobGlnaHQgPSBmYWxzZTtcbnByb3RvLl9oaWdobGlnaHRIZWlnaHQgPSAwO1xucHJvdG8uX2hpZ2hsaWdodENvbG9yID0gMHhGRjAwMDAwMDtcbnByb3RvLl9oaWdobGlnaHRPZmZzZXQgPSAwO1xucHJvdG8uX2hpZ2hsaWdodFBhZGRpbmdMZWZ0ID0gMDtcbnByb3RvLl9oaWdobGlnaHRQYWRkaW5nUmlnaHQgPSAwO1xucHJvdG8uX2xldHRlclNwYWNpbmcgPSAwO1xucHJvdG8uX3RleHRJbmRlbnQgPSAwO1xucHJvdG8uX2N1dFN4ID0gMDtcbnByb3RvLl9jdXRFeCA9IDA7XG5wcm90by5fY3V0U3kgPSAwO1xucHJvdG8uX2N1dEV5ID0gMDtcbnByb3RvLl9hZHZhbmNlZFJlbmRlcmVyID0gZmFsc2U7XG5cblxuaW1wb3J0IFRleHRUZXh0dXJlUmVuZGVyZXIgZnJvbSBcIi4vVGV4dFRleHR1cmVSZW5kZXJlci5tanNcIjtcbmltcG9ydCBUZXh0VGV4dHVyZVJlbmRlcmVyQWR2YW5jZWQgZnJvbSBcIi4vVGV4dFRleHR1cmVSZW5kZXJlckFkdmFuY2VkLm1qc1wiO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4uL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdHJlZS9VdGlscy5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dFRleHR1cmVSZW5kZXJlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSwgY2FudmFzLCBzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9zdGFnZSA9IHN0YWdlO1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB9XG5cbiAgICBnZXRQcmVjaXNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncy5wcmVjaXNpb247XG4gICAgfTtcblxuICAgIHNldEZvbnRQcm9wZXJ0aWVzKCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmZvbnQgPSBVdGlscy5pc1NwYXJrID8gdGhpcy5fc3RhZ2UucGxhdGZvcm0uZ2V0Rm9udFNldHRpbmcodGhpcykgOiB0aGlzLl9nZXRGb250U2V0dGluZygpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LnRleHRCYXNlbGluZSA9IHRoaXMuX3NldHRpbmdzLnRleHRCYXNlbGluZTtcbiAgICB9O1xuXG4gICAgX2dldEZvbnRTZXR0aW5nKCkge1xuICAgICAgICBsZXQgZmYgPSB0aGlzLl9zZXR0aW5ncy5mb250RmFjZTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmYpKSB7XG4gICAgICAgICAgICBmZiA9IFtmZl07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmZzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gZmYubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZmZbaV0gPT09IFwic2VyaWZcIiB8fCBmZltpXSA9PT0gXCJzYW5zLXNlcmlmXCIpIHtcbiAgICAgICAgICAgICAgICBmZnMucHVzaChmZltpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZmcy5wdXNoKGBcIiR7ZmZbaV19XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgJHt0aGlzLl9zZXR0aW5ncy5mb250U3R5bGV9ICR7dGhpcy5fc2V0dGluZ3MuZm9udFNpemUgKiB0aGlzLmdldFByZWNpc2lvbigpfXB4ICR7ZmZzLmpvaW4oXCIsXCIpfWBcbiAgICB9XG5cbiAgICBfbG9hZCgpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzV2ViICYmIGRvY3VtZW50LmZvbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBmb250U2V0dGluZyA9IHRoaXMuX2dldEZvbnRTZXR0aW5nKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnQuZm9udHMuY2hlY2soZm9udFNldHRpbmcsIHRoaXMuX3NldHRpbmdzLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhIHByb21pc2UgdGhhdCB3YWl0cyBmb3IgbG9hZGluZy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmZvbnRzLmxvYWQoZm9udFNldHRpbmcsIHRoaXMuX3NldHRpbmdzLnRleHQpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IGxvYWQgdGhlIGZhbGxiYWNrIGZvbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tMaWdodG5pbmddIEZvbnQgbG9hZCBlcnJvcicsIGVyciwgZm9udFNldHRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnQuZm9udHMuY2hlY2soZm9udFNldHRpbmcsIHRoaXMuX3NldHRpbmdzLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbTGlnaHRuaW5nXSBGb250IG5vdCBmb3VuZCcsIGZvbnRTZXR0aW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0xpZ2h0bmluZ10gQ2FuJ3QgY2hlY2sgZm9udCBsb2FkaW5nIGZvciBcIiArIGZvbnRTZXR0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRyYXcoKSB7XG4gICAgICAgIC8vIFdlIGRvIG5vdCB1c2UgYSBwcm9taXNlIHNvIHRoYXQgbG9hZGluZyBpcyBwZXJmb3JtZWQgc3luY3Jvbm91cyB3aGVuIHBvc3NpYmxlLlxuICAgICAgICBjb25zdCBsb2FkUHJvbWlzZSA9IHRoaXMuX2xvYWQoKTtcbiAgICAgICAgaWYgKCFsb2FkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLmlzU3BhcmsgPyB0aGlzLl9zdGFnZS5wbGF0Zm9ybS5kcmF3VGV4dCh0aGlzKSA6IHRoaXMuX2RyYXcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMuaXNTcGFyayA/IHRoaXMuX3N0YWdlLnBsYXRmb3JtLmRyYXdUZXh0KHRoaXMpIDogdGhpcy5fZHJhdygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlUmVuZGVySW5mbygpIHtcbiAgICAgICAgbGV0IHJlbmRlckluZm8gPSB7fTtcblxuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLmdldFByZWNpc2lvbigpO1xuXG4gICAgICAgIGNvbnN0IHBhZGRpbmdMZWZ0ID0gdGhpcy5fc2V0dGluZ3MucGFkZGluZ0xlZnQgKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IHRoaXMuX3NldHRpbmdzLnBhZGRpbmdSaWdodCAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9zZXR0aW5ncy5mb250U2l6ZSAqIHByZWNpc2lvbjtcbiAgICAgICAgbGV0IG9mZnNldFkgPSB0aGlzLl9zZXR0aW5ncy5vZmZzZXRZID09PSBudWxsID8gbnVsbCA6ICh0aGlzLl9zZXR0aW5ncy5vZmZzZXRZICogcHJlY2lzaW9uKTtcbiAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSB0aGlzLl9zZXR0aW5ncy5saW5lSGVpZ2h0ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy5fc2V0dGluZ3MudyAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuX3NldHRpbmdzLmggKiBwcmVjaXNpb247XG4gICAgICAgIGxldCB3b3JkV3JhcFdpZHRoID0gdGhpcy5fc2V0dGluZ3Mud29yZFdyYXBXaWR0aCAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgY3V0U3ggPSB0aGlzLl9zZXR0aW5ncy5jdXRTeCAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgY3V0RXggPSB0aGlzLl9zZXR0aW5ncy5jdXRFeCAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgY3V0U3kgPSB0aGlzLl9zZXR0aW5ncy5jdXRTeSAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgY3V0RXkgPSB0aGlzLl9zZXR0aW5ncy5jdXRFeSAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgbGV0dGVyU3BhY2luZyA9ICh0aGlzLl9zZXR0aW5ncy5sZXR0ZXJTcGFjaW5nIHx8IDApICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCB0ZXh0SW5kZW50ID0gdGhpcy5fc2V0dGluZ3MudGV4dEluZGVudCAqIHByZWNpc2lvbjtcblxuICAgICAgICAvLyBTZXQgZm9udCBwcm9wZXJ0aWVzLlxuICAgICAgICB0aGlzLnNldEZvbnRQcm9wZXJ0aWVzKCk7XG5cbiAgICAgICAgLy8gVG90YWwgd2lkdGguXG4gICAgICAgIGxldCB3aWR0aCA9IHcgfHwgKDIwNDggLyB0aGlzLmdldFByZWNpc2lvbigpKTtcblxuICAgICAgICAvLyBJbm5lciB3aWR0aC5cbiAgICAgICAgbGV0IGlubmVyV2lkdGggPSB3aWR0aCAtIChwYWRkaW5nTGVmdCk7XG4gICAgICAgIGlmIChpbm5lcldpZHRoIDwgMTApIHtcbiAgICAgICAgICAgIHdpZHRoICs9ICgxMCAtIGlubmVyV2lkdGgpO1xuICAgICAgICAgICAgaW5uZXJXaWR0aCArPSAoMTAgLSBpbm5lcldpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgICAgd29yZFdyYXBXaWR0aCA9IGlubmVyV2lkdGhcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRleHQgb3ZlcmZsb3dcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnRleHRPdmVyZmxvdyAmJiAhdGhpcy5fc2V0dGluZ3Mud29yZFdyYXApIHtcbiAgICAgICAgICAgIGxldCBzdWZmaXg7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3NldHRpbmdzLnRleHRPdmVyZmxvdykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NsaXAnOlxuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSAnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWxsaXBzaXMnOlxuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSB0aGlzLl9zZXR0aW5ncy5tYXhMaW5lc1N1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gdGhpcy5fc2V0dGluZ3MudGV4dE92ZXJmbG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3MudGV4dCA9IHRoaXMud3JhcFdvcmQodGhpcy5fc2V0dGluZ3MudGV4dCwgd29yZFdyYXBXaWR0aCAtIHRleHRJbmRlbnQsIHN1ZmZpeClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdvcmQgd3JhcFxuICAgICAgICAvLyBwcmVzZXJ2ZSBvcmlnaW5hbCB0ZXh0XG4gICAgICAgIGxldCBsaW5lc0luZm87XG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy53b3JkV3JhcCkge1xuICAgICAgICAgICAgbGluZXNJbmZvID0gdGhpcy53cmFwVGV4dCh0aGlzLl9zZXR0aW5ncy50ZXh0LCB3b3JkV3JhcFdpZHRoLCBsZXR0ZXJTcGFjaW5nLCB0ZXh0SW5kZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVzSW5mbyA9IHtsOiB0aGlzLl9zZXR0aW5ncy50ZXh0LnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKSwgbjogW119O1xuICAgICAgICAgICAgbGV0IGksIG4gPSBsaW5lc0luZm8ubC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsaW5lc0luZm8ubi5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5lcyA9IGxpbmVzSW5mby5sO1xuXG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tYXhMaW5lcyAmJiBsaW5lcy5sZW5ndGggPiB0aGlzLl9zZXR0aW5ncy5tYXhMaW5lcykge1xuICAgICAgICAgICAgbGV0IHVzZWRMaW5lcyA9IGxpbmVzLnNsaWNlKDAsIHRoaXMuX3NldHRpbmdzLm1heExpbmVzKTtcblxuICAgICAgICAgICAgbGV0IG90aGVyTGluZXMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLm1heExpbmVzU3VmZml4KSB7XG4gICAgICAgICAgICAgICAgLy8gV3JhcCBhZ2FpbiB3aXRoIG1heCBsaW5lcyBzdWZmaXggZW5hYmxlZC5cbiAgICAgICAgICAgICAgICBsZXQgdyA9IHRoaXMuX3NldHRpbmdzLm1heExpbmVzU3VmZml4ID8gdGhpcy5tZWFzdXJlVGV4dCh0aGlzLl9zZXR0aW5ncy5tYXhMaW5lc1N1ZmZpeCkgOiAwO1xuICAgICAgICAgICAgICAgIGxldCBhbCA9IHRoaXMud3JhcFRleHQodXNlZExpbmVzW3VzZWRMaW5lcy5sZW5ndGggLSAxXSwgd29yZFdyYXBXaWR0aCAtIHcsIGxldHRlclNwYWNpbmcsIHRleHRJbmRlbnQpO1xuICAgICAgICAgICAgICAgIHVzZWRMaW5lc1t1c2VkTGluZXMubGVuZ3RoIC0gMV0gPSBhbC5sWzBdICsgdGhpcy5fc2V0dGluZ3MubWF4TGluZXNTdWZmaXg7XG4gICAgICAgICAgICAgICAgb3RoZXJMaW5lcyA9IFthbC5sLmxlbmd0aCA+IDEgPyBhbC5sWzFdIDogJyddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdGhlckxpbmVzID0gWycnXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmUtYXNzZW1ibGUgdGhlIHJlbWFpbmluZyB0ZXh0LlxuICAgICAgICAgICAgbGV0IGksIG4gPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICBsZXQgbSA9IGxpbmVzSW5mby5uLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuX3NldHRpbmdzLm1heExpbmVzOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3RoZXJMaW5lc1tqXSArPSAob3RoZXJMaW5lc1tqXSA/IFwiIFwiIDogXCJcIikgKyBsaW5lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBtICYmIGxpbmVzSW5mby5uW2kgKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJJbmZvLnJlbWFpbmluZ1RleHQgPSBvdGhlckxpbmVzLmpvaW4oXCJcXG5cIik7XG5cbiAgICAgICAgICAgIHJlbmRlckluZm8ubW9yZVRleHRMaW5lcyA9IHRydWU7XG5cbiAgICAgICAgICAgIGxpbmVzID0gdXNlZExpbmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVySW5mby5tb3JlVGV4dExpbmVzID0gZmFsc2U7XG4gICAgICAgICAgICByZW5kZXJJbmZvLnJlbWFpbmluZ1RleHQgPSBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRleHQgd2lkdGhcbiAgICAgICAgbGV0IG1heExpbmVXaWR0aCA9IDA7XG4gICAgICAgIGxldCBsaW5lV2lkdGhzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lV2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KGxpbmVzW2ldLCBsZXR0ZXJTcGFjaW5nKSArIChpID09PSAwID8gdGV4dEluZGVudCA6IDApO1xuICAgICAgICAgICAgbGluZVdpZHRocy5wdXNoKGxpbmVXaWR0aCk7XG4gICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJJbmZvLmxpbmVXaWR0aHMgPSBsaW5lV2lkdGhzO1xuXG4gICAgICAgIGlmICghdykge1xuICAgICAgICAgICAgLy8gQXV0by1zZXQgd2lkdGggdG8gbWF4IHRleHQgbGVuZ3RoLlxuICAgICAgICAgICAgd2lkdGggPSBtYXhMaW5lV2lkdGggKyBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodDtcbiAgICAgICAgICAgIGlubmVyV2lkdGggPSBtYXhMaW5lV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGV4dCBoZWlnaHRcbiAgICAgICAgbGluZUhlaWdodCA9IGxpbmVIZWlnaHQgfHwgZm9udFNpemU7XG5cbiAgICAgICAgbGV0IGhlaWdodDtcbiAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlbGluZU9mZnNldCA9ICh0aGlzLl9zZXR0aW5ncy50ZXh0QmFzZWxpbmUgIT0gJ2JvdHRvbScpID8gMC41ICogZm9udFNpemUgOiAwO1xuICAgICAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodCAqIChsaW5lcy5sZW5ndGggLSAxKSArIGJhc2VsaW5lT2Zmc2V0ICsgTWF0aC5tYXgobGluZUhlaWdodCwgZm9udFNpemUpICsgb2Zmc2V0WTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvZmZzZXRZID09PSBudWxsKSB7XG4gICAgICAgICAgICBvZmZzZXRZID0gZm9udFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJJbmZvLncgPSB3aWR0aDtcbiAgICAgICAgcmVuZGVySW5mby5oID0gaGVpZ2h0O1xuICAgICAgICByZW5kZXJJbmZvLmxpbmVzID0gbGluZXM7XG4gICAgICAgIHJlbmRlckluZm8ucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuXG4gICAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGVycm9ycy5cbiAgICAgICAgICAgIHdpZHRoID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IGNhbnZhcyBlcnJvcnMuXG4gICAgICAgICAgICBoZWlnaHQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1dFN4IHx8IGN1dEV4KSB7XG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWluKHdpZHRoLCBjdXRFeCAtIGN1dFN4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXRTeSB8fCBjdXRFeSkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBjdXRFeSAtIGN1dFN5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlckluZm8ud2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmVuZGVySW5mby5pbm5lcldpZHRoID0gaW5uZXJXaWR0aDtcbiAgICAgICAgcmVuZGVySW5mby5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJlbmRlckluZm8uZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgcmVuZGVySW5mby5jdXRTeCA9IGN1dFN4O1xuICAgICAgICByZW5kZXJJbmZvLmN1dFN5ID0gY3V0U3k7XG4gICAgICAgIHJlbmRlckluZm8uY3V0RXggPSBjdXRFeDtcbiAgICAgICAgcmVuZGVySW5mby5jdXRFeSA9IGN1dEV5O1xuICAgICAgICByZW5kZXJJbmZvLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICByZW5kZXJJbmZvLmxpbmVXaWR0aHMgPSBsaW5lV2lkdGhzO1xuICAgICAgICByZW5kZXJJbmZvLm9mZnNldFkgPSBvZmZzZXRZO1xuICAgICAgICByZW5kZXJJbmZvLnBhZGRpbmdMZWZ0ID0gcGFkZGluZ0xlZnQ7XG4gICAgICAgIHJlbmRlckluZm8ucGFkZGluZ1JpZ2h0ID0gcGFkZGluZ1JpZ2h0O1xuICAgICAgICByZW5kZXJJbmZvLmxldHRlclNwYWNpbmcgPSBsZXR0ZXJTcGFjaW5nO1xuICAgICAgICByZW5kZXJJbmZvLnRleHRJbmRlbnQgPSB0ZXh0SW5kZW50O1xuXG4gICAgICAgIHJldHVybiByZW5kZXJJbmZvO1xuICAgIH1cblxuICAgIF9kcmF3KCkge1xuICAgICAgICBjb25zdCByZW5kZXJJbmZvID0gdGhpcy5fY2FsY3VsYXRlUmVuZGVySW5mbygpO1xuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLmdldFByZWNpc2lvbigpO1xuXG4gICAgICAgIC8vIEFkZCBleHRyYSBtYXJnaW4gdG8gcHJldmVudCBpc3N1ZSB3aXRoIGNsaXBwZWQgdGV4dCB3aGVuIHNjYWxpbmcuXG4gICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IE1hdGguY2VpbChyZW5kZXJJbmZvLndpZHRoICsgdGhpcy5fc3RhZ2UuZ2V0T3B0aW9uKCd0ZXh0UmVuZGVySXNzdWVNYXJnaW4nKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwocmVuZGVySW5mby5oZWlnaHQpO1xuXG4gICAgICAgIC8vIENhbnZhcyBjb250ZXh0IGhhcyBiZWVuIHJlc2V0LlxuICAgICAgICB0aGlzLnNldEZvbnRQcm9wZXJ0aWVzKCk7XG5cbiAgICAgICAgaWYgKHJlbmRlckluZm8uZm9udFNpemUgPj0gMTI4KSB7XG4gICAgICAgICAgICAvLyBXcGVXZWJLaXQgYnVnOiBtdXN0IGZvcmNlIGNvbXBvc2l0aW5nIGJlY2F1c2UgY2Fpcm8tdHJhcHMtY29tcG9zaXRvciB3aWxsIG5vdCB3b3JrIHdpdGggdGV4dCBmaXJzdC5cbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZ2xvYmFsQWxwaGEgPSAwLjAxO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsUmVjdCgwLCAwLCAwLjAxLCAwLjAxKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZ2xvYmFsQWxwaGEgPSAxLjA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVySW5mby5jdXRTeCB8fCByZW5kZXJJbmZvLmN1dFN5KSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnRyYW5zbGF0ZSgtcmVuZGVySW5mby5jdXRTeCwgLXJlbmRlckluZm8uY3V0U3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxpbmVQb3NpdGlvblg7XG4gICAgICAgIGxldCBsaW5lUG9zaXRpb25ZO1xuXG4gICAgICAgIGxldCBkcmF3TGluZXMgPSBbXTtcblxuICAgICAgICAvLyBEcmF3IGxpbmVzIGxpbmUgYnkgbGluZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSByZW5kZXJJbmZvLmxpbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCA9IGkgPT09IDAgPyByZW5kZXJJbmZvLnRleHRJbmRlbnQgOiAwO1xuXG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCB0ZXh0IGlzIGFsaWduZWQgdG8gdG9wXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25ZID0gKGkgKiByZW5kZXJJbmZvLmxpbmVIZWlnaHQpICsgcmVuZGVySW5mby5vZmZzZXRZO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MudmVydGljYWxBbGlnbiA9PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblkgKz0gKHJlbmRlckluZm8ubGluZUhlaWdodCAtIHJlbmRlckluZm8uZm9udFNpemUpIC8gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc2V0dGluZ3MudmVydGljYWxBbGlnbiA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblkgKz0gcmVuZGVySW5mby5saW5lSGVpZ2h0IC0gcmVuZGVySW5mby5mb250U2l6ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKHJlbmRlckluZm8uaW5uZXJXaWR0aCAtIHJlbmRlckluZm8ubGluZVdpZHRoc1tpXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3NldHRpbmdzLnRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25YICs9ICgocmVuZGVySW5mby5pbm5lcldpZHRoIC0gcmVuZGVySW5mby5saW5lV2lkdGhzW2ldKSAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSByZW5kZXJJbmZvLnBhZGRpbmdMZWZ0O1xuXG4gICAgICAgICAgICBkcmF3TGluZXMucHVzaCh7dGV4dDogcmVuZGVySW5mby5saW5lc1tpXSwgeDogbGluZVBvc2l0aW9uWCwgeTogbGluZVBvc2l0aW9uWSwgdzogcmVuZGVySW5mby5saW5lV2lkdGhzW2ldfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIaWdobGlnaHQuXG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHQpIHtcbiAgICAgICAgICAgIGxldCBjb2xvciA9IHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodENvbG9yIHx8IDB4MDAwMDAwMDA7XG5cbiAgICAgICAgICAgIGxldCBobEhlaWdodCA9ICh0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHRIZWlnaHQgKiBwcmVjaXNpb24gfHwgcmVuZGVySW5mby5mb250U2l6ZSAqIDEuNSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHRPZmZzZXQgKiBwcmVjaXNpb247XG4gICAgICAgICAgICBjb25zdCBobFBhZGRpbmdMZWZ0ID0gKHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodFBhZGRpbmdMZWZ0ICE9PSBudWxsID8gdGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0UGFkZGluZ0xlZnQgKiBwcmVjaXNpb24gOiByZW5kZXJJbmZvLnBhZGRpbmdMZWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IGhsUGFkZGluZ1JpZ2h0ID0gKHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodFBhZGRpbmdSaWdodCAhPT0gbnVsbCA/IHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodFBhZGRpbmdSaWdodCAqIHByZWNpc2lvbiA6IHJlbmRlckluZm8ucGFkZGluZ1JpZ2h0KTtcblxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsU3R5bGUgPSBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcoY29sb3IpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcmF3TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZHJhd0xpbmUgPSBkcmF3TGluZXNbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsUmVjdCgoZHJhd0xpbmUueCAtIGhsUGFkZGluZ0xlZnQpLCAoZHJhd0xpbmUueSAtIHJlbmRlckluZm8ub2Zmc2V0WSArIG9mZnNldCksIChkcmF3TGluZS53ICsgaGxQYWRkaW5nUmlnaHQgKyBobFBhZGRpbmdMZWZ0KSwgaGxIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGV4dCBzaGFkb3cuXG4gICAgICAgIGxldCBwcmV2U2hhZG93U2V0dGluZ3MgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3Muc2hhZG93KSB7XG4gICAgICAgICAgICBwcmV2U2hhZG93U2V0dGluZ3MgPSBbdGhpcy5fY29udGV4dC5zaGFkb3dDb2xvciwgdGhpcy5fY29udGV4dC5zaGFkb3dPZmZzZXRYLCB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFksIHRoaXMuX2NvbnRleHQuc2hhZG93Qmx1cl07XG5cbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93Q29sb3IgPSBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcodGhpcy5fc2V0dGluZ3Muc2hhZG93Q29sb3IpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dPZmZzZXRYID0gdGhpcy5fc2V0dGluZ3Muc2hhZG93T2Zmc2V0WCAqIHByZWNpc2lvbjtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WSA9IHRoaXMuX3NldHRpbmdzLnNoYWRvd09mZnNldFkgKiBwcmVjaXNpb247XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd0JsdXIgPSB0aGlzLl9zZXR0aW5ncy5zaGFkb3dCbHVyICogcHJlY2lzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29udGV4dC5maWxsU3R5bGUgPSBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcodGhpcy5fc2V0dGluZ3MudGV4dENvbG9yKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBkcmF3TGluZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZHJhd0xpbmUgPSBkcmF3TGluZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJJbmZvLmxldHRlclNwYWNpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxUZXh0KGRyYXdMaW5lLnRleHQsIGRyYXdMaW5lLngsIGRyYXdMaW5lLnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0U3BsaXQgPSBkcmF3TGluZS50ZXh0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBsZXQgeCA9IGRyYXdMaW5lLng7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSB0ZXh0U3BsaXQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFRleHQodGV4dFNwbGl0W2ldLCB4LCBkcmF3TGluZS55KTtcbiAgICAgICAgICAgICAgICAgICAgeCArPSB0aGlzLm1lYXN1cmVUZXh0KHRleHRTcGxpdFtpXSwgcmVuZGVySW5mby5sZXR0ZXJTcGFjaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlNoYWRvd1NldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd0NvbG9yID0gcHJldlNoYWRvd1NldHRpbmdzWzBdO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dPZmZzZXRYID0gcHJldlNoYWRvd1NldHRpbmdzWzFdO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dPZmZzZXRZID0gcHJldlNoYWRvd1NldHRpbmdzWzJdO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dCbHVyID0gcHJldlNoYWRvd1NldHRpbmdzWzNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlckluZm8uY3V0U3ggfHwgcmVuZGVySW5mby5jdXRTeSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC50cmFuc2xhdGUocmVuZGVySW5mby5jdXRTeCwgcmVuZGVySW5mby5jdXRTeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlckluZm8gPSByZW5kZXJJbmZvO1xuICAgIH07XG5cbiAgICB3cmFwV29yZCh3b3JkLCB3b3JkV3JhcFdpZHRoLCBzdWZmaXgpIHtcbiAgICAgICAgY29uc3Qgc3VmZml4V2lkdGggPSB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHN1ZmZpeCkud2lkdGg7XG4gICAgICAgIGNvbnN0IHdvcmRMZW4gPSB3b3JkLmxlbmd0aFxuICAgICAgICBjb25zdCB3b3JkV2lkdGggPSB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHdvcmQpLndpZHRoO1xuXG4gICAgICAgIC8qIElmIHdvcmQgZml0cyB3cmFwV2lkdGgsIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgaWYgKHdvcmRXaWR0aCA8PSB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gd29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIE1ha2UgaW5pdGlhbCBndWVzcyBmb3IgdGV4dCBjdXR0b2ZmICovXG4gICAgICAgIGxldCBjdXRvZmZJbmRleCA9IE1hdGguZmxvb3IoKHdvcmRXcmFwV2lkdGggKiB3b3JkTGVuKSAvIHdvcmRXaWR0aCk7XG4gICAgICAgIGxldCB0cnVuY1dvcmRXaWR0aCA9IHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQod29yZC5zdWJzdHJpbmcoMCwgY3V0b2ZmSW5kZXgpKS53aWR0aCArIHN1ZmZpeFdpZHRoO1xuXG4gICAgICAgIC8qIEluIGNhc2UgZ3Vlc3Mgd2FzIG92ZXJlc3RpbWF0ZWQsIHNocmluayBpdCBsZXR0ZXIgYnkgbGV0dGVyLiAqL1xuICAgICAgICBpZiAodHJ1bmNXb3JkV2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICB3aGlsZSAoY3V0b2ZmSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgdHJ1bmNXb3JkV2lkdGggPSB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHdvcmQuc3Vic3RyaW5nKDAsIGN1dG9mZkluZGV4KSkud2lkdGggKyBzdWZmaXhXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAodHJ1bmNXb3JkV2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1dG9mZkluZGV4IC09IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIC8qIEluIGNhc2UgZ3Vlc3Mgd2FzIHVuZGVyZXN0aW1hdGVkLCBleHRlbmQgaXQgbGV0dGVyIGJ5IGxldHRlci4gKi9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChjdXRvZmZJbmRleCA8IHdvcmRMZW4pIHtcbiAgICAgICAgICAgICAgICB0cnVuY1dvcmRXaWR0aCA9IHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQod29yZC5zdWJzdHJpbmcoMCwgY3V0b2ZmSW5kZXgpKS53aWR0aCArIHN1ZmZpeFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmICh0cnVuY1dvcmRXaWR0aCA8IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0b2ZmSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCB3aGVuIGJvdW5kIGlzIGNyb3NzZWQsIHJldHJhY3QgbGFzdCBsZXR0ZXIuXG4gICAgICAgICAgICAgICAgICAgIGN1dG9mZkluZGV4IC09MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogSWYgd3JhcFdpZHRoIGlzIHRvbyBzaG9ydCB0byBldmVuIGNvbnRhaW4gc3VmZml4IGFsb25lLCByZXR1cm4gZW1wdHkgc3RyaW5nICovXG4gICAgICAgIHJldHVybiB3b3JkLnN1YnN0cmluZygwLCBjdXRvZmZJbmRleCkgKyAod29yZFdyYXBXaWR0aCA+PSBzdWZmaXhXaWR0aCA/IHN1ZmZpeCA6ICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIG5ld2xpbmVzIHRvIGEgc3RyaW5nIHRvIGhhdmUgaXQgb3B0aW1hbGx5IGZpdCBpbnRvIHRoZSBob3Jpem9udGFsXG4gICAgICogYm91bmRzIHNldCBieSB0aGUgVGV4dCBvYmplY3QncyB3b3JkV3JhcFdpZHRoIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHdyYXBUZXh0KHRleHQsIHdvcmRXcmFwV2lkdGgsIGxldHRlclNwYWNpbmcsIGluZGVudCA9IDApIHtcbiAgICAgICAgLy8gR3JlZWR5IHdyYXBwaW5nIGFsZ29yaXRobSB0aGF0IHdpbGwgd3JhcCB3b3JkcyBhcyB0aGUgbGluZSBncm93cyBsb25nZXIuXG4gICAgICAgIC8vIHRoYW4gaXRzIGhvcml6b250YWwgYm91bmRzLlxuICAgICAgICBsZXQgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHI/XFxuL2cpO1xuICAgICAgICBsZXQgYWxsTGluZXMgPSBbXTtcbiAgICAgICAgbGV0IHJlYWxOZXdsaW5lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0TGluZXMgPSBbXTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGxldCBzcGFjZUxlZnQgPSB3b3JkV3JhcFdpZHRoIC0gaW5kZW50O1xuICAgICAgICAgICAgbGV0IHdvcmRzID0gbGluZXNbaV0uc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JkV2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KHdvcmRzW2pdLCBsZXR0ZXJTcGFjaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JkV2lkdGhXaXRoU3BhY2UgPSB3b3JkV2lkdGggKyB0aGlzLm1lYXN1cmVUZXh0KCcgJyxsZXR0ZXJTcGFjaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCB8fCB3b3JkV2lkdGhXaXRoU3BhY2UgPiBzcGFjZUxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwcmludGluZyB0aGUgbmV3bGluZSBpZiBpdCdzIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBsaW5lIHRoYXQgaXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdyZWF0ZXIgdGhhbiB0aGUgd29yZCB3cmFwIHdpZHRoLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdExpbmVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3b3Jkc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VMZWZ0ID0gd29yZFdyYXBXaWR0aCAtIHdvcmRXaWR0aCAtIChqID09PSAwID8gaW5kZW50IDogMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFjZUxlZnQgLT0gd29yZFdpZHRoV2l0aFNwYWNlO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAnICsgd29yZHNbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICByZXN1bHQgPSAnJztcblxuICAgICAgICAgICAgYWxsTGluZXMgPSBhbGxMaW5lcy5jb25jYXQocmVzdWx0TGluZXMpO1xuXG4gICAgICAgICAgICBpZiAoaSA8IGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZWFsTmV3bGluZXMucHVzaChhbGxMaW5lcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtsOiBhbGxMaW5lcywgbjogcmVhbE5ld2xpbmVzfTtcbiAgICB9O1xuXG4gICAgbWVhc3VyZVRleHQod29yZCwgc3BhY2UgPSAwKSB7XG4gICAgICAgIGlmICghc3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHdvcmQpLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkLnNwbGl0KCcnKS5yZWR1Y2UoKGFjYywgY2hhcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQoY2hhcikud2lkdGggKyBzcGFjZTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4uL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdHJlZS9VdGlscy5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dFRleHR1cmVSZW5kZXJlckFkdmFuY2VkIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlLCBjYW52YXMsIHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX3N0YWdlID0gc3RhZ2U7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIH1cblxuICAgIGdldFByZWNpc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnByZWNpc2lvbjtcbiAgICB9O1xuXG4gICAgc2V0Rm9udFByb3BlcnRpZXMoKSB7XG4gICAgICAgIGNvbnN0IGZvbnQgPSBVdGlscy5pc1NwYXJrID8gdGhpcy5fc3RhZ2UucGxhdGZvcm0uZ2V0Rm9udFNldHRpbmcodGhpcykgOiB0aGlzLl9nZXRGb250U2V0dGluZygpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmZvbnQgPSBmb250O1xuICAgICAgICB0aGlzLl9jb250ZXh0LnRleHRCYXNlbGluZSA9IHRoaXMuX3NldHRpbmdzLnRleHRCYXNlbGluZTtcbiAgICAgICAgcmV0dXJuIGZvbnQ7XG4gICAgfTtcblxuICAgIF9nZXRGb250U2V0dGluZygpIHtcbiAgICAgICAgbGV0IGZmID0gdGhpcy5fc2V0dGluZ3MuZm9udEZhY2U7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZmKSkge1xuICAgICAgICAgICAgZmYgPSBbZmZdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZmcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGZmLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKGZmW2ldID09PSBcInNlcmlmXCIgfHwgZmZbaV0gPT09IFwic2Fucy1zZXJpZlwiKSB7XG4gICAgICAgICAgICAgICAgZmZzLnB1c2goZmZbaV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmZnMucHVzaChgXCIke2ZmW2ldfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYCR7dGhpcy5fc2V0dGluZ3MuZm9udFN0eWxlfSAke3RoaXMuX3NldHRpbmdzLmZvbnRTaXplICogdGhpcy5nZXRQcmVjaXNpb24oKX1weCAke2Zmcy5qb2luKFwiLFwiKX1gXG4gICAgfVxuXG4gICAgX2xvYWQoKSB7XG4gICAgICAgIGlmIChVdGlscy5pc1dlYiAmJiBkb2N1bWVudC5mb250cykge1xuICAgICAgICAgICAgY29uc3QgZm9udFNldHRpbmcgPSB0aGlzLl9nZXRGb250U2V0dGluZygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmZvbnRzLmNoZWNrKGZvbnRTZXR0aW5nLCB0aGlzLl9zZXR0aW5ncy50ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYSBwcm9taXNlIHRoYXQgd2FpdHMgZm9yIGxvYWRpbmcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5mb250cy5sb2FkKGZvbnRTZXR0aW5nLCB0aGlzLl9zZXR0aW5ncy50ZXh0KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCBsb2FkIHRoZSBmYWxsYmFjayBmb250LlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGb250IGxvYWQgZXJyb3InLCBlcnIsIGZvbnRTZXR0aW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmZvbnRzLmNoZWNrKGZvbnRTZXR0aW5nLCB0aGlzLl9zZXR0aW5ncy50ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRm9udCBub3QgZm91bmQnLCBmb250U2V0dGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhbid0IGNoZWNrIGZvbnQgbG9hZGluZyBmb3IgXCIgKyBmb250U2V0dGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkcmF3KCkge1xuICAgICAgICAvLyBXZSBkbyBub3QgdXNlIGEgcHJvbWlzZSBzbyB0aGF0IGxvYWRpbmcgaXMgcGVyZm9ybWVkIHN5bmNyb25vdXMgd2hlbiBwb3NzaWJsZS5cbiAgICAgICAgY29uc3QgbG9hZFByb21pc2UgPSB0aGlzLl9sb2FkKCk7XG4gICAgICAgIGlmICghbG9hZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5pc1NwYXJrID8gdGhpcy5fc3RhZ2UucGxhdGZvcm0uZHJhd1RleHQodGhpcykgOiB0aGlzLl9kcmF3KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLmlzU3BhcmsgPyB0aGlzLl9zdGFnZS5wbGF0Zm9ybS5kcmF3VGV4dCh0aGlzKSA6IHRoaXMuX2RyYXcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZVJlbmRlckluZm8oKSB7XG4gICAgICAgIGxldCByZW5kZXJJbmZvID0ge307XG5cbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gdGhpcy5nZXRQcmVjaXNpb24oKTtcblxuICAgICAgICBjb25zdCBwYWRkaW5nTGVmdCA9IHRoaXMuX3NldHRpbmdzLnBhZGRpbmdMZWZ0ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBwYWRkaW5nUmlnaHQgPSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nUmlnaHQgKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5fc2V0dGluZ3MuZm9udFNpemUgKiBwcmVjaXNpb247XG4gICAgICAgIC8vIGNvbnN0IG9mZnNldFkgPSB0aGlzLl9zZXR0aW5ncy5vZmZzZXRZID09PSBudWxsID8gbnVsbCA6ICh0aGlzLl9zZXR0aW5ncy5vZmZzZXRZICogcHJlY2lzaW9uKTtcbiAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IHRoaXMuX3NldHRpbmdzLmxpbmVIZWlnaHQgKiBwcmVjaXNpb24gfHwgZm9udFNpemU7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLl9zZXR0aW5ncy53ICE9IDAgPyB0aGlzLl9zZXR0aW5ncy53ICogcHJlY2lzaW9uIDogMjA0OCAvIHByZWNpc2lvbjtcbiAgICAgICAgLy8gY29uc3QgaCA9IHRoaXMuX3NldHRpbmdzLmggKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IHdvcmRXcmFwV2lkdGggPSB0aGlzLl9zZXR0aW5ncy53b3JkV3JhcFdpZHRoICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBjdXRTeCA9IHRoaXMuX3NldHRpbmdzLmN1dFN4ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBjdXRFeCA9IHRoaXMuX3NldHRpbmdzLmN1dEV4ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBjdXRTeSA9IHRoaXMuX3NldHRpbmdzLmN1dFN5ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBjdXRFeSA9IHRoaXMuX3NldHRpbmdzLmN1dEV5ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBsZXR0ZXJTcGFjaW5nID0gdGhpcy5fc2V0dGluZ3MubGV0dGVyU3BhY2luZyB8fCAwO1xuXG4gICAgICAgIC8vIFNldCBmb250IHByb3BlcnRpZXMuXG4gICAgICAgIHJlbmRlckluZm8uYmFzZUZvbnQgPSB0aGlzLnNldEZvbnRQcm9wZXJ0aWVzKCk7XG5cbiAgICAgICAgcmVuZGVySW5mby53ID0gdztcbiAgICAgICAgcmVuZGVySW5mby53aWR0aCA9IHc7XG4gICAgICAgIHJlbmRlckluZm8udGV4dCA9IHRoaXMuX3NldHRpbmdzLnRleHQ7XG4gICAgICAgIHJlbmRlckluZm8ucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgICAgICByZW5kZXJJbmZvLmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgIHJlbmRlckluZm8ubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHJlbmRlckluZm8ubGV0dGVyU3BhY2luZyA9IGxldHRlclNwYWNpbmc7XG4gICAgICAgIHJlbmRlckluZm8udGV4dEFsaWduID0gdGhpcy5fc2V0dGluZ3MudGV4dEFsaWduO1xuICAgICAgICByZW5kZXJJbmZvLnRleHRDb2xvciA9IHRoaXMuX3NldHRpbmdzLnRleHRDb2xvcjtcbiAgICAgICAgcmVuZGVySW5mby52ZXJ0aWNhbEFsaWduID0gdGhpcy5fc2V0dGluZ3MudmVydGljYWxBbGlnbjtcbiAgICAgICAgcmVuZGVySW5mby5oaWdobGlnaHQgPSB0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHQ7XG4gICAgICAgIHJlbmRlckluZm8uaGlnaGxpZ2h0Q29sb3IgPSB0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHRDb2xvcjtcbiAgICAgICAgcmVuZGVySW5mby5oaWdobGlnaHRIZWlnaHQgPSB0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHRIZWlnaHQ7XG4gICAgICAgIHJlbmRlckluZm8uaGlnaGxpZ2h0UGFkZGluZ0xlZnQgPSB0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHRQYWRkaW5nTGVmdDtcbiAgICAgICAgcmVuZGVySW5mby5oaWdobGlnaHRQYWRkaW5nUmlnaHQgPSB0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHRQYWRkaW5nUmlnaHQ7XG4gICAgICAgIHJlbmRlckluZm8uaGlnaGxpZ2h0T2Zmc2V0ID0gdGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0T2Zmc2V0O1xuICAgICAgICByZW5kZXJJbmZvLnBhZGRpbmdMZWZ0ID0gdGhpcy5fc2V0dGluZ3MucGFkZGluZ0xlZnQ7XG4gICAgICAgIHJlbmRlckluZm8ucGFkZGluZ1JpZ2h0ID0gdGhpcy5fc2V0dGluZ3MucGFkZGluZ1JpZ2h0O1xuICAgICAgICByZW5kZXJJbmZvLm1heExpbmVzID0gdGhpcy5fc2V0dGluZ3MubWF4TGluZXM7XG4gICAgICAgIHJlbmRlckluZm8ubWF4TGluZXNTdWZmaXggPSB0aGlzLl9zZXR0aW5ncy5tYXhMaW5lc1N1ZmZpeDtcbiAgICAgICAgcmVuZGVySW5mby50ZXh0T3ZlcmZsb3cgPSB0aGlzLl9zZXR0aW5ncy50ZXh0T3ZlcmZsb3c7XG4gICAgICAgIHJlbmRlckluZm8ud29yZFdyYXAgPSB0aGlzLl9zZXR0aW5ncy53b3JkV3JhcDtcbiAgICAgICAgcmVuZGVySW5mby53b3JkV3JhcFdpZHRoID0gd29yZFdyYXBXaWR0aDtcbiAgICAgICAgcmVuZGVySW5mby5zaGFkb3cgPSB0aGlzLl9zZXR0aW5ncy5zaGFkb3c7XG4gICAgICAgIHJlbmRlckluZm8uc2hhZG93Q29sb3IgPSB0aGlzLl9zZXR0aW5ncy5zaGFkb3dDb2xvcjtcbiAgICAgICAgcmVuZGVySW5mby5zaGFkb3dPZmZzZXRYID0gdGhpcy5fc2V0dGluZ3Muc2hhZG93T2Zmc2V0WDtcbiAgICAgICAgcmVuZGVySW5mby5zaGFkb3dPZmZzZXRZID0gdGhpcy5fc2V0dGluZ3Muc2hhZG93T2Zmc2V0WTtcbiAgICAgICAgcmVuZGVySW5mby5zaGFkb3dCbHVyID0gdGhpcy5fc2V0dGluZ3Muc2hhZG93Qmx1cjtcbiAgICAgICAgcmVuZGVySW5mby5jdXRTeCA9IGN1dFN4O1xuICAgICAgICByZW5kZXJJbmZvLmN1dEV4ID0gY3V0RXg7XG4gICAgICAgIHJlbmRlckluZm8uY3V0U3kgPSBjdXRTeTtcbiAgICAgICAgcmVuZGVySW5mby5jdXRFeSA9IGN1dEV5O1xuICAgICAgICByZW5kZXJJbmZvLnRleHRJbmRlbnQgPSB0aGlzLl9zZXR0aW5ncy50ZXh0SW5kZW50ICogcHJlY2lzaW9uO1xuICAgICAgICByZW5kZXJJbmZvLndvcmRCcmVhayA9IHRoaXMuX3NldHRpbmdzLndvcmRCcmVhaztcblxuICAgICAgICBsZXQgdGV4dCA9IHJlbmRlckluZm8udGV4dDtcbiAgICAgICAgbGV0IHdyYXBXaWR0aCA9IHJlbmRlckluZm8ud29yZFdyYXAgPyAocmVuZGVySW5mby53b3JkV3JhcFdpZHRoIHx8IHJlbmRlckluZm8ud2lkdGgpIDogcmVuZGVySW5mby53aWR0aDtcblxuICAgICAgICAvLyBUZXh0IG92ZXJmbG93XG4gICAgICAgIGlmIChyZW5kZXJJbmZvLnRleHRPdmVyZmxvdyAmJiAhcmVuZGVySW5mby53b3JkV3JhcCkge1xuICAgICAgICAgICAgbGV0IHN1ZmZpeDtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fc2V0dGluZ3MudGV4dE92ZXJmbG93KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xpcCc6XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlbGxpcHNpcyc6XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHRoaXMuX3NldHRpbmdzLm1heExpbmVzU3VmZml4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSB0aGlzLl9zZXR0aW5ncy50ZXh0T3ZlcmZsb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy53cmFwV29yZCh0ZXh0LCB3b3JkV3JhcFdpZHRoIHx8IHJlbmRlckluZm8udywgc3VmZml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHQgPSB0aGlzLnRva2VuaXplKHRleHQpO1xuICAgICAgICB0ZXh0ID0gdGhpcy5wYXJzZSh0ZXh0KTtcbiAgICAgICAgdGV4dCA9IHRoaXMubWVhc3VyZSh0ZXh0LCBsZXR0ZXJTcGFjaW5nLCByZW5kZXJJbmZvLmJhc2VGb250KTtcblxuICAgICAgICBpZiAocmVuZGVySW5mby50ZXh0SW5kZW50KSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy5pbmRlbnQodGV4dCwgcmVuZGVySW5mby50ZXh0SW5kZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJJbmZvLndvcmRCcmVhaykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVkdWNlKChhY2MsIHQpID0+IGFjYy5jb25jYXQodGhpcy53b3JkQnJlYWsodCwgd3JhcFdpZHRoLCByZW5kZXJJbmZvLmJhc2VGb250KSksIFtdKVxuICAgICAgICAgICAgdGhpcy5yZXNldEZvbnRTdHlsZSgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgZGV0YWlsZWQgZHJhd2luZyBpbmZvcm1hdGlvblxuICAgICAgICBsZXQgeCA9IHBhZGRpbmdMZWZ0O1xuICAgICAgICBsZXQgbGluZU5vID0gMDtcblxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdGV4dCkge1xuICAgICAgICAgICAgLy8gV3JhcCB0ZXh0XG4gICAgICAgICAgICBpZiAocmVuZGVySW5mby53b3JkV3JhcCAmJiB4ICsgdC53aWR0aCA+IHdyYXBXaWR0aCB8fCB0LnRleHQgPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICB4ID0gcGFkZGluZ0xlZnQ7XG4gICAgICAgICAgICAgICAgbGluZU5vICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0LmxpbmVObyA9IGxpbmVObztcblxuICAgICAgICAgICAgaWYgKHQudGV4dCA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0LnggPSB4O1xuICAgICAgICAgICAgeCArPSB0LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlckluZm8ubGluZU51bSA9IGxpbmVObyArIDE7XG5cbiAgICAgICAgLy8gVmVydGljYWwgYWxpZ25cbiAgICAgICAgbGV0IHZhT2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKHJlbmRlckluZm8udmVydGljYWxBbGlnbiA9PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgdmFPZmZzZXQgKz0gKHJlbmRlckluZm8ubGluZUhlaWdodCAtIHJlbmRlckluZm8uZm9udFNpemUpIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zZXR0aW5ncy52ZXJ0aWNhbEFsaWduID09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB2YU9mZnNldCArPSByZW5kZXJJbmZvLmxpbmVIZWlnaHQgLSByZW5kZXJJbmZvLmZvbnRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGxpbmVzIGluZm9ybWF0aW9uXG4gICAgICAgIHJlbmRlckluZm8ubGluZXMgPSBbXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlckluZm8ubGluZU51bTsgaSsrKSB7XG4gICAgICAgICAgICByZW5kZXJJbmZvLmxpbmVzW2ldID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogcmVuZGVySW5mby5saW5lSGVpZ2h0ICogaSArIHZhT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHRleHQ6IFtdLFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgdCBvZiB0ZXh0KSB7XG4gICAgICAgICAgICByZW5kZXJJbmZvLmxpbmVzW3QubGluZU5vXS50ZXh0LnB1c2godCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaWx0ZXIgb3V0IHdoaXRlIHNwYWNlcyBhdCBiZWdpbm5pbmcgYW5kIGVuZCBvZiBlYWNoIGxpbmVcbiAgICAgICAgZm9yIChjb25zdCBsIG9mIHJlbmRlckluZm8ubGluZXMpIHtcbiAgICAgICAgICAgIGlmIChsLnRleHQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZmlyc3RXb3JkID0gbC50ZXh0WzBdLnRleHQ7XG4gICAgICAgICAgICBjb25zdCBsYXN0V29yZCA9IGwudGV4dFtsLnRleHQubGVuZ3RoIC0gMV0udGV4dDtcblxuICAgICAgICAgICAgaWYgKGZpcnN0V29yZCA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIGwudGV4dC5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RXb3JkID09ICcgJyB8fCBsYXN0V29yZCA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIGwudGV4dC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGxpbmUgd2lkdGhcbiAgICAgICAgZm9yIChsZXQgbCBvZiByZW5kZXJJbmZvLmxpbmVzKSB7XG4gICAgICAgICAgICBsLndpZHRoID0gbC50ZXh0LnJlZHVjZSgoYWNjLCB0KSA9PiBhY2MgKyB0LndpZHRoLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlckluZm8ud2lkdGggPSB0aGlzLl9zZXR0aW5ncy53ICE9IDAgPyB0aGlzLl9zZXR0aW5ncy53ICogcHJlY2lzaW9uIDogTWF0aC5tYXgoLi4ucmVuZGVySW5mby5saW5lcy5tYXAoKGwpID0+IGwud2lkdGgpKSArIHBhZGRpbmdSaWdodDtcbiAgICAgICAgcmVuZGVySW5mby53ID0gcmVuZGVySW5mby53aWR0aDtcblxuICAgICAgICAvLyBBcHBseSBtYXhMaW5lc1N1ZmZpeFxuICAgICAgICBpZiAocmVuZGVySW5mby5tYXhMaW5lcyAmJiByZW5kZXJJbmZvLmxpbmVOdW0gPiByZW5kZXJJbmZvLm1heExpbmVzICYmIHJlbmRlckluZm8ubWF4TGluZXNTdWZmaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmVuZGVySW5mby5tYXhMaW5lcyAtIDE7XG4gICAgICAgICAgICBsZXQgbGFzdExpbmVUZXh0ID0gdGV4dC5maWx0ZXIoKHQpID0+IHQubGluZU5vID09IGluZGV4KVxuICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IHJlbmRlckluZm8ubWF4TGluZXNTdWZmaXg7XG4gICAgICAgICAgICBzdWZmaXggPSB0aGlzLnRva2VuaXplKHN1ZmZpeCk7XG4gICAgICAgICAgICBzdWZmaXggPSB0aGlzLnBhcnNlKHN1ZmZpeCk7XG4gICAgICAgICAgICBzdWZmaXggPSB0aGlzLm1lYXN1cmUoc3VmZml4LCByZW5kZXJJbmZvLmxldHRlclNwYWNpbmcsIHJlbmRlckluZm8uYmFzZUZvbnQpWzBdO1xuICAgICAgICAgICAgc3VmZml4LmxpbmVObyA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKGxhc3RMaW5lVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzdWZmaXgueCA9IGxhc3RMaW5lVGV4dFtsYXN0TGluZVRleHQubGVuZ3RoIC0gMV0ueCArIGxhc3RMaW5lVGV4dFtsYXN0TGluZVRleHQubGVuZ3RoIC0gMV0ud2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1ZmZpeC54ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RMaW5lVGV4dC5wdXNoKHN1ZmZpeClcblxuICAgICAgICAgICAgbGV0IF93ID0gbGFzdExpbmVUZXh0LnJlZHVjZSgoYWNjLCB0KSA9PiBhY2MgKyB0LndpZHRoLCAwKTtcbiAgICAgICAgICAgIHdoaWxlIChfdyA+IHJlbmRlckluZm8ud2lkdGggfHwgbGFzdExpbmVUZXh0W2xhc3RMaW5lVGV4dC5sZW5ndGggLSAyXS50ZXh0ID09ICcgJykge1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lVGV4dC5zcGxpY2UobGFzdExpbmVUZXh0Lmxlbmd0aCAtIDIsIDEpO1xuICAgICAgICAgICAgICAgIF93ID0gbGFzdExpbmVUZXh0LnJlZHVjZSgoYWNjLCB0KSA9PiBhY2MgKyB0LndpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gbGFzdExpbmVUZXh0W2xhc3RMaW5lVGV4dC5sZW5ndGggLSAyXSB8fCB7eDogMCwgd2lkdGg6IDB9XG4gICAgICAgICAgICAgICAgc3VmZml4LnggPSBwcmV2LnggKyBwcmV2LndpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TGluZVRleHQubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlckluZm8ubGluZXNbaW5kZXhdLnRleHQgPSBsYXN0TGluZVRleHQ7XG4gICAgICAgICAgICByZW5kZXJJbmZvLmxpbmVzW2luZGV4XS53aWR0aCA9IF93O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmgpIHtcbiAgICAgICAgICAgIHJlbmRlckluZm8uaCA9IHRoaXMuX3NldHRpbmdzLmg7XG4gICAgICAgIH0gZWxzZSBpZiAocmVuZGVySW5mby5tYXhMaW5lcyAmJiByZW5kZXJJbmZvLm1heExpbmVzIDwgcmVuZGVySW5mby5saW5lTnVtKSB7XG4gICAgICAgICAgICByZW5kZXJJbmZvLmggPSByZW5kZXJJbmZvLm1heExpbmVzICogcmVuZGVySW5mby5saW5lSGVpZ2h0ICsgZm9udFNpemUgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVySW5mby5oID0gcmVuZGVySW5mby5saW5lTnVtICogcmVuZGVySW5mby5saW5lSGVpZ2h0ICsgZm9udFNpemUgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSG9yaXpvbnRhbCBhbGlnbm1lbnQgb2Zmc2V0XG4gICAgICAgIGlmIChyZW5kZXJJbmZvLnRleHRBbGlnbiA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgZm9yIChsZXQgbCBvZiByZW5kZXJJbmZvLmxpbmVzKSB7XG4gICAgICAgICAgICAgICAgbC54ID0gKHJlbmRlckluZm8ud2lkdGggLSBsLndpZHRoIC0gcGFkZGluZ0xlZnQpIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZW5kZXJJbmZvLnRleHRBbGlnbiA9PSAncmlnaHQnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBsIG9mIHJlbmRlckluZm8ubGluZXMpIHtcbiAgICAgICAgICAgICAgICBsLnggPSByZW5kZXJJbmZvLndpZHRoIC0gbC53aWR0aCAtIHBhZGRpbmdMZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlckluZm87XG4gICAgfVxuXG4gICAgX2RyYXcoKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlckluZm8gPSB0aGlzLl9jYWxjdWxhdGVSZW5kZXJJbmZvKCk7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IHRoaXMuZ2V0UHJlY2lzaW9uKCk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdMZWZ0ID0gcmVuZGVySW5mby5wYWRkaW5nTGVmdCAqIHByZWNpc2lvbjtcblxuICAgICAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnNcbiAgICAgICAgbGV0IGNhbnZhc1dpZHRoID0gcmVuZGVySW5mby53IHx8IHJlbmRlckluZm8ud2lkdGg7XG4gICAgICAgIGlmIChyZW5kZXJJbmZvLmN1dFN4IHx8IHJlbmRlckluZm8uY3V0RXgpIHtcbiAgICAgICAgICAgIGNhbnZhc1dpZHRoID0gTWF0aC5taW4ocmVuZGVySW5mby53LCByZW5kZXJJbmZvLmN1dEV4IC0gcmVuZGVySW5mby5jdXRTeCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2FudmFzSGVpZ2h0ID0gcmVuZGVySW5mby5oO1xuICAgICAgICBpZiAocmVuZGVySW5mby5jdXRTeSB8fCByZW5kZXJJbmZvLmN1dEV5KSB7XG4gICAgICAgICAgICBjYW52YXNIZWlnaHQgPSBNYXRoLm1pbihyZW5kZXJJbmZvLmgsIHJlbmRlckluZm8uY3V0RXkgLSByZW5kZXJJbmZvLmN1dFN5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IE1hdGguY2VpbChjYW52YXNXaWR0aCArIHRoaXMuX3N0YWdlLmdldE9wdGlvbigndGV4dFJlbmRlcklzc3VlTWFyZ2luJykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGNhbnZhc0hlaWdodCk7XG5cbiAgICAgICAgLy8gQ2FudmFzIGNvbnRleHQgaGFzIGJlZW4gcmVzZXQuXG4gICAgICAgIHRoaXMuc2V0Rm9udFByb3BlcnRpZXMoKTtcblxuICAgICAgICBpZiAocmVuZGVySW5mby5mb250U2l6ZSA+PSAxMjgpIHtcbiAgICAgICAgICAgIC8vIFdwZVdlYktpdCBidWc6IG11c3QgZm9yY2UgY29tcG9zaXRpbmcgYmVjYXVzZSBjYWlyby10cmFwcy1jb21wb3NpdG9yIHdpbGwgbm90IHdvcmsgd2l0aCB0ZXh0IGZpcnN0LlxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5nbG9iYWxBbHBoYSA9IDAuMDE7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxSZWN0KDAsIDAsIDAuMDEsIDAuMDEpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5nbG9iYWxBbHBoYSA9IDEuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEN1dFxuICAgICAgICBpZiAocmVuZGVySW5mby5jdXRTeCB8fCByZW5kZXJJbmZvLmN1dFN5KSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnRyYW5zbGF0ZSgtcmVuZGVySW5mby5jdXRTeCwgLXJlbmRlckluZm8uY3V0U3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGlnaGxpZ2h0XG4gICAgICAgIGlmIChyZW5kZXJJbmZvLmhpZ2hsaWdodCkge1xuICAgICAgICAgICAgY29uc3QgaGxDb2xvciA9IHJlbmRlckluZm8uaGlnaGxpZ2h0Q29sb3IgfHwgMHgwMDAwMDAwMDtcbiAgICAgICAgICAgIGNvbnN0IGhsSGVpZ2h0ID0gcmVuZGVySW5mby5oaWdobGlnaHRIZWlnaHQgPyByZW5kZXJJbmZvLmhpZ2hsaWdodEhlaWdodCAqIHByZWNpc2lvbiA6ICByZW5kZXJJbmZvLmZvbnRTaXplICogMS41O1xuICAgICAgICAgICAgY29uc3QgaGxPZmZzZXQgPSByZW5kZXJJbmZvLmhpZ2hsaWdodE9mZnNldCA/IHJlbmRlckluZm8uaGlnaGxpZ2h0T2Zmc2V0ICogcHJlY2lzaW9uIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGhsUGFkZGluZ0xlZnQgPSAocmVuZGVySW5mby5oaWdobGlnaHRQYWRkaW5nTGVmdCAhPT0gbnVsbCA/IHJlbmRlckluZm8uaGlnaGxpZ2h0UGFkZGluZ0xlZnQgKiBwcmVjaXNpb24gOiByZW5kZXJJbmZvLnBhZGRpbmdMZWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IGhsUGFkZGluZ1JpZ2h0ID0gKHJlbmRlckluZm8uaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0ICE9PSBudWxsID8gcmVuZGVySW5mby5oaWdobGlnaHRQYWRkaW5nUmlnaHQgKiBwcmVjaXNpb24gOiByZW5kZXJJbmZvLnBhZGRpbmdSaWdodCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKGhsQ29sb3IpO1xuICAgICAgICAgICAgY29uc3QgbGluZU51bSA9IHJlbmRlckluZm8ubWF4TGluZXMgPyBNYXRoLm1pbihyZW5kZXJJbmZvLm1heExpbmVzLCByZW5kZXJJbmZvLmxpbmVOdW0pIDogcmVuZGVySW5mby5saW5lTnVtOyBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZU51bTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbCA9IHJlbmRlckluZm8ubGluZXNbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsUmVjdChsLnggLSBobFBhZGRpbmdMZWZ0ICsgcGFkZGluZ0xlZnQsIGwueSArIGhsT2Zmc2V0LCBsLndpZHRoICsgaGxQYWRkaW5nTGVmdCArIGhsUGFkZGluZ1JpZ2h0LCBobEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXh0IHNoYWRvdy5cbiAgICAgICAgbGV0IHByZXZTaGFkb3dTZXR0aW5ncyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zaGFkb3cpIHtcbiAgICAgICAgICAgIHByZXZTaGFkb3dTZXR0aW5ncyA9IFt0aGlzLl9jb250ZXh0LnNoYWRvd0NvbG9yLCB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFgsIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WSwgdGhpcy5fY29udGV4dC5zaGFkb3dCbHVyXTtcblxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dDb2xvciA9IFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyh0aGlzLl9zZXR0aW5ncy5zaGFkb3dDb2xvcik7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFggPSB0aGlzLl9zZXR0aW5ncy5zaGFkb3dPZmZzZXRYICogcHJlY2lzaW9uO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dPZmZzZXRZID0gdGhpcy5fc2V0dGluZ3Muc2hhZG93T2Zmc2V0WSAqIHByZWNpc2lvbjtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93Qmx1ciA9IHRoaXMuX3NldHRpbmdzLnNoYWRvd0JsdXIgKiBwcmVjaXNpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IHRleHRcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbG9yID0gU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKHRoaXMuX3NldHRpbmdzLnRleHRDb2xvcik7XG4gICAgICAgIGxldCBjdXJyZW50Q29sb3IgPSBkZWZhdWx0Q29sb3I7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gZGVmYXVsdENvbG9yO1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgcmVuZGVySW5mby5saW5lcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0IG9mIGxpbmUudGV4dCkge1xuICAgICAgICAgICAgICAgIGxldCBseCA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAodC50ZXh0ID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJJbmZvLm1heExpbmVzICYmIHQubGluZU5vID49IHJlbmRlckluZm8ubWF4TGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHQuY29sb3IgIT0gY3VycmVudENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb2xvciA9IHQuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gY3VycmVudENvbG9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZm9udCA9IHQuZm9udFN0eWxlO1xuXG4gICAgICAgICAgICAgICAgLy8gRHJhdyB3aXRoIGxldHRlciBzcGFjaW5nXG4gICAgICAgICAgICAgICAgaWYgKHQubGV0dGVycykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBsIG9mIHQubGV0dGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX3ggPSByZW5kZXJJbmZvLmxpbmVzW3QubGluZU5vXS54ICsgdC54ICsgbHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxUZXh0KGwudGV4dCwgX3gsIHJlbmRlckluZm8ubGluZXNbdC5saW5lTm9dLnkgKyByZW5kZXJJbmZvLmZvbnRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGx4ICs9IGwud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTdGFuZGFyZCBkcmF3aW5nXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgX3ggPSByZW5kZXJJbmZvLmxpbmVzW3QubGluZU5vXS54ICsgdC54O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxUZXh0KHQudGV4dCwgX3gsIHJlbmRlckluZm8ubGluZXNbdC5saW5lTm9dLnkgKyByZW5kZXJJbmZvLmZvbnRTaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCB0ZXh0IHNoYWRvd1xuICAgICAgICBpZiAocHJldlNoYWRvd1NldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd0NvbG9yID0gcHJldlNoYWRvd1NldHRpbmdzWzBdO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dPZmZzZXRYID0gcHJldlNoYWRvd1NldHRpbmdzWzFdO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dPZmZzZXRZID0gcHJldlNoYWRvd1NldHRpbmdzWzJdO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dCbHVyID0gcHJldlNoYWRvd1NldHRpbmdzWzNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgY3V0IHRyYW5zbGF0aW9uXG4gICAgICAgIGlmIChyZW5kZXJJbmZvLmN1dFN4IHx8IHJlbmRlckluZm8uY3V0U3kpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQudHJhbnNsYXRlKHJlbmRlckluZm8uY3V0U3gsIHJlbmRlckluZm8uY3V0U3kpO1xuICAgICAgICB9XG4gXG4gICAgICAgIC8vIFBvc3Rwcm9jZXNzIHJlbmRlckluZm8ubGluZXMgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHN0YW5kYXJkIHZlcnNpb25cbiAgICAgICAgcmVuZGVySW5mby5saW5lcyA9IHJlbmRlckluZm8ubGluZXMubWFwKChsKSA9PiBsLnRleHQucmVkdWNlKChhY2MsIHYpID0+IGFjYyArIHYudGV4dCwgJycpKTtcbiAgICAgICAgaWYgKHJlbmRlckluZm8ubWF4TGluZXMpIHtcbiAgICAgICAgICAgIHJlbmRlckluZm8ubGluZXMgPSByZW5kZXJJbmZvLmxpbmVzLnNsaWNlKDAsIHJlbmRlckluZm8ubWF4TGluZXMpO1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLnJlbmRlckluZm8gPSByZW5kZXJJbmZvO1xuXG4gICAgfTtcblxuICAgIG1lYXN1cmVUZXh0KHdvcmQsIHNwYWNlID0gMCkge1xuICAgICAgICBpZiAoIXNwYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh3b3JkKS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZC5zcGxpdCgnJykucmVkdWNlKChhY2MsIGNoYXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhY2MgKyB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KGNoYXIpLndpZHRoICsgc3BhY2U7XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIHRva2VuaXplKHRleHQpIHtcbiAgICAgICAgY29uc3QgcmUgPS8gfFxcbnw8aT58PFxcL2k+fDxiPnw8XFwvYj58PGNvbG9yPTBbeFhdWzAtOWEtZkEtRl17OH0+fDxcXC9jb2xvcj4vZ1xuICAgIFxuICAgICAgICBjb25zdCBkZWxpbWV0ZXJzID0gdGV4dC5tYXRjaChyZSkgfHwgW107XG4gICAgICAgIGNvbnN0IHdvcmRzID0gdGV4dC5zcGxpdChyZSkgfHwgW107XG4gICAgXG4gICAgICAgIGxldCBmaW5hbCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmaW5hbC5wdXNoKHdvcmRzW2ldLCBkZWxpbWV0ZXJzW2ldKVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsLnBvcCgpXG4gICAgICAgIHJldHVybiBmaW5hbC5maWx0ZXIoKHdvcmQpID0+IHdvcmQgIT0gJycpO1xuICAgIFxuICAgIH1cbiAgICBcbiAgICBwYXJzZSh0b2tlbnMpIHtcbiAgICAgICAgbGV0IGl0YWxpYyA9IDA7XG4gICAgICAgIGxldCBib2xkID0gMDtcbiAgICAgICAgbGV0IGNvbG9yU3RhY2sgPSBbU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKHRoaXMuX3NldHRpbmdzLnRleHRDb2xvcildO1xuICAgICAgICBsZXQgY29sb3IgPSAwO1xuXG4gICAgICAgIGNvbnN0IGNvbG9yUmVnZXhwID0gLzxjb2xvcj0oPzxjb2xvcj4wW3hYXVswLTlhLWZBLUZdezh9KS87XG4gICAgXG4gICAgICAgIHJldHVybiB0b2tlbnMubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICBpZiAodCA9PSAnPGk+Jykge1xuICAgICAgICAgICAgICAgIGl0YWxpYyArPSAxO1xuICAgICAgICAgICAgICAgIHQgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodCA9PSAnPC9pPicgJiYgaXRhbGljID4gMCkge1xuICAgICAgICAgICAgICAgIGl0YWxpYyAtPSAxO1xuICAgICAgICAgICAgICAgIHQgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodCA9PSAnPGI+Jykge1xuICAgICAgICAgICAgICAgIGJvbGQgKz0gMTtcbiAgICAgICAgICAgICAgICB0ID0gJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT0gJzwvYj4nICYmIGJvbGQgPiAwKSB7XG4gICAgICAgICAgICAgICAgYm9sZCAtPSAxO1xuICAgICAgICAgICAgICAgIHQgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodCA9PSAnPC9jb2xvcj4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yU3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvciAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBjb2xvclN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ID0gJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbG9yUmVnZXhwLnRlc3QodCkpIHtcbiAgICAgICAgICAgICAgICBjb2xvclN0YWNrLnB1c2goU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKHBhcnNlSW50KGNvbG9yUmVnZXhwLmV4ZWModCkuZ3JvdXBzWydjb2xvciddKSkpO1xuICAgICAgICAgICAgICAgIGNvbG9yICs9IDE7XG4gICAgICAgICAgICAgICAgdCA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHQsXG4gICAgICAgICAgICAgICAgaXRhbGljOiBpdGFsaWMsXG4gICAgICAgICAgICAgICAgYm9sZDogYm9sZCxcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JTdGFja1tjb2xvcl0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKG8pID0+IG8udGV4dCAhPSAnJyk7XG4gICAgfVxuXG4gICAgYXBwbHlGb250U3R5bGUod29yZCwgYmFzZUZvbnQpIHtcbiAgICAgICAgbGV0IGZvbnQgPSBiYXNlRm9udDtcbiAgICAgICAgaWYgKHdvcmQuYm9sZCkge1xuICAgICAgICAgICAgZm9udCA9ICdib2xkICcgKyBmb250O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkLml0YWxpYykge1xuICAgICAgICAgICAgZm9udCA9ICdpdGFsaWMgJyArIGZvbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dC5mb250ID0gZm9udFxuICAgICAgICB3b3JkLmZvbnRTdHlsZSA9IGZvbnQ7XG4gICAgfVxuXG4gICAgcmVzZXRGb250U3R5bGUoYmFzZUZvbnQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5mb250ID0gYmFzZUZvbnQ7XG4gICAgfVxuXG4gICAgbWVhc3VyZShwYXJzZWQsIGxldHRlclNwYWNpbmcgPSAwLCBiYXNlRm9udCkge1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcGFyc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5Rm9udFN0eWxlKHAsIGJhc2VGb250KTtcbiAgICAgICAgICAgIHAud2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KHAudGV4dCwgbGV0dGVyU3BhY2luZyk7XG5cbiAgICAgICAgICAgIC8vIExldHRlciBieSBsZXR0ZXIgZGV0YWlsIGZvciBsZXR0ZXIgc3BhY2luZ1xuICAgICAgICAgICAgaWYgKGxldHRlclNwYWNpbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgcC5sZXR0ZXJzID0gcC50ZXh0LnNwbGl0KCcnKS5tYXAoKGwpID0+IHtyZXR1cm4ge3RleHQ6IGx9fSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbCBvZiBwLmxldHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbC53aWR0aCA9IHRoaXMubWVhc3VyZVRleHQobC50ZXh0LCBsZXR0ZXJTcGFjaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0Rm9udFN0eWxlKGJhc2VGb250KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG5cbiAgICBpbmRlbnQocGFyc2VkLCB0ZXh0SW5kZW50KSB7XG4gICAgICAgIHBhcnNlZC5zcGxpY2UoMCwgMCwge3RleHQ6IFwiXCIsIHdpZHRoOiB0ZXh0SW5kZW50fSk7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuXG4gICAgd3JhcFdvcmQod29yZCwgd29yZFdyYXBXaWR0aCwgc3VmZml4KSB7XG4gICAgICAgIGNvbnN0IHN1ZmZpeFdpZHRoID0gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dChzdWZmaXgpLndpZHRoO1xuICAgICAgICBjb25zdCB3b3JkTGVuID0gd29yZC5sZW5ndGhcbiAgICAgICAgY29uc3Qgd29yZFdpZHRoID0gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh3b3JkKS53aWR0aDtcblxuICAgICAgICAvKiBJZiB3b3JkIGZpdHMgd3JhcFdpZHRoLCBkbyBub3RoaW5nICovXG4gICAgICAgIGlmICh3b3JkV2lkdGggPD0gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHdvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBNYWtlIGluaXRpYWwgZ3Vlc3MgZm9yIHRleHQgY3V0dG9mZiAqL1xuICAgICAgICBsZXQgY3V0b2ZmSW5kZXggPSBNYXRoLmZsb29yKCh3b3JkV3JhcFdpZHRoICogd29yZExlbikgLyB3b3JkV2lkdGgpO1xuICAgICAgICBsZXQgdHJ1bmNXb3JkV2lkdGggPSB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHdvcmQuc3Vic3RyaW5nKDAsIGN1dG9mZkluZGV4KSkud2lkdGggKyBzdWZmaXhXaWR0aDtcblxuICAgICAgICAvKiBJbiBjYXNlIGd1ZXNzIHdhcyBvdmVyZXN0aW1hdGVkLCBzaHJpbmsgaXQgbGV0dGVyIGJ5IGxldHRlci4gKi9cbiAgICAgICAgaWYgKHRydW5jV29yZFdpZHRoID4gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgICAgd2hpbGUgKGN1dG9mZkluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHRydW5jV29yZFdpZHRoID0gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh3b3JkLnN1YnN0cmluZygwLCBjdXRvZmZJbmRleCkpLndpZHRoICsgc3VmZml4V2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKHRydW5jV29yZFdpZHRoID4gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXRvZmZJbmRleCAtPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAvKiBJbiBjYXNlIGd1ZXNzIHdhcyB1bmRlcmVzdGltYXRlZCwgZXh0ZW5kIGl0IGxldHRlciBieSBsZXR0ZXIuICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoY3V0b2ZmSW5kZXggPCB3b3JkTGVuKSB7XG4gICAgICAgICAgICAgICAgdHJ1bmNXb3JkV2lkdGggPSB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHdvcmQuc3Vic3RyaW5nKDAsIGN1dG9mZkluZGV4KSkud2lkdGggKyBzdWZmaXhXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAodHJ1bmNXb3JkV2lkdGggPCB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1dG9mZkluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluYWxseSwgd2hlbiBib3VuZCBpcyBjcm9zc2VkLCByZXRyYWN0IGxhc3QgbGV0dGVyLlxuICAgICAgICAgICAgICAgICAgICBjdXRvZmZJbmRleCAtPTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIElmIHdyYXBXaWR0aCBpcyB0b28gc2hvcnQgdG8gZXZlbiBjb250YWluIHN1ZmZpeCBhbG9uZSwgcmV0dXJuIGVtcHR5IHN0cmluZyAqL1xuICAgICAgICByZXR1cm4gd29yZC5zdWJzdHJpbmcoMCwgY3V0b2ZmSW5kZXgpICsgKHdvcmRXcmFwV2lkdGggPj0gc3VmZml4V2lkdGggPyBzdWZmaXggOiAnJylcbiAgICB9XG5cbiAgICBfZ2V0QnJlYWtJbmRleCh3b3JkLCB3aWR0aCkge1xuICAgICAgICBjb25zdCB3b3JkTGVuID0gd29yZC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHdvcmRXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQod29yZCk7XG5cbiAgICAgICAgaWYgKHdvcmRXaWR0aCA8PSB3aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHticmVha0luZGV4OiB3b3JkLmxlbmd0aCwgdHJ1bmNXb3JkV2lkdGg6IHdvcmRXaWR0aH07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYnJlYWtJbmRleCA9IE1hdGguZmxvb3IoKHdpZHRoICogd29yZExlbikgLyB3b3JkV2lkdGgpO1xuICAgICAgICBsZXQgdHJ1bmNXb3JkV2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KHdvcmQuc3Vic3RyaW5nKDAsIGJyZWFrSW5kZXgpKVxuXG4gICAgICAgIC8qIEluIGNhc2UgZ3Vlc3Mgd2FzIG92ZXJlc3RpbWF0ZWQsIHNocmluayBpdCBsZXR0ZXIgYnkgbGV0dGVyLiAqL1xuICAgICAgICBpZiAodHJ1bmNXb3JkV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgICAgd2hpbGUgKGJyZWFrSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgdHJ1bmNXb3JkV2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KHdvcmQuc3Vic3RyaW5nKDAsIGJyZWFrSW5kZXgpKTtcbiAgICAgICAgICAgICAgICBpZiAodHJ1bmNXb3JkV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVha0luZGV4IC09IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIC8qIEluIGNhc2UgZ3Vlc3Mgd2FzIHVuZGVyZXN0aW1hdGVkLCBleHRlbmQgaXQgbGV0dGVyIGJ5IGxldHRlci4gKi9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChicmVha0luZGV4IDwgd29yZExlbikge1xuICAgICAgICAgICAgICAgIHRydW5jV29yZFdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dCh3b3JkLnN1YnN0cmluZygwLCBicmVha0luZGV4KSk7XG4gICAgICAgICAgICAgICAgaWYgKHRydW5jV29yZFdpZHRoIDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIHdoZW4gYm91bmQgaXMgY3Jvc3NlZCwgcmV0cmFjdCBsYXN0IGxldHRlci5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtJbmRleCAtPTE7XG4gICAgICAgICAgICAgICAgICAgIHRydW5jV29yZFdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dCh3b3JkLnN1YnN0cmluZygwLCBicmVha0luZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge2JyZWFrSW5kZXgsIHRydW5jV29yZFdpZHRofTtcblxuICAgIH1cblxuICAgIHdvcmRCcmVhayh3b3JkLCB3aWR0aCwgYmFzZUZvbnQpIHtcbiAgICAgICAgaWYgKCF3b3JkLnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB3b3JkXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBseUZvbnRTdHlsZSh3b3JkLCBiYXNlRm9udClcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgbGV0IHRleHQgPSB3b3JkLnRleHQ7XG4gICAgICAgIGlmICghd29yZC5sZXR0ZXJzKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHticmVha0luZGV4LCB0cnVuY1dvcmRXaWR0aH0gPSB0aGlzLl9nZXRCcmVha0luZGV4KHRleHQsIHdpZHRoKTtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsuLi53b3JkfSk7XG4gICAgICAgICAgICAgICAgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0udGV4dCA9IHRleHQuc2xpY2UoMCwgYnJlYWtJbmRleCk7XG4gICAgICAgICAgICAgICAgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0ud2lkdGggPSB0cnVuY1dvcmRXaWR0aDtcblxuICAgICAgICAgICAgICAgIGlmIChicmVha0luZGV4ID09PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShicmVha0luZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCB0b3RhbFdpZHRoID0gMDtcbiAgICAgICAgICAgIGxldCBsZXR0ZXJzID0gW107XG4gICAgICAgICAgICBsZXQgYnJlYWtJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGwgb2Ygd29yZC5sZXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsV2lkdGggKyBsLndpZHRoID49IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goey4uLndvcmR9KTtcbiAgICAgICAgICAgICAgICAgICAgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0udGV4dCA9IHRleHQuc2xpY2UoMCwgYnJlYWtJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLndpZHRoID0gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0ubGV0dGVycyA9IGxldHRlcnM7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKGJyZWFrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVha0luZGV4ID0gMDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVycy5wdXNoKGwpO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbFdpZHRoICs9IGwud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG90YWxXaWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsuLi53b3JkfSk7XG4gICAgICAgICAgICAgICAgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0udGV4dCA9IHRleHQuc2xpY2UoMCwgYnJlYWtJbmRleCk7XG4gICAgICAgICAgICAgICAgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0ud2lkdGggPSB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLmxldHRlcnMgPSBsZXR0ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbn0iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3RyZWUvVXRpbHMubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE11bHRpU3BsaW5lIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9jbGVhcigpO1xuICAgIH1cblxuICAgIF9jbGVhcigpIHtcbiAgICAgICAgdGhpcy5fcCA9IFtdO1xuICAgICAgICB0aGlzLl9wZSA9IFtdO1xuICAgICAgICB0aGlzLl9pZHAgPSBbXTtcbiAgICAgICAgdGhpcy5fZiA9IFtdO1xuICAgICAgICB0aGlzLl92ID0gW107XG4gICAgICAgIHRoaXMuX2x2ID0gW107XG4gICAgICAgIHRoaXMuX3NtID0gW107XG4gICAgICAgIHRoaXMuX3MgPSBbXTtcbiAgICAgICAgdGhpcy5fdmUgPSBbXTtcbiAgICAgICAgdGhpcy5fc21lID0gW107XG4gICAgICAgIHRoaXMuX3NlID0gW107XG5cbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBwYXJzZShyZ2JhLCBkZWYpIHtcbiAgICAgICAgbGV0IGksIG47XG4gICAgICAgIGlmICghVXRpbHMuaXNPYmplY3RMaXRlcmFsKGRlZikpIHtcbiAgICAgICAgICAgIGRlZiA9IHswOiBkZWZ9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGVmYXVsdFNtb290aG5lc3MgPSAwLjU7XG5cbiAgICAgICAgbGV0IGl0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBkZWYpIHtcbiAgICAgICAgICAgIGlmIChkZWYuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGxldCBvYmogPSBkZWZba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIVV0aWxzLmlzT2JqZWN0TGl0ZXJhbChvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IHt2OiBvYmp9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHAgPSBwYXJzZUZsb2F0KGtleSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcInNtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFNtb290aG5lc3MgPSBvYmoudjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihwKSAmJiBwID49IDAgJiYgcCA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5wID0gcDtcblxuICAgICAgICAgICAgICAgICAgICBvYmouZiA9IFV0aWxzLmlzRnVuY3Rpb24ob2JqLnYpO1xuICAgICAgICAgICAgICAgICAgICBvYmoubHYgPSBvYmouZiA/IG9iai52KDAsIDApIDogb2JqLnY7XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChvYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvcnQgYnkgcHJvZ3Jlc3MgdmFsdWUuXG4gICAgICAgIGl0ZW1zID0gaXRlbXMuc29ydChmdW5jdGlvbihhLCBiKSB7cmV0dXJuIGEucCAtIGIucH0pO1xuXG4gICAgICAgIG4gPSBpdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSAoaSA9PT0gbiAtIDEpO1xuICAgICAgICAgICAgaWYgKCFpdGVtc1tpXS5oYXNPd25Qcm9wZXJ0eSgncGUnKSkge1xuICAgICAgICAgICAgICAgIC8vIFByb2dyZXNzLlxuICAgICAgICAgICAgICAgIGl0ZW1zW2ldLnBlID0gbGFzdCA/IChpdGVtc1tpXS5wIDw9IDEgPyAxIDogMiAvKiBzdXBwb3J0IG9uZXRvdHdvIHN0b3AgKi8pIDogaXRlbXNbaSArIDFdLnA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgaXRlbXMgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXggPSBpIDwgbiAtIDEgPyBpdGVtc1tpICsgMV0ucCA6IDE7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1zW2ldLnBlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldLnBlID0gbWF4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtc1tpXS5wZSA9PT0gaXRlbXNbaV0ucCkge1xuICAgICAgICAgICAgICAgIGl0ZW1zW2ldLmlkcCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1zW2ldLmlkcCA9IDEgLyAoaXRlbXNbaV0ucGUgLSBpdGVtc1tpXS5wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbG9yIG1lcmdlcjogd2UgbmVlZCB0byBzcGxpdC9jb21iaW5lIFJHQkEgY29tcG9uZW50cy5cblxuICAgICAgICAvLyBDYWxjdWxhdGUgYmV6aWVyIGhlbHBlciB2YWx1ZXMuO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW1zW2ldLmhhc093blByb3BlcnR5KCdzbScpKSB7XG4gICAgICAgICAgICAgICAgLy8gU21vb3RobmVzcy47XG4gICAgICAgICAgICAgICAgaXRlbXNbaV0uc20gPSBkZWZhdWx0U21vb3RobmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXRlbXNbaV0uaGFzT3duUHJvcGVydHkoJ3MnKSkge1xuICAgICAgICAgICAgICAgIC8vIFNsb3BlLjtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBuIC0gMSB8fCAoaXRlbXNbaV0ucCA9PT0gMSAvKiBmb3Igb25ldG90d28gKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgc2xvcGUgYXQgc3RhcnQgYW5kIGVuZC47XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldLnMgPSByZ2JhID8gWzAsIDAsIDAsIDBdIDogMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaSA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmkgPSBpdGVtc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaS5wID09PSBuaS5wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS5zID0gcmdiYSA/IFswLCAwLCAwLCAwXSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmdiYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5jID0gTXVsdGlTcGxpbmUuZ2V0UmdiYUNvbXBvbmVudHMobmkubHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBjID0gTXVsdGlTcGxpbmUuZ2V0UmdiYUNvbXBvbmVudHMocGkubHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSAxIC8gKG5pLnAgLSBwaS5wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS5zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkICogKG5jWzBdIC0gcGNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkICogKG5jWzFdIC0gcGNbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkICogKG5jWzJdIC0gcGNbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkICogKG5jWzNdIC0gcGNbM10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0ucyA9IChuaS5sdiAtIHBpLmx2KSAvIChuaS5wIC0gcGkucCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHZhbHVlIGZ1bmN0aW9uLjtcbiAgICAgICAgICAgIGlmICghaXRlbXNbaV0uZikge1xuXG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSAoaSA9PT0gbiAtIDEpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbXNbaV0uaGFzT3duUHJvcGVydHkoJ3ZlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0udmUgPSBsYXN0ID8gaXRlbXNbaV0ubHYgOiBpdGVtc1tpICsgMV0ubHY7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIG9ubHkgaW50ZXJwb2xhdGUgb24gbnVtZXJpYyB2YWx1ZXMuIE5vbi1udW1lcmljIHZhbHVlcyBhcmUgc2V0IGxpdGVyYWxseSB3aGVuIHJlYWNoZWQgdGltZS5cbiAgICAgICAgICAgICAgICBpZiAoVXRpbHMuaXNOdW1iZXIoaXRlbXNbaV0udikgJiYgVXRpbHMuaXNOdW1iZXIoaXRlbXNbaV0ubHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbXNbaV0uaGFzT3duUHJvcGVydHkoJ3NtZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS5zbWUgPSBsYXN0ID8gZGVmYXVsdFNtb290aG5lc3MgOiBpdGVtc1tpICsgMV0uc207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtc1tpXS5oYXNPd25Qcm9wZXJ0eSgnc2UnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0uc2UgPSBsYXN0ID8gKHJnYmEgPyBbMCwgMCwgMCwgMF0gOiAwKSA6IGl0ZW1zW2kgKyAxXS5zO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgc3BsaW5lLjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJnYmEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldLnYgPSBNdWx0aVNwbGluZS5nZXRTcGxpbmVSZ2JhVmFsdWVGdW5jdGlvbihpdGVtc1tpXS52LCBpdGVtc1tpXS52ZSwgaXRlbXNbaV0ucCwgaXRlbXNbaV0ucGUsIGl0ZW1zW2ldLnNtLCBpdGVtc1tpXS5zbWUsIGl0ZW1zW2ldLnMsIGl0ZW1zW2ldLnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldLnYgPSBNdWx0aVNwbGluZS5nZXRTcGxpbmVWYWx1ZUZ1bmN0aW9uKGl0ZW1zW2ldLnYsIGl0ZW1zW2ldLnZlLCBpdGVtc1tpXS5wLCBpdGVtc1tpXS5wZSwgaXRlbXNbaV0uc20sIGl0ZW1zW2ldLnNtZSwgaXRlbXNbaV0ucywgaXRlbXNbaV0uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0uZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fYWRkKGl0ZW1zW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9hZGQoaXRlbSkge1xuICAgICAgICB0aGlzLl9wLnB1c2goaXRlbS5wIHx8IDApO1xuICAgICAgICB0aGlzLl9wZS5wdXNoKGl0ZW0ucGUgfHwgMCk7XG4gICAgICAgIHRoaXMuX2lkcC5wdXNoKGl0ZW0uaWRwIHx8IDApO1xuICAgICAgICB0aGlzLl9mLnB1c2goaXRlbS5mIHx8IGZhbHNlKTtcbiAgICAgICAgdGhpcy5fdi5wdXNoKGl0ZW0uaGFzT3duUHJvcGVydHkoJ3YnKSA/IGl0ZW0udiA6IDAgLyogdiBtaWdodCBiZSBmYWxzZSBvciBudWxsICovICk7XG4gICAgICAgIHRoaXMuX2x2LnB1c2goaXRlbS5sdiB8fCAwKTtcbiAgICAgICAgdGhpcy5fc20ucHVzaChpdGVtLnNtIHx8IDApO1xuICAgICAgICB0aGlzLl9zLnB1c2goaXRlbS5zIHx8IDApO1xuICAgICAgICB0aGlzLl92ZS5wdXNoKGl0ZW0udmUgfHwgMCk7XG4gICAgICAgIHRoaXMuX3NtZS5wdXNoKGl0ZW0uc21lIHx8IDApO1xuICAgICAgICB0aGlzLl9zZS5wdXNoKGl0ZW0uc2UgfHwgMCk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCsrO1xuICAgIH1cblxuICAgIF9nZXRJdGVtKHApIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2xlbmd0aDtcbiAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocCA8IHRoaXMuX3BbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wW2ldIDw9IHAgJiYgcCA8IHRoaXMuX3BlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbiAtIDE7XG4gICAgfVxuXG4gICAgZ2V0VmFsdWUocCkge1xuICAgICAgICBjb25zdCBpID0gdGhpcy5fZ2V0SXRlbShwKTtcbiAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZbaV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgKHAgLSB0aGlzLl9wW2ldKSAqIHRoaXMuX2lkcFtpXSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92W2ldKG8pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFJnYmFDb21wb25lbnRzKGFyZ2IpIHtcbiAgICAgICAgbGV0IHIgPSAoKGFyZ2IgLyA2NTUzNikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGcgPSAoKGFyZ2IgLyAyNTYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBiID0gYXJnYiAlIDI1NjtcbiAgICAgICAgbGV0IGEgPSAoKGFyZ2IgLyAxNjc3NzIxNikgfCAwKTtcbiAgICAgICAgcmV0dXJuIFtyLCBnLCBiLCBhXTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldFNwbGluZVZhbHVlRnVuY3Rpb24odjEsIHYyLCBwMSwgcDIsIG8xLCBpMiwgczEsIHMyKSB7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBzbG9wZXMgYmVjYXVzZSB3ZSB1c2UgYSBzcGxpbmUgdGhhdCBnb2VzIGZyb20gMCB0byAxLlxuICAgICAgICBsZXQgZHAgPSBwMiAtIHAxO1xuICAgICAgICBzMSAqPSBkcDtcbiAgICAgICAgczIgKj0gZHA7XG5cbiAgICAgICAgbGV0IGhlbHBlcnMgPSBNdWx0aVNwbGluZS5nZXRTcGxpbmVIZWxwZXJzKHYxLCB2MiwgbzEsIGkyLCBzMSwgczIpO1xuICAgICAgICBpZiAoIWhlbHBlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIGlmIChwID09PSAwKSByZXR1cm4gdjE7XG4gICAgICAgICAgICAgICAgaWYgKHAgPT09IDEpIHJldHVybiB2MjtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2MiAqIHAgKyB2MSAqICgxIC0gcCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAgPT09IDApIHJldHVybiB2MTtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gMSkgcmV0dXJuIHYyO1xuICAgICAgICAgICAgICAgIHJldHVybiBNdWx0aVNwbGluZS5jYWxjdWxhdGVTcGxpbmUoaGVscGVycywgcCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRTcGxpbmVSZ2JhVmFsdWVGdW5jdGlvbih2MSwgdjIsIHAxLCBwMiwgbzEsIGkyLCBzMSwgczIpIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHNsb3BlcyBiZWNhdXNlIHdlIHVzZSBhIHNwbGluZSB0aGF0IGdvZXMgZnJvbSAwIHRvIDEuXG4gICAgICAgIGxldCBkcCA9IHAyIC0gcDE7XG4gICAgICAgIHMxWzBdICo9IGRwO1xuICAgICAgICBzMVsxXSAqPSBkcDtcbiAgICAgICAgczFbMl0gKj0gZHA7XG4gICAgICAgIHMxWzNdICo9IGRwO1xuICAgICAgICBzMlswXSAqPSBkcDtcbiAgICAgICAgczJbMV0gKj0gZHA7XG4gICAgICAgIHMyWzJdICo9IGRwO1xuICAgICAgICBzMlszXSAqPSBkcDtcblxuICAgICAgICBsZXQgY3YxID0gTXVsdGlTcGxpbmUuZ2V0UmdiYUNvbXBvbmVudHModjEpO1xuICAgICAgICBsZXQgY3YyID0gTXVsdGlTcGxpbmUuZ2V0UmdiYUNvbXBvbmVudHModjIpO1xuXG4gICAgICAgIGxldCBoZWxwZXJzID0gW1xuICAgICAgICAgICAgTXVsdGlTcGxpbmUuZ2V0U3BsaW5lSGVscGVycyhjdjFbMF0sIGN2MlswXSwgbzEsIGkyLCBzMVswXSwgczJbMF0pLFxuICAgICAgICAgICAgTXVsdGlTcGxpbmUuZ2V0U3BsaW5lSGVscGVycyhjdjFbMV0sIGN2MlsxXSwgbzEsIGkyLCBzMVsxXSwgczJbMV0pLFxuICAgICAgICAgICAgTXVsdGlTcGxpbmUuZ2V0U3BsaW5lSGVscGVycyhjdjFbMl0sIGN2MlsyXSwgbzEsIGkyLCBzMVsyXSwgczJbMl0pLFxuICAgICAgICAgICAgTXVsdGlTcGxpbmUuZ2V0U3BsaW5lSGVscGVycyhjdjFbM10sIGN2MlszXSwgbzEsIGkyLCBzMVszXSwgczJbM10pXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKCFoZWxwZXJzWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAvLyBMaW5lYXIuXG4gICAgICAgICAgICAgICAgaWYgKHAgPT09IDApIHJldHVybiB2MTtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gMSkgcmV0dXJuIHYyO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIE11bHRpU3BsaW5lLm1lcmdlQ29sb3JzKHYyLCB2MSwgcCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAgPT09IDApIHJldHVybiB2MTtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gMSkgcmV0dXJuIHYyO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIE11bHRpU3BsaW5lLmdldEFyZ2JOdW1iZXIoW1xuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbigyNTUsIE11bHRpU3BsaW5lLmNhbGN1bGF0ZVNwbGluZShoZWxwZXJzWzBdLCBwKSksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKDI1NSwgTXVsdGlTcGxpbmUuY2FsY3VsYXRlU3BsaW5lKGhlbHBlcnNbMV0sIHApKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oMjU1LCBNdWx0aVNwbGluZS5jYWxjdWxhdGVTcGxpbmUoaGVscGVyc1syXSwgcCkpLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbigyNTUsIE11bHRpU3BsaW5lLmNhbGN1bGF0ZVNwbGluZShoZWxwZXJzWzNdLCBwKSlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGhlbHBlcnMgdG8gYmUgdXNlZCBpbiB0aGUgc3BsaW5lIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2MVxuICAgICAqICAgRnJvbSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdjJcbiAgICAgKiAgIFRvIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvMVxuICAgICAqICAgRnJvbSBzbW9vdGhuZXNzICgwID0gbGluZWFyLCAxID0gc21vb3RoKS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gczFcbiAgICAgKiAgIEZyb20gc2xvcGUgKDAgPSBob3Jpem9udGFsLCBpbmZpbml0ZSA9IHZlcnRpY2FsKS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaTJcbiAgICAgKiAgIFRvIHNtb290aG5lc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHMyXG4gICAgICogICBUbyBzbG9wZS5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyW119XG4gICAgICogICBUaGUgaGVscGVyIHZhbHVlcyB0byBiZSBzdXBwbGllZCB0byB0aGUgc3BsaW5lIGZ1bmN0aW9uLlxuICAgICAqICAgSWYgdGhlIGNvbmZpZ3VyYXRpb24gaXMgYWN0dWFsbHkgbGluZWFyLCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTcGxpbmVIZWxwZXJzKHYxLCB2MiwgbzEsIGkyLCBzMSwgczIpIHtcbiAgICAgICAgaWYgKCFvMSAmJiAhaTIpIHtcbiAgICAgICAgICAgIC8vIExpbmVhci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3ViaWMgYmV6aWVyIHBvaW50cy5cbiAgICAgICAgLy8gaHR0cDovL2N1YmljLWJlemllci5jb20vXG4gICAgICAgIGxldCBjc3ggPSBvMTtcbiAgICAgICAgbGV0IGNzeSA9IHYxICsgczEgKiBvMTtcbiAgICAgICAgbGV0IGNleCA9IDEgLSBpMjtcbiAgICAgICAgbGV0IGNleSA9IHYyIC0gczIgKiBpMjtcblxuICAgICAgICBsZXQgeGEgPSAzICogY3N4IC0gMyAqIGNleCArIDE7XG4gICAgICAgIGxldCB4YiA9IC02ICogY3N4ICsgMyAqIGNleDtcbiAgICAgICAgbGV0IHhjID0gMyAqIGNzeDtcblxuICAgICAgICBsZXQgeWEgPSAzICogY3N5IC0gMyAqIGNleSArIHYyIC0gdjE7XG4gICAgICAgIGxldCB5YiA9IDMgKiAoY2V5ICsgdjEpIC0gNiAqIGNzeTtcbiAgICAgICAgbGV0IHljID0gMyAqIChjc3kgLSB2MSk7XG4gICAgICAgIGxldCB5ZCA9IHYxO1xuXG4gICAgICAgIHJldHVybiBbeGEsIHhiLCB4YywgeWEsIHliLCB5YywgeWRdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBpbnRlcm1lZGlhdGUgc3BsaW5lIHZhbHVlIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgaGVscGVycy5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBoZWxwZXJzXG4gICAgICogICBPYnRhaW5lZCBmcm9tIGdldFNwbGluZUhlbHBlcnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgc3RhdGljIGNhbGN1bGF0ZVNwbGluZShoZWxwZXJzLCBwKSB7XG4gICAgICAgIGxldCB4YSA9IGhlbHBlcnNbMF07XG4gICAgICAgIGxldCB4YiA9IGhlbHBlcnNbMV07XG4gICAgICAgIGxldCB4YyA9IGhlbHBlcnNbMl07XG4gICAgICAgIGxldCB5YSA9IGhlbHBlcnNbM107XG4gICAgICAgIGxldCB5YiA9IGhlbHBlcnNbNF07XG4gICAgICAgIGxldCB5YyA9IGhlbHBlcnNbNV07XG4gICAgICAgIGxldCB5ZCA9IGhlbHBlcnNbNl07XG5cbiAgICAgICAgaWYgKHhhID09PSAtMiAmJiB5YSA9PT0gLTIgJiYgeGMgPT09IDAgJiYgeWMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIExpbmVhci5cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCB0IGZvciBwLlxuICAgICAgICBsZXQgdCA9IDAuNSwgY2J4LCBkeDtcblxuICAgICAgICBmb3IgKGxldCBpdCA9IDA7IGl0IDwgMjA7IGl0KyspIHtcbiAgICAgICAgICAgIC8vIEN1YmljIGJlemllciBmdW5jdGlvbjogZih0KT10Kih0Kih0KmErYikrYykuXG4gICAgICAgICAgICBjYnggPSB0ICogKHQgKiAodCAqIHhhICsgeGIpICsgeGMpO1xuXG4gICAgICAgICAgICBkeCA9IHAgLSBjYng7XG4gICAgICAgICAgICBpZiAoZHggPiAtMWUtOCAmJiBkeCA8IDFlLTgpIHtcbiAgICAgICAgICAgICAgICAvLyBTb2x1dGlvbiBmb3VuZCFcbiAgICAgICAgICAgICAgICByZXR1cm4gdCAqICh0ICogKHQgKiB5YSArIHliKSArIHljKSArIHlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDdWJpYyBiZXppZXIgZGVyaXZhdGl2ZSBmdW5jdGlvbjogZicodCk9dCoodCooMyphKSsyKmIpK2NcbiAgICAgICAgICAgIGxldCBjYnhkID0gdCAqICh0ICogKDMgKiB4YSkgKyAyICogeGIpICsgeGM7XG5cbiAgICAgICAgICAgIGlmIChjYnhkID4gMWUtMTAgJiYgY2J4ZCA8IDFlLTEwKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvYmxlbWF0aWMuIEZhbGwgYmFjayB0byBiaW5hcnkgc2VhcmNoIG1ldGhvZC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdCArPSBkeCAvIGNieGQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGYWxsYmFjazogYmluYXJ5IHNlYXJjaCBtZXRob2QuIFRoaXMgaXMgbW9yZSByZWxpYWJsZSB3aGVuIHRoZXJlIGFyZSBuZWFyLTAgc2xvcGVzLlxuICAgICAgICBsZXQgbWluVCA9IDA7XG4gICAgICAgIGxldCBtYXhUID0gMTtcbiAgICAgICAgZm9yIChsZXQgaXQgPSAwOyBpdCA8IDIwOyBpdCsrKSB7XG4gICAgICAgICAgICB0ID0gMC41ICogKG1pblQgKyBtYXhUKTtcblxuICAgICAgICAgICAgLy8gQ3ViaWMgYmV6aWVyIGZ1bmN0aW9uOiBmKHQpPXQqKHQqKHQqYStiKStjKStkLlxuICAgICAgICAgICAgY2J4ID0gdCAqICh0ICogKHQgKiB4YSArIHhiKSArIHhjKTtcblxuICAgICAgICAgICAgZHggPSBwIC0gY2J4O1xuICAgICAgICAgICAgaWYgKGR4ID4gLTFlLTggJiYgZHggPCAxZS04KSB7XG4gICAgICAgICAgICAgICAgLy8gU29sdXRpb24gZm91bmQhXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQgKiAodCAqICh0ICogeWEgKyB5YikgKyB5YykgKyB5ZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGR4IDwgMCkge1xuICAgICAgICAgICAgICAgIG1heFQgPSB0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW5UID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG5cbiAgICBzdGF0aWMgbWVyZ2VDb2xvcnMoYzEsIGMyLCBwKSB7XG4gICAgICAgIGxldCByMSA9ICgoYzEgLyA2NTUzNikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGcxID0gKChjMSAvIDI1NikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGIxID0gYzEgJSAyNTY7XG4gICAgICAgIGxldCBhMSA9ICgoYzEgLyAxNjc3NzIxNikgfCAwKTtcblxuICAgICAgICBsZXQgcjIgPSAoKGMyIC8gNjU1MzYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBnMiA9ICgoYzIgLyAyNTYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBiMiA9IGMyICUgMjU2O1xuICAgICAgICBsZXQgYTIgPSAoKGMyIC8gMTY3NzcyMTYpIHwgMCk7XG5cbiAgICAgICAgbGV0IHIgPSByMSAqIHAgKyByMiAqICgxIC0gcCk7XG4gICAgICAgIGxldCBnID0gZzEgKiBwICsgZzIgKiAoMSAtIHApO1xuICAgICAgICBsZXQgYiA9IGIxICogcCArIGIyICogKDEgLSBwKTtcbiAgICAgICAgbGV0IGEgPSBhMSAqIHAgKyBhMiAqICgxIC0gcCk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoYSkgKiAxNjc3NzIxNiArIE1hdGgucm91bmQocikgKiA2NTUzNiArIE1hdGgucm91bmQoZykgKiAyNTYgKyBNYXRoLnJvdW5kKGIpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0QXJnYk51bWJlcihyZ2JhKSB7XG4gICAgICAgIHJnYmFbMF0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYmFbMF0pKTtcbiAgICAgICAgcmdiYVsxXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiYVsxXSkpO1xuICAgICAgICByZ2JhWzJdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2JhWzJdKSk7XG4gICAgICAgIHJnYmFbM10gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYmFbM10pKTtcbiAgICAgICAgbGV0IHYgPSAoKHJnYmFbM10gfCAwKSA8PCAyNCkgKyAoKHJnYmFbMF0gfCAwKSA8PCAxNikgKyAoKHJnYmFbMV0gfCAwKSA8PCA4KSArIChyZ2JhWzJdIHwgMCk7XG4gICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgdiA9IDB4RkZGRkZGRkYgKyB2ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9O1xufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi90cmVlL1V0aWxzLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPYmpNZXJnZXIge1xuXG4gICAgc3RhdGljIGlzTWYoZikge1xuICAgICAgICByZXR1cm4gVXRpbHMuaXNGdW5jdGlvbihmKSAmJiBmLl9fbWY7XG4gICAgfVxuXG4gICAgc3RhdGljIG1mKGYpIHtcbiAgICAgICAgLy8gU2V0IGFzIG1lcmdlIGZ1bmN0aW9uLlxuICAgICAgICBmLl9fbWYgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZjtcbiAgICB9XG5cbiAgICBzdGF0aWMgbWVyZ2UoYSwgYikge1xuICAgICAgICBjb25zdCBha3MgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgY29uc3QgYmtzID0gT2JqZWN0LmtleXMoYik7XG5cbiAgICAgICAgaWYgKCFia3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBpbmRleCBhcnJheSBmb3IgYWxsIGVsZW1lbnRzLlxuICAgICAgICBjb25zdCBhaSA9IHt9O1xuICAgICAgICBjb25zdCBiaSA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGJrcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGJrc1tpXTtcbiAgICAgICAgICAgIGFpW2tleV0gPSAtMTtcbiAgICAgICAgICAgIGJpW2tleV0gPSBpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gYWtzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYWtzW2ldO1xuICAgICAgICAgICAgYWlba2V5XSA9IGk7XG4gICAgICAgICAgICBpZiAoYmlba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYmlba2V5XSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWtzbCA9IGFrcy5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gYmtzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYmtzW2ldO1xuXG4gICAgICAgICAgICAvLyBQcmVwZW5kIGFsbCBpdGVtcyBpbiBhIHRoYXQgYXJlIG5vdCBpbiBiIC0gYmVmb3JlIHRoZSBub3cgYWRkZWQgYiBhdHRyaWJ1dGUuXG4gICAgICAgICAgICBjb25zdCBhSW5kZXggPSBhaVtrZXldO1xuICAgICAgICAgICAgbGV0IGN1ckluZGV4ID0gYUluZGV4O1xuICAgICAgICAgICAgd2hpbGUoLS1jdXJJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWtleSA9IGFrc1tjdXJJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGJpW2FrZXldICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGZvdW5kPyBTdG9wIHByb2Nlc3NpbmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCB5ZXQgZm91bmQgYnV0IGV4aXN0cyBpbiBiPyBBbHNvIHN0b3AgcHJvY2Vzc2luZzogd2FpdCB1bnRpbCB3ZSBmaW5kIGl0IGluIGIuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlKCsrY3VySW5kZXggPCBhSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBha2V5ID0gYWtzW2N1ckluZGV4XTtcbiAgICAgICAgICAgICAgICByZXN1bHRbYWtleV0gPSBhW2FrZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBidiA9IGJba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGF2ID0gYVtrZXldO1xuICAgICAgICAgICAgbGV0IHI7XG4gICAgICAgICAgICBpZiAodGhpcy5pc01mKGJ2KSkge1xuICAgICAgICAgICAgICAgIHIgPSBidihhdik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghVXRpbHMuaXNPYmplY3RMaXRlcmFsKGF2KSB8fCAhVXRpbHMuaXNPYmplY3RMaXRlcmFsKGJ2KSkge1xuICAgICAgICAgICAgICAgICAgICByID0gYnY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IE9iak1lcmdlci5tZXJnZShhdiwgYnYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2hlbiBtYXJrZWQgYXMgdW5kZWZpbmVkLCBwcm9wZXJ0eSBpcyBkZWxldGVkLlxuICAgICAgICAgICAgaWYgKHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGVuZCByZW1haW5pbmcgZmluYWwgaXRlbXMgaW4gYS5cbiAgICAgICAgbGV0IGN1ckluZGV4ID0gYWtzbDtcbiAgICAgICAgd2hpbGUoLS1jdXJJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBha2V5ID0gYWtzW2N1ckluZGV4XTtcbiAgICAgICAgICAgIGlmIChiaVtha2V5XSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSgrK2N1ckluZGV4IDwgYWtzbCkge1xuICAgICAgICAgICAgY29uc3QgYWtleSA9IGFrc1tjdXJJbmRleF07XG4gICAgICAgICAgICByZXN1bHRbYWtleV0gPSBhW2FrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogTWFuYWdlcyB0aGUgbGlzdCBvZiBjaGlsZHJlbiBmb3IgYW4gZWxlbWVudC5cbiAqL1xuXG5pbXBvcnQgT2JqZWN0TGlzdCBmcm9tIFwiLi4vdHJlZS9PYmplY3RMaXN0Lm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPYmplY3RMaXN0UHJveHkgZXh0ZW5kcyBPYmplY3RMaXN0IHtcblxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgb25BZGQoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEF0KGl0ZW0sIGluZGV4KTtcbiAgICB9XG5cbiAgICBvblJlbW92ZShpdGVtLCBpbmRleCkge1xuICAgICAgICB0aGlzLl90YXJnZXQucmVtb3ZlQXQoaW5kZXgpO1xuICAgIH1cblxuICAgIG9uU3luYyhyZW1vdmVkLCBhZGRlZCwgb3JkZXIpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0Ll9zZXRCeUFycmF5KG9yZGVyKTtcbiAgICB9XG5cbiAgICBvblNldChpdGVtLCBpbmRleCkge1xuICAgICAgICB0aGlzLl90YXJnZXQuc2V0QXQoaXRlbSwgaW5kZXgpO1xuICAgIH1cblxuICAgIG9uTW92ZShpdGVtLCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnNldEF0KGl0ZW0sIHRvSW5kZXgpO1xuICAgIH1cblxuICAgIGNyZWF0ZUl0ZW0ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQuY3JlYXRlSXRlbShvYmplY3QpO1xuICAgIH1cblxuICAgIGlzSXRlbShvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldC5pc0l0ZW0ob2JqZWN0KTtcbiAgICB9XG5cbn1cblxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIGxpc3Qgb2YgY2hpbGRyZW4gZm9yIGFuIGVsZW1lbnQuXG4gKi9cblxuaW1wb3J0IE9iamVjdExpc3RQcm94eSBmcm9tIFwiLi9PYmplY3RMaXN0UHJveHkubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9iamVjdExpc3RXcmFwcGVyIGV4dGVuZHMgT2JqZWN0TGlzdFByb3h5IHtcblxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgd3JhcCkge1xuICAgICAgICBzdXBlcih0YXJnZXQpO1xuICAgICAgICB0aGlzLl93cmFwID0gd3JhcDtcbiAgICB9XG5cbiAgICB3cmFwKGl0ZW0pIHtcbiAgICAgICAgbGV0IHdyYXBwZXIgPSB0aGlzLl93cmFwKGl0ZW0pO1xuICAgICAgICBpdGVtLl93cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgb25BZGQoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaXRlbSA9IHRoaXMud3JhcChpdGVtKTtcbiAgICAgICAgc3VwZXIub25BZGQoaXRlbSwgaW5kZXgpO1xuICAgIH1cblxuICAgIG9uUmVtb3ZlKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHN1cGVyLm9uUmVtb3ZlKGl0ZW0sIGluZGV4KTtcbiAgICB9XG5cbiAgICBvblN5bmMocmVtb3ZlZCwgYWRkZWQsIG9yZGVyKSB7XG4gICAgICAgIGFkZGVkLmZvckVhY2goYSA9PiB0aGlzLndyYXAoYSkpO1xuICAgICAgICBvcmRlciA9IG9yZGVyLm1hcChhID0+IGEuX3dyYXBwZXIpO1xuICAgICAgICBzdXBlci5vblN5bmMocmVtb3ZlZCwgYWRkZWQsIG9yZGVyKTtcbiAgICB9XG5cbiAgICBvblNldChpdGVtLCBpbmRleCkge1xuICAgICAgICBpdGVtID0gdGhpcy53cmFwKGl0ZW0pO1xuICAgICAgICBzdXBlci5vblNldChpdGVtLCBpbmRleCk7XG4gICAgfVxuXG4gICAgb25Nb3ZlKGl0ZW0sIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICBzdXBlci5vbk1vdmUoaXRlbSwgZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdHJlZS9VdGlscy5tanNcIjtcbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5pbXBvcnQgU3RhdGljQ2FudmFzVGV4dHVyZSBmcm9tIFwiLi4vdGV4dHVyZXMvU3RhdGljQ2FudmFzVGV4dHVyZS5tanNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb29scyB7XG5cbiAgICBzdGF0aWMgZ2V0Q2FudmFzVGV4dHVyZShjYW52YXNGYWN0b3J5LCBsb29rdXBJZCkge1xuICAgICAgICByZXR1cm4ge3R5cGU6IFN0YXRpY0NhbnZhc1RleHR1cmUsIGNvbnRlbnQ6IHtmYWN0b3J5OiBjYW52YXNGYWN0b3J5LCBsb29rdXBJZDogbG9va3VwSWR9fVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRSb3VuZFJlY3QodywgaCwgcmFkaXVzLCBzdHJva2VXaWR0aCwgc3Ryb2tlQ29sb3IsIGZpbGwsIGZpbGxDb2xvcikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmFkaXVzKSl7XG4gICAgICAgICAgICAvLyB1cHBlci1sZWZ0LCB1cHBlci1yaWdodCwgYm90dG9tLXJpZ2h0LCBib3R0b20tbGVmdC5cbiAgICAgICAgICAgIHJhZGl1cyA9IFtyYWRpdXMsIHJhZGl1cywgcmFkaXVzLCByYWRpdXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZhY3RvcnkgPSAoY2IsIHN0YWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNTcGFyaykge1xuICAgICAgICAgICAgICAgIHN0YWdlLnBsYXRmb3JtLmNyZWF0ZVJvdW5kUmVjdChjYiwgc3RhZ2UsIHcsIGgsIHJhZGl1cywgc3Ryb2tlV2lkdGgsIHN0cm9rZUNvbG9yLCBmaWxsLCBmaWxsQ29sb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYihudWxsLCB0aGlzLmNyZWF0ZVJvdW5kUmVjdChzdGFnZSwgdywgaCwgcmFkaXVzLCBzdHJva2VXaWR0aCwgc3Ryb2tlQ29sb3IsIGZpbGwsIGZpbGxDb2xvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgaWQgPSAncmVjdCcgKyBbdywgaCwgc3Ryb2tlV2lkdGgsIHN0cm9rZUNvbG9yLCBmaWxsID8gMSA6IDAsIGZpbGxDb2xvcl0uY29uY2F0KHJhZGl1cykuam9pbihcIixcIik7XG4gICAgICAgIHJldHVybiBUb29scy5nZXRDYW52YXNUZXh0dXJlKGZhY3RvcnksIGlkKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlUm91bmRSZWN0KHN0YWdlLCB3LCBoLCByYWRpdXMsIHN0cm9rZVdpZHRoLCBzdHJva2VDb2xvciwgZmlsbCwgZmlsbENvbG9yKSB7XG4gICAgICAgIGlmIChmaWxsID09PSB1bmRlZmluZWQpIGZpbGwgPSB0cnVlO1xuICAgICAgICBpZiAoc3Ryb2tlV2lkdGggPT09IHVuZGVmaW5lZCkgc3Ryb2tlV2lkdGggPSAwO1xuXG4gICAgICAgIGxldCBjYW52YXMgPSBzdGFnZS5wbGF0Zm9ybS5nZXREcmF3aW5nQ2FudmFzKCk7XG4gICAgICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgY2FudmFzLndpZHRoID0gdyArIHN0cm9rZVdpZHRoICsgMjtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGggKyBzdHJva2VXaWR0aCArIDI7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBsZXQgeCA9IDAuNSAqIHN0cm9rZVdpZHRoICsgMSwgeSA9IDAuNSAqIHN0cm9rZVdpZHRoICsgMTtcblxuICAgICAgICBjdHgubW92ZVRvKHggKyByYWRpdXNbMF0sIHkpO1xuICAgICAgICBjdHgubGluZVRvKHggKyB3IC0gcmFkaXVzWzFdLCB5KTtcbiAgICAgICAgY3R4LmFyY1RvKHggKyB3LCB5LCB4ICsgdywgeSArIHJhZGl1c1sxXSwgcmFkaXVzWzFdKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgdywgeSArIGggLSByYWRpdXNbMl0pO1xuICAgICAgICBjdHguYXJjVG8oeCArIHcsIHkgKyBoLCB4ICsgdyAtIHJhZGl1c1syXSwgeSArIGgsIHJhZGl1c1syXSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHJhZGl1c1szXSwgeSArIGgpO1xuICAgICAgICBjdHguYXJjVG8oeCwgeSArIGgsIHgsIHkgKyBoIC0gcmFkaXVzWzNdLCByYWRpdXNbM10pO1xuICAgICAgICBjdHgubGluZVRvKHgsIHkgKyByYWRpdXNbMF0pO1xuICAgICAgICBjdHguYXJjVG8oeCwgeSwgeCArIHJhZGl1c1swXSwgeSwgcmFkaXVzWzBdKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNOdW1iZXIoZmlsbENvbG9yKSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcoZmlsbENvbG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3Ryb2tlV2lkdGgpIHtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc051bWJlcihzdHJva2VDb2xvcikpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcoc3Ryb2tlQ29sb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRTaGFkb3dSZWN0KHcsIGgsIHJhZGl1cyA9IDAsIGJsdXIgPSA1LCBtYXJnaW4gPSBibHVyICogMikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmFkaXVzKSl7XG4gICAgICAgICAgICAvLyB1cHBlci1sZWZ0LCB1cHBlci1yaWdodCwgYm90dG9tLXJpZ2h0LCBib3R0b20tbGVmdC5cbiAgICAgICAgICAgIHJhZGl1cyA9IFtyYWRpdXMsIHJhZGl1cywgcmFkaXVzLCByYWRpdXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZhY3RvcnkgPSAoY2IsIHN0YWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNTcGFyaykge1xuICAgICAgICAgICAgICAgIHN0YWdlLnBsYXRmb3JtLmNyZWF0ZVNoYWRvd1JlY3QoY2IsIHN0YWdlLCB3LCBoLCByYWRpdXMsIGJsdXIsIG1hcmdpbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiKG51bGwsIHRoaXMuY3JlYXRlU2hhZG93UmVjdChzdGFnZSwgdywgaCwgcmFkaXVzLCBibHVyLCBtYXJnaW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGlkID0gJ3NoYWRvdycgKyBbdywgaCwgYmx1ciwgbWFyZ2luXS5jb25jYXQocmFkaXVzKS5qb2luKFwiLFwiKTtcbiAgICAgICAgcmV0dXJuIFRvb2xzLmdldENhbnZhc1RleHR1cmUoZmFjdG9yeSwgaWQpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTaGFkb3dSZWN0KHN0YWdlLCB3LCBoLCByYWRpdXMsIGJsdXIsIG1hcmdpbikge1xuICAgICAgICBsZXQgY2FudmFzID0gc3RhZ2UucGxhdGZvcm0uZ2V0RHJhd2luZ0NhbnZhcygpO1xuICAgICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHcgKyBtYXJnaW4gKiAyO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaCArIG1hcmdpbiAqIDI7XG5cbiAgICAgICAgLy8gV3BlV2ViS2l0IGJ1Zzogd2UgZXhwZXJpZW5jZWQgcHJvYmxlbXMgd2l0aG91dCB0aGlzIHdpdGggc2hhZG93cyBpbiBub25jb21wb3NpdGVkd2ViZ2wgbW9kZS5cbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC4wMTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIDAuMDEsIDAuMDEpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG5cbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKDB4RkZGRkZGRkYpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKDB4RkZGRkZGRkYpO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IGJsdXI7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gKHcgKyAxMCkgKyBtYXJnaW47XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gbWFyZ2luO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29uc3QgeCA9IC0odyArIDEwKTtcbiAgICAgICAgY29uc3QgeSA9IDA7XG5cbiAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcmFkaXVzWzBdLCB5KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgdyAtIHJhZGl1c1sxXSwgeSk7XG4gICAgICAgIGN0eC5hcmNUbyh4ICsgdywgeSwgeCArIHcsIHkgKyByYWRpdXNbMV0sIHJhZGl1c1sxXSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHcsIHkgKyBoIC0gcmFkaXVzWzJdKTtcbiAgICAgICAgY3R4LmFyY1RvKHggKyB3LCB5ICsgaCwgeCArIHcgLSByYWRpdXNbMl0sIHkgKyBoLCByYWRpdXNbMl0pO1xuICAgICAgICBjdHgubGluZVRvKHggKyByYWRpdXNbM10sIHkgKyBoKTtcbiAgICAgICAgY3R4LmFyY1RvKHgsIHkgKyBoLCB4LCB5ICsgaCAtIHJhZGl1c1szXSwgcmFkaXVzWzNdKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzWzBdKTtcbiAgICAgICAgY3R4LmFyY1RvKHgsIHksIHggKyByYWRpdXNbMF0sIHksIHJhZGl1c1swXSk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRTdmdUZXh0dXJlKHVybCwgdywgaCkge1xuICAgICAgICBsZXQgZmFjdG9yeSA9IChjYiwgc3RhZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc1NwYXJrKSB7XG4gICAgICAgICAgICAgICAgc3RhZ2UucGxhdGZvcm0uY3JlYXRlU3ZnKGNiLCBzdGFnZSwgdXJsLCB3LCBoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVTdmcoY2IsIHN0YWdlLCB1cmwsIHcsIGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgaWQgPSAnc3ZnJyArIFt3LCBoLCB1cmxdLmpvaW4oXCIsXCIpO1xuICAgICAgICByZXR1cm4gVG9vbHMuZ2V0Q2FudmFzVGV4dHVyZShmYWN0b3J5LCBpZCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVN2ZyhjYiwgc3RhZ2UsIHVybCwgdywgaCkge1xuICAgICAgICBsZXQgY2FudmFzID0gc3RhZ2UucGxhdGZvcm0uZ2V0RHJhd2luZ0NhbnZhcygpO1xuICAgICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIGxldCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHc7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgY2IobnVsbCwgY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICBpbWcub25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbiB0aGUgUFM0IHBsYXRmb3JtIHNldHRpbmcgdGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIG9uIGltYWdlc1xuICAgICAgICAvLyBjYW4gY2F1c2UgQ09SUyBmYWlsdXJlcy5cbiAgICAgICAgaWYgKCFVdGlscy5pc1BTNCkge1xuICAgICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5jbGFzcyBVdGlscyB7XG5cbiAgICBzdGF0aWMgaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAodmFsdWUgJSAxKSA9PT0gMCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc09iamVjdExpdGVyYWwodmFsdWUpe1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEFycmF5SW5kZXgoaW5kZXgsIGFycikge1xuICAgICAgICByZXR1cm4gVXRpbHMuZ2V0TW9kdWxvSW5kZXgoaW5kZXgsIGFyci5sZW5ndGgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBlcXVhbFZhbHVlcyh2MSwgdjIpIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgdjEpICE9PSAodHlwZW9mIHYyKSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwodjEpKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYyKSAmJiBVdGlscy5lcXVhbE9iamVjdExpdGVyYWxzKHYxLCB2MilcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYxKSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodjIpICYmIFV0aWxzLmVxdWFsQXJyYXlzKHYxLCB2MilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2MSA9PT0gdjJcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBlcXVhbE9iamVjdExpdGVyYWxzKG9iajEsIG9iajIpIHtcbiAgICAgICAgbGV0IGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG4gICAgICAgIGxldCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICAgICAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzMS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGsxID0ga2V5czFbaV07XG4gICAgICAgICAgICBjb25zdCBrMiA9IGtleXMyW2ldO1xuICAgICAgICAgICAgaWYgKGsxICE9PSBrMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2MSA9IG9iajFbazFdO1xuICAgICAgICAgICAgY29uc3QgdjIgPSBvYmoyW2syXTtcblxuICAgICAgICAgICAgaWYgKCFVdGlscy5lcXVhbFZhbHVlcyh2MSwgdjIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZXF1YWxBcnJheXModjEsIHYyKSB7XG4gICAgICAgIGlmICh2MS5sZW5ndGggIT09IHYyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB2MS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lcXVhbFZhbHVlcyh2MVtpXSwgdjJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxufVxuXG4vKipcbiAqIE1haW50YWlucyB0aGUgc3RhdGUgb2YgYSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKi9cbmNsYXNzIFdlYkdMU3RhdGUge1xuXG4gICAgY29uc3RydWN0b3IoaWQsIGdsKSB7XG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XG4gICAgICAgIHRoaXMuX3Byb2dyYW0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2ZyYW1lYnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyYnVmZmVycyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvLyBDb250YWlucyB2ZXJ0ZXggYXR0cmlidXRlIGRlZmluaXRpb24gYXJyYXlzIChlbmFibGVkLCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldCkuXG4gICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYnMgPSBuZXcgQXJyYXkoMTYpO1xuICAgICAgICB0aGlzLl9ub25EZWZhdWx0RmxhZ3MgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl90ZXh0dXJlcyA9IG5ldyBBcnJheSg4KTtcbiAgICAgICAgdGhpcy5fbWF4VGV4dHVyZSA9IDA7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVRleHR1cmUgPSBnbC5URVhUVVJFMDtcbiAgICAgICAgdGhpcy5fcGl4ZWxTdG9yZWkgPSBuZXcgQXJyYXkoNSk7XG4gICAgfVxuXG4gICAgX2dldERlZmF1bHRGbGFnKGNhcCkge1xuICAgICAgICByZXR1cm4gKGNhcCA9PT0gdGhpcy5fZ2wuRElUSEVSKTtcbiAgICB9XG5cbiAgICBzZXRGbGFnKGNhcCwgdikge1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9nZXREZWZhdWx0RmxhZyhjYXApO1xuICAgICAgICBpZiAodiA9PT0gZGVmKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9uRGVmYXVsdEZsYWdzLmRlbGV0ZShjYXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ub25EZWZhdWx0RmxhZ3MuaGFzKGNhcCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub25EZWZhdWx0RmxhZ3MuYWRkKGNhcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEJ1ZmZlcih0YXJnZXQsIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSB0aGlzLl9idWZmZXJzLmdldCh0YXJnZXQpICE9PSBidWZmZXI7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnMuc2V0KHRhcmdldCwgYnVmZmVyKTtcblxuICAgICAgICBpZiAoY2hhbmdlICYmICh0YXJnZXQgPT09IHRoaXMuX2dsLkFSUkFZX0JVRkZFUikpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGFycmF5IGJ1ZmZlciBpcyBjaGFuZ2VkIGFsbCBhdHRyaWJ1dGVzIGFyZSBjbGVhcmVkLlxuICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmlicyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG5cbiAgICBzZXRGcmFtZWJ1ZmZlcih0YXJnZXQsIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSB0aGlzLl9mcmFtZWJ1ZmZlcnMuZ2V0KHRhcmdldCkgIT09IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5fZnJhbWVidWZmZXJzLnNldCh0YXJnZXQsIGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuXG4gICAgc2V0UmVuZGVyYnVmZmVyKHRhcmdldCwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9IHRoaXMuX3JlbmRlcmJ1ZmZlcnMuZ2V0KHRhcmdldCkgIT09IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5fcmVuZGVyYnVmZmVycy5zZXQodGFyZ2V0LCBidWZmZXIpO1xuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cblxuICAgIHNldFByb2dyYW0ocHJvZ3JhbSkge1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSB0aGlzLl9wcm9ncmFtICE9PSBwcm9ncmFtO1xuICAgICAgICB0aGlzLl9wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZVxuICAgIH1cblxuICAgIHNldFNldHRpbmcoZnVuYywgdikge1xuICAgICAgICBjb25zdCBzID0gdGhpcy5fc2V0dGluZ3MuZ2V0KGZ1bmMpO1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSAhcyB8fCAhVXRpbHMuZXF1YWxWYWx1ZXMocywgdik7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzLnNldChmdW5jLCB2KTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZVxuICAgIH1cblxuICAgIGRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCkge1xuICAgICAgICBjb25zdCB2YSA9IHRoaXMuX3ZlcnRleEF0dHJpYnNbaW5kZXhdO1xuICAgICAgICBpZiAodmEgJiYgdmFbNV0pIHtcbiAgICAgICAgICAgIHZhWzVdID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgdmEgPSB0aGlzLl92ZXJ0ZXhBdHRyaWJzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhKSB7XG4gICAgICAgICAgICBpZiAoIXZhWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFbMF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmlic1tpbmRleF0gPSBbMCwgMCwgMCwgMCwgMCwgdHJ1ZV07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmVydGV4QXR0cmliUG9pbnRlcihpbmRleCwgcHJvcHMpIHtcbiAgICAgICAgbGV0IHZhID0gdGhpcy5fdmVydGV4QXR0cmlic1tpbmRleF07XG4gICAgICAgIGxldCBlcXVhbCA9IGZhbHNlO1xuICAgICAgICBpZiAodmEpIHtcbiAgICAgICAgICAgIGVxdWFsID0gdmFbMF0gPT09IHByb3BzWzBdICYmXG4gICAgICAgICAgICAgICAgdmFbMV0gPT09IHByb3BzWzFdICYmXG4gICAgICAgICAgICAgICAgdmFbMl0gPT09IHByb3BzWzJdICYmXG4gICAgICAgICAgICAgICAgdmFbM10gPT09IHByb3BzWzNdICYmXG4gICAgICAgICAgICAgICAgdmFbNF0gPT09IHByb3BzWzRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVxdWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wc1s1XSA9IHZhID8gdmFbNV0gOiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0QWN0aXZlVGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9hY3RpdmVUZXh0dXJlICE9PSB0ZXh0dXJlO1xuICAgICAgICB0aGlzLl9hY3RpdmVUZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuXG4gICAgYmluZFRleHR1cmUodGFyZ2V0LCB0ZXh0dXJlKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gV2ViR0xTdGF0ZS5fZ2V0VGV4dHVyZUluZGV4KHRoaXMuX2FjdGl2ZVRleHR1cmUpO1xuICAgICAgICB0aGlzLl9tYXhUZXh0dXJlID0gTWF0aC5tYXgodGhpcy5fbWF4VGV4dHVyZSwgYWN0aXZlSW5kZXggKyAxKTtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX3RleHR1cmVzW2FjdGl2ZUluZGV4XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXggPSBXZWJHTFN0YXRlLl9nZXRUZXh0dXJlVGFyZ2V0SW5kZXgodGFyZ2V0KTtcbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50W3RhcmdldEluZGV4XSA9PT0gdGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRbdGFyZ2V0SW5kZXhdID0gdGV4dHVyZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlc1thY3RpdmVJbmRleF0gPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlc1thY3RpdmVJbmRleF1bdGFyZ2V0SW5kZXhdID0gdGV4dHVyZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFBpeGVsU3RvcmVpKHBuYW1lLCBwYXJhbSkge1xuICAgICAgICBjb25zdCBpID0gV2ViR0xTdGF0ZS5fZ2V0UGl4ZWxTdG9yZWlJbmRleChwbmFtZSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9ICFVdGlscy5lcXVhbFZhbHVlcyh0aGlzLl9waXhlbFN0b3JlaVtpXSwgcGFyYW0pO1xuICAgICAgICB0aGlzLl9waXhlbFN0b3JlaVtpXSA9IHBhcmFtO1xuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cblxuICAgIG1pZ3JhdGUocykge1xuICAgICAgICBjb25zdCB0ID0gdGhpcztcblxuICAgICAgICAvLyBXYXJuaW5nOiBtaWdyYXRlIHNob3VsZCBjYWxsIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgbWV0aG9kcyBkaXJlY3RseS5cblxuICAgICAgICB0aGlzLl9taWdyYXRlRmxhZ3ModCwgcyk7XG5cbiAgICAgICAgLy8gdXNlUHJvZ3JhbVxuICAgICAgICBpZiAocy5fcHJvZ3JhbSAhPT0gdC5fcHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5fZ2wuX3VzZVByb2dyYW0ocy5fcHJvZ3JhbSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9taWdyYXRlRnJhbWVidWZmZXJzKHQsIHMpO1xuICAgICAgICB0aGlzLl9taWdyYXRlUmVuZGVyYnVmZmVycyh0LCBzKTtcblxuICAgICAgICBjb25zdCBidWZmZXJzQ2hhbmdlZCA9IHRoaXMuX21pZ3JhdGVCdWZmZXJzKHQsIHMpO1xuICAgICAgICB0aGlzLl9taWdyYXRlQXR0cmlidXRlcyh0LCBzLCBidWZmZXJzQ2hhbmdlZCk7XG5cbiAgICAgICAgdGhpcy5fbWlncmF0ZUZsYWdzKHQsIHMpO1xuXG4gICAgICAgIHRoaXMuX21pZ3JhdGVTZXR0aW5ncyh0LCBzKTtcblxuICAgICAgICB0aGlzLl9taWdyYXRlUGl4ZWxTdG9yZWkodCwgcyk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9taWdyYXRlVGV4dHVyZXModCwgcyk7XG4gICAgICAgIFxuICAgIH1cblxuICAgIF9taWdyYXRlUGl4ZWxTdG9yZWkodCwgcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHQuX3BpeGVsU3RvcmVpLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKHQuX3BpeGVsU3RvcmVpW2ldICE9PSBzLl9waXhlbFN0b3JlaVtpXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcy5fcGl4ZWxTdG9yZWlbaV0gIT09IHVuZGVmaW5lZCA/IHMuX3BpeGVsU3RvcmVpW2ldIDogV2ViR0xTdGF0ZS5fZ2V0RGVmYXVsdFBpeGVsU3RvcmVpQnlJbmRleChpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5fcGl4ZWxTdG9yZWkoV2ViR0xTdGF0ZS5fZ2V0UGl4ZWxTdG9yZWlCeUluZGV4KGkpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfbWlncmF0ZVRleHR1cmVzKHQsIHMpIHtcbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgodC5fbWF4VGV4dHVyZSwgcy5fbWF4VGV4dHVyZSk7XG5cbiAgICAgICAgbGV0IGFjdGl2ZVRleHR1cmUgPSB0Ll9hY3RpdmVUZXh0dXJlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNUYXJnZXRzID0gcy5fdGV4dHVyZXNbaV07XG4gICAgICAgICAgICBjb25zdCB0VGFyZ2V0cyA9IHQuX3RleHR1cmVzW2ldO1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZU51bWIgPSBXZWJHTFN0YXRlLl9nZXRUZXh0dXJlQnlJbmRleChpKTtcblxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0TWF4ID0gTWF0aC5tYXgodFRhcmdldHMgPyB0VGFyZ2V0cy5sZW5ndGggOiAwLCBzVGFyZ2V0cyA/IHNUYXJnZXRzLmxlbmd0aCA6IDApO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIG4gPSB0YXJnZXRNYXg7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBXZWJHTFN0YXRlLl9nZXRUZXh0dXJlVGFyZ2V0QnlJbmRleChqKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVGV4dHVyZSAhPT0gdGV4dHVyZU51bWIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2FjdGl2ZVRleHR1cmUodGV4dHVyZU51bWIpO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUZXh0dXJlID0gdGV4dHVyZU51bWI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IChzVGFyZ2V0cyAmJiBzVGFyZ2V0c1tqXSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5fYmluZFRleHR1cmUodGFyZ2V0LCB0ZXh0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzLl9hY3RpdmVUZXh0dXJlICE9PSBhY3RpdmVUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5fYWN0aXZlVGV4dHVyZShzLl9hY3RpdmVUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9taWdyYXRlQnVmZmVycyh0LCBzKSB7XG4gICAgICAgIHMuX2J1ZmZlcnMuZm9yRWFjaCgoZnJhbWVidWZmZXIsIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgaWYgKHQuX2J1ZmZlcnMuZ2V0KHRhcmdldCkgIT09IGZyYW1lYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2JpbmRCdWZmZXIodGFyZ2V0LCBmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHQuX2J1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyLCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBzLl9idWZmZXJzLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9iaW5kQnVmZmVyKHRhcmdldCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKHMuX2J1ZmZlcnMuZ2V0KHRoaXMuX2dsLkFSUkFZX0JVRkZFUikgIT09IHQuX2J1ZmZlcnMuZ2V0KHRoaXMuX2dsLkFSUkFZX0JVRkZFUikpXG4gICAgfVxuXG4gICAgX21pZ3JhdGVGcmFtZWJ1ZmZlcnModCwgcykge1xuICAgICAgICBzLl9mcmFtZWJ1ZmZlcnMuZm9yRWFjaCgoZnJhbWVidWZmZXIsIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgaWYgKHQuX2ZyYW1lYnVmZmVycy5nZXQodGFyZ2V0KSAhPT0gZnJhbWVidWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5fYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0Ll9mcmFtZWJ1ZmZlcnMuZm9yRWFjaCgoZnJhbWVidWZmZXIsIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmIgPSBzLl9mcmFtZWJ1ZmZlcnMuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICBpZiAoZmIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9iaW5kRnJhbWVidWZmZXIodGFyZ2V0LCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX21pZ3JhdGVSZW5kZXJidWZmZXJzKHQsIHMpIHtcbiAgICAgICAgcy5fcmVuZGVyYnVmZmVycy5mb3JFYWNoKChyZW5kZXJidWZmZXIsIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgaWYgKHQuX3JlbmRlcmJ1ZmZlcnMuZ2V0KHRhcmdldCkgIT09IHJlbmRlcmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9iaW5kUmVuZGVyYnVmZmVyKHRhcmdldCwgcmVuZGVyYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdC5fcmVuZGVyYnVmZmVycy5mb3JFYWNoKChyZW5kZXJidWZmZXIsIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmIgPSBzLl9yZW5kZXJidWZmZXJzLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKGZiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5fYmluZFJlbmRlcmJ1ZmZlcih0YXJnZXQsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfbWlncmF0ZUF0dHJpYnV0ZXModCwgcywgYnVmZmVyc0NoYW5nZWQpIHtcblxuICAgICAgICBpZiAoIWJ1ZmZlcnNDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0Ll92ZXJ0ZXhBdHRyaWJzLmZvckVhY2goKGF0dHJpYiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXMuX3ZlcnRleEF0dHJpYnNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0ICdkZWxldGUnIGEgdmVydGV4IGF0dHJpYiBzbyB3ZSdsbCBkaXNhYmxlIGl0LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbC5fZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcy5fdmVydGV4QXR0cmlicy5mb3JFYWNoKChhdHRyaWIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuX3ZlcnRleEF0dHJpYlBvaW50ZXIoaW5kZXgsIGF0dHJpYlswXSwgYXR0cmliWzFdLCBhdHRyaWJbMl0sIGF0dHJpYls0XSk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYls1XSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbC5fZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2hlbiBidWZmZXJzIGFyZSBjaGFuZ2VkLCBwcmV2aW91cyBhdHRyaWJ1dGVzIHdlcmUgcmVzZXQgYXV0b21hdGljYWxseS5cbiAgICAgICAgICAgIHMuX3ZlcnRleEF0dHJpYnMuZm9yRWFjaCgoYXR0cmliLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IHNldCB2ZXJ0ZXggYXR0cmliIHBvaW50ZXIgd2hlbiBpdCB3YXMganVzdCB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2wuX3ZlcnRleEF0dHJpYlBvaW50ZXIoaW5kZXgsIGF0dHJpYlswXSwgYXR0cmliWzFdLCBhdHRyaWJbMl0sIGF0dHJpYlszXSwgYXR0cmliWzRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYls1XSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbC5fZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX21pZ3JhdGVTZXR0aW5ncyh0LCBzKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRzID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXREZWZhdWx0U2V0dGluZ3MoKTtcbiAgICAgICAgdC5fc2V0dGluZ3MuZm9yRWFjaCgodmFsdWUsIGZ1bmMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBmdW5jLm5hbWUgfHwgZnVuYy54bmFtZTtcbiAgICAgICAgICAgIGlmICghcy5fc2V0dGluZ3MuaGFzKGZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFyZ3MgPSBkZWZhdWx0cy5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKFV0aWxzLmlzRnVuY3Rpb24oYXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3ModGhpcy5fZ2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgYWN0dWFsbHkgc2V0dGluZyB0aGUgc2V0dGluZyBmb3Igb3B0aW1pemF0aW9uIHB1cnBvc2VzLlxuICAgICAgICAgICAgICAgIHMuX3NldHRpbmdzLnNldChmdW5jLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMuX2dsLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHMuX3NldHRpbmdzLmZvckVhY2goKHZhbHVlLCBmdW5jKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0VmFsdWUgPSB0Ll9zZXR0aW5ncy5nZXQoZnVuYyk7XG4gICAgICAgICAgICBpZiAoIXRWYWx1ZSB8fCAhVXRpbHMuZXF1YWxWYWx1ZXModFZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMuX2dsLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9taWdyYXRlRmxhZ3ModCwgcykge1xuICAgICAgICB0Ll9ub25EZWZhdWx0RmxhZ3MuZm9yRWFjaChzZXR0aW5nID0+IHtcbiAgICAgICAgICAgIGlmICghcy5fbm9uRGVmYXVsdEZsYWdzLmhhcyhzZXR0aW5nKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9nZXREZWZhdWx0RmxhZyhzZXR0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbC5fZW5hYmxlKHNldHRpbmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9kaXNhYmxlKHNldHRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHMuX25vbkRlZmF1bHRGbGFncy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgICAgICAgaWYgKCF0Ll9ub25EZWZhdWx0RmxhZ3MuaGFzKHNldHRpbmcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dldERlZmF1bHRGbGFnKHNldHRpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9kaXNhYmxlKHNldHRpbmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9lbmFibGUoc2V0dGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdFNldHRpbmdzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RlZmF1bHRTZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFNldHRpbmdzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgY29uc3QgZCA9IHRoaXMuX2RlZmF1bHRTZXR0aW5ncztcbiAgICAgICAgICAgIGNvbnN0IGcgPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlO1xuICAgICAgICAgICAgZC5zZXQoXCJ2aWV3cG9ydFwiLCBmdW5jdGlvbihnbCkge3JldHVybiBbMCwwLGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodF19KTtcbiAgICAgICAgICAgIGQuc2V0KFwic2Npc3NvclwiLCBmdW5jdGlvbihnbCkge3JldHVybiBbMCwwLGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodF19KTtcbiAgICAgICAgICAgIGQuc2V0KFwiYmxlbmRDb2xvclwiLCBbMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgZC5zZXQoXCJibGVuZEVxdWF0aW9uXCIsIFtnLkZVTkNfQUREXSk7XG4gICAgICAgICAgICBkLnNldChcImJsZW5kRXF1YXRpb25TZXBhcmF0ZVwiLCBbZy5GVU5DX0FERCwgZy5GVU5DX0FERF0pO1xuICAgICAgICAgICAgZC5zZXQoXCJibGVuZEZ1bmNcIiwgW2cuT05FLCBnLlpFUk9dKTtcbiAgICAgICAgICAgIGQuc2V0KFwiYmxlbmRGdW5jU2VwYXJhdGVcIiwgW2cuT05FLCBnLlpFUk8sIGcuT05FLCBnLlpFUk9dKTtcbiAgICAgICAgICAgIGQuc2V0KFwiY2xlYXJDb2xvclwiLCBbMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgZC5zZXQoXCJjbGVhckRlcHRoXCIsIFsxXSk7XG4gICAgICAgICAgICBkLnNldChcImNsZWFyU3RlbmNpbFwiLCBbMF0pO1xuICAgICAgICAgICAgZC5zZXQoXCJjb2xvck1hc2tcIiwgW3RydWUsIHRydWUsIHRydWUsIHRydWVdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiY3VsbEZhY2VcIiwgW2cuQkFDS10pO1xuICAgICAgICAgICAgZC5zZXQoXCJkZXB0aEZ1bmNcIiwgW2cuTEVTU10pO1xuICAgICAgICAgICAgZC5zZXQoXCJkZXB0aE1hc2tcIiwgW3RydWVdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiZGVwdGhSYW5nZVwiLCBbMCwgMV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJmcm9udEZhY2VcIiwgW2cuQ0NXXSk7XG4gICAgICAgICAgICBkLnNldChcImxpbmVXaWR0aFwiLCBbMV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJwb2x5Z29uT2Zmc2V0XCIsIFswLCAwXSk7XG4gICAgICAgICAgICBkLnNldChcInNhbXBsZUNvdmVyYWdlXCIsIFsxLCBmYWxzZV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJzdGVuY2lsRnVuY1wiLCBbZy5BTFdBWVMsIDAsIDFdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiX3N0ZW5jaWxGdW5jU2VwYXJhdGVGcm9udFwiLCBbZy5BTFdBWVMsIDAsIDFdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiX3N0ZW5jaWxGdW5jU2VwYXJhdGVCYWNrXCIsIFtnLkFMV0FZUywgMCwgMV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJfc3RlbmNpbEZ1bmNTZXBhcmF0ZUZyb250QW5kQmFja1wiLCBbZy5BTFdBWVMsIDAsIDFdKTtcbiAgICAgICAgICAgIGQuc2V0KFwic3RlbmNpbE1hc2tcIiwgWzFdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiX3N0ZW5jaWxNYXNrU2VwYXJhdGVGcm9udFwiLCBbMV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJfc3RlbmNpbE1hc2tTZXBhcmF0ZUJhY2tcIiwgWzFdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiX3N0ZW5jaWxNYXNrU2VwYXJhdGVGcm9udEFuZEJhY2tcIiwgWzFdKTtcbiAgICAgICAgICAgIGQuc2V0KFwic3RlbmNpbE9wXCIsIFtnLktFRVAsIGcuS0VFUCwgZy5LRUVQXSk7XG4gICAgICAgICAgICBkLnNldChcIl9zdGVuY2lsT3BTZXBhcmF0ZUZyb250XCIsIFtnLktFRVAsIGcuS0VFUCwgZy5LRUVQXSk7XG4gICAgICAgICAgICBkLnNldChcIl9zdGVuY2lsT3BTZXBhcmF0ZUJhY2tcIiwgW2cuS0VFUCwgZy5LRUVQLCBnLktFRVBdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiX3N0ZW5jaWxPcFNlcGFyYXRlRnJvbnRBbmRCYWNrXCIsIFtnLktFRVAsIGcuS0VFUCwgZy5LRUVQXSk7XG4gICAgICAgICAgICBkLnNldChcInZlcnRleEF0dHJpYjFmXCIsIFtdKTtcbiAgICAgICAgICAgIGQuc2V0KFwidmVydGV4QXR0cmliMWZ2XCIsIFtdKTtcbiAgICAgICAgICAgIGQuc2V0KFwidmVydGV4QXR0cmliMmZcIiwgW10pO1xuICAgICAgICAgICAgZC5zZXQoXCJ2ZXJ0ZXhBdHRyaWIyZnZcIiwgW10pO1xuICAgICAgICAgICAgZC5zZXQoXCJ2ZXJ0ZXhBdHRyaWIzZlwiLCBbXSk7XG4gICAgICAgICAgICBkLnNldChcInZlcnRleEF0dHJpYjNmdlwiLCBbXSk7XG4gICAgICAgICAgICBkLnNldChcInZlcnRleEF0dHJpYjRmXCIsIFtdKTtcbiAgICAgICAgICAgIGQuc2V0KFwidmVydGV4QXR0cmliNGZ2XCIsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFNldHRpbmdzXG4gICAgfVxuXG4gICAgc3RhdGljIF9nZXRUZXh0dXJlVGFyZ2V0SW5kZXgodGFyZ2V0KSB7XG4gICAgICAgIHN3aXRjaCh0YXJnZXQpIHtcbiAgICAgICAgICAgIGNhc2UgMHgwREUxOlxuICAgICAgICAgICAgICAgIC8qIFRFWFRVUkVfMkQgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgMHg4NTEzOlxuICAgICAgICAgICAgICAgIC8qIFRFWFRVUkVfQ1VCRV9NQVAgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkbid0IGhhcHBlbi5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdGV4dHVyZSB0YXJnZXQ6ICcgKyB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIF9nZXRUZXh0dXJlVGFyZ2V0QnlJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmVUYXJnZXRJbmRpY2VzKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlVGFyZ2V0SW5kaWNlcyA9IFsweDBERTEsIDB4ODUxM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVUYXJnZXRJbmRpY2VzW2luZGV4XVxuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0VGV4dHVyZUluZGV4KGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCAtIDB4ODRDMCAvKiBHTF9URVhUVVJFMCAqLztcbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldFRleHR1cmVCeUluZGV4KGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCArIDB4ODRDMDtcbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldFBpeGVsU3RvcmVpSW5kZXgocG5hbWUpIHtcbiAgICAgICAgc3dpdGNoKHBuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIDB4MEQwNTpcbiAgICAgICAgICAgICAgICAvKiBQQUNLX0FMSUdOTUVOVCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgY2FzZSAweDBDRjU6XG4gICAgICAgICAgICAgICAgLyogVU5QQUNLX0FMSUdOTUVOVCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAweDkyNDA6XG4gICAgICAgICAgICAgICAgLyogVU5QQUNLX0ZMSVBfWV9XRUJHTCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgY2FzZSAweDkyNDE6XG4gICAgICAgICAgICAgICAgLyogVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICBjYXNlIDB4OTI0MzpcbiAgICAgICAgICAgICAgICAvKiBVTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgICAgICAgICAgLy9AdG9kbzogc3VwcG9ydCBXZWJHTDIgcHJvcGVydGllcywgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJHTFJlbmRlcmluZ0NvbnRleHQvcGl4ZWxTdG9yZWlcbiAgICAgICAgICAgIGNhc2UgMHg5MjQ1OlxuICAgICAgICAgICAgICAgIC8qIFVOUEFDS19GTElQX0JMVUVfUkVEICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFNob3VsZG4ndCBoYXBwZW4uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHBpeGVsc3RvcmVpOiAnICsgcG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIF9nZXRQaXhlbFN0b3JlaUJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9waXhlbFN0b3JlaUluZGljZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3BpeGVsU3RvcmVpSW5kaWNlcyA9IFsweDBEMDUsIDB4MENGNSwgMHg5MjQwLCAweDkyNDEsIDB4OTI0M107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BpeGVsU3RvcmVpSW5kaWNlc1tpbmRleF1cbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldERlZmF1bHRQaXhlbFN0b3JlaUJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9waXhlbFN0b3JlaURlZmF1bHRzKSB7XG4gICAgICAgICAgICB0aGlzLl9waXhlbFN0b3JlaURlZmF1bHRzID0gWzQsIDQsIGZhbHNlLCBmYWxzZSwgV2ViR0xSZW5kZXJpbmdDb250ZXh0LnByb3RvdHlwZS5CUk9XU0VSX0RFRkFVTFRfV0VCR0xdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9waXhlbFN0b3JlaURlZmF1bHRzW2luZGV4XVxuICAgIH1cbn1cblxuY2xhc3MgV2ViR0xTdGF0ZU1hbmFnZXIge1xuXG4gICAgX2luaXRTdGF0ZU1hbmFnZXIoaWQgPSBcImRlZmF1bHRcIikge1xuICAgICAgICB0aGlzLl9zdGF0ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpZCk7XG4gICAgfVxuXG4gICAgX2dldFN0YXRlKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhdGVzW2lkXSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVzW2lkXSA9IG5ldyBXZWJHTFN0YXRlKGlkLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVzW2lkXTtcbiAgICB9XG5cbiAgICBzd2l0Y2hTdGF0ZShpZCA9IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5faWQgIT09IGlkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGlkKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLm1pZ3JhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICR1c2VQcm9ncmFtKHByb2dyYW0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFByb2dyYW0ocHJvZ3JhbSkpXG4gICAgICAgICAgICB0aGlzLl91c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgIH1cblxuICAgICRiaW5kQnVmZmVyKHRhcmdldCwgZmIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldEJ1ZmZlcih0YXJnZXQsIGZiKSlcbiAgICAgICAgICAgIHRoaXMuX2JpbmRCdWZmZXIodGFyZ2V0LCBmYik7XG4gICAgfVxuXG4gICAgJGJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIGZiKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRGcmFtZWJ1ZmZlcih0YXJnZXQsIGZiKSlcbiAgICAgICAgICAgIHRoaXMuX2JpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIGZiKTtcbiAgICB9XG5cbiAgICAkYmluZFJlbmRlcmJ1ZmZlcih0YXJnZXQsIGZiKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRSZW5kZXJidWZmZXIodGFyZ2V0LCBmYikpXG4gICAgICAgICAgICB0aGlzLl9iaW5kUmVuZGVyYnVmZmVyKHRhcmdldCwgZmIpO1xuICAgIH1cblxuICAgICRlbmFibGUoY2FwKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRGbGFnKGNhcCwgdHJ1ZSkpXG4gICAgICAgICAgICB0aGlzLl9lbmFibGUoY2FwKTtcbiAgICB9XG5cbiAgICAkZGlzYWJsZShjYXApIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldEZsYWcoY2FwLCBmYWxzZSkpXG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlKGNhcCk7XG4gICAgfVxuXG4gICAgJHZpZXdwb3J0KHgsIHksIHcsIGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fdmlld3BvcnQsIFt4LCB5LCB3LCBoXSkpXG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydCh4LCB5LCB3LCBoKTtcbiAgICB9XG5cbiAgICAkc2Npc3Nvcih4LCB5LCB3LCBoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3NjaXNzb3IsIFt4LCB5LCB3LCBoXSkpXG4gICAgICAgICAgICB0aGlzLl9zY2lzc29yKHgsIHksIHcsIGgpO1xuICAgIH1cblxuICAgICRkaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCkpXG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgIH1cblxuICAgICRlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpKVxuICAgICAgICAgICAgdGhpcy5fZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgIH1cblxuICAgICR2ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4LCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUudmVydGV4QXR0cmliUG9pbnRlcihpbmRleCwgW3NpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgb2Zmc2V0XSkpXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4LCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgJGFjdGl2ZVRleHR1cmUodGV4dHVyZSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0QWN0aXZlVGV4dHVyZSh0ZXh0dXJlKSlcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgfVxuXG4gICAgJGJpbmRUZXh0dXJlKHRhcmdldCwgdGV4dHVyZSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXh0dXJlKSlcbiAgICAgICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlKHRhcmdldCwgdGV4dHVyZSk7XG4gICAgfVxuXG4gICAgJHBpeGVsU3RvcmVpKHBuYW1lLCBwYXJhbSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0UGl4ZWxTdG9yZWkocG5hbWUsIHBhcmFtKSkge1xuICAgICAgICAgICAgdGhpcy5fcGl4ZWxTdG9yZWkocG5hbWUsIHBhcmFtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICRzdGVuY2lsRnVuY1NlcGFyYXRlKGZhY2UsIGZ1bmMsIHJlZiwgbWFzaykge1xuICAgICAgICBsZXQgZjtcbiAgICAgICAgc3dpdGNoKGZhY2UpIHtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5GUk9OVDpcbiAgICAgICAgICAgICAgICBmID0gdGhpcy5fc3RlbmNpbEZ1bmNTZXBhcmF0ZUZyb250O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aGlzLkJBQ0s6XG4gICAgICAgICAgICAgICAgZiA9IHRoaXMuX3N0ZW5jaWxGdW5jU2VwYXJhdGVCYWNrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aGlzLkZST05UX0FORF9CQUNLOlxuICAgICAgICAgICAgICAgIGYgPSB0aGlzLl9zdGVuY2lsRnVuY1NlcGFyYXRlRnJvbnRBbmRCYWNrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcoZiwgW2Z1bmMsIHJlZiwgbWFza10pKVxuICAgICAgICAgICAgZi5hcHBseSh0aGlzLCBbZnVuYywgcmVmLCBtYXNrXSk7XG4gICAgfVxuXG4gICAgX3N0ZW5jaWxGdW5jU2VwYXJhdGVGcm9udChmdW5jLCByZWYsIG1hc2spIHtcbiAgICAgICAgdGhpcy5fc3RlbmNpbEZ1bmNTZXBhcmF0ZSh0aGlzLkZST05ULCBmdW5jLCByZWYsIG1hc2spO1xuICAgIH1cblxuICAgIF9zdGVuY2lsRnVuY1NlcGFyYXRlQmFjayhmdW5jLCByZWYsIG1hc2spIHtcbiAgICAgICAgdGhpcy5fc3RlbmNpbEZ1bmNTZXBhcmF0ZSh0aGlzLkJBQ0ssIGZ1bmMsIHJlZiwgbWFzayk7XG4gICAgfVxuXG4gICAgX3N0ZW5jaWxGdW5jU2VwYXJhdGVGcm9udEFuZEJhY2soZnVuYywgcmVmLCBtYXNrKSB7XG4gICAgICAgIHRoaXMuX3N0ZW5jaWxGdW5jU2VwYXJhdGUodGhpcy5GUk9OVF9BTkRfQkFDSywgZnVuYywgcmVmLCBtYXNrKTtcbiAgICB9XG5cbiAgICAkc3RlbmNpbE1hc2tTZXBhcmF0ZShmYWNlLCBtYXNrKSB7XG4gICAgICAgIGxldCBmO1xuICAgICAgICBzd2l0Y2goZmFjZSkge1xuICAgICAgICAgICAgY2FzZSB0aGlzLkZST05UOlxuICAgICAgICAgICAgICAgIGYgPSB0aGlzLl9zdGVuY2lsTWFza1NlcGFyYXRlRnJvbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuQkFDSzpcbiAgICAgICAgICAgICAgICBmID0gdGhpcy5fc3RlbmNpbE1hc2tTZXBhcmF0ZUJhY2s7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuRlJPTlRfQU5EX0JBQ0s6XG4gICAgICAgICAgICAgICAgZiA9IHRoaXMuX3N0ZW5jaWxNYXNrU2VwYXJhdGVGcm9udEFuZEJhY2s7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyhmLCBbbWFza10pKVxuICAgICAgICAgICAgZi5hcHBseSh0aGlzLCBbbWFza10pO1xuICAgIH1cblxuICAgIF9zdGVuY2lsTWFza1NlcGFyYXRlRnJvbnQobWFzaykge1xuICAgICAgICB0aGlzLl9zdGVuY2lsTWFza1NlcGFyYXRlKHRoaXMuRlJPTlQsIG1hc2spO1xuICAgIH1cblxuICAgIF9zdGVuY2lsTWFza1NlcGFyYXRlQmFjayhtYXNrKSB7XG4gICAgICAgIHRoaXMuX3N0ZW5jaWxNYXNrU2VwYXJhdGUodGhpcy5CQUNLLCBtYXNrKTtcbiAgICB9XG5cbiAgICBfc3RlbmNpbE1hc2tTZXBhcmF0ZUZyb250QW5kQmFjayhtYXNrKSB7XG4gICAgICAgIHRoaXMuX3N0ZW5jaWxNYXNrU2VwYXJhdGUodGhpcy5GUk9OVF9BTkRfQkFDSywgbWFzayk7XG4gICAgfVxuXG4gICAgJHN0ZW5jaWxPcFNlcGFyYXRlKGZhY2UsIGZhaWwsIHpmYWlsLCB6cGFzcykge1xuICAgICAgICBsZXQgZjtcbiAgICAgICAgc3dpdGNoKGZhY2UpIHtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5GUk9OVDpcbiAgICAgICAgICAgICAgICBmID0gdGhpcy5fc3RlbmNpbE9wU2VwYXJhdGVGcm9udDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5CQUNLOlxuICAgICAgICAgICAgICAgIGYgPSB0aGlzLl9zdGVuY2lsT3BTZXBhcmF0ZUJhY2s7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuRlJPTlRfQU5EX0JBQ0s6XG4gICAgICAgICAgICAgICAgZiA9IHRoaXMuX3N0ZW5jaWxPcFNlcGFyYXRlRnJvbnRBbmRCYWNrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcoZiwgW2ZhaWwsIHpmYWlsLCB6cGFzc10pKVxuICAgICAgICAgICAgZi5hcHBseSh0aGlzLCBbZmFpbCwgemZhaWwsIHpwYXNzXSk7XG4gICAgfVxuXG4gICAgX3N0ZW5jaWxPcFNlcGFyYXRlRnJvbnQoZmFpbCwgemZhaWwsIHpwYXNzKSB7XG4gICAgICAgIHRoaXMuX3N0ZW5jaWxPcFNlcGFyYXRlKHRoaXMuRlJPTlQsIGZhaWwsIHpmYWlsLCB6cGFzcyk7XG4gICAgfVxuXG4gICAgX3N0ZW5jaWxPcFNlcGFyYXRlQmFjayhmYWlsLCB6ZmFpbCwgenBhc3MpIHtcbiAgICAgICAgdGhpcy5fc3RlbmNpbE9wU2VwYXJhdGUodGhpcy5CQUNLLCBmYWlsLCB6ZmFpbCwgenBhc3MpO1xuICAgIH1cblxuICAgIF9zdGVuY2lsT3BTZXBhcmF0ZUZyb250QW5kQmFjayhmYWlsLCB6ZmFpbCwgenBhc3MpIHtcbiAgICAgICAgdGhpcy5fc3RlbmNpbE9wU2VwYXJhdGUodGhpcy5GUk9OVF9BTkRfQkFDSywgZmFpbCwgemZhaWwsIHpwYXNzKTtcbiAgICB9XG5cbiAgICAkYmxlbmRDb2xvcihyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9ibGVuZENvbG9yLCBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdKSlcbiAgICAgICAgICAgIHRoaXMuX2JsZW5kQ29sb3IocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpO1xuICAgIH1cblxuICAgICRibGVuZEVxdWF0aW9uKG1vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fYmxlbmRFcXVhdGlvbiwgW21vZGVdKSlcbiAgICAgICAgICAgIHRoaXMuX2JsZW5kRXF1YXRpb24obW9kZSk7XG4gICAgfVxuXG4gICAgJGJsZW5kRXF1YXRpb25TZXBhcmF0ZShtb2RlUkdCLCBtb2RlQWxwaGEpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fYmxlbmRFcXVhdGlvblNlcGFyYXRlLCBbbW9kZVJHQiwgbW9kZUFscGhhXSkpXG4gICAgICAgICAgICB0aGlzLl9ibGVuZEVxdWF0aW9uU2VwYXJhdGUobW9kZVJHQiwgbW9kZUFscGhhKTtcbiAgICB9XG5cbiAgICAkYmxlbmRGdW5jKHNmYWN0b3IsIGRmYWN0b3IpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fYmxlbmRGdW5jLCBbc2ZhY3RvciwgZGZhY3Rvcl0pKVxuICAgICAgICAgICAgdGhpcy5fYmxlbmRGdW5jKHNmYWN0b3IsIGRmYWN0b3IpO1xuICAgIH1cblxuICAgICRibGVuZEZ1bmNTZXBhcmF0ZShzcmNSR0IsIGRzdFJHQiwgc3JjQWxwaGEsIGRzdEFscGhhKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2JsZW5kRnVuY1NlcGFyYXRlLCBbc3JjUkdCLCBkc3RSR0IsIHNyY0FscGhhLCBkc3RBbHBoYV0pKVxuICAgICAgICAgICAgdGhpcy5fYmxlbmRGdW5jU2VwYXJhdGUoc3JjUkdCLCBkc3RSR0IsIHNyY0FscGhhLCBkc3RBbHBoYSk7XG4gICAgfVxuXG4gICAgJGNsZWFyQ29sb3IocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fY2xlYXJDb2xvciwgW3JlZCwgZ3JlZW4sIGJsdWUsIGFscGhhXSkpXG4gICAgICAgICAgICB0aGlzLl9jbGVhckNvbG9yKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKTtcbiAgICB9XG5cbiAgICAkY2xlYXJEZXB0aChkZXB0aCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9jbGVhckRlcHRoLCBbZGVwdGhdKSlcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyRGVwdGgoZGVwdGgpO1xuICAgIH1cblxuICAgICRjbGVhclN0ZW5jaWwocykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9jbGVhclN0ZW5jaWwsIFtzXSkpXG4gICAgICAgICAgICB0aGlzLl9jbGVhclN0ZW5jaWwocyk7XG4gICAgfVxuXG4gICAgJGNvbG9yTWFzayhyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9jb2xvck1hc2ssIFtyZWQsIGdyZWVuLCBibHVlLCBhbHBoYV0pKVxuICAgICAgICAgICAgdGhpcy5fY29sb3JNYXNrKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKTtcbiAgICB9XG5cbiAgICAkY3VsbEZhY2UobW9kZSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9jdWxsRmFjZSwgW21vZGVdKSlcbiAgICAgICAgICAgIHRoaXMuX2N1bGxGYWNlKG1vZGUpO1xuICAgIH1cblxuICAgICRkZXB0aEZ1bmMoZnVuYykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9kZXB0aEZ1bmMsIFtmdW5jXSkpXG4gICAgICAgICAgICB0aGlzLl9kZXB0aEZ1bmMoZnVuYyk7XG4gICAgfVxuXG4gICAgJGRlcHRoTWFzayhmbGFnKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2RlcHRoTWFzaywgW2ZsYWddKSlcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoTWFzayhmbGFnKTtcbiAgICB9XG5cbiAgICAkZGVwdGhSYW5nZSh6TmVhciwgekZhcikge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9kZXB0aFJhbmdlLCBbek5lYXIsIHpGYXJdKSlcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoUmFuZ2Uoek5lYXIsIHpGYXIpO1xuICAgIH1cblxuICAgICRmcm9udEZhY2UobW9kZSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9mcm9udEZhY2UsIFttb2RlXSkpXG4gICAgICAgICAgICB0aGlzLl9mcm9udEZhY2UobW9kZSk7XG4gICAgfVxuXG4gICAgJGxpbmVXaWR0aCh3aWR0aCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9saW5lV2lkdGgsIFt3aWR0aF0pKVxuICAgICAgICAgICAgdGhpcy5fbGluZVdpZHRoKHdpZHRoKTtcbiAgICB9XG5cbiAgICAkcG9seWdvbk9mZnNldChmYWN0b3IsIHVuaXRzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3BvbHlnb25PZmZzZXQsIFtmYWN0b3IsIHVuaXRzXSkpXG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29uT2Zmc2V0KGZhY3RvciwgdW5pdHMpO1xuICAgIH1cblxuICAgICRzYW1wbGVDb3ZlcmFnZSh2YWx1ZSwgaW52ZXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3NhbXBsZUNvdmVyYWdlLCBbdmFsdWUsIGludmVydF0pKVxuICAgICAgICAgICAgdGhpcy5fc2FtcGxlQ292ZXJhZ2UodmFsdWUsIGludmVydCk7XG4gICAgfVxuXG4gICAgJHN0ZW5jaWxGdW5jKGZ1bmMsIHJlZiwgbWFzaykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9zdGVuY2lsRnVuYywgW2Z1bmMsIHJlZiwgbWFza10pKVxuICAgICAgICAgICAgdGhpcy5fc3RlbmNpbEZ1bmMoZnVuYywgcmVmLCBtYXNrKTtcbiAgICB9XG5cbiAgICAkc3RlbmNpbE1hc2sobWFzaykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9zdGVuY2lsTWFzaywgW21hc2tdKSlcbiAgICAgICAgICAgIHRoaXMuX3N0ZW5jaWxNYXNrKG1hc2spO1xuICAgIH1cblxuICAgICRzdGVuY2lsT3AoZmFpbCwgemZhaWwsIHpwYXNzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3N0ZW5jaWxPcCwgW2ZhaWwsIHpmYWlsLCB6cGFzc10pKVxuICAgICAgICAgICAgdGhpcy5fc3RlbmNpbE9wKGZhaWwsIHpmYWlsLCB6cGFzcyk7XG4gICAgfVxuXG4gICAgJHZlcnRleEF0dHJpYjFmKGluZHgsIHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fdmVydGV4QXR0cmliMWYsIFtpbmR4LCB4XSkpXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWIxZihpbmR4LCB4KTtcbiAgICB9XG5cbiAgICAkdmVydGV4QXR0cmliMWZ2KGluZHgsIHZhbHVlcykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl92ZXJ0ZXhBdHRyaWIxZnYsIFtpbmR4LCB2YWx1ZXNdKSlcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYjFmdihpbmR4LCB2YWx1ZXMpO1xuICAgIH1cblxuICAgICR2ZXJ0ZXhBdHRyaWIyZihpbmR4LCB4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3ZlcnRleEF0dHJpYjJmLCBbaW5keCwgeCwgeV0pKVxuICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmliMmYoaW5keCwgeCwgeSk7XG4gICAgfVxuXG4gICAgJHZlcnRleEF0dHJpYjJmdihpbmR4LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fdmVydGV4QXR0cmliMmZ2LCBbaW5keCwgdmFsdWVzXSkpXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWIyZnYoaW5keCwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAkdmVydGV4QXR0cmliM2YoaW5keCwgeCwgeSwgeikge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl92ZXJ0ZXhBdHRyaWIzZiwgW2luZHgsIHgsIHksIHpdKSlcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYjNmKGluZHgsIHgsIHksIHopO1xuICAgIH1cblxuICAgICR2ZXJ0ZXhBdHRyaWIzZnYoaW5keCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3ZlcnRleEF0dHJpYjNmdiwgW2luZHgsIHZhbHVlc10pKVxuICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmliM2Z2KGluZHgsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgJHZlcnRleEF0dHJpYjRmKGluZHgsIHgsIHksIHosIHcpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fdmVydGV4QXR0cmliNGYsIFtpbmR4LCB4LCB5LCB6LCB3XSkpXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWI0ZihpbmR4LCB4LCB5LCB6LCB3KTtcbiAgICB9XG5cbiAgICAkdmVydGV4QXR0cmliNGZ2KGluZHgsIHZhbHVlcykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl92ZXJ0ZXhBdHRyaWI0ZnYsIFtpbmR4LCB2YWx1ZXNdKSlcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYjRmdihpbmR4LCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciBjb250ZXh0IHNoYXJpbmcuXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICovXG4gICAgc3RhdGljIGVuYWJsZShnbCwgaWQgPSBcImRlZmF1bHRcIikge1xuICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFdlYkdMU3RhdGVNYW5hZ2VyLnByb3RvdHlwZSk7XG4gICAgICAgIGNvbnN0IFdlYkdMUmVuZGVyaW5nQ29udGV4dFByb3RvID0gZ2wuX19wcm90b19fO1xuICAgICAgICBuYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IFdlYkdMU3RhdGVNYW5hZ2VyLnByb3RvdHlwZVtuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwiJFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdsW25hbWVdICE9PSBtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdsW25hbWVdLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIGZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIENocm9tZSBXZWJHTCBJbnNwZWN0b3IgcGx1Z2luLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsW25hbWVdLnhuYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsWydfJyArIG5hbWVdID0gZ2xbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2xbbmFtZV0gPSBtZXRob2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBXZWJHTFN0YXRlTWFuYWdlci5wcm90b3R5cGUuX2luaXRTdGF0ZU1hbmFnZXIuY2FsbChnbCwgaWQpO1xuXG4gICAgICAgIHJldHVybiBnbDtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgV2ViR0xTdGF0ZU1hbmFnZXI7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlIHtcblxuICAgIHN0YXRpYyBkZWZhdWx0U2V0dGVyKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgb2JqW25hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhdGNoT2JqZWN0KG9iaiwgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKCFVdGlscy5pc09iamVjdExpdGVyYWwoc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW0xpZ2h0bmluZ10gU2V0dGluZ3MgbXVzdCBiZSBvYmplY3QgbGl0ZXJhbFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuYW1lcyA9IE9iamVjdC5rZXlzKHNldHRpbmdzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbmFtZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBuYW1lc1tpXTtcblxuICAgICAgICAgICAgICAgIHRoaXMucGF0Y2hPYmplY3RQcm9wZXJ0eShvYmosIG5hbWUsIHNldHRpbmdzW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBwYXRjaE9iamVjdFByb3BlcnR5KG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHNldHRlciA9IG9iai5zZXRTZXR0aW5nIHx8IEJhc2UuZGVmYXVsdFNldHRlcjtcblxuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwiX1wiKSB7XG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBwYXRjaGluZyBwcml2YXRlIHZhcmlhYmxlcy5cbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBcIl9fY3JlYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW0xpZ2h0bmluZ10gUGF0Y2ggb2YgcHJpdmF0ZSBwcm9wZXJ0eSAnXCIgKyBuYW1lICsgXCInIGlzIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgIT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgICAvLyBUeXBlIGlzIGEgcmVzZXJ2ZWQga2V5d29yZCB0byBzcGVjaWZ5IHRoZSBjbGFzcyB0eXBlIG9uIGNyZWF0aW9uLlxuICAgICAgICAgICAgaWYgKFV0aWxzLmlzRnVuY3Rpb24odmFsdWUpICYmIHZhbHVlLl9fbG9jYWwpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2NhbCBmdW5jdGlvbiAoQmFzZS5sb2NhbChzID0+IHMuc29tZXRoaW5nKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLl9fbG9jYWwob2JqKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0dGVyKG9iaiwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGxvY2FsKGZ1bmMpIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCBhcyBhbiBvYmplY3Qgc2V0dGluZywgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICAgIGZ1bmMuX19sb2NhbCA9IHRydWU7XG4gICAgfVxuXG5cbn1cblxuaW1wb3J0IFV0aWxzIGZyb20gXCIuL1V0aWxzLm1qc1wiO1xuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFJlbmRlciB0cmVlIG5vZGUuXG4gKi9cblxuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4vU3RhZ2VVdGlscy5tanNcIjtcbmltcG9ydCBFbGVtZW50Q29yZSBmcm9tIFwiLi9jb3JlL0VsZW1lbnRDb3JlLm1qc1wiO1xuaW1wb3J0IEJhc2UgZnJvbSBcIi4vQmFzZS5tanNcIjtcblxuaW1wb3J0IFV0aWxzIGZyb20gXCIuL1V0aWxzLm1qc1wiO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiLi4vRXZlbnRFbWl0dGVyLm1qc1wiO1xuaW1wb3J0IFNoYWRlciBmcm9tIFwiLi9TaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnQge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuXG4gICAgICAgIHRoaXMuX19pZCA9IEVsZW1lbnQuaWQrKztcblxuICAgICAgICB0aGlzLl9fc3RhcnQoKTtcblxuICAgICAgICAvLyBFdmVudEVtaXR0ZXIgY29uc3RydWN0b3IuXG4gICAgICAgIHRoaXMuX2hhc0V2ZW50TGlzdGVuZXJzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fX2NvcmUgPSBuZXcgRWxlbWVudENvcmUodGhpcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRoYXQgY2FuIGJlIHVzZWQgd2hpbGUgbWVyZ2luZyB0cmVlcy5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX19yZWYgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBlbGVtZW50IGlzIGF0dGFjaGVkIGlmIGl0IGlzIGEgZGVzY2VuZGFudCBvZiB0aGUgc3RhZ2Ugcm9vdC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fYXR0YWNoZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZWxlbWVudCBpcyBlbmFibGVkIHdoZW4gaXQgaXMgYXR0YWNoZWQgYW5kIGl0IGlzIHZpc2libGUgKHdvcmxkQWxwaGEgPiAwKS5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBlbGVtZW50IGlzIGFjdGl2ZSB3aGVuIGl0IGlzIGVuYWJsZWQgYW5kIGl0IGlzIHdpdGhpbiBib3VuZHMuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX2FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX19wYXJlbnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dHVyZSB0aGF0IGlzIGN1cnJlbnRseSBzZXQuXG4gICAgICAgICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX3RleHR1cmUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IGRpc3BsYXllZCB0ZXh0dXJlLiBXaGlsZSB0aGlzLnRleHR1cmUgaXMgbG9hZGluZywgdGhpcyBvbmUgbWF5IGJlIGRpZmZlcmVudC5cbiAgICAgICAgICogQHR5cGUge1RleHR1cmV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fZGlzcGxheWVkVGV4dHVyZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRhZ3MgdGhhdCBjYW4gYmUgdXNlZCB0byBpZGVudGlmeS9zZWFyY2ggZm9yIGEgc3BlY2lmaWMgZWxlbWVudC5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ1tdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX3RhZ3MgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHJlZSdzIHRhZ3MgbWFwcGluZy5cbiAgICAgICAgICogVGhpcyBjb250YWlucyBhbGwgZWxlbWVudHMgZm9yIGFsbCBrbm93biB0YWdzLCBhdCBhbGwgdGltZXMuXG4gICAgICAgICAqIEB0eXBlIHtNYXB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fdHJlZVRhZ3MgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgdGFnIGNvbnRleHQ6IHRhZ2dlZCBlbGVtZW50cyBpbiB0aGlzIGJyYW5jaCB3aWxsIG5vdCBiZSByZWFjaGFibGUgZnJvbSBhbmNlc3RvcnMgb2YgdGhpcyBlbGVtZW50cy5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fdGFnUm9vdCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAoTGF6eS1pbml0aWFsaXNlZCkgbGlzdCBvZiBjaGlsZHJlbiBvd25lZCBieSB0aGlzIGVsZW1lbnRzLlxuICAgICAgICAgKiBAdHlwZSB7RWxlbWVudENoaWxkTGlzdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX19jaGlsZExpc3QgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3cgPSAwO1xuXG4gICAgICAgIHRoaXMuX2ggPSAwO1xuICAgIH1cblxuICAgIF9fc3RhcnQoKSB7XG4gICAgfVxuXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2lkO1xuICAgIH1cblxuICAgIHNldCByZWYocmVmKSB7XG4gICAgICAgIGlmICh0aGlzLl9fcmVmICE9PSByZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJjb2RlID0gcmVmLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoIVV0aWxzLmlzVWNDaGFyKGNoYXJjb2RlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJSZWYgbXVzdCBzdGFydCB3aXRoIGFuIHVwcGVyIGNhc2UgY2hhcmFjdGVyOiBcIiArIHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fX3JlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGFnKHRoaXMuX19yZWYpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19wYXJlbnQuX19jaGlsZExpc3QuY2xlYXJSZWYodGhpcy5fX3JlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9fcmVmID0gcmVmO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3JlZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRhZyh0aGlzLl9fcmVmKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcGFyZW50Ll9fY2hpbGRMaXN0LnNldFJlZih0aGlzLl9fcmVmLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3JlZjtcbiAgICB9XG5cbiAgICBnZXQgY29yZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlO1xuICAgIH1cblxuICAgIHNldEFzUm9vdCgpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuc2V0QXNSb290KCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUF0dGFjaGVkRmxhZygpO1xuICAgICAgICB0aGlzLl91cGRhdGVFbmFibGVkRmxhZygpO1xuICAgIH1cblxuICAgIGdldCBpc1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5pc1Jvb3Q7XG4gICAgfVxuXG4gICAgX3NldFBhcmVudChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX19wYXJlbnQgPT09IHBhcmVudCkgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aGlzLl9fcGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl91bnNldFRhZ3NQYXJlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0VGFnc1BhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlQXR0YWNoZWRGbGFnKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUVuYWJsZWRGbGFnKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbGxpc2lvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzUm9vdCAmJiBwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJSb290IHNob3VsZCBub3QgYmUgYWRkZWQgYXMgYSBjaGlsZCEgUmVzdWx0cyBhcmUgdW5zcGVjaWZpZWQhXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGdldERlcHRoKCkge1xuICAgICAgICBsZXQgZGVwdGggPSAwO1xuXG4gICAgICAgIGxldCBwID0gdGhpcy5fX3BhcmVudDtcbiAgICAgICAgd2hpbGUocCkge1xuICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIHAgPSBwLl9fcGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgIH07XG5cbiAgICBnZXRBbmNlc3RvcihsKSB7XG4gICAgICAgIGxldCBwID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGwgPiAwICYmIHAuX19wYXJlbnQpIHtcbiAgICAgICAgICAgIHAgPSBwLl9fcGFyZW50O1xuICAgICAgICAgICAgbC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICBnZXRBbmNlc3RvcnMoKSB7XG4gICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgYS5wdXNoKHApO1xuICAgICAgICAgICAgcCA9IHAuX19wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZ2V0QW5jZXN0b3JBdERlcHRoKGRlcHRoKSB7XG4gICAgICAgIGxldCBsZXZlbHMgPSB0aGlzLmdldERlcHRoKCkgLSBkZXB0aDtcbiAgICAgICAgaWYgKGxldmVscyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFuY2VzdG9yKGxldmVscyk7XG4gICAgfTtcblxuICAgIGlzQW5jZXN0b3JPZihjKSB7XG4gICAgICAgIGxldCBwID0gYztcbiAgICAgICAgd2hpbGUocCA9IHAucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcyA9PT0gcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgZ2V0U2hhcmVkQW5jZXN0b3IoYykge1xuICAgICAgICBsZXQgbzEgPSB0aGlzO1xuICAgICAgICBsZXQgbzIgPSBjO1xuICAgICAgICBsZXQgbDEgPSBvMS5nZXREZXB0aCgpO1xuICAgICAgICBsZXQgbDIgPSBvMi5nZXREZXB0aCgpO1xuICAgICAgICBpZiAobDEgPiBsMikge1xuICAgICAgICAgICAgbzEgPSBvMS5nZXRBbmNlc3RvcihsMSAtIGwyKTtcbiAgICAgICAgfSBlbHNlIGlmIChsMiA+IGwxKSB7XG4gICAgICAgICAgICBvMiA9IG8yLmdldEFuY2VzdG9yKGwyIC0gbDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKG8xID09PSBvMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbzEgPSBvMS5fX3BhcmVudDtcbiAgICAgICAgICAgIG8yID0gbzIuX19wYXJlbnQ7XG4gICAgICAgIH0gd2hpbGUgKG8xICYmIG8yKTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgZ2V0IGF0dGFjaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2F0dGFjaGVkO1xuICAgIH1cblxuICAgIGdldCBlbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2VuYWJsZWQ7XG4gICAgfVxuXG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19hY3RpdmU7XG4gICAgfVxuXG4gICAgX2lzQXR0YWNoZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fX3BhcmVudCA/IHRoaXMuX19wYXJlbnQuX19hdHRhY2hlZCA6ICh0aGlzLnN0YWdlLnJvb3QgPT09IHRoaXMpKTtcbiAgICB9O1xuXG4gICAgX2lzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLnZpc2libGUgJiYgKHRoaXMuX19jb3JlLmFscGhhID4gMCkgJiYgKHRoaXMuX19wYXJlbnQgPyB0aGlzLl9fcGFyZW50Ll9fZW5hYmxlZCA6ICh0aGlzLnN0YWdlLnJvb3QgPT09IHRoaXMpKTtcbiAgICB9O1xuXG4gICAgX2lzQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNFbmFibGVkKCkgJiYgdGhpcy53aXRoaW5Cb3VuZHNNYXJnaW47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlICdhdHRhY2hlZCcgZmxhZyBmb3IgdGhpcyBicmFuY2guXG4gICAgICovXG4gICAgX3VwZGF0ZUF0dGFjaGVkRmxhZygpIHtcbiAgICAgICAgbGV0IG5ld0F0dGFjaGVkID0gdGhpcy5faXNBdHRhY2hlZCgpO1xuICAgICAgICBpZiAodGhpcy5fX2F0dGFjaGVkICE9PSBuZXdBdHRhY2hlZCkge1xuICAgICAgICAgICAgdGhpcy5fX2F0dGFjaGVkID0gbmV3QXR0YWNoZWQ7XG5cbiAgICAgICAgICAgIGlmIChuZXdBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU2V0dXAoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4uZ2V0KCk7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgbSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLl91cGRhdGVBdHRhY2hlZEZsYWcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5ld0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25BdHRhY2goKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25EZXRhY2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSAnZW5hYmxlZCcgZmxhZyBmb3IgdGhpcyBicmFuY2guXG4gICAgICovXG4gICAgX3VwZGF0ZUVuYWJsZWRGbGFnKCkge1xuICAgICAgICBsZXQgbmV3RW5hYmxlZCA9IHRoaXMuX2lzRW5hYmxlZCgpO1xuICAgICAgICBpZiAodGhpcy5fX2VuYWJsZWQgIT09IG5ld0VuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChuZXdFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25FbmFibGVkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RW5hYmxlZEZsYWcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25EaXNhYmxlZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vuc2V0RW5hYmxlZEZsYWcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4uZ2V0KCk7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgbSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLl91cGRhdGVFbmFibGVkRmxhZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIF9zZXRFbmFibGVkRmxhZygpIHtcbiAgICAgICAgdGhpcy5fX2VuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIEZvcmNlIHJlLWNoZWNrIG9mIHRleHR1cmUgYmVjYXVzZSBkaW1lbnNpb25zIG1pZ2h0IGhhdmUgY2hhbmdlZCAoY3V0dGluZykuXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVGV4dHVyZUNvb3JkcygpO1xuXG4gICAgICAgIGlmICh0aGlzLl9fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fX3RleHR1cmUuYWRkRWxlbWVudCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLndpdGhpbkJvdW5kc01hcmdpbikge1xuICAgICAgICAgICAgdGhpcy5fc2V0QWN0aXZlRmxhZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX19jb3JlLnNoYWRlcikge1xuICAgICAgICAgICAgdGhpcy5fX2NvcmUuc2hhZGVyLmFkZEVsZW1lbnQodGhpcy5fX2NvcmUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBfdW5zZXRFbmFibGVkRmxhZygpIHtcbiAgICAgICAgaWYgKHRoaXMuX19hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc2V0QWN0aXZlRmxhZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX190ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9fdGV4dHVyZS5yZW1vdmVFbGVtZW50KHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX19jb3JlLnNoYWRlcikge1xuICAgICAgICAgICAgdGhpcy5fX2NvcmUuc2hhZGVyLnJlbW92ZUVsZW1lbnQodGhpcy5fX2NvcmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cml6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyaXplci5maWx0ZXJzLmZvckVhY2goZmlsdGVyID0+IGZpbHRlci5yZW1vdmVFbGVtZW50KHRoaXMuX19jb3JlKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9zZXRBY3RpdmVGbGFnKCkge1xuICAgICAgICB0aGlzLl9fYWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIG11c3QgaGFwcGVuIGJlZm9yZSBlbmFibGluZyB0aGUgdGV4dHVyZSwgYmVjYXVzZSBpdCBtYXkgYWxyZWFkeSBiZSBsb2FkZWQgb3IgbG9hZCBkaXJlY3RseS5cbiAgICAgICAgaWYgKHRoaXMuX190ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9fdGV4dHVyZS5pbmNBY3RpdmVDb3VudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX190ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25BY3RpdmUoKTtcbiAgICB9XG5cbiAgICBfdW5zZXRBY3RpdmVGbGFnKCkge1xuICAgICAgICBpZiAodGhpcy5fX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX190ZXh0dXJlLmRlY0FjdGl2ZUNvdW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZVRleHR1cmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9oYXNUZXh0dXJpemVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyaXplci5kZWFjdGl2YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vbkluYWN0aXZlKCk7XG4gICAgfVxuXG4gICAgX29uU2V0dXAoKSB7XG4gICAgfVxuXG4gICAgX29uQXR0YWNoKCkge1xuICAgIH1cblxuICAgIF9vbkRldGFjaCgpIHtcbiAgICB9XG5cbiAgICBfb25FbmFibGVkKCkge1xuICAgIH1cblxuICAgIF9vbkRpc2FibGVkKCkge1xuICAgIH1cblxuICAgIF9vbkFjdGl2ZSgpIHtcbiAgICB9XG5cbiAgICBfb25JbmFjdGl2ZSgpIHtcbiAgICB9XG5cbiAgICBfb25SZXNpemUoKSB7XG4gICAgfVxuXG4gICAgX2dldFJlbmRlcldpZHRoKCkge1xuICAgICAgICBpZiAodGhpcy5fdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3c7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fX2Rpc3BsYXllZFRleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGlzcGxheWVkVGV4dHVyZS5nZXRSZW5kZXJXaWR0aCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX190ZXh0dXJlKSB7XG4gICAgICAgICAgICAvLyBUZXh0dXJlIGFscmVhZHkgbG9hZGVkLCBidXQgbm90IHlldCB1cGRhdGVkIChwcm9iYWJseSBiZWNhdXNlIHRoaXMgZWxlbWVudCBpcyBub3QgYWN0aXZlKS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdGV4dHVyZS5nZXRSZW5kZXJXaWR0aCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX2dldFJlbmRlckhlaWdodCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2Rpc3BsYXllZFRleHR1cmUuZ2V0UmVuZGVySGVpZ2h0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fX3RleHR1cmUpIHtcbiAgICAgICAgICAgIC8vIFRleHR1cmUgYWxyZWFkeSBsb2FkZWQsIGJ1dCBub3QgeWV0IHVwZGF0ZWQgKHByb2JhYmx5IGJlY2F1c2UgdGhpcyBlbGVtZW50IGlzIG5vdCBhY3RpdmUpLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX190ZXh0dXJlLmdldFJlbmRlckhlaWdodCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ2V0IHJlbmRlcldpZHRoKCkge1xuICAgICAgICBpZiAodGhpcy5fX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFJlbmRlciB3aWR0aCBpcyBvbmx5IG1haW50YWluZWQgaWYgdGhpcyBlbGVtZW50IGlzIGVuYWJsZWQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuZ2V0UmVuZGVyV2lkdGgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRSZW5kZXJXaWR0aCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHJlbmRlckhlaWdodCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX19lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuZ2V0UmVuZGVySGVpZ2h0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UmVuZGVySGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZmluYWxYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUueDtcbiAgICB9XG5cbiAgICBnZXQgZmluYWxZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUueTtcbiAgICB9XG5cbiAgICBnZXQgZmluYWxXKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUudztcbiAgICB9XG5cbiAgICBnZXQgZmluYWxIKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuaDtcbiAgICB9XG5cbiAgICB0ZXh0dXJlSXNMb2FkZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fdGV4dHVyZSAmJiB0aGlzLl9fdGV4dHVyZS5pc0xvYWRlZCgpO1xuICAgIH1cblxuICAgIGxvYWRUZXh0dXJlKCkge1xuICAgICAgICBpZiAodGhpcy5fX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX190ZXh0dXJlLmxvYWQoKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9fdGV4dHVyZS5pc1VzZWQoKSB8fCAhdGhpcy5faXNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2FkaW5nIHRoZSB0ZXh0dXJlIHdpbGwgaGF2ZSBubyBlZmZlY3Qgb24gdGhlIGRpbWVuc2lvbnMgb2YgdGhpcyBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IHVwZGF0ZSB0aGVtLCBzbyB0aGF0IGNhbGNzIGNhbiBiZSBwZXJmb3JtZWQgaW1tZWRpYXRlbHkgaW4gdXNlcmxhbmQuXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2VuYWJsZVRleHR1cmVFcnJvcigpIHtcbiAgICAgICAgLy8gdHhFcnJvciBldmVudCBzaG91bGQgYXV0b21hdGljYWxseSBiZSByZS10cmlnZ2VyZWQgd2hlbiBhIGVsZW1lbnQgYmVjb21lcyBhY3RpdmUuXG4gICAgICAgIGNvbnN0IGxvYWRFcnJvciA9IHRoaXMuX190ZXh0dXJlLmxvYWRFcnJvcjtcbiAgICAgICAgaWYgKGxvYWRFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd0eEVycm9yJywgbG9hZEVycm9yLCB0aGlzLl9fdGV4dHVyZS5fc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9lbmFibGVUZXh0dXJlKCkge1xuICAgICAgICBpZiAodGhpcy5fX3RleHR1cmUuaXNMb2FkZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0RGlzcGxheWVkVGV4dHVyZSh0aGlzLl9fdGV4dHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJldGFpbiB0aGUgb2xkICdnaG9zdCcgaW1hZ2UgYXMgaXQgd2Fzbid0IHZpc2libGUgYW55d2F5LlxuICAgICAgICAgICAgdGhpcy5fc2V0RGlzcGxheWVkVGV4dHVyZShudWxsKTtcblxuICAgICAgICAgICAgdGhpcy5fZW5hYmxlVGV4dHVyZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZGlzYWJsZVRleHR1cmUoKSB7XG4gICAgICAgIC8vIFdlIGRpc2FibGUgdGhlIGRpc3BsYXllZCB0ZXh0dXJlIGJlY2F1c2UsIHdoZW4gdGhlIHRleHR1cmUgY2hhbmdlcyB3aGlsZSBpbnZpc2libGUsIHdlIHNob3VsZCB1c2UgdGhhdCB3LCBoLFxuICAgICAgICAvLyBtdywgbWggZm9yIGNoZWNraW5nIHdpdGhpbiBib3VuZHMuXG4gICAgICAgIHRoaXMuX3NldERpc3BsYXllZFRleHR1cmUobnVsbCk7XG4gICAgfVxuXG4gICAgZ2V0IHRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fdGV4dHVyZTtcbiAgICB9XG5cbiAgICBzZXQgdGV4dHVyZSh2KSB7XG4gICAgICAgIGxldCB0ZXh0dXJlO1xuICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYpKSB7XG4gICAgICAgICAgICBpZiAodi50eXBlKSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZSA9IG5ldyB2LnR5cGUodGhpcy5zdGFnZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgQmFzZS5wYXRjaE9iamVjdCh0ZXh0dXJlLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghdikge1xuICAgICAgICAgICAgdGV4dHVyZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodi5pc1RleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlID0gdjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodi5pc1RleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlID0gbmV3IFNvdXJjZVRleHR1cmUodGhpcy5zdGFnZSk7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS50ZXh0dXJlU291cmNlID0gdjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltMaWdodG5pbmddIFBsZWFzZSBzcGVjaWZ5IGEgdGV4dHVyZSB0eXBlLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcmV2VGV4dHVyZSA9IHRoaXMuX190ZXh0dXJlO1xuICAgICAgICBpZiAodGV4dHVyZSAhPT0gcHJldlRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX190ZXh0dXJlID0gdGV4dHVyZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX190ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190ZXh0dXJlLmFkZEVsZW1lbnQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMud2l0aGluQm91bmRzTWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3RleHR1cmUuaXNMb2FkZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldERpc3BsYXllZFRleHR1cmUodGhpcy5fX3RleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmFibGVUZXh0dXJlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgY3VycmVudCB0ZXh0dXJlIGlzIGNsZWFyZWQgd2hlbiB0aGUgdGV4dHVyZSBpcyBleHBsaWNpdGx5IHNldCB0byBudWxsLlxuICAgICAgICAgICAgICAgIHRoaXMuX3NldERpc3BsYXllZFRleHR1cmUobnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2VGV4dHVyZSAmJiBwcmV2VGV4dHVyZSAhPT0gdGhpcy5fX2Rpc3BsYXllZFRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBwcmV2VGV4dHVyZS5yZW1vdmVFbGVtZW50KHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZGlzcGxheWVkVGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlO1xuICAgIH1cblxuICAgIF9zZXREaXNwbGF5ZWRUZXh0dXJlKHYpIHtcbiAgICAgICAgbGV0IHByZXZUZXh0dXJlID0gdGhpcy5fX2Rpc3BsYXllZFRleHR1cmU7XG5cbiAgICAgICAgaWYgKHByZXZUZXh0dXJlICYmICh2ICE9PSBwcmV2VGV4dHVyZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9fdGV4dHVyZSAhPT0gcHJldlRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb2xkIGRpc3BsYXllZCB0ZXh0dXJlIGlzIGRlcHJlY2F0ZWQuXG4gICAgICAgICAgICAgICAgcHJldlRleHR1cmUucmVtb3ZlRWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByZXZTb3VyY2UgPSB0aGlzLl9fY29yZS5kaXNwbGF5ZWRUZXh0dXJlU291cmNlID8gdGhpcy5fX2NvcmUuZGlzcGxheWVkVGV4dHVyZVNvdXJjZS5fc291cmNlIDogbnVsbDtcbiAgICAgICAgY29uc3Qgc291cmNlQ2hhbmdlZCA9ICh2ID8gdi5fc291cmNlIDogbnVsbCkgIT09IHByZXZTb3VyY2U7XG5cbiAgICAgICAgdGhpcy5fX2Rpc3BsYXllZFRleHR1cmUgPSB2O1xuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmVmZXJlbmNlIHRoZSBkaXNwbGF5ZWQgdGV4dHVyZSBiZWNhdXNlIGl0IHdhcyBhbHJlYWR5IHJlZmVyZW5jZWQgKHRoaXMudGV4dHVyZSA9PT0gdGhpcy5kaXNwbGF5ZWRUZXh0dXJlKS5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVUZXh0dXJlQ29vcmRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvcmUuc2V0RGlzcGxheWVkVGV4dHVyZVNvdXJjZSh0aGlzLl9fZGlzcGxheWVkVGV4dHVyZS5fc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19jb3JlLnNldERpc3BsYXllZFRleHR1cmVTb3VyY2UobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc291cmNlQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd0eExvYWRlZCcsIHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd0eFVubG9hZGVkJywgdGhpcy5fX2Rpc3BsYXllZFRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25UZXh0dXJlU291cmNlTG9hZGVkKCkge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGVsZW1lbnQgaXMgZW5hYmxlZCwgYnV0IHdlIG9ubHkgd2FudCB0byBzZXQgZGlzcGxheWVkIHRleHR1cmUgZm9yIGFjdGl2ZSBlbGVtZW50cy5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAvLyBXZSBtYXkgYmUgZGVhbGluZyB3aXRoIGEgdGV4dHVyZSByZWxvYWRpbmcsIHNvIHdlIG11c3QgZm9yY2UgdXBkYXRlLlxuICAgICAgICAgICAgdGhpcy5fc2V0RGlzcGxheWVkVGV4dHVyZSh0aGlzLl9fdGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgb25UZXh0dXJlU291cmNlTG9hZEVycm9yKGUpIHtcbiAgICAgICAgdGhpcy5lbWl0KCd0eEVycm9yJywgZSwgdGhpcy5fX3RleHR1cmUuX3NvdXJjZSk7XG4gICAgfTtcblxuICAgIGZvcmNlUmVuZGVyVXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9fY29yZS5zZXRIYXNSZW5kZXJVcGRhdGVzKDMpO1xuICAgIH1cblxuICAgIG9uRGlzcGxheWVkVGV4dHVyZUNsaXBwaW5nQ2hhbmdlZCgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLl91cGRhdGVUZXh0dXJlQ29vcmRzKCk7XG4gICAgfTtcblxuICAgIG9uUHJlY2lzaW9uQ2hhbmdlZCgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuICAgIH07XG5cbiAgICBvbkRpbWVuc2lvbnNDaGFuZ2VkKHcsIGgpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSBpbnN0YW5jZW9mIFRleHRUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUudyA9IHc7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUuaCA9IGg7XG4gICAgICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICAgICAgdGhpcy5oID0gaDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF91cGRhdGVEaW1lbnNpb25zKCkge1xuICAgICAgICBsZXQgdyA9IHRoaXMuX2dldFJlbmRlcldpZHRoKCk7XG4gICAgICAgIGxldCBoID0gdGhpcy5fZ2V0UmVuZGVySGVpZ2h0KCk7XG5cbiAgICAgICAgbGV0IHVua25vd25TaXplID0gZmFsc2U7XG4gICAgICAgIGlmICghdyB8fCAhaCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9fZGlzcGxheWVkVGV4dHVyZSAmJiB0aGlzLl9fdGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBhICdtYXggd2lkdGgnIHJlcGxhY2VtZW50IGluc3RlYWQgaW4gdGhlIEVsZW1lbnRDb3JlIGNhbGNzLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IGl0IGlzIGFibGUgdG8gZGV0ZXJtaW5lIHdpdGhpbkJvdW5kcy5cbiAgICAgICAgICAgICAgICB3ID0gdyB8fCB0aGlzLl9fdGV4dHVyZS5tdztcbiAgICAgICAgICAgICAgICBoID0gaCB8fCB0aGlzLl9fdGV4dHVyZS5taDtcblxuICAgICAgICAgICAgICAgIGlmICgoIXcgfHwgIWgpICYmIHRoaXMuX190ZXh0dXJlLmlzQXV0b3NpemVUZXh0dXJlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5rbm93blNpemUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9fY29yZS5zZXREaW1lbnNpb25zKHcsIGgsIHVua25vd25TaXplKSkge1xuICAgICAgICAgICAgdGhpcy5fb25SZXNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF91cGRhdGVUZXh0dXJlQ29vcmRzKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNwbGF5ZWRUZXh0dXJlICYmIHRoaXMuZGlzcGxheWVkVGV4dHVyZS5fc291cmNlKSB7XG4gICAgICAgICAgICBsZXQgZGlzcGxheWVkVGV4dHVyZSA9IHRoaXMuZGlzcGxheWVkVGV4dHVyZTtcbiAgICAgICAgICAgIGxldCBkaXNwbGF5ZWRUZXh0dXJlU291cmNlID0gdGhpcy5kaXNwbGF5ZWRUZXh0dXJlLl9zb3VyY2U7XG5cbiAgICAgICAgICAgIGxldCB0eDEgPSAwLCB0eTEgPSAwLCB0eDIgPSAxLjAsIHR5MiA9IDEuMDtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5ZWRUZXh0dXJlLmNsaXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdGV4dHVyZSBjbGlwcGluZy5cbiAgICAgICAgICAgICAgICBsZXQgdyA9IGRpc3BsYXllZFRleHR1cmVTb3VyY2UuZ2V0UmVuZGVyV2lkdGgoKTtcbiAgICAgICAgICAgICAgICBsZXQgaCA9IGRpc3BsYXllZFRleHR1cmVTb3VyY2UuZ2V0UmVuZGVySGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgbGV0IGl3LCBpaCwgcncsIHJoO1xuICAgICAgICAgICAgICAgIGl3ID0gMSAvIHc7XG4gICAgICAgICAgICAgICAgaWggPSAxIC8gaDtcblxuICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5ZWRUZXh0dXJlLnB3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ3ID0gKGRpc3BsYXllZFRleHR1cmUucHcpICogaXc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcncgPSAodyAtIGRpc3BsYXllZFRleHR1cmUucHgpICogaXc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRpc3BsYXllZFRleHR1cmUucGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmggPSBkaXNwbGF5ZWRUZXh0dXJlLnBoICogaWg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmggPSAoaCAtIGRpc3BsYXllZFRleHR1cmUucHkpICogaWg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXcgKj0gKGRpc3BsYXllZFRleHR1cmUucHgpO1xuICAgICAgICAgICAgICAgIGloICo9IChkaXNwbGF5ZWRUZXh0dXJlLnB5KTtcblxuICAgICAgICAgICAgICAgIHR4MSA9IGl3O1xuICAgICAgICAgICAgICAgIHR5MSA9IGloO1xuICAgICAgICAgICAgICAgIHR4MiA9IHR4MiAqIHJ3ICsgaXc7XG4gICAgICAgICAgICAgICAgdHkyID0gdHkyICogcmggKyBpaDtcblxuICAgICAgICAgICAgICAgIHR4MSA9IE1hdGgubWF4KDAsIHR4MSk7XG4gICAgICAgICAgICAgICAgdHkxID0gTWF0aC5tYXgoMCwgdHkxKTtcbiAgICAgICAgICAgICAgICB0eDIgPSBNYXRoLm1pbigxLCB0eDIpO1xuICAgICAgICAgICAgICAgIHR5MiA9IE1hdGgubWluKDEsIHR5Mik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkaXNwbGF5ZWRUZXh0dXJlU291cmNlLl9mbGlwVGV4dHVyZVkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcHR5ID0gdHkyO1xuICAgICAgICAgICAgICAgIHR5MiA9IHR5MTtcbiAgICAgICAgICAgICAgICB0eTEgPSB0ZW1wdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9fY29yZS5zZXRUZXh0dXJlQ29vcmRzKHR4MSwgdHkxLCB0eDIsIHR5Mik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDb3JuZXJQb2ludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5nZXRDb3JuZXJQb2ludHMoKTtcbiAgICB9XG5cbiAgICBfdW5zZXRUYWdzUGFyZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fX3RhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX190YWdzLmZvckVhY2goKHRhZykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRyZWVUYWdzLlxuICAgICAgICAgICAgICAgIGxldCBwID0gdGhpcztcbiAgICAgICAgICAgICAgICB3aGlsZSAocCA9IHAuX19wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudFRyZWVUYWdzID0gcC5fX3RyZWVUYWdzLmdldCh0YWcpO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmVlVGFncy5kZWxldGUodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHAuX190YWdSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRhZ3MgPSBudWxsO1xuICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgIGlmICh0aGlzLl9fdHJlZVRhZ3MpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fX3RhZ1Jvb3QpIHtcbiAgICAgICAgICAgICAgICB0YWdzID0gVXRpbHMuaXRlcmF0b3JUb0FycmF5KHRoaXMuX190cmVlVGFncy5rZXlzKCkpO1xuICAgICAgICAgICAgICAgIG4gPSB0YWdzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRhZ1NldCA9IHRoaXMuX190cmVlVGFncy5nZXQodGFnc1tpXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRyZWVUYWdzLlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChwID0gcC5fX3BhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50VHJlZVRhZ3MgPSBwLl9fdHJlZVRhZ3MuZ2V0KHRhZ3NbaV0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnU2V0LmZvckVhY2goZnVuY3Rpb24gKGNvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJlZVRhZ3MuZGVsZXRlKGNvbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuX190YWdSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfc2V0VGFnc1BhcmVudCgpIHtcbiAgICAgICAgLy8gSnVzdCBjb3B5IG92ZXIgdGhlICdsb2NhbCcgdGFncy5cbiAgICAgICAgaWYgKHRoaXMuX190YWdzKSB7XG4gICAgICAgICAgICB0aGlzLl9fdGFncy5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHAgPSBwLl9fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcC5fX3RyZWVUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLl9fdHJlZVRhZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IHAuX190cmVlVGFncy5nZXQodGFnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5fX3RyZWVUYWdzLnNldCh0YWcsIHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcy5hZGQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHAuX190YWdSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX190cmVlVGFncyAmJiB0aGlzLl9fdHJlZVRhZ3Muc2l6ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9fdGFnUm9vdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX190cmVlVGFncy5mb3JFYWNoKCh0YWdTZXQsIHRhZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghcC5fX3RhZ1Jvb3QgJiYgKHAgPSBwLl9fcGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuX190YWdSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGNvcHkgYWxsIHN1YnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXAuX190cmVlVGFncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuX190cmVlVGFncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBwLl9fdHJlZVRhZ3MuZ2V0KHRhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuX190cmVlVGFncy5zZXQodGFnLCBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnU2V0LmZvckVhY2goZnVuY3Rpb24gKGNvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmFkZChjb21wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBfZ2V0QnlUYWcodGFnKSB7XG4gICAgICAgIGlmICghdGhpcy5fX3RyZWVUYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHQgPSB0aGlzLl9fdHJlZVRhZ3MuZ2V0KHRhZyk7XG4gICAgICAgIHJldHVybiB0ID8gVXRpbHMuc2V0VG9BcnJheSh0KSA6IFtdO1xuICAgIH07XG5cbiAgICBnZXRUYWdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3RhZ3MgPyB0aGlzLl9fdGFncyA6IFtdO1xuICAgIH07XG5cbiAgICBzZXRUYWdzKHRhZ3MpIHtcbiAgICAgICAgdGFncyA9IHRhZ3MucmVkdWNlKChhY2MsIHRhZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQodGFnLnNwbGl0KCcgJykpO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX19yZWYpIHtcbiAgICAgICAgICAgIHRhZ3MucHVzaCh0aGlzLl9fcmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpLCBuID0gdGFncy5sZW5ndGg7XG4gICAgICAgIGxldCByZW1vdmVzID0gW107XG4gICAgICAgIGxldCBhZGRzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNUYWcodGFnc1tpXSkpIHtcbiAgICAgICAgICAgICAgICBhZGRzLnB1c2godGFnc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VycmVudFRhZ3MgPSB0aGlzLnRhZ3MgfHwgW107XG4gICAgICAgIG4gPSBjdXJyZW50VGFncy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0YWdzLmluZGV4T2YoY3VycmVudFRhZ3NbaV0pID09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVtb3Zlcy5wdXNoKGN1cnJlbnRUYWdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZW1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRhZyhyZW1vdmVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhZGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRhZyhhZGRzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFRhZyh0YWcpIHtcbiAgICAgICAgaWYgKHRhZy5pbmRleE9mKCcgJykgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNVY0NoYXIodGFnLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIlRhZyBtYXkgbm90IHN0YXJ0IHdpdGggYW4gdXBwZXIgY2FzZSBjaGFyYWN0ZXIuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hZGRUYWcodGFnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB0YWcuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBtID0gdGFncy5sZW5ndGg7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWcgPSB0YWdzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxzLmlzVWNDaGFyKHRhZy5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiVGFnIG1heSBub3Qgc3RhcnQgd2l0aCBhbiB1cHBlciBjYXNlIGNoYXJhY3Rlci5cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVGFnKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfYWRkVGFnKHRhZykge1xuICAgICAgICBpZiAoIXRoaXMuX190YWdzKSB7XG4gICAgICAgICAgICB0aGlzLl9fdGFncyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9fdGFncy5pbmRleE9mKHRhZykgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9fdGFncy5wdXNoKHRhZyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0byB0cmVlVGFncyBoaWVyYXJjaHkuXG4gICAgICAgICAgICBsZXQgcCA9IHRoaXMuX19wYXJlbnQ7XG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwLl9fdHJlZVRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuX190cmVlVGFncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gcC5fX3RyZWVUYWdzLmdldCh0YWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLl9fdHJlZVRhZ3Muc2V0KHRhZywgcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzLmFkZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKCFwLl9fdGFnUm9vdCAmJiAocCA9IHAuX19wYXJlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZVRhZyh0YWcpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLl9fdGFncy5pbmRleE9mKHRhZyk7XG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fX3RhZ3Muc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSB0cmVlVGFncyBoaWVyYXJjaHkuXG4gICAgICAgICAgICBsZXQgcCA9IHRoaXMuX19wYXJlbnQ7XG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3QgPSBwLl9fdHJlZVRhZ3MuZ2V0KHRhZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0LmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKCFwLl9fdGFnUm9vdCAmJiAocCA9IHAuX19wYXJlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhc1RhZyh0YWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9fdGFncyAmJiAodGhpcy5fX3RhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb25lIG9mIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBzdWJ0cmVlIHRoYXQgaGF2ZSB0aGlzIHRhZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gICAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAgICovXG4gICAgX3RhZyh0YWcpIHtcbiAgICAgICAgaWYgKHRhZy5pbmRleE9mKFwiLlwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm10YWcodGFnKVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9fdHJlZVRhZ3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgdCA9IHRoaXMuX190cmVlVGFncy5nZXQodGFnKTtcbiAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdC52YWx1ZXMoKS5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtID8gaXRlbS52YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ2V0IHRhZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhZztcbiAgICB9XG5cbiAgICBzZXQgdGFnKHQpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBzdWJ0cmVlIHRoYXQgaGF2ZSB0aGlzIHRhZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gICAgICogQHJldHVybnMge0VsZW1lbnRbXX1cbiAgICAgKi9cbiAgICBtdGFnKHRhZykge1xuICAgICAgICBsZXQgaWR4ID0gdGFnLmluZGV4T2YoXCIuXCIpO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgIGxldCBwYXJ0cyA9IHRhZy5zcGxpdCgnLicpO1xuICAgICAgICAgICAgbGV0IHJlcyA9IHRoaXMuX2dldEJ5VGFnKHBhcnRzWzBdKTtcbiAgICAgICAgICAgIGxldCBsZXZlbCA9IDE7XG4gICAgICAgICAgICBsZXQgYyA9IHBhcnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChyZXMubGVuZ3RoICYmIGxldmVsIDwgYykge1xuICAgICAgICAgICAgICAgIGxldCByZXNuID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIG4gPSByZXMubGVuZ3RoOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc24gPSByZXNuLmNvbmNhdChyZXNbal0uX2dldEJ5VGFnKHBhcnRzW2xldmVsXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcyA9IHJlc247XG4gICAgICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlUYWcodGFnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzdGFnKHRhZywgc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzLm10YWcodGFnKTtcbiAgICAgICAgbGV0IG4gPSB0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIEJhc2UucGF0Y2hPYmplY3QodFtpXSwgc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHRhZ1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fdGFnUm9vdDtcbiAgICB9XG5cbiAgICBzZXQgdGFnUm9vdCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9fdGFnUm9vdCAhPT0gdikge1xuICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VGFnc1BhcmVudCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bnNldFRhZ3NQYXJlbnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fX3RhZ1Jvb3QgPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsKHBhdGgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuc2VsZWN0KHBhdGgpO1xuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoXCIsXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgbGV0IHNlbGVjdG9ycyA9IHBhdGguc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdCh0aGlzLl9zZWxlY3Qoc2VsZWN0b3JzW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdChwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZWxlY3QocGF0aCkge1xuICAgICAgICBpZiAocGF0aCA9PT0gXCJcIikgcmV0dXJuIFt0aGlzXTtcblxuXG4gICAgICAgIGxldCBwb2ludElkeCA9IHBhdGguaW5kZXhPZihcIi5cIik7XG4gICAgICAgIGxldCBhcnJvd0lkeCA9IHBhdGguaW5kZXhPZihcIj5cIik7XG4gICAgICAgIGlmIChwb2ludElkeCA9PT0gLTEgJiYgYXJyb3dJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBRdWljayBjYXNlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXRhZyhwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVjdCBieSBmaXJzdCBjaGFyLlxuICAgICAgICBsZXQgaXNSZWY7XG4gICAgICAgIGlmIChhcnJvd0lkeCA9PT0gMCkge1xuICAgICAgICAgICAgaXNSZWYgPSB0cnVlO1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDEpO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50SWR4ID09PSAwKSB7XG4gICAgICAgICAgICBpc1JlZiA9IGZhbHNlO1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNSZWYgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RDaGlsZHMocGF0aCwgaXNSZWYpO1xuICAgIH1cblxuICAgIF9zZWxlY3RDaGlsZHMocGF0aCwgaXNSZWYpIHtcbiAgICAgICAgY29uc3QgcG9pbnRJZHggPSBwYXRoLmluZGV4T2YoXCIuXCIpO1xuICAgICAgICBjb25zdCBhcnJvd0lkeCA9IHBhdGguaW5kZXhPZihcIj5cIik7XG5cbiAgICAgICAgaWYgKHBvaW50SWR4ID09PSAtMSAmJiBhcnJvd0lkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChpc1JlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXMuZ2V0QnlSZWYocGF0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZiA/IFtyZWZdIDogW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm10YWcocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGFycm93SWR4ID09PSAtMSkgfHwgKHBvaW50SWR4ICE9PSAtMSAmJiBwb2ludElkeCA8IGFycm93SWR4KSkge1xuICAgICAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgICAgICBjb25zdCBzdHIgPSBwYXRoLnN1YnN0cigwLCBwb2ludElkeCk7XG4gICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSB0aGlzLmdldEJ5UmVmKHN0cik7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHJlZiA/IFtyZWZdIDogW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLm10YWcoc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3RhbCA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc3ViUGF0aCA9IHBhdGguc3Vic3RyKHBvaW50SWR4ICsgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IG5leHQubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSB0b3RhbC5jb25jYXQobmV4dFtpXS5fc2VsZWN0Q2hpbGRzKHN1YlBhdGgsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IHBhdGguc3Vic3RyKDAsIGFycm93SWR4KTtcbiAgICAgICAgICAgIGlmIChpc1JlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXMuZ2V0QnlSZWYoc3RyKTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gcmVmID8gW3JlZl0gOiBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMubXRhZyhzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvdGFsID0gW107XG4gICAgICAgICAgICBjb25zdCBzdWJQYXRoID0gcGF0aC5zdWJzdHIoYXJyb3dJZHggKyAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbmV4dC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHRvdGFsLmNvbmNhdChuZXh0W2ldLl9zZWxlY3RDaGlsZHMoc3ViUGF0aCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0QnlSZWYocmVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkTGlzdC5nZXRCeVJlZihyZWYpO1xuICAgIH1cblxuICAgIGdldExvY2F0aW9uU3RyaW5nKCkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaSA9IHRoaXMuX19wYXJlbnQgPyB0aGlzLl9fcGFyZW50Ll9jaGlsZHJlbi5nZXRJbmRleCh0aGlzKSA6IFwiUlwiO1xuICAgICAgICBsZXQgbG9jYWxUYWdzID0gdGhpcy5nZXRUYWdzKCk7XG4gICAgICAgIGxldCBzdHIgPSB0aGlzLl9fcGFyZW50ID8gdGhpcy5fX3BhcmVudC5nZXRMb2NhdGlvblN0cmluZygpOiBcIlwiO1xuICAgICAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICAgICAgIHN0ciArPSBcIjpbXCIgKyBpICsgXCJdXCIgKyB0aGlzLnJlZjtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbFRhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHIgKz0gXCI6W1wiICsgaSArIFwiXVwiICsgbG9jYWxUYWdzLmpvaW4oXCIsXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyICs9IFwiOltcIiArIGkgKyBcIl0jXCIgKyB0aGlzLmlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBvYmogPSB0aGlzLmdldFNldHRpbmdzKCk7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmdldFByZXR0eVN0cmluZyhvYmosIFwiXCIpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0UHJldHR5U3RyaW5nKG9iaiwgaW5kZW50KSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IG9iai5jaGlsZHJlbjtcbiAgICAgICAgZGVsZXRlIG9iai5jaGlsZHJlbjtcblxuXG4gICAgICAgIC8vIENvbnZlcnQgc2luZ3VsYXIganNvbiBzZXR0aW5ncyBvYmplY3QuXG4gICAgICAgIGxldCBjb2xvcktleXMgPSBbXCJjb2xvclwiLCBcImNvbG9yVWxcIiwgXCJjb2xvclVyXCIsIFwiY29sb3JCbFwiLCBcImNvbG9yQnJcIl07XG4gICAgICAgIGxldCBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmosIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICBpZiAoY29sb3JLZXlzLmluZGV4T2YoaykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQ09MT1JbXCIgKyB2LnRvU3RyaW5nKDE2KSArIFwiXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXCJDT0xPUlxcWyhbYS1mMC05XXsxLDh9KVxcXVwiL2csIFwiMHgkMVwiKTtcblxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBjaGlsZFN0ciA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgIGxldCByZWZzID0gT2JqZWN0LmtleXMoY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGNoaWxkU3RyID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHJlZnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkU3RyICs9IGBcXG4ke2luZGVudH0gIFwiJHtyZWZzW2ldfVwiOmBcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkcmVuW3JlZnNbaV1dLnJlZjtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRTdHIgKz0gRWxlbWVudC5nZXRQcmV0dHlTdHJpbmcoY2hpbGRyZW5bcmVmc1tpXV0sIGluZGVudCArIFwiICBcIikgKyAoaSA8IG4gLSAxID8gXCIsXCIgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGlzRW1wdHkgPSAoc3RyID09PSBcInt9XCIpO1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoMCwgc3RyLmxlbmd0aCAtIDEpICsgKGlzRW1wdHkgPyBcIlwiIDogXCIsXCIpICsgY2hpbGRTdHIgKyBcIlxcblwiICsgaW5kZW50ICsgXCJ9XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNoaWxkU3RyID0gXCJbXCI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRTdHIgKz0gRWxlbWVudC5nZXRQcmV0dHlTdHJpbmcoY2hpbGRyZW5baV0sIGluZGVudCArIFwiICBcIikgKyAoaSA8IG4gLSAxID8gXCIsXCIgOiBcIlwiKSArIFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkU3RyICs9IGluZGVudCArIFwiXX1cIjtcbiAgICAgICAgICAgICAgICBsZXQgaXNFbXB0eSA9IChzdHIgPT09IFwie31cIik7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCBzdHIubGVuZ3RoIC0gMSkgKyAoaXNFbXB0eSA/IFwiXCIgOiBcIixcIikgKyBcIlxcXCJjaGlsZHJlblxcXCI6XFxuXCIgKyBpbmRlbnQgKyBjaGlsZFN0ciArIFwifVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICBsZXQgc2V0dGluZ3MgPSB0aGlzLmdldE5vbkRlZmF1bHRzKCk7XG5cbiAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4uZ2V0KCk7XG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IG4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgbWlzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQXJyYXkucHVzaChjaGlsZHJlbltpXS5nZXRTZXR0aW5ncygpKTtcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZyA9IG1pc3NpbmcgfHwgIWNoaWxkcmVuW2ldLnJlZjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuY2hpbGRyZW4gPSB7fVxuICAgICAgICAgICAgICAgICAgICBjaGlsZEFycmF5LmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuY2hpbGRyZW5bY2hpbGQucmVmXSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGluZ3MuaWQgPSB0aGlzLmlkO1xuXG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9XG5cbiAgICBnZXROb25EZWZhdWx0cygpIHtcbiAgICAgICAgbGV0IHNldHRpbmdzID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgIT09IEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnR5cGUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fX3JlZikge1xuICAgICAgICAgICAgc2V0dGluZ3MucmVmID0gdGhpcy5fX3JlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9fdGFncyAmJiB0aGlzLl9fdGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnRhZ3MgPSB0aGlzLl9fdGFncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnggIT09IDApIHNldHRpbmdzLnggPSB0aGlzLng7XG4gICAgICAgIGlmICh0aGlzLnkgIT09IDApIHNldHRpbmdzLnkgPSB0aGlzLnk7XG4gICAgICAgIGlmICh0aGlzLncgIT09IDApIHNldHRpbmdzLncgPSB0aGlzLnc7XG4gICAgICAgIGlmICh0aGlzLmggIT09IDApIHNldHRpbmdzLmggPSB0aGlzLmg7XG5cbiAgICAgICAgaWYgKHRoaXMuc2NhbGVYID09PSB0aGlzLnNjYWxlWSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NhbGVYICE9PSAxKSBzZXR0aW5ncy5zY2FsZSA9IHRoaXMuc2NhbGVYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NhbGVYICE9PSAxKSBzZXR0aW5ncy5zY2FsZVggPSB0aGlzLnNjYWxlWDtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjYWxlWSAhPT0gMSkgc2V0dGluZ3Muc2NhbGVZID0gdGhpcy5zY2FsZVk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5waXZvdFggPT09IHRoaXMucGl2b3RZKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5waXZvdFggIT09IDAuNSkgc2V0dGluZ3MucGl2b3QgPSB0aGlzLnBpdm90WDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBpdm90WCAhPT0gMC41KSBzZXR0aW5ncy5waXZvdFggPSB0aGlzLnBpdm90WDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBpdm90WSAhPT0gMC41KSBzZXR0aW5ncy5waXZvdFkgPSB0aGlzLnBpdm90WTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1vdW50WCA9PT0gdGhpcy5tb3VudFkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vdW50WCAhPT0gMCkgc2V0dGluZ3MubW91bnQgPSB0aGlzLm1vdW50WDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vdW50WCAhPT0gMCkgc2V0dGluZ3MubW91bnRYID0gdGhpcy5tb3VudFg7XG4gICAgICAgICAgICBpZiAodGhpcy5tb3VudFkgIT09IDApIHNldHRpbmdzLm1vdW50WSA9IHRoaXMubW91bnRZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYWxwaGEgIT09IDEpIHNldHRpbmdzLmFscGhhID0gdGhpcy5hbHBoYTtcblxuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSkgc2V0dGluZ3MudmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLnJvdGF0aW9uICE9PSAwKSBzZXR0aW5ncy5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG5cbiAgICAgICAgaWYgKHRoaXMuY29sb3JVbCA9PT0gdGhpcy5jb2xvclVyICYmIHRoaXMuY29sb3JCbCA9PT0gdGhpcy5jb2xvckJyICYmIHRoaXMuY29sb3JVbCA9PT0gdGhpcy5jb2xvckJsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvclVsICE9PSAweEZGRkZGRkZGKSBzZXR0aW5ncy5jb2xvciA9IHRoaXMuY29sb3JVbC50b1N0cmluZygxNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvclVsICE9PSAweEZGRkZGRkZGKSBzZXR0aW5ncy5jb2xvclVsID0gdGhpcy5jb2xvclVsLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yVXIgIT09IDB4RkZGRkZGRkYpIHNldHRpbmdzLmNvbG9yVXIgPSB0aGlzLmNvbG9yVXIudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3JCbCAhPT0gMHhGRkZGRkZGRikgc2V0dGluZ3MuY29sb3JCbCA9IHRoaXMuY29sb3JCbC50b1N0cmluZygxNik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvckJyICE9PSAweEZGRkZGRkZGKSBzZXR0aW5ncy5jb2xvckJyID0gdGhpcy5jb2xvckJyLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnpJbmRleCkgc2V0dGluZ3MuekluZGV4ID0gdGhpcy56SW5kZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuZm9yY2VaSW5kZXhDb250ZXh0KSBzZXR0aW5ncy5mb3JjZVpJbmRleENvbnRleHQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLmNsaXBwaW5nKSBzZXR0aW5ncy5jbGlwcGluZyA9IHRoaXMuY2xpcHBpbmc7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNsaXBib3gpIHNldHRpbmdzLmNsaXBib3ggPSB0aGlzLmNsaXBib3g7XG5cbiAgICAgICAgaWYgKHRoaXMuX190ZXh0dXJlKSB7XG4gICAgICAgICAgICBsZXQgdG5kID0gdGhpcy5fX3RleHR1cmUuZ2V0Tm9uRGVmYXVsdHMoKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0bmQpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnRleHR1cmUgPSB0bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zaGFkZXIgJiYgVXRpbHMuaXNGdW5jdGlvbih0aGlzLnNoYWRlci5nZXROb25EZWZhdWx0cykpIHtcbiAgICAgICAgICAgIGxldCB0bmQgPSB0aGlzLnNoYWRlci5nZXROb25EZWZhdWx0cygpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRuZCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc2hhZGVyID0gdG5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhc1RleHR1cml6ZXIoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dHVyaXplci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucmVuZGVyVG9UZXh0dXJlID0gdGhpcy50ZXh0dXJpemVyLmVuYWJsZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0dXJpemVyLmxhenkpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5yZW5kZXJUb1RleHR1cmVMYXp5ID0gdGhpcy50ZXh0dXJpemVyLmxhenk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0dXJpemVyLmNvbG9yaXplKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuY29sb3JpemVSZXN1bHRUZXh0dXJlID0gdGhpcy50ZXh0dXJpemVyLmNvbG9yaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dHVyaXplci5yZW5kZXJPZmZzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5yZW5kZXJPZmZzY3JlZW4gPSB0aGlzLnRleHR1cml6ZXIucmVuZGVyT2Zmc2NyZWVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0R2V0dGVyKHByb3BlcnR5UGF0aCkge1xuICAgICAgICBsZXQgZ2V0dGVyID0gRWxlbWVudC5QUk9QX0dFVFRFUlMuZ2V0KHByb3BlcnR5UGF0aCk7XG4gICAgICAgIGlmICghZ2V0dGVyKSB7XG4gICAgICAgICAgICBnZXR0ZXIgPSBuZXcgRnVuY3Rpb24oJ29iaicsICdyZXR1cm4gb2JqLicgKyBwcm9wZXJ0eVBhdGgpO1xuICAgICAgICAgICAgRWxlbWVudC5QUk9QX0dFVFRFUlMuc2V0KHByb3BlcnR5UGF0aCwgZ2V0dGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0dGVyO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRTZXR0ZXIocHJvcGVydHlQYXRoKSB7XG4gICAgICAgIGxldCBzZXR0ZXIgPSBFbGVtZW50LlBST1BfU0VUVEVSUy5nZXQocHJvcGVydHlQYXRoKTtcbiAgICAgICAgaWYgKCFzZXR0ZXIpIHtcbiAgICAgICAgICAgIHNldHRlciA9IG5ldyBGdW5jdGlvbignb2JqJywgJ3YnLCAnb2JqLicgKyBwcm9wZXJ0eVBhdGggKyAnID0gdicpO1xuICAgICAgICAgICAgRWxlbWVudC5QUk9QX1NFVFRFUlMuc2V0KHByb3BlcnR5UGF0aCwgc2V0dGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0dGVyO1xuICAgIH1cblxuICAgIGdldCB3aXRoaW5Cb3VuZHNNYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5fd2l0aGluQm91bmRzTWFyZ2luO1xuICAgIH1cblxuICAgIF9lbmFibGVXaXRoaW5Cb3VuZHNNYXJnaW4oKSB7XG4gICAgICAgIC8vIElmZiBlbmFibGVkLCB0aGlzIHRvZ2dsZXMgdGhlIGFjdGl2ZSBmbGFnLlxuICAgICAgICBpZiAodGhpcy5fX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZUZsYWcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9kaXNhYmxlV2l0aGluQm91bmRzTWFyZ2luKCkge1xuICAgICAgICAvLyBJZmYgYWN0aXZlLCB0aGlzIHRvZ2dsZXMgdGhlIGFjdGl2ZSBmbGFnLlxuICAgICAgICBpZiAodGhpcy5fX2FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zZXRBY3RpdmVGbGFnKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgYm91bmRzTWFyZ2luKHYpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHYpICYmIHYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJvdW5kc01hcmdpbiBzaG91bGQgYmUgYW4gYXJyYXkgb2YgbGVmdC10b3AtcmlnaHQtYm90dG9tIHZhbHVlcyBvciBudWxsIChpbmhlcml0IG1hcmdpbilcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2NvcmUuYm91bmRzTWFyZ2luID0gdjtcbiAgICB9XG5cbiAgICBnZXQgYm91bmRzTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuYm91bmRzTWFyZ2luO1xuICAgIH1cblxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUub2Zmc2V0WDtcbiAgICB9XG5cbiAgICBzZXQgeCh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLm9mZnNldFggPSB2O1xuICAgIH1cblxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUub2Zmc2V0WTtcbiAgICB9XG5cbiAgICBzZXQgeSh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLm9mZnNldFkgPSB2O1xuICAgIH1cblxuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdztcbiAgICB9XG5cbiAgICBzZXQgdyh2KSB7XG4gICAgICAgIGlmIChVdGlscy5pc0Z1bmN0aW9uKHYpKSB7XG4gICAgICAgICAgICB0aGlzLl93ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX19jb3JlLmZ1bmNXID0gdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHYgPSBNYXRoLm1heCh2LCAwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93ICE9PSB2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvcmUuZGlzYWJsZUZ1bmNXKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdyA9IHY7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oO1xuICAgIH1cblxuICAgIHNldCBoKHYpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzRnVuY3Rpb24odikpIHtcbiAgICAgICAgICAgIHRoaXMuX2ggPSAwO1xuICAgICAgICAgICAgdGhpcy5fX2NvcmUuZnVuY0ggPSB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdiA9IE1hdGgubWF4KHYsIDApO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ggIT09IHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29yZS5kaXNhYmxlRnVuY0goKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oID0gdjtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY29sbGlzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlzaW9uO1xuICAgIH1cblxuICAgIHNldCBjb2xsaXNpb24odikge1xuICAgICAgICB0aGlzLl9jb2xsaXNpb24gPSB2O1xuICAgIH1cblxuICAgIF91cGRhdGVDb2xsaXNpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbGxpc2lvbiAmJiB0aGlzLl9fcGFyZW50ICYmIHRoaXMuX19wYXJlbnQuY29sbGlzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFyayBjb2xsaXNpb24gYXMgMiB0byBpbmRpY2F0ZSBhdGxlYXN0IG9uZSBkZXNjZW5kYW50IGhhcyBjb2xsaXNpb24gZW5hYmxlZC5cbiAgICAgICAgICAgICAqIFRoaXMgbmFycm93cyBkb3duIHRoZSBzZWFyY2ggZm9yIGVsZW1lbnRzIHdpdGggYWN0aXZlIGNvbGxpc2lvbi5cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9fcGFyZW50LmNvbGxpc2lvbiA9IDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2NhbGVYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuc2NhbGVYO1xuICAgIH1cblxuICAgIHNldCBzY2FsZVgodikge1xuICAgICAgICB0aGlzLl9fY29yZS5zY2FsZVggPSB2O1xuICAgIH1cblxuICAgIGdldCBzY2FsZVkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5zY2FsZVk7XG4gICAgfVxuXG4gICAgc2V0IHNjYWxlWSh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLnNjYWxlWSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuc2NhbGU7XG4gICAgfVxuXG4gICAgc2V0IHNjYWxlKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuc2NhbGUgPSB2O1xuICAgIH1cblxuICAgIGdldCBwaXZvdFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5waXZvdFg7XG4gICAgfVxuXG4gICAgc2V0IHBpdm90WCh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLnBpdm90WCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLnBpdm90WTtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3RZKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUucGl2b3RZID0gdjtcbiAgICB9XG5cbiAgICBnZXQgcGl2b3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5waXZvdDtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3Qodikge1xuICAgICAgICB0aGlzLl9fY29yZS5waXZvdCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IG1vdW50WCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLm1vdW50WDtcbiAgICB9XG5cbiAgICBzZXQgbW91bnRYKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUubW91bnRYID0gdjtcbiAgICB9XG5cbiAgICBnZXQgbW91bnRZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUubW91bnRZO1xuICAgIH1cblxuICAgIHNldCBtb3VudFkodikge1xuICAgICAgICB0aGlzLl9fY29yZS5tb3VudFkgPSB2O1xuICAgIH1cblxuICAgIGdldCBtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLm1vdW50O1xuICAgIH1cblxuICAgIHNldCBtb3VudCh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLm1vdW50ID0gdjtcbiAgICB9XG5cbiAgICBnZXQgcm90YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5yb3RhdGlvbjtcbiAgICB9XG5cbiAgICBzZXQgcm90YXRpb24odikge1xuICAgICAgICB0aGlzLl9fY29yZS5yb3RhdGlvbiA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGFscGhhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuYWxwaGE7XG4gICAgfVxuXG4gICAgc2V0IGFscGhhKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuYWxwaGEgPSB2O1xuICAgIH1cblxuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUudmlzaWJsZTtcbiAgICB9XG5cbiAgICBzZXQgdmlzaWJsZSh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLnZpc2libGUgPSB2O1xuICAgIH1cbiAgICBcbiAgICBnZXQgY29sb3JVbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmNvbG9yVWw7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yVWwodikge1xuICAgICAgICB0aGlzLl9fY29yZS5jb2xvclVsID0gdjtcbiAgICB9XG5cbiAgICBnZXQgY29sb3JVcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmNvbG9yVXI7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yVXIodikge1xuICAgICAgICB0aGlzLl9fY29yZS5jb2xvclVyID0gdjtcbiAgICB9XG5cbiAgICBnZXQgY29sb3JCbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmNvbG9yQmw7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yQmwodikge1xuICAgICAgICB0aGlzLl9fY29yZS5jb2xvckJsID0gdjtcbiAgICB9XG5cbiAgICBnZXQgY29sb3JCcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmNvbG9yQnI7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yQnIodikge1xuICAgICAgICB0aGlzLl9fY29yZS5jb2xvckJyID0gdjtcbiAgICB9XG5cbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5jb2xvclVsO1xuICAgIH1cblxuICAgIHNldCBjb2xvcih2KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbG9yVWwgIT09IHYgfHwgdGhpcy5jb2xvclVyICE9PSB2IHx8IHRoaXMuY29sb3JCbCAhPT0gdiB8fCB0aGlzLmNvbG9yQnIgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3JVbCA9IHY7XG4gICAgICAgICAgICB0aGlzLmNvbG9yVXIgPSB2O1xuICAgICAgICAgICAgdGhpcy5jb2xvckJsID0gdjtcbiAgICAgICAgICAgIHRoaXMuY29sb3JCciA9IHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY29sb3JUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yVWw7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yVG9wKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JVbCAhPT0gdiB8fCB0aGlzLmNvbG9yVXIgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3JVbCA9IHY7XG4gICAgICAgICAgICB0aGlzLmNvbG9yVXIgPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yQm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvckJsO1xuICAgIH1cblxuICAgIHNldCBjb2xvckJvdHRvbSh2KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbG9yQmwgIT09IHYgfHwgdGhpcy5jb2xvckJyICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yQmwgPSB2O1xuICAgICAgICAgICAgdGhpcy5jb2xvckJyID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjb2xvckxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yVWw7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yTGVmdCh2KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbG9yVWwgIT09IHYgfHwgdGhpcy5jb2xvckJsICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yVWwgPSB2O1xuICAgICAgICAgICAgdGhpcy5jb2xvckJsID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjb2xvclJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvclVyO1xuICAgIH1cblxuICAgIHNldCBjb2xvclJpZ2h0KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JVciAhPT0gdiB8fCB0aGlzLmNvbG9yQnIgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3JVciA9IHY7XG4gICAgICAgICAgICB0aGlzLmNvbG9yQnIgPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHpJbmRleCgpIHtyZXR1cm4gdGhpcy5fX2NvcmUuekluZGV4fVxuICAgIHNldCB6SW5kZXgodikge1xuICAgICAgICB0aGlzLl9fY29yZS56SW5kZXggPSB2O1xuICAgIH1cblxuICAgIGdldCBmb3JjZVpJbmRleENvbnRleHQoKSB7cmV0dXJuIHRoaXMuX19jb3JlLmZvcmNlWkluZGV4Q29udGV4dH1cbiAgICBzZXQgZm9yY2VaSW5kZXhDb250ZXh0KHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuZm9yY2VaSW5kZXhDb250ZXh0ID0gdjtcbiAgICB9XG5cbiAgICBnZXQgY2xpcHBpbmcoKSB7cmV0dXJuIHRoaXMuX19jb3JlLmNsaXBwaW5nfVxuICAgIHNldCBjbGlwcGluZyh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLmNsaXBwaW5nID0gdjtcbiAgICB9XG5cbiAgICBnZXQgY2xpcGJveCgpIHtyZXR1cm4gdGhpcy5fX2NvcmUuY2xpcGJveH1cbiAgICBzZXQgY2xpcGJveCh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLmNsaXBib3ggPSB2O1xuICAgIH1cblxuICAgIGdldCB0YWdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUYWdzKCk7XG4gICAgfVxuXG4gICAgc2V0IHRhZ3Modikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodikpIHYgPSBbdl07XG4gICAgICAgIHRoaXMuc2V0VGFncyh2KTtcbiAgICB9XG5cbiAgICBzZXQgdCh2KSB7XG4gICAgICAgIHRoaXMudGFncyA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IF9jaGlsZHJlbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fY2hpbGRMaXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9fY2hpbGRMaXN0ID0gbmV3IEVsZW1lbnRDaGlsZExpc3QodGhpcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fY2hpbGRMaXN0O1xuICAgIH1cblxuICAgIGdldCBjaGlsZExpc3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYWxsb3dDaGlsZHJlbkFjY2VzcygpKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiRGlyZWN0IGFjY2VzcyB0byBjaGlsZHJlbiBpcyBub3QgYWxsb3dlZCBpbiBcIiArIHRoaXMuZ2V0TG9jYXRpb25TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuICAgIH1cblxuICAgIGhhc0NoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsb3dDaGlsZHJlbkFjY2VzcygpICYmIHRoaXMuX19jaGlsZExpc3QgJiYgKHRoaXMuX19jaGlsZExpc3QubGVuZ3RoID4gMCk7XG4gICAgfVxuXG4gICAgX2FsbG93Q2hpbGRyZW5BY2Nlc3MoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRMaXN0LmdldCgpO1xuICAgIH1cblxuICAgIHNldCBjaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgICB0aGlzLmNoaWxkTGlzdC5wYXRjaChjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgYWRkKG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRMaXN0LmEobyk7XG4gICAgfVxuXG4gICAgZ2V0IHAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fcGFyZW50O1xuICAgIH1cblxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fcGFyZW50O1xuICAgIH1cblxuICAgIGdldCBzcmMoKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHR1cmUgJiYgdGhpcy50ZXh0dXJlIGluc3RhbmNlb2YgSW1hZ2VUZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLl9zcmM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IHNyYyh2KSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgSW1hZ2VUZXh0dXJlKHRoaXMuc3RhZ2UpO1xuICAgICAgICB0ZXh0dXJlLnNyYyA9IHY7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgfVxuXG4gICAgc2V0IG13KHYpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlLm13ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoJ1BsZWFzZSBzZXQgbXcgYWZ0ZXIgc2V0dGluZyBhIHRleHR1cmUuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgbWgodikge1xuICAgICAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUubWggPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcignUGxlYXNlIHNldCBtaCBhZnRlciBzZXR0aW5nIGEgdGV4dHVyZS4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCByZWN0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudGV4dHVyZSA9PT0gdGhpcy5zdGFnZS5yZWN0YW5nbGVUZXh0dXJlKTtcbiAgICB9XG5cbiAgICBzZXQgcmVjdCh2KSB7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLnN0YWdlLnJlY3RhbmdsZVRleHR1cmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW5hYmxlVGV4dFRleHR1cmUoKSB7XG4gICAgICAgIGlmICghdGhpcy50ZXh0dXJlIHx8ICEodGhpcy50ZXh0dXJlIGluc3RhbmNlb2YgVGV4dFRleHR1cmUpKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBuZXcgVGV4dFRleHR1cmUodGhpcy5zdGFnZSk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy50ZXh0dXJlLncgJiYgIXRoaXMudGV4dHVyZS5oKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5oZXJpdCBkaW1lbnNpb25zIGZyb20gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFsbG93cyB1c2VybGFuZCB0byBzZXQgZGltZW5zaW9ucyBvZiB0aGUgRWxlbWVudCBhbmQgdGhlbiBsYXRlciBzcGVjaWZ5IHRoZSB0ZXh0LlxuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS53ID0gdGhpcy53O1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5oID0gdGhpcy5oO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmU7XG4gICAgfVxuXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHR1cmUgJiYgKHRoaXMudGV4dHVyZSBpbnN0YW5jZW9mIFRleHRUZXh0dXJlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IHRleHQodikge1xuICAgICAgICBpZiAoIXRoaXMudGV4dHVyZSB8fCAhKHRoaXMudGV4dHVyZSBpbnN0YW5jZW9mIFRleHRUZXh0dXJlKSkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVUZXh0VGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVdGlscy5pc1N0cmluZyh2KSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlLnRleHQgPSB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlLnBhdGNoKHYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IG9uVXBkYXRlKGYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUub25VcGRhdGUgPSBmO1xuICAgIH1cblxuICAgIHNldCBvbkFmdGVyQ2FsY3MoZikge1xuICAgICAgICB0aGlzLl9fY29yZS5vbkFmdGVyQ2FsY3MgPSBmO1xuICAgIH1cblxuICAgIHNldCBvbkFmdGVyVXBkYXRlKGYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUub25BZnRlclVwZGF0ZSA9IGY7XG4gICAgfVxuXG4gICAgZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSB1cGRhdGUgbG9vcCBpcyBydW4uXG4gICAgICAgIHRoaXMuX19jb3JlLl9zZXRIYXNVcGRhdGVzKCk7XG4gICAgfVxuXG4gICAgZ2V0IHNoYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLnNoYWRlcjtcbiAgICB9XG5cbiAgICBzZXQgc2hhZGVyKHYpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2KSAmJiAhdi50eXBlKSB7XG4gICAgICAgICAgICAvLyBTZXR0aW5nIHByb3BlcnRpZXMgb24gYW4gZXhpc3Rpbmcgc2hhZGVyLlxuICAgICAgICAgICAgaWYgKHRoaXMuc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkZXIucGF0Y2godik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzaGFkZXIgPSBTaGFkZXIuY3JlYXRlKHRoaXMuc3RhZ2UsIHYpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fX2VuYWJsZWQgJiYgdGhpcy5fX2NvcmUuc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvcmUuc2hhZGVyLnJlbW92ZUVsZW1lbnQodGhpcy5fX2NvcmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9fY29yZS5zaGFkZXIgPSBzaGFkZXI7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fZW5hYmxlZCAmJiB0aGlzLl9fY29yZS5zaGFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29yZS5zaGFkZXIuYWRkRWxlbWVudCh0aGlzLl9fY29yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfaGFzVGV4dHVyaXplcigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fX2NvcmUuX3RleHR1cml6ZXI7XG4gICAgfVxuXG4gICAgZ2V0IHJlbmRlclRvVGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnR0XG4gICAgfVxuXG4gICAgc2V0IHJlbmRlclRvVGV4dHVyZSh2KSB7XG4gICAgICAgIHRoaXMucnR0ID0gdlxuICAgIH1cblxuICAgIGdldCBydHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNUZXh0dXJpemVyKCkgJiYgdGhpcy50ZXh0dXJpemVyLmVuYWJsZWQ7XG4gICAgfVxuXG4gICAgc2V0IHJ0dCh2KSB7XG4gICAgICAgIHRoaXMudGV4dHVyaXplci5lbmFibGVkID0gdjtcbiAgICB9XG5cbiAgICBnZXQgcnR0TGF6eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1RleHR1cml6ZXIoKSAmJiB0aGlzLnRleHR1cml6ZXIubGF6eTtcbiAgICB9XG5cbiAgICBzZXQgcnR0TGF6eSh2KSB7XG4gICAgICAgIHRoaXMudGV4dHVyaXplci5sYXp5ID0gdjtcbiAgICB9XG5cbiAgICBnZXQgcmVuZGVyT2Zmc2NyZWVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzVGV4dHVyaXplcigpICYmIHRoaXMudGV4dHVyaXplci5yZW5kZXJPZmZzY3JlZW47XG4gICAgfVxuXG4gICAgc2V0IHJlbmRlck9mZnNjcmVlbih2KSB7XG4gICAgICAgIHRoaXMudGV4dHVyaXplci5yZW5kZXJPZmZzY3JlZW4gPSB2O1xuICAgIH1cblxuICAgIGdldCBjb2xvcml6ZVJlc3VsdFRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNUZXh0dXJpemVyKCkgJiYgdGhpcy50ZXh0dXJpemVyLmNvbG9yaXplO1xuICAgIH1cblxuICAgIHNldCBjb2xvcml6ZVJlc3VsdFRleHR1cmUodikge1xuICAgICAgICB0aGlzLnRleHR1cml6ZXIuY29sb3JpemUgPSB2O1xuICAgIH1cblxuICAgIGdldFRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cml6ZXIuX2dldFRleHR1cmVTb3VyY2UoKTtcbiAgICB9XG5cbiAgICBnZXQgdGV4dHVyaXplcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLnRleHR1cml6ZXI7XG4gICAgfVxuXG4gICAgcGF0Y2goc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IHBhdGhzID0gT2JqZWN0LmtleXMoc2V0dGluZ3MpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gcGF0aHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcGF0aCA9IHBhdGhzW2ldO1xuICAgICAgICAgICAgY29uc3QgdiA9IHNldHRpbmdzW3BhdGhdO1xuXG4gICAgICAgICAgICBjb25zdCBmaXJzdENoYXJDb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzVWNDaGFyKGZpcnN0Q2hhckNvZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVmLlxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5nZXRCeVJlZihwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBsaXN0IGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2F0Y2ggdGhpcyBjYXNlIHRvIGNhcHR1cmUgY3JlYXRlTW9kZSBmbGFnLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0aGlzLmNoaWxkTGlzdC5jcmVhdGVJdGVtKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMucGF0Y2godik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5pc0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnJlZiA9IHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRMaXN0LmEoYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQucGFyZW50LmNoaWxkTGlzdC5yZW1vdmUoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQucGF0Y2godik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodi5pc0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgZWxlbWVudCBieSBuZXcgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHYucmVmID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRMaXN0LnJlcGxhY2UodiwgY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgZm9yIHBhdGg6IFwiICsgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFByb3BlcnR5LlxuICAgICAgICAgICAgICAgIEJhc2UucGF0Y2hPYmplY3RQcm9wZXJ0eSh0aGlzLCBwYXRoLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF90aHJvd0Vycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiIChcIiArIHRoaXMuZ2V0TG9jYXRpb25TdHJpbmcoKSArIFwiKTogXCIgKyBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBhbmltYXRpb24oc2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhZ2UuYW5pbWF0aW9ucy5jcmVhdGVBbmltYXRpb24odGhpcywgc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIHRyYW5zaXRpb24ocHJvcGVydHksIHNldHRpbmdzID0gbnVsbCkge1xuICAgICAgICBpZiAoc2V0dGluZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2l0aW9uKHByb3BlcnR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFRyYW5zaXRpb24ocHJvcGVydHksIHNldHRpbmdzKTtcbiAgICAgICAgICAgIC8vIFdlIGRvIG5vdCBjcmVhdGUvcmV0dXJuIHRoZSB0cmFuc2l0aW9uLCBiZWNhdXNlIGl0IHdvdWxkIHVuZG8gdGhlICdsYXp5IHRyYW5zaXRpb24gY3JlYXRpb24nIG9wdGltaXphdGlvbi5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IHRyYW5zaXRpb25zKG9iamVjdCkge1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICAgIGtleXMuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24ocHJvcGVydHksIG9iamVjdFtwcm9wZXJ0eV0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXQgc21vb3RoKG9iamVjdCkge1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICAgIGtleXMuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTbW9vdGgocHJvcGVydHksIHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U21vb3RoKHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZhc3RGb3J3YXJkKHByb3BlcnR5KSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2l0aW9ucykge1xuICAgICAgICAgICAgbGV0IHQgPSB0aGlzLl90cmFuc2l0aW9uc1twcm9wZXJ0eV07XG4gICAgICAgICAgICBpZiAodCAmJiB0LmlzVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIHQuZmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0VHJhbnNpdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ID0gdGhpcy5fdHJhbnNpdGlvbnNbcHJvcGVydHldO1xuICAgICAgICBpZiAoIXQpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IHRyYW5zaXRpb24uXG4gICAgICAgICAgICB0ID0gbmV3IFRyYW5zaXRpb24odGhpcy5zdGFnZS50cmFuc2l0aW9ucywgdGhpcy5zdGFnZS50cmFuc2l0aW9ucy5kZWZhdWx0VHJhbnNpdGlvblNldHRpbmdzLCB0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH0gZWxzZSBpZiAodC5pc1RyYW5zaXRpb25TZXR0aW5ncykge1xuICAgICAgICAgICAgLy8gVXBncmFkZSB0byAncmVhbCcgdHJhbnNpdGlvbi5cbiAgICAgICAgICAgIHQgPSBuZXcgVHJhbnNpdGlvbihcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLnRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uc1twcm9wZXJ0eV0gPSB0O1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG5cbiAgICBfc2V0VHJhbnNpdGlvbihwcm9wZXJ0eSwgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKCFzZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVHJhbnNpdGlvbihwcm9wZXJ0eSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHNldHRpbmdzKSkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgcGxhaW4gb2JqZWN0IHRvIHByb3BlciBzZXR0aW5ncyBvYmplY3QuXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSB0aGlzLnN0YWdlLnRyYW5zaXRpb25zLmNyZWF0ZVNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc2l0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25zID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5fdHJhbnNpdGlvbnNbcHJvcGVydHldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5pc1RyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBSdW50aW1lIHNldHRpbmdzIGNoYW5nZS5cbiAgICAgICAgICAgICAgICBjdXJyZW50LnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxseSwgb25seSBzZXQgdGhlIHNldHRpbmdzIGFuZCB1cGdyYWRlIHRvIGEgJ3JlYWwnIHRyYW5zaXRpb24gd2hlbiBpdCBpcyB1c2VkLlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25zW3Byb3BlcnR5XSA9IHNldHRpbmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3JlbW92ZVRyYW5zaXRpb24ocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdHJhbnNpdGlvbnNbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0U21vb3RoKHByb3BlcnR5LCB2KSB7XG4gICAgICAgIGxldCB0ID0gdGhpcy5fZ2V0VHJhbnNpdGlvbihwcm9wZXJ0eSk7XG4gICAgICAgIGlmICh0ICYmIHQuaXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdC50YXJnZXRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0U21vb3RoKHByb3BlcnR5LCB2LCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFRyYW5zaXRpb24ocHJvcGVydHksIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdCA9IHRoaXMuX2dldFRyYW5zaXRpb24ocHJvcGVydHkpO1xuICAgICAgICB0LnN0YXJ0KHYpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG5cbiAgICBnZXQgZmxleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmZsZXg7XG4gICAgfVxuXG4gICAgc2V0IGZsZXgodikge1xuICAgICAgICB0aGlzLl9fY29yZS5mbGV4ID0gdjtcbiAgICB9XG5cbiAgICBnZXQgZmxleEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5mbGV4SXRlbTtcbiAgICB9XG5cbiAgICBzZXQgZmxleEl0ZW0odikge1xuICAgICAgICB0aGlzLl9fY29yZS5mbGV4SXRlbSA9IHY7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzQ29sb3JQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHkudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiY29sb3JcIikgPj0gMDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0TWVyZ2VyKHByb3BlcnR5KSB7XG4gICAgICAgIGlmIChFbGVtZW50LmlzQ29sb3JQcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBTdGFnZVV0aWxzLm1lcmdlQ29sb3JzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN0YWdlVXRpbHMubWVyZ2VOdW1iZXJzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZWYgPSBbYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWBdO1xuICAgICAgICBjb25zdCB0cmVlID0ge307XG4gICAgICAgIHRyZWVbcmVmXSA9IHt9O1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgIEVsZW1lbnQuY29sbGVjdENoaWxkcmVuKHRyZWVbcmVmXSwgdGhpcy5fX2NoaWxkTGlzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmVlW3JlZl0gPSB7Li4uRWxlbWVudC5nZXRQcm9wZXJ0aWVzKHRoaXMpfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY29sbGVjdENoaWxkcmVuKHRyZWUsIGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTGlzdCA9IGNoaWxkcmVuO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGNoaWxkTGlzdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjaGlsZExpc3QuZ2V0QXQoaSk7XG4gICAgICAgICAgICBjb25zdCByZWYgPSBgJHtlbGVtZW50Ll9fcmVmIHx8IGBFbGVtZW50LSR7ZWxlbWVudC5pZH1gfWA7XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gdGhpcy5nZXRQcm9wZXJ0aWVzKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICB0cmVlW3JlZl0gPSB7Li4ucHJvcGVydGllc307XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICB0cmVlW3JlZl0uY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxlY3RDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgdHJlZVtyZWZdLmNoaWxkcmVuLCBlbGVtZW50Ll9fY2hpbGRMaXN0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRQcm9wZXJ0aWVzKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7fTtcbiAgICAgICAgY29uc3QgbGlzdCA9IFtcbiAgICAgICAgICAgIFwiYWxwaGFcIiwgXCJhY3RpdmVcIiwgXCJhdHRhY2hlZFwiLCBcImJvdW5kc01hcmdpblwiLCBcImNvbG9yXCIsIFwiY2xpcHBpbmdcIiwgXCJlbmFibGVkXCIsIFwiaFwiLCBcImlkXCIsIFwiaXNDb21wb25lbnRcIixcbiAgICAgICAgICAgIFwibW91bnRcIiwgXCJtb3VudFlcIiwgXCJtb3VudFhcIiwgXCJwaXZvdFwiLCBcInBpdm90WFwiLCBcInBpdm90WVwiLCBcInJlZlwiLCBcInJlbmRlck9mU2NyZWVuXCIsIFwicmVuZGVyVG9UZXh0dXJlXCIsIFwic2NhbGVcIixcbiAgICAgICAgICAgIFwic2NhbGVYXCIsIFwic2NhbGVZXCIsIFwic3RhdGVcIiwgXCJ0YWdcIiwgXCJ2aXNpYmxlXCIsIFwid1wiLCBcInhcIiwgXCJ5XCIsIFwiekluZGV4XCIsXG4gICAgICAgICAgICBcIiEhZmxleFwiLCBcIiEhZmxleEl0ZW1cIiwgXCJoYXNGb2N1cygpXCIsIFwiaGFzRmluYWxGb2N1cygpXCJcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IG4gPSBsaXN0Lmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICBsZXQga2V5ID0gbGlzdFtuXTtcbiAgICAgICAgICAgIGNvbnN0IGdldEJvb2xlYW4gPSAvXiF7Mn0vO1xuICAgICAgICAgICAgY29uc3QgaXNGdW5jdGlvbiA9IC9cXChcXCkkLztcblxuICAgICAgICAgICAgaWYgKGdldEJvb2xlYW4udGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5LnN1YnN0cmluZygyLCBrZXkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldID0gISFlbGVtZW50W2tleV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24udGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5LnN1YnN0cmluZygwLCBrZXkubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50W2tleV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1trZXldID0gZWxlbWVudFtrZXldKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldID0gZWxlbWVudFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7Li4ucHJvcHMsIC4uLmVsZW1lbnQuZ2V0Tm9uRGVmYXVsdHMoKX07XG4gICAgfVxufVxuXG4vLyBUaGlzIGdpdmVzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGJlbmVmaXQgY29tcGFyZWQgdG8gZXh0ZW5kaW5nIEV2ZW50RW1pdHRlci5cbkV2ZW50RW1pdHRlci5hZGRBc01peGluKEVsZW1lbnQpO1xuXG5FbGVtZW50LnByb3RvdHlwZS5pc0VsZW1lbnQgPSAxO1xuXG5FbGVtZW50LmlkID0gMTtcblxuLy8gR2V0dGVycyByZXVzZWQgd2hlbiByZWZlcmVuY2luZyBlbGVtZW50IChzdWJvYmplY3QpIHByb3BlcnRpZXMgYnkgYSBwcm9wZXJ0eSBwYXRoLCBhcyB1c2VkIGluIGEgdHJhbnNpdGlvbiBvciBhbmltYXRpb24gKCd4JywgJ3RleHR1cmUueCcsIGV0YykuXG5FbGVtZW50LlBST1BfR0VUVEVSUyA9IG5ldyBNYXAoKTtcblxuLy8gU2V0dGVycyByZXVzZWQgd2hlbiByZWZlcmVuY2luZyBlbGVtZW50IChzdWJvYmplY3QpIHByb3BlcnRpZXMgYnkgYSBwcm9wZXJ0eSBwYXRoLCBhcyB1c2VkIGluIGEgdHJhbnNpdGlvbiBvciBhbmltYXRpb24gKCd4JywgJ3RleHR1cmUueCcsIGV0YykuXG5FbGVtZW50LlBST1BfU0VUVEVSUyA9IG5ldyBNYXAoKTtcblxuaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4vVGV4dHVyZS5tanNcIjtcbmltcG9ydCBJbWFnZVRleHR1cmUgZnJvbSBcIi4uL3RleHR1cmVzL0ltYWdlVGV4dHVyZS5tanNcIjtcbmltcG9ydCBUZXh0VGV4dHVyZSBmcm9tIFwiLi4vdGV4dHVyZXMvVGV4dFRleHR1cmUubWpzXCI7XG5pbXBvcnQgU291cmNlVGV4dHVyZSBmcm9tIFwiLi4vdGV4dHVyZXMvU291cmNlVGV4dHVyZS5tanNcIjtcbmltcG9ydCBUcmFuc2l0aW9uIGZyb20gXCIuLi9hbmltYXRpb24vVHJhbnNpdGlvbi5tanNcIjtcbmltcG9ydCBFbGVtZW50Q2hpbGRMaXN0IGZyb20gXCIuL0VsZW1lbnRDaGlsZExpc3QubWpzXCI7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIGxpc3Qgb2YgY2hpbGRyZW4gZm9yIGFuIGVsZW1lbnQuXG4gKi9cblxuaW1wb3J0IE9iamVjdExpc3QgZnJvbSBcIi4vT2JqZWN0TGlzdC5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudENoaWxkTGlzdCBleHRlbmRzIE9iamVjdExpc3Qge1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB9XG5cbiAgICBfY29ubmVjdFBhcmVudChpdGVtKSB7XG4gICAgICAgIGNvbnN0IHByZXZQYXJlbnQgPSBpdGVtLnBhcmVudDtcbiAgICAgICAgaWYgKHByZXZQYXJlbnQgJiYgcHJldlBhcmVudCAhPT0gdGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gQ2xlYW51cCBpbiBwcmV2aW91cyBjaGlsZCBsaXN0LCB3aXRob3V0XG4gICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGRMaXN0ID0gaXRlbS5wYXJlbnQuY2hpbGRMaXN0O1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwcmV2Q2hpbGRMaXN0LmdldEluZGV4KGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5yZWYpIHtcbiAgICAgICAgICAgICAgICBwcmV2Q2hpbGRMaXN0Ll9yZWZzW2l0ZW0ucmVmXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZDaGlsZExpc3QuX2l0ZW1zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgIC8vIEFsc28gY2xlYW4gdXAgZWxlbWVudCBjb3JlLlxuICAgICAgICAgICAgcHJldlBhcmVudC5jb3JlLnJlbW92ZUNoaWxkQXQoaW5kZXgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtLl9zZXRQYXJlbnQodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2UgYXJlIGV4cGVjdGluZyB0aGUgY2FsbGVyIHRvIHN5bmMgaXQgdG8gdGhlIGNvcmUuXG4gICAgfVxuXG4gICAgb25BZGQoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdFBhcmVudChpdGVtKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jb3JlLmFkZENoaWxkQXQoaW5kZXgsIGl0ZW0uY29yZSk7XG4gICAgfVxuXG4gICAgb25SZW1vdmUoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaXRlbS5fc2V0UGFyZW50KG51bGwpO1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNvcmUucmVtb3ZlQ2hpbGRBdChpbmRleCk7XG4gICAgfVxuXG4gICAgb25TeW5jKHJlbW92ZWQsIGFkZGVkLCBvcmRlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHJlbW92ZWQubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICByZW1vdmVkW2ldLl9zZXRQYXJlbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhZGRlZC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RQYXJlbnQoYWRkZWRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnYyA9IGkgPT4gaS5jb3JlO1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNvcmUuc3luY0NoaWxkcmVuKHJlbW92ZWQubWFwKGdjKSwgYWRkZWQubWFwKGdjKSwgb3JkZXIubWFwKGdjKSk7XG4gICAgfVxuXG4gICAgb25TZXQoaXRlbSwgaW5kZXgsIHByZXZJdGVtKSB7XG4gICAgICAgIHByZXZJdGVtLl9zZXRQYXJlbnQobnVsbCk7XG5cbiAgICAgICAgdGhpcy5fY29ubmVjdFBhcmVudChpdGVtKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jb3JlLnNldENoaWxkQXQoaW5kZXgsIGl0ZW0uY29yZSk7XG4gICAgfVxuXG4gICAgb25Nb3ZlKGl0ZW0sIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNvcmUubW92ZUNoaWxkKGZyb21JbmRleCwgdG9JbmRleCk7XG4gICAgfVxuXG4gICAgY3JlYXRlSXRlbShvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdC50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG9iamVjdC50eXBlKHRoaXMuX2VsZW1lbnQuc3RhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuc3RhZ2UuY3JlYXRlRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNJdGVtKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0LmlzRWxlbWVudDtcbiAgICB9XG5cbn1cblxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIE1hbmFnZXMgYSBsaXN0IG9mIG9iamVjdHMuXG4gKiBPYmplY3RzIG1heSBiZSBwYXRjaGVkLiBUaGVuLCB0aGV5IGNhbiBiZSByZWZlcmVuY2VkIHVzaW5nIHRoZSAncmVmJyAoc3RyaW5nKSBwcm9wZXJ0eS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JqZWN0TGlzdCB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVmcyA9IHt9XG4gICAgfVxuXG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gICAgfVxuXG4gICAgZ2V0IGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbMF07XG4gICAgfVxuXG4gICAgZ2V0IGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGggPyB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBhZGQoaXRlbSkge1xuICAgICAgICB0aGlzLmFkZEF0KGl0ZW0sIHRoaXMuX2l0ZW1zLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgYWRkQXQoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPD0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvID0gaXRlbTtcbiAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5jcmVhdGVJdGVtKG8pO1xuICAgICAgICAgICAgICAgIGl0ZW0ucGF0Y2gobyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0KGl0ZW0sIGluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnNbaXRlbS5yZWZdID0gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQWRkKGl0ZW0sIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkQXQ6IFRoZSBpbmRleCAnICsgaW5kZXggKyAnIGlzIG91dCBvZiBib3VuZHMgJyArIHRoaXMuX2l0ZW1zLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXBsYWNlQnlSZWYoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5yZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuZ2V0QnlSZWYoaXRlbS5yZWYpO1xuICAgICAgICAgICAgaWYgKCFleGlzdGluZ0l0ZW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcGxhY2VCeVJlZjogbm8gaXRlbSBmb3VuZCB3aXRoIHJlZmVyZW5jZTogJyArIGl0ZW0ucmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVwbGFjZShpdGVtLCBleGlzdGluZ0l0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXBsYWNlQnlSZWY6IG5vIHJlZiBzcGVjaWZpZWQgaW4gaXRlbScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkQXQoaXRlbSwgdGhpcy5faXRlbXMubGVuZ3RoKTtcblxuICAgIH1cblxuICAgIHJlcGxhY2UoaXRlbSwgcHJldkl0ZW0pIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEluZGV4KHByZXZJdGVtKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXBsYWNlOiBUaGUgcHJldmlvdXMgaXRlbSBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QXQoaXRlbSwgaW5kZXgpO1xuICAgIH1cblxuICAgIHNldEF0KGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5faXRlbXMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvID0gaXRlbTtcbiAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5jcmVhdGVJdGVtKG8pO1xuICAgICAgICAgICAgICAgIGl0ZW0ucGF0Y2gobyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb21JbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21JbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Nb3ZlKGl0ZW0sIGZyb21JbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZW1zW2luZGV4XS5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnNbdGhpcy5faXRlbXNbaW5kZXhdLnJlZl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2SXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0OiBvdmVyd3JpdGUgY3VycmVudC5cbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtc1tpbmRleF0gPSBpdGVtO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnNbaXRlbS5yZWZdID0gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9uU2V0KGl0ZW0sIGluZGV4LCBwcmV2SXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldEF0OiBUaGUgaW5kZXggJyArIGluZGV4ICsgJyBpcyBvdXQgb2YgYm91bmRzICcgKyB0aGlzLl9pdGVtcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0QXQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICB9XG5cbiAgICBnZXRJbmRleChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgIH1cblxuICAgIHJlbW92ZShpdGVtKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBdChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVtb3ZlQXQoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG5cbiAgICAgICAgICAgIGlmIChpdGVtLnJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZnNbaXRlbS5yZWZdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICB0aGlzLm9uUmVtb3ZlKGl0ZW0sIGluZGV4KTtcblxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlbW92ZUF0OiBUaGUgaW5kZXggJHtpbmRleH0gaXMgb3V0IG9mIGJvdW5kcyAke3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDF9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGxldCBuID0gdGhpcy5faXRlbXMubGVuZ3RoO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLl9pdGVtcztcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgICAgICAgICB0aGlzLl9yZWZzID0ge31cbiAgICAgICAgICAgIHRoaXMub25TeW5jKHByZXYsIFtdLCBbXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYShvKSB7XG4gICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwobykpIHtcbiAgICAgICAgICAgIGxldCBjID0gdGhpcy5jcmVhdGVJdGVtKG8pO1xuICAgICAgICAgICAgYy5wYXRjaChvKTtcbiAgICAgICAgICAgIHRoaXMuYWRkKGMpO1xuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBvLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYShvW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNJdGVtKG8pKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChvKTtcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgX2dldFJlZnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZzO1xuICAgIH1cblxuICAgIGdldEJ5UmVmKHJlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmc1tyZWZdO1xuICAgIH1cblxuICAgIGNsZWFyUmVmKHJlZikge1xuICAgICAgICBkZWxldGUgdGhpcy5fcmVmc1tyZWZdO1xuICAgIH1cblxuICAgIHNldFJlZihyZWYsIGNoaWxkKSB7XG4gICAgICAgIHRoaXMuX3JlZnNbcmVmXSA9IGNoaWxkO1xuICAgIH1cblxuICAgIHBhdGNoKHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwoc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRCeU9iamVjdChzZXR0aW5ncyk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZXR0aW5ncykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEJ5QXJyYXkoc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NldEJ5T2JqZWN0KHNldHRpbmdzKSB7XG4gICAgICAgIC8vIE92ZXJydWxlIHNldHRpbmdzIG9mIGtub3duIHJlZmVyZW5jZWQgaXRlbXMuXG4gICAgICAgIGxldCByZWZzID0gdGhpcy5fZ2V0UmVmcygpO1xuICAgICAgICBsZXQgY3JlZnMgPSBPYmplY3Qua2V5cyhzZXR0aW5ncyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gY3JlZnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3JlZiA9IGNyZWZzW2ldO1xuICAgICAgICAgICAgbGV0IHMgPSBzZXR0aW5nc1tjcmVmXTtcblxuICAgICAgICAgICAgbGV0IGMgPSByZWZzW2NyZWZdO1xuICAgICAgICAgICAgaWYgKCFjKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJdGVtKHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgcHJldmlvdXMgaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgcy5yZWYgPSBjcmVmO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IGl0ZW0uXG4gICAgICAgICAgICAgICAgICAgIGMgPSB0aGlzLmNyZWF0ZUl0ZW0ocyk7XG4gICAgICAgICAgICAgICAgICAgIGMucmVmID0gY3JlZjtcbiAgICAgICAgICAgICAgICAgICAgYy5wYXRjaChzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0l0ZW0ocykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgIT09IHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgcHJldmlvdXMgaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpZHggPSB0aGlzLmdldEluZGV4KGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5yZWYgPSBjcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdChzLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYy5wYXRjaChzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZXF1YWxzQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgbGV0IHNhbWUgPSB0cnVlO1xuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID09PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5faXRlbXMubGVuZ3RoOyAoaSA8IG4pICYmIHNhbWU7IGkrKykge1xuICAgICAgICAgICAgICAgIHNhbWUgPSBzYW1lICYmICh0aGlzLl9pdGVtc1tpXSA9PT0gYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2FtZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYW1lO1xuICAgIH1cblxuICAgIF9zZXRCeUFycmF5KGFycmF5KSB7XG4gICAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBmaXJzdCBjaGVjayBpZiB0aGUgYXJyYXlzIG1hdGNoIGV4YWN0bHkgYW5kIGJhaWwgb3V0IGlmIHRoZXkgZG8uXG4gICAgICAgIGlmICh0aGlzLl9lcXVhbHNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5faXRlbXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtc1tpXS5tYXJrZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlZnM7XG4gICAgICAgIGxldCBuZXdJdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGFycmF5Lmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbGV0IHMgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSXRlbShzKSkge1xuICAgICAgICAgICAgICAgIHMubWFya2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmV3SXRlbXMucHVzaChzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNyZWYgPSBzLnJlZjtcbiAgICAgICAgICAgICAgICBsZXQgYztcbiAgICAgICAgICAgICAgICBpZiAoY3JlZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZnMpIHJlZnMgPSB0aGlzLl9nZXRSZWZzKCk7XG4gICAgICAgICAgICAgICAgICAgIGMgPSByZWZzW2NyZWZdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghYykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IGl0ZW0uXG4gICAgICAgICAgICAgICAgICAgIGMgPSB0aGlzLmNyZWF0ZUl0ZW0ocyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYy5tYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGMucGF0Y2gocyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV3SXRlbXMucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldEl0ZW1zKG5ld0l0ZW1zKTtcbiAgICB9XG5cbiAgICBfc2V0SXRlbXMobmV3SXRlbXMpIHtcbiAgICAgICAgbGV0IHByZXZJdGVtcyA9IHRoaXMuX2l0ZW1zO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IG5ld0l0ZW1zO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgaXRlbXMuXG4gICAgICAgIGxldCByZW1vdmVkID0gcHJldkl0ZW1zLmZpbHRlcihpdGVtID0+IHtsZXQgbSA9IGl0ZW0ubWFya2VyOyBkZWxldGUgaXRlbS5tYXJrZXI7IHJldHVybiBtfSk7XG4gICAgICAgIGxldCBhZGRlZCA9IG5ld0l0ZW1zLmZpbHRlcihpdGVtID0+IChwcmV2SXRlbXMuaW5kZXhPZihpdGVtKSA9PT0gLTEpKTtcblxuICAgICAgICBpZiAocmVtb3ZlZC5sZW5ndGggfHwgYWRkZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSByZWZzLlxuICAgICAgICAgICAgdGhpcy5fcmVmcyA9IHt9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByZWYgPSB0aGlzLl9pdGVtc1tpXS5yZWY7XG4gICAgICAgICAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZzW3JlZl0gPSB0aGlzLl9pdGVtc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uU3luYyhyZW1vdmVkLCBhZGRlZCwgbmV3SXRlbXMpO1xuICAgIH1cblxuICAgIHNvcnQoZikge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2l0ZW1zLnNsaWNlKCk7XG4gICAgICAgIGl0ZW1zLnNvcnQoZik7XG4gICAgICAgIHRoaXMuX3NldEJ5QXJyYXkoaXRlbXMpO1xuICAgIH1cblxuICAgIG9uQWRkKGl0ZW0sIGluZGV4KSB7XG4gICAgfVxuXG4gICAgb25SZW1vdmUoaXRlbSwgaW5kZXgpIHtcbiAgICB9XG5cbiAgICBvblN5bmMocmVtb3ZlZCwgYWRkZWQsIG9yZGVyKSB7XG4gICAgfVxuXG4gICAgb25TZXQoaXRlbSwgaW5kZXgsIHByZXZJdGVtKSB7XG4gICAgfVxuXG4gICAgb25Nb3ZlKGl0ZW0sIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgIH1cblxuICAgIGNyZWF0ZUl0ZW0ob2JqZWN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdExpc3QuY3JlYXRlSXRlbSBtdXN0IGNyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IG9iamVjdFwiKTtcbiAgICB9XG5cbiAgICBpc0l0ZW0ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgdGhpcy5nZXQoKS5mb3JFYWNoKGYpO1xuICAgIH1cblxufVxuXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4vVXRpbHMubWpzXCI7XG5cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFV0aWxzIGZyb20gXCIuL1V0aWxzLm1qc1wiO1xuaW1wb3J0IEJhc2UgZnJvbSBcIi4vQmFzZS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvcmVDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5jdHggPSBjb3JlQ29udGV4dDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIChlbmFibGVkKSBlbGVtZW50cyB0aGF0IHVzZSB0aGlzIHNoYWRlci5cbiAgICAgICAgICogQHR5cGUge1NldDxFbGVtZW50Q29yZT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IG5ldyBTZXQoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlKHN0YWdlLCB2KSB7XG4gICAgICAgIGxldCBzaGFkZXI7XG4gICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwodikpIHtcbiAgICAgICAgICAgIGlmICh2LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBzaGFkZXIgPSBzdGFnZS5yZW5kZXJlci5jcmVhdGVTaGFkZXIoc3RhZ2UuY3R4LCB2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhZGVyID0gdGhpcy5zaGFkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaGFkZXIpIHtcbiAgICAgICAgICAgICAgICBCYXNlLnBhdGNoT2JqZWN0KHNoYWRlciwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc2hhZGVyID0gc3RhZ2UuY3R4LnJlbmRlclN0YXRlLmRlZmF1bHRTaGFkZXI7XG4gICAgICAgIH0gZWxzZSBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzaGFkZXIgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHYuaXNTaGFkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YWdlLnJlbmRlcmVyLmlzVmFsaWRTaGFkZXJUeXBlKHYuY29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbTGlnaHRuaW5nXSBJbnZhbGlkIHNoYWRlciB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICB2ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2hhZGVyID0gdjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltMaWdodG5pbmddIFBsZWFzZSBzcGVjaWZ5IGEgc2hhZGVyIHR5cGUuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFdlYkdMKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRDMmQoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgYWRkRWxlbWVudChlbGVtZW50Q29yZSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50cy5hZGQoZWxlbWVudENvcmUpO1xuICAgIH1cblxuICAgIHJlbW92ZUVsZW1lbnQoZWxlbWVudENvcmUpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMuZGVsZXRlKGVsZW1lbnRDb3JlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWRyYXcoKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzLmZvckVhY2goZWxlbWVudENvcmUgPT4ge1xuICAgICAgICAgICAgZWxlbWVudENvcmUuc2V0SGFzUmVuZGVyVXBkYXRlcygyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGF0Y2goc2V0dGluZ3MpIHtcbiAgICAgICAgQmFzZS5wYXRjaE9iamVjdCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgLy8gU2hvdWxkIHJldHVybiB0cnVlIGlmIHRoaXMgc2hhZGVyIGlzIGNvbmZpZ3VyZWQgKHVzaW5nIGl0J3MgcHJvcGVydGllcykgdG8gbm90IGhhdmUgYW55IGVmZmVjdC5cbiAgICAgICAgLy8gVGhpcyBtYXkgYWxsb3cgdGhlIHJlbmRlciBlbmdpbmUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgc2hhZGVyIHByb2dyYW0gc3dpdGNoZXMgb3IgZXZlbiB0ZXh0dXJlIGNvcGllcy5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGFkZEVtcHR5KCkge1xuICAgICAgICAvLyBEcmF3cyB0aGlzIHNoYWRlciBldmVuIGlmIHRoZXJlIGFyZSBubyBxdWFkcyB0byBiZSBhZGRlZC5cbiAgICAgICAgLy8gVGhpcyBpcyBoYW5keSBmb3IgY3VzdG9tIHNoYWRlcnMuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICAvLyBDYWxsZWQgd2hlbiBubyBtb3JlIGVuYWJsZWQgZWxlbWVudHMgaGF2ZSB0aGlzIHNoYWRlci5cbiAgICB9XG5cbiAgICBnZXQgaXNTaGFkZXIoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBBcHBsaWNhdGlvbiByZW5kZXIgdHJlZS5cbiAqL1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCIuLi9FdmVudEVtaXR0ZXIubWpzXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4vVXRpbHMubWpzXCI7XG5pbXBvcnQgV2ViR0xSZW5kZXJlciBmcm9tIFwiLi4vcmVuZGVyZXIvd2ViZ2wvV2ViR0xSZW5kZXJlci5tanNcIjtcbmltcG9ydCBDMmRSZW5kZXJlciBmcm9tIFwiLi4vcmVuZGVyZXIvYzJkL0MyZFJlbmRlcmVyLm1qc1wiO1xuaW1wb3J0IFNwYXJrUmVuZGVyZXIgZnJvbSBcIi4uL3JlbmRlcmVyL3NwYXJrL1NwYXJrUmVuZGVyZXIubWpzXCI7XG5pbXBvcnQgUGxhdGZvcm1Mb2FkZXIgZnJvbSBcIi4uL3BsYXRmb3Jtcy9QbGF0Zm9ybUxvYWRlci5tanNcIjtcbmltcG9ydCBXZWJHTFN0YXRlTWFuYWdlciBmcm9tIFwiLi4vdG9vbHMvV2ViR0xTdGF0ZU1hbmFnZXIubWpzXCI7XG5pbXBvcnQgU2hhZGVyIGZyb20gXCIuL1NoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhZ2UgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3NldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fdXNlZE1lbW9yeSA9IDA7XG4gICAgICAgIHRoaXMuX2xhc3RHY0ZyYW1lID0gMDtcblxuICAgICAgICBjb25zdCBwbGF0Zm9ybVR5cGUgPSBTdGFnZS5wbGF0Zm9ybSA/IFN0YWdlLnBsYXRmb3JtIDogUGxhdGZvcm1Mb2FkZXIubG9hZChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyBwbGF0Zm9ybVR5cGUoKTtcblxuICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybS5pbml0KSB7XG4gICAgICAgICAgICB0aGlzLnBsYXRmb3JtLmluaXQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdsID0gbnVsbDtcbiAgICAgICAgdGhpcy5jMmQgPSBudWxsO1xuXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldE9wdGlvbignY29udGV4dCcpO1xuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQudXNlUHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wgPSBjb250ZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmMyZCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNXZWIgJiYgKCFTdGFnZS5pc1dlYmdsU3VwcG9ydGVkKCkgfHwgdGhpcy5nZXRPcHRpb24oJ2NhbnZhczJkJykpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jMmQgPSB0aGlzLnBsYXRmb3JtLmNyZWF0ZUNhbnZhc0NvbnRleHQodGhpcy5nZXRPcHRpb24oJ3cnKSwgdGhpcy5nZXRPcHRpb24oJ2gnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wgPSB0aGlzLnBsYXRmb3JtLmNyZWF0ZVdlYkdMQ29udGV4dCh0aGlzLmdldE9wdGlvbigndycpLCB0aGlzLmdldE9wdGlvbignaCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdsKSB7XG4gICAgICAgICAgICAvLyBXcmFwIGluIFdlYkdMU3RhdGVNYW5hZ2VyLlxuICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyB1bm5lY2Vzc2FyeSBkb3VibGUgV2ViR0wgY29tbWFuZHMgZnJvbSBiZWluZyBleGVjdXRlZCwgYW5kIGFsbG93cyBjb250ZXh0IHN3aXRjaGluZy5cbiAgICAgICAgICAgIC8vIENvbnRleHQgc3dpdGNoaW5nIGlzIG5lY2Vzc2FyeSB3aGVuIHJldXNpbmcgdGhlIHNhbWUgY29udGV4dCBmb3IgVGhyZWUuanMuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIHVzZXIgbXVzdCBtYWtlIHN1cmUgdGhhdCB0aGUgV2ViR0wgY29udGV4dCBpcyB1bnRvdWNoZWQgYmVmb3JlIGNyZWF0aW5nIHRoZSBhcHBsaWNhdGlvbixcbiAgICAgICAgICAgIC8vICB3aGVuIG1hbnVhbGx5IHBhc3Npbmcgb3ZlciBhIGNhbnZhcyBvciBjb250ZXh0IGluIHRoZSBvcHRpb25zLlxuICAgICAgICAgICAgV2ViR0xTdGF0ZU1hbmFnZXIuZW5hYmxlKHRoaXMuZ2wsIFwibGlnaHRuaW5nXCIpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb2RlID0gdGhpcy5nbCA/IDAgOiAxO1xuXG4gICAgICAgIC8vIE92ZXJyaWRlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgIGlmICh0aGlzLmdldENhbnZhcygpKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLncgPSB0aGlzLmdldENhbnZhcygpLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5oID0gdGhpcy5nZXRDYW52YXMoKS5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzU3BhcmspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBTcGFya1JlbmRlcmVyKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBuZXcgQzJkUmVuZGVyZXIodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldENsZWFyQ29sb3IodGhpcy5nZXRPcHRpb24oJ2NsZWFyQ29sb3InKSk7XG5cbiAgICAgICAgdGhpcy5mcmFtZUNvdW50ZXIgPSAwO1xuXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgVHJhbnNpdGlvbk1hbmFnZXIodGhpcyk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25NYW5hZ2VyKHRoaXMpO1xuXG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgVGV4dHVyZU1hbmFnZXIodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dHVyZVRocm90dGxlciA9IG5ldyBUZXh0dXJlVGhyb3R0bGVyKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gICAgICAgIHRoaXMuZHQgPSAwO1xuXG4gICAgICAgIC8vIFByZWxvYWQgcmVjdGFuZ2xlIHRleHR1cmUsIHNvIHRoYXQgd2UgY2FuIHNraXAgc29tZSBib3JkZXIgY2hlY2tzIGZvciBsb2FkaW5nIHRleHR1cmVzLlxuICAgICAgICB0aGlzLnJlY3RhbmdsZVRleHR1cmUgPSBuZXcgUmVjdGFuZ2xlVGV4dHVyZSh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWN0YW5nbGVUZXh0dXJlLmxvYWQoKTtcblxuICAgICAgICAvLyBOZXZlciBjbGVhbiB1cCBiZWNhdXNlIHdlIHVzZSBpdCBhbGwgdGhlIHRpbWUuXG4gICAgICAgIHRoaXMucmVjdGFuZ2xlVGV4dHVyZS5zb3VyY2UucGVybWFuZW50ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmN0eCA9IG5ldyBDb3JlQ29udGV4dCh0aGlzKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVTb3VyY2VUZXh0dXJlcyA9IG5ldyBTZXQoKTtcbiAgICB9XG5cbiAgICBnZXQgcmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlcjtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNXZWJnbFN1cHBvcnRlZCgpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICEhd2luZG93LldlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZW5kZXJpbmcgbW9kZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqICAwOiBXZWJHTFxuICAgICAqICAxOiBDYW52YXMyZFxuICAgICAqL1xuICAgIGdldCBtb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgICB9XG5cbiAgICBpc1dlYmdsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSAwO1xuICAgIH1cblxuICAgIGlzQzJkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSAxO1xuICAgIH1cblxuICAgIGdldE9wdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zW25hbWVdO1xuICAgIH1cblxuICAgIF9zZXRPcHRpb25zKG8pIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIGxldCBvcHQgPSAobmFtZSwgZGVmKSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBvW25hbWVdO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnNbbmFtZV0gPSBkZWY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdCgnY2FudmFzJywgbnVsbCk7XG4gICAgICAgIG9wdCgnY29udGV4dCcsIG51bGwpO1xuICAgICAgICBvcHQoJ3cnLCAxOTIwKTtcbiAgICAgICAgb3B0KCdoJywgMTA4MCk7XG4gICAgICAgIG9wdCgnc3JjQmFzZVBhdGgnLCBudWxsKTtcbiAgICAgICAgb3B0KCdtZW1vcnlQcmVzc3VyZScsIDI0ZTYpO1xuICAgICAgICBvcHQoJ2J1ZmZlck1lbW9yeScsIDJlNik7XG4gICAgICAgIG9wdCgndGV4dFJlbmRlcklzc3VlTWFyZ2luJywgMCk7XG4gICAgICAgIG9wdCgnZm9udFNoYXJwJyx7cHJlY2lzaW9uOjAuNjY2NjY2NjY2NywgZm9udFNpemU6IDI0fSlcbiAgICAgICAgb3B0KCdjbGVhckNvbG9yJywgWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgb3B0KCdkZWZhdWx0Rm9udEZhY2UnLCAnc2Fucy1zZXJpZicpO1xuICAgICAgICBvcHQoJ2ZpeGVkRHQnLCAwKTtcbiAgICAgICAgb3B0KCd1c2VJbWFnZVdvcmtlcicsIHRydWUpO1xuICAgICAgICBvcHQoJ2F1dG9zdGFydCcsIHRydWUpO1xuICAgICAgICBvcHQoJ3ByZWNpc2lvbicsIDEpO1xuICAgICAgICBvcHQoJ2NhbnZhczJkJywgZmFsc2UpO1xuICAgICAgICBvcHQoJ3BsYXRmb3JtJywgbnVsbCk7XG4gICAgICAgIG9wdCgncmVhZFBpeGVsc0JlZm9yZURyYXcnLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgc2V0QXBwbGljYXRpb24oYXBwKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24gPSBhcHA7XG4gICAgfVxuXG4gICAgaW5pdCgpIHtcblxuICAgICAgICBpZiAodGhpcy5hcHBsaWNhdGlvbi5nZXRPcHRpb24oJ2RlYnVnJykgJiYgdGhpcy5wbGF0Zm9ybS5faW1hZ2VXb3JrZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbTGlnaHRuaW5nXSBVc2luZyBpbWFnZSB3b3JrZXIhJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hcHBsaWNhdGlvbi5nZXRPcHRpb24oJ2RlYnVnJykgJiYgdGhpcy5jMmQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbTGlnaHRuaW5nXSBVc2luZyBjYW52YXMyZCByZW5kZXJlcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5zZXRBc1Jvb3QoKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9uKCdhdXRvc3RhcnQnKSkge1xuICAgICAgICAgICAgdGhpcy5wbGF0Zm9ybS5zdGFydExvb3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm0uc3RvcExvb3AoKTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY3R4LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnBsYXRmb3JtLnN0b3BMb29wKCk7XG4gICAgfVxuXG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnBsYXRmb3JtLnN0YXJ0TG9vcCgpO1xuICAgIH1cblxuICAgIGdldCByb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbjtcbiAgICB9XG5cbiAgICBnZXRDYW52YXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlID8gdGhpcy5jMmQuY2FudmFzIDogdGhpcy5nbC5jYW52YXM7XG4gICAgfVxuXG4gICAgZ2V0UmVuZGVyUHJlY2lzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5wcmVjaXNpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFya3MgYSB0ZXh0dXJlIGZvciB1cGRhdGluZyBpdCdzIHNvdXJjZSB1cG9uIHRoZSBuZXh0IGRyYXdGcmFtZS5cbiAgICAgKiBAcGFyYW0gdGV4dHVyZVxuICAgICAqL1xuICAgIGFkZFVwZGF0ZVNvdXJjZVRleHR1cmUodGV4dHVyZSkge1xuICAgICAgICBpZiAodGhpcy5fdXBkYXRpbmdGcmFtZSkge1xuICAgICAgICAgICAgLy8gV2hlbiBjYWxsZWQgZnJvbSB0aGUgdXBsb2FkIGxvb3AsIHdlIG11c3QgaW1tZWRpYXRlbHkgbG9hZCB0aGUgdGV4dHVyZSBpbiBvcmRlciB0byBhdm9pZCBhICdmbGFzaCcuXG4gICAgICAgICAgICB0ZXh0dXJlLl9wZXJmb3JtVXBkYXRlU291cmNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTb3VyY2VUZXh0dXJlcy5hZGQodGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVVcGRhdGVTb3VyY2VUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZVNvdXJjZVRleHR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTb3VyY2VUZXh0dXJlcy5kZWxldGUodGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNVcGRhdGVTb3VyY2VUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl91cGRhdGVTb3VyY2VUZXh0dXJlcyAmJiB0aGlzLl91cGRhdGVTb3VyY2VUZXh0dXJlcy5oYXModGV4dHVyZSkpO1xuICAgIH1cblxuICAgIGRyYXdGcmFtZSgpIHtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGhpcy5wbGF0Zm9ybS5nZXRIclRpbWUoKTtcblxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5maXhlZER0KSB7XG4gICAgICAgICAgICB0aGlzLmR0ID0gdGhpcy5fb3B0aW9ucy5maXhlZER0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kdCA9ICghdGhpcy5zdGFydFRpbWUpID8gLjAyIDogLjAwMSAqICh0aGlzLmN1cnJlbnRUaW1lIC0gdGhpcy5zdGFydFRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdmcmFtZVN0YXJ0Jyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZVNvdXJjZVRleHR1cmVzLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNvdXJjZVRleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5fcGVyZm9ybVVwZGF0ZVNvdXJjZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTb3VyY2VUZXh0dXJlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJyk7XG5cbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuY3R4Lmhhc1JlbmRlclVwZGF0ZXMoKTtcblxuICAgICAgICAvLyBVcGRhdGUgbWF5IGNhdXNlIHRleHR1cmVzIHRvIGJlIGxvYWRlZCBpbiBzeW5jLCBzbyBieSBwcm9jZXNzaW5nIHRoZW0gaGVyZSB3ZSBtYXkgYmUgYWJsZSB0byBzaG93IHRoZW1cbiAgICAgICAgLy8gZHVyaW5nIHRoZSBjdXJyZW50IGZyYW1lIGFscmVhZHkuXG4gICAgICAgIHRoaXMudGV4dHVyZVRocm90dGxlci5wcm9jZXNzU29tZSgpO1xuXG4gICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGluZ0ZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY3R4LnVwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5jdHgucmVuZGVyKCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGluZ0ZyYW1lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBsYXRmb3JtLm5leHRGcmFtZShjaGFuZ2VzKTtcblxuICAgICAgICB0aGlzLmVtaXQoJ2ZyYW1lRW5kJyk7XG5cbiAgICAgICAgdGhpcy5mcmFtZUNvdW50ZXIrKztcbiAgICB9XG5cbiAgICBpc1VwZGF0aW5nRnJhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGluZ0ZyYW1lO1xuICAgIH1cblxuICAgIHJlbmRlckZyYW1lKCkge1xuICAgICAgICB0aGlzLmN0eC5mcmFtZSgpO1xuICAgIH1cblxuICAgIGZvcmNlUmVuZGVyVXBkYXRlKCkge1xuICAgICAgICAvLyBFbmZvcmNlIHJlLXJlbmRlcmluZy5cbiAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5yb290LmNvcmUuX3BhcmVudC5zZXRIYXNSZW5kZXJVcGRhdGVzKDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Q2xlYXJDb2xvcihjbGVhckNvbG9yKSB7XG4gICAgICAgIHRoaXMuZm9yY2VSZW5kZXJVcGRhdGUoKTtcbiAgICAgICAgaWYgKGNsZWFyQ29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBjbGVhci5cbiAgICAgICAgICAgIHRoaXMuX2NsZWFyQ29sb3IgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2xlYXJDb2xvcikpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyQ29sb3IgPSBjbGVhckNvbG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJDb2xvciA9IFN0YWdlVXRpbHMuZ2V0UmdiYUNvbXBvbmVudHNOb3JtYWxpemVkKGNsZWFyQ29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q2xlYXJDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsZWFyQ29sb3I7XG4gICAgfVxuXG4gICAgY3JlYXRlRWxlbWVudChzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQoc2V0dGluZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlU2hhZGVyKHNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBTaGFkZXIuY3JlYXRlKHRoaXMsIHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBlbGVtZW50KHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5pc0VsZW1lbnQpIHJldHVybiBzZXR0aW5ncztcblxuICAgICAgICBsZXQgZWxlbWVudDtcbiAgICAgICAgaWYgKHNldHRpbmdzLnR5cGUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgc2V0dGluZ3MudHlwZSh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQucGF0Y2goc2V0dGluZ3MpO1xuXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGMoc2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudChzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnc7XG4gICAgfVxuXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmg7XG4gICAgfVxuXG4gICAgZ2V0IGNvb3Jkc1dpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53IC8gdGhpcy5fb3B0aW9ucy5wcmVjaXNpb247XG4gICAgfVxuXG4gICAgZ2V0IGNvb3Jkc0hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaCAvIHRoaXMuX29wdGlvbnMucHJlY2lzaW9uO1xuICAgIH1cblxuICAgIGFkZE1lbW9yeVVzYWdlKGRlbHRhKSB7XG4gICAgICAgIHRoaXMuX3VzZWRNZW1vcnkgKz0gZGVsdGE7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0R2NGcmFtZSAhPT0gdGhpcy5mcmFtZUNvdW50ZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl91c2VkTWVtb3J5ID4gdGhpcy5nZXRPcHRpb24oJ21lbW9yeVByZXNzdXJlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdjKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXNlZE1lbW9yeSA+IHRoaXMuZ2V0T3B0aW9uKCdtZW1vcnlQcmVzc3VyZScpIC0gMmU2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRvbyBmZXcgcmVsZWFzZWQuIEFnZ3Jlc3NpdmUgY2xlYW51cC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYyh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdXNlZE1lbW9yeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZWRNZW1vcnk7XG4gICAgfVxuXG4gICAgZ2MoYWdncmVzc2l2ZSkge1xuICAgICAgICBpZiAodGhpcy5fbGFzdEdjRnJhbWUgIT09IHRoaXMuZnJhbWVDb3VudGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0R2NGcmFtZSA9IHRoaXMuZnJhbWVDb3VudGVyO1xuICAgICAgICAgICAgY29uc3QgbWVtb3J5VXNhZ2VCZWZvcmUgPSB0aGlzLl91c2VkTWVtb3J5O1xuICAgICAgICAgICAgdGhpcy5nY1RleHR1cmVNZW1vcnkoYWdncmVzc2l2ZSk7XG4gICAgICAgICAgICB0aGlzLmdjUmVuZGVyVGV4dHVyZU1lbW9yeShhZ2dyZXNzaXZlKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZ2MoYWdncmVzc2l2ZSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uLmdldE9wdGlvbignZGVidWcnKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbTGlnaHRuaW5nXSBHQyR7YWdncmVzc2l2ZSA/IFwiW2FnZ3Jlc3NpdmVdXCIgOiBcIlwifSEgRnJhbWUgJHt0aGlzLl9sYXN0R2NGcmFtZX0gRnJlZWQgJHsoKG1lbW9yeVVzYWdlQmVmb3JlIC0gdGhpcy5fdXNlZE1lbW9yeSkgLyAxZTYpLnRvRml4ZWQoMil9TVAgZnJvbSBHUFUgbWVtb3J5LiBSZW1haW5pbmc6ICR7KHRoaXMuX3VzZWRNZW1vcnkgLyAxZTYpLnRvRml4ZWQoMil9TVBgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlciA9IHRoaXMuX3VzZWRNZW1vcnkgLSB0aGlzLnRleHR1cmVNYW5hZ2VyLnVzZWRNZW1vcnkgLSB0aGlzLmN0eC51c2VkTWVtb3J5O1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbTGlnaHRuaW5nXSBUZXh0dXJlczogJHsodGhpcy50ZXh0dXJlTWFuYWdlci51c2VkTWVtb3J5IC8gMWU2KS50b0ZpeGVkKDIpfU1QLCBSZW5kZXIgVGV4dHVyZXM6ICR7KHRoaXMuY3R4LnVzZWRNZW1vcnkgLyAxZTYpLnRvRml4ZWQoMil9TVAsIFJlbmRlcmVyIGNhY2hlczogJHsob3RoZXIgLyAxZTYpLnRvRml4ZWQoMil9TVBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdjVGV4dHVyZU1lbW9yeShhZ2dyZXNzaXZlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGFnZ3Jlc3NpdmUgJiYgdGhpcy5jdHgucm9vdC52aXNpYmxlKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBBTEwgdGV4dHVyZXMgYXJlIGNsZWFuZWQ7XG4gICAgICAgICAgICB0aGlzLmN0eC5yb290LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIuZ2MoKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LnJvb3QudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLmdjKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnY1JlbmRlclRleHR1cmVNZW1vcnkoYWdncmVzc2l2ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChhZ2dyZXNzaXZlICYmIHRoaXMucm9vdC52aXNpYmxlKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBBTEwgcmVuZGVyIHRleHR1cmVzIGFyZSBjbGVhbmVkO1xuICAgICAgICAgICAgdGhpcy5yb290LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmZyZWVVbnVzZWRSZW5kZXJUZXh0dXJlcygwKTtcbiAgICAgICAgICAgIHRoaXMucm9vdC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmZyZWVVbnVzZWRSZW5kZXJUZXh0dXJlcygwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldERyYXdpbmdDYW52YXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsYXRmb3JtLmdldERyYXdpbmdDYW52YXMoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuY3R4LnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgYWRkU2VydmljZVByb3ZpZGVyKHNlcnZpY2Vwcm92aWRlcikge1xuICAgICAgICBpZiAoVXRpbHMuaXNTcGFyaykge1xuICAgICAgICAgICAgdGhpcy5wbGF0Zm9ybS5hZGRTZXJ2aWNlUHJvdmlkZXIoc2VydmljZXByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldENoaWxkcmVuQnlQb3NpdGlvbih4LCB5KXtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5yb290LmNvcmUudXBkYXRlKCk7XG4gICAgICAgIHRoaXMucm9vdC5jb3JlLmNvbGxlY3RBdENvb3JkKHgseSxjaGlsZHJlbik7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbn1cblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4vRWxlbWVudC5tanNcIjtcbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuL1N0YWdlVXRpbHMubWpzXCI7XG5pbXBvcnQgVGV4dHVyZU1hbmFnZXIgZnJvbSBcIi4vVGV4dHVyZU1hbmFnZXIubWpzXCI7XG5pbXBvcnQgVGV4dHVyZVRocm90dGxlciBmcm9tIFwiLi9UZXh0dXJlVGhyb3R0bGVyLm1qc1wiO1xuaW1wb3J0IENvcmVDb250ZXh0IGZyb20gXCIuL2NvcmUvQ29yZUNvbnRleHQubWpzXCI7XG5pbXBvcnQgVHJhbnNpdGlvbk1hbmFnZXIgZnJvbSBcIi4uL2FuaW1hdGlvbi9UcmFuc2l0aW9uTWFuYWdlci5tanNcIjtcbmltcG9ydCBBbmltYXRpb25NYW5hZ2VyIGZyb20gXCIuLi9hbmltYXRpb24vQW5pbWF0aW9uTWFuYWdlci5tanNcIjtcbmltcG9ydCBSZWN0YW5nbGVUZXh0dXJlIGZyb20gXCIuLi90ZXh0dXJlcy9SZWN0YW5nbGVUZXh0dXJlLm1qc1wiO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhZ2VVdGlscyB7XG5cbiAgICBzdGF0aWMgbWVyZ2VOdW1iZXJzKHYxLCB2MiwgcCkge1xuICAgICAgICByZXR1cm4gdjEgKiBwICsgdjIgKiAoMSAtIHApO1xuICAgIH07XG5cbiAgICBzdGF0aWMgcmdiKHIsIGcsIGIpIHtcbiAgICAgICAgcmV0dXJuIChyIDw8IDE2KSArIChnIDw8IDgpICsgYiArICgyNTUgKiAxNjc3NzIxNik7XG4gICAgfTtcblxuICAgIHN0YXRpYyByZ2JhKHIsIGcsIGIsIGEpIHtcbiAgICAgICAgcmV0dXJuIChyIDw8IDE2KSArIChnIDw8IDgpICsgYiArICgoKGEgKiAyNTUpIHwgMCkgKiAxNjc3NzIxNik7XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRSZ2JTdHJpbmcoY29sb3IpIHtcbiAgICAgICAgbGV0IHIgPSAoKGNvbG9yIC8gNjU1MzYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBnID0gKChjb2xvciAvIDI1NikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGIgPSBjb2xvciAlIDI1NjtcbiAgICAgICAgcmV0dXJuICdyZ2IoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcpJztcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldFJnYmFTdHJpbmcoY29sb3IpIHtcbiAgICAgICAgbGV0IHIgPSAoKGNvbG9yIC8gNjU1MzYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBnID0gKChjb2xvciAvIDI1NikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGIgPSBjb2xvciAlIDI1NjtcbiAgICAgICAgbGV0IGEgPSAoKGNvbG9yIC8gMTY3NzcyMTYpIHwgMCkgLyAyNTU7XG4gICAgICAgIHJldHVybiAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYS50b0ZpeGVkKDQpICsgJyknO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0UmdiYVN0cmluZ0Zyb21BcnJheShjb2xvcikge1xuICAgICAgICBsZXQgciA9IE1hdGguZmxvb3IoY29sb3JbMF0gKiAyNTUpO1xuICAgICAgICBsZXQgZyA9IE1hdGguZmxvb3IoY29sb3JbMV0gKiAyNTUpO1xuICAgICAgICBsZXQgYiA9IE1hdGguZmxvb3IoY29sb3JbMl0gKiAyNTUpO1xuICAgICAgICBsZXQgYSA9IE1hdGguZmxvb3IoY29sb3JbM10gKiAyNTUpIC8gMjU1O1xuICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEudG9GaXhlZCg0KSArICcpJztcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldFJnYmFDb21wb25lbnRzTm9ybWFsaXplZChhcmdiKSB7XG4gICAgICAgIGxldCByID0gKChhcmdiIC8gNjU1MzYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBnID0gKChhcmdiIC8gMjU2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgYiA9IGFyZ2IgJSAyNTY7XG4gICAgICAgIGxldCBhID0gKChhcmdiIC8gMTY3NzcyMTYpIHwgMCk7XG4gICAgICAgIHJldHVybiBbciAvIDI1NSwgZyAvIDI1NSwgYiAvIDI1NSwgYSAvIDI1NV07XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRSZ2JDb21wb25lbnRzTm9ybWFsaXplZChhcmdiKSB7XG4gICAgICAgIGxldCByID0gKChhcmdiIC8gNjU1MzYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBnID0gKChhcmdiIC8gMjU2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgYiA9IGFyZ2IgJSAyNTY7XG4gICAgICAgIHJldHVybiBbciAvIDI1NSwgZyAvIDI1NSwgYiAvIDI1NV07XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRSZ2JhQ29tcG9uZW50cyhhcmdiKSB7XG4gICAgICAgIGxldCByID0gKChhcmdiIC8gNjU1MzYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBnID0gKChhcmdiIC8gMjU2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgYiA9IGFyZ2IgJSAyNTY7XG4gICAgICAgIGxldCBhID0gKChhcmdiIC8gMTY3NzcyMTYpIHwgMCk7XG4gICAgICAgIHJldHVybiBbciwgZywgYiwgYV07XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRBcmdiTnVtYmVyKHJnYmEpIHtcbiAgICAgICAgcmdiYVswXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiYVswXSkpO1xuICAgICAgICByZ2JhWzFdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2JhWzFdKSk7XG4gICAgICAgIHJnYmFbMl0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYmFbMl0pKTtcbiAgICAgICAgcmdiYVszXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiYVszXSkpO1xuICAgICAgICBsZXQgdiA9ICgocmdiYVszXSB8IDApIDw8IDI0KSArICgocmdiYVswXSB8IDApIDw8IDE2KSArICgocmdiYVsxXSB8IDApIDw8IDgpICsgKHJnYmFbMl0gfCAwKTtcbiAgICAgICAgaWYgKHYgPCAwKSB7XG4gICAgICAgICAgICB2ID0gMHhGRkZGRkZGRiArIHYgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH07XG5cbiAgICBzdGF0aWMgbWVyZ2VDb2xvcnMoYzEsIGMyLCBwKSB7XG4gICAgICAgIGxldCByMSA9ICgoYzEgLyA2NTUzNikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGcxID0gKChjMSAvIDI1NikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGIxID0gYzEgJSAyNTY7XG4gICAgICAgIGxldCBhMSA9ICgoYzEgLyAxNjc3NzIxNikgfCAwKTtcblxuICAgICAgICBsZXQgcjIgPSAoKGMyIC8gNjU1MzYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBnMiA9ICgoYzIgLyAyNTYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBiMiA9IGMyICUgMjU2O1xuICAgICAgICBsZXQgYTIgPSAoKGMyIC8gMTY3NzcyMTYpIHwgMCk7XG5cbiAgICAgICAgbGV0IHIgPSByMSAqIHAgKyByMiAqICgxIC0gcCk7XG4gICAgICAgIGxldCBnID0gZzEgKiBwICsgZzIgKiAoMSAtIHApO1xuICAgICAgICBsZXQgYiA9IGIxICogcCArIGIyICogKDEgLSBwKTtcbiAgICAgICAgbGV0IGEgPSBhMSAqIHAgKyBhMiAqICgxIC0gcCk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoYSkgKiAxNjc3NzIxNiArIE1hdGgucm91bmQocikgKiA2NTUzNiArIE1hdGgucm91bmQoZykgKiAyNTYgKyBNYXRoLnJvdW5kKGIpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgbWVyZ2VNdWx0aUNvbG9ycyhjLCBwKSB7XG4gICAgICAgIGxldCByID0gMCwgZyA9IDAsIGIgPSAwLCBhID0gMCwgdCA9IDA7XG4gICAgICAgIGxldCBuID0gYy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcjEgPSAoKGNbaV0gLyA2NTUzNikgfCAwKSAlIDI1NjtcbiAgICAgICAgICAgIGxldCBnMSA9ICgoY1tpXSAvIDI1NikgfCAwKSAlIDI1NjtcbiAgICAgICAgICAgIGxldCBiMSA9IGNbaV0gJSAyNTY7XG4gICAgICAgICAgICBsZXQgYTEgPSAoKGNbaV0gLyAxNjc3NzIxNikgfCAwKTtcbiAgICAgICAgICAgIHIgKz0gcjEgKiBwW2ldO1xuICAgICAgICAgICAgZyArPSBnMSAqIHBbaV07XG4gICAgICAgICAgICBiICs9IGIxICogcFtpXTtcbiAgICAgICAgICAgIGEgKz0gYTEgKiBwW2ldO1xuICAgICAgICAgICAgdCArPSBwW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgdCA9IDEgLyB0O1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChhICogdCkgKiAxNjc3NzIxNiArIE1hdGgucm91bmQociAqIHQpICogNjU1MzYgKyBNYXRoLnJvdW5kKGcgKiB0KSAqIDI1NiArIE1hdGgucm91bmQoYiAqIHQpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgbWVyZ2VNdWx0aUNvbG9yc0VxdWFsKGMpIHtcbiAgICAgICAgbGV0IHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAwLCB0ID0gMDtcbiAgICAgICAgbGV0IG4gPSBjLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByMSA9ICgoY1tpXSAvIDY1NTM2KSB8IDApICUgMjU2O1xuICAgICAgICAgICAgbGV0IGcxID0gKChjW2ldIC8gMjU2KSB8IDApICUgMjU2O1xuICAgICAgICAgICAgbGV0IGIxID0gY1tpXSAlIDI1NjtcbiAgICAgICAgICAgIGxldCBhMSA9ICgoY1tpXSAvIDE2Nzc3MjE2KSB8IDApO1xuICAgICAgICAgICAgciArPSByMTtcbiAgICAgICAgICAgIGcgKz0gZzE7XG4gICAgICAgICAgICBiICs9IGIxO1xuICAgICAgICAgICAgYSArPSBhMTtcbiAgICAgICAgICAgIHQgKz0gMS4wO1xuICAgICAgICB9XG5cbiAgICAgICAgdCA9IDEgLyB0O1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChhICogdCkgKiAxNjc3NzIxNiArIE1hdGgucm91bmQociAqIHQpICogNjU1MzYgKyBNYXRoLnJvdW5kKGcgKiB0KSAqIDI1NiArIE1hdGgucm91bmQoYiAqIHQpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgbWVyZ2VDb2xvckFscGhhKGMsIGFscGhhKSB7XG4gICAgICAgIGxldCBhID0gKChjIC8gMTY3NzcyMTYgfCAwKSAqIGFscGhhKSB8IDA7XG4gICAgICAgIHJldHVybiAoKCgoKGMgPj4gMTYpICYgMHhmZikgKiBhKSAvIDI1NSkgJiAweGZmKSArXG4gICAgICAgICAgICAoKCgoYyAmIDB4ZmYwMCkgKiBhKSAvIDI1NSkgJiAweGZmMDApICtcbiAgICAgICAgICAgICgoKCgoYyAmIDB4ZmYpIDw8IDE2KSAqIGEpIC8gMjU1KSAmIDB4ZmYwMDAwKSArXG4gICAgICAgICAgICAoYSA8PCAyNCk7XG4gICAgfTtcblxuICAgIHN0YXRpYyByYWQoZGVnKSB7XG4gICAgICAgIHJldHVybiBkZWcgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRUaW1pbmdCZXppZXIoYSwgYiwgYywgZCkge1xuICAgICAgICBsZXQgeGMgPSAzLjAgKiBhO1xuICAgICAgICBsZXQgeGIgPSAzLjAgKiAoYyAtIGEpIC0geGM7XG4gICAgICAgIGxldCB4YSA9IDEuMCAtIHhjIC0geGI7XG4gICAgICAgIGxldCB5YyA9IDMuMCAqIGI7XG4gICAgICAgIGxldCB5YiA9IDMuMCAqIChkIC0gYikgLSB5YztcbiAgICAgICAgbGV0IHlhID0gMS4wIC0geWMgLSB5YjtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aW1lID49IDEuMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWUgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgdCA9IDAuNSwgY2J4LCBjYnhkLCBkeDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaXQgPSAwOyBpdCA8IDIwOyBpdCsrKSB7XG4gICAgICAgICAgICAgICAgY2J4ID0gdCAqICh0ICogKHQgKiB4YSArIHhiKSArIHhjKTtcbiAgICAgICAgICAgICAgICBkeCA9IHRpbWUgLSBjYng7XG4gICAgICAgICAgICAgICAgaWYgKGR4ID4gLTFlLTggJiYgZHggPCAxZS04KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ICogKHQgKiAodCAqIHlhICsgeWIpICsgeWMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEN1YmljIGJlemllciBkZXJpdmF0aXZlLlxuICAgICAgICAgICAgICAgIGNieGQgPSB0ICogKHQgKiAoMyAqIHhhKSArIDIgKiB4YikgKyB4YztcblxuICAgICAgICAgICAgICAgIGlmIChjYnhkID4gMWUtMTAgJiYgY2J4ZCA8IDFlLTEwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb2JsZW1hdGljLiBGYWxsIGJhY2sgdG8gYmluYXJ5IHNlYXJjaCBtZXRob2QuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHQgKz0gZHggLyBjYnhkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGYWxsYmFjazogYmluYXJ5IHNlYXJjaCBtZXRob2QuIFRoaXMgaXMgbW9yZSByZWxpYWJsZSB3aGVuIHRoZXJlIGFyZSBuZWFyLTAgc2xvcGVzLlxuICAgICAgICAgICAgbGV0IG1pblQgPSAwO1xuICAgICAgICAgICAgbGV0IG1heFQgPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgaXQgPSAwOyBpdCA8IDIwOyBpdCsrKSB7XG4gICAgICAgICAgICAgICAgdCA9IDAuNSAqIChtaW5UICsgbWF4VCk7XG5cbiAgICAgICAgICAgICAgICBjYnggPSB0ICogKHQgKiAodCAqIHhhICsgeGIpICsgeGMpO1xuXG4gICAgICAgICAgICAgICAgZHggPSB0aW1lIC0gY2J4O1xuICAgICAgICAgICAgICAgIGlmIChkeCA+IC0xZS04ICYmIGR4IDwgMWUtOCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTb2x1dGlvbiBmb3VuZCFcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgKiAodCAqICh0ICogeWEgKyB5YikgKyB5Yyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGR4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhUID0gdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtaW5UID0gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldFRpbWluZ0Z1bmN0aW9uKHN0cikge1xuICAgICAgICBzd2l0Y2ggKHN0cikge1xuICAgICAgICAgICAgY2FzZSBcImxpbmVhclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZWFzZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBTdGFnZVV0aWxzLmdldFRpbWluZ0JlemllcigwLjI1LCAwLjEsIDAuMjUsIDEuMCk7XG4gICAgICAgICAgICBjYXNlIFwiZWFzZS1pblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBTdGFnZVV0aWxzLmdldFRpbWluZ0JlemllcigwLjQyLCAwLCAxLjAsIDEuMCk7XG4gICAgICAgICAgICBjYXNlIFwiZWFzZS1vdXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RhZ2VVdGlscy5nZXRUaW1pbmdCZXppZXIoMCwgMCwgMC41OCwgMS4wKTtcbiAgICAgICAgICAgIGNhc2UgXCJlYXNlLWluLW91dFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBTdGFnZVV0aWxzLmdldFRpbWluZ0JlemllcigwLjQyLCAwLCAwLjU4LCAxLjApO1xuICAgICAgICAgICAgY2FzZSBcInN0ZXAtc3RhcnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwic3RlcC1lbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWUgPT09IDEgPyAxIDogMDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBsZXQgcyA9IFwiY3ViaWMtYmV6aWVyKFwiO1xuICAgICAgICAgICAgICAgIGlmIChzdHIgJiYgc3RyLmluZGV4T2YocykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRzID0gc3RyLnN1YnN0cihzLmxlbmd0aCwgc3RyLmxlbmd0aCAtIHMubGVuZ3RoIC0gMSkuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbTGlnaHRuaW5nXSBVbmtub3duIHRpbWluZyBmdW5jdGlvbjogXCIgKyBzdHIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjazogdXNlIGxpbmVhci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBhID0gcGFyc2VGbG9hdChwYXJ0c1swXSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiID0gcGFyc2VGbG9hdChwYXJ0c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjID0gcGFyc2VGbG9hdChwYXJ0c1syXSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcGFyc2VGbG9hdChwYXJ0c1szXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihhKSB8fCBpc05hTihiKSB8fCBpc05hTihjKSB8fCBpc05hTihkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0xpZ2h0bmluZ10gVW5rbm93biB0aW1pbmcgZnVuY3Rpb246IFwiICsgc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrOiB1c2UgbGluZWFyLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RhZ2VVdGlscy5nZXRUaW1pbmdCZXppZXIoYSwgYiwgYywgZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0xpZ2h0bmluZ10gVW5rbm93biB0aW1pbmcgZnVuY3Rpb246IFwiICsgc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IHVzZSBsaW5lYXIuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuXG4gICAgICAgIHRoaXMubWFuYWdlciA9IHRoaXMuc3RhZ2UudGV4dHVyZU1hbmFnZXI7XG5cbiAgICAgICAgdGhpcy5pZCA9IFRleHR1cmUuaWQrKztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIGVuYWJsZWQgZWxlbWVudHMgdGhhdCB1c2UgdGhpcyB0ZXh0dXJlIG9iamVjdCAoZWl0aGVyIGFzIHRleHR1cmUgb3IgZGlzcGxheWVkVGV4dHVyZSkuXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8RWxlbWVudD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGVuYWJsZWQgZWxlbWVudHMgdGhhdCBhcmUgYWN0aXZlLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWN0aXZlQ291bnQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXNzb2NpYXRlZCB0ZXh0dXJlIHNvdXJjZS5cbiAgICAgICAgICogU2hvdWxkIG5vdCBiZSBjaGFuZ2VkLlxuICAgICAgICAgKiBAdHlwZSB7VGV4dHVyZVNvdXJjZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVzaXplIG1vZGUgY2FuIGJlIHNldCB0byBjb3ZlciBvciBjb250YWluIGEgY2VydGFpbiBhcmVhLlxuICAgICAgICAgKiBJdCB3aWxsIHJlc2V0IHRoZSB0ZXh0dXJlIGNsaXBwaW5nIHNldHRpbmdzLlxuICAgICAgICAgKiBXaGVuIG1hbnVhbCB0ZXh0dXJlIGNsaXBwaW5nIGlzIHBlcmZvcm1lZCwgdGhlIHJlc2l6ZU1vZGUgaXMgcmVzZXQuXG4gICAgICAgICAqIEB0eXBlIHt7dHlwZTogc3RyaW5nLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZXNpemVNb2RlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHR1cmUgY2xpcHBpbmcgeC1vZmZzZXQuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl94ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHR1cmUgY2xpcHBpbmcgeS1vZmZzZXQuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl95ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHR1cmUgY2xpcHBpbmcgd2lkdGguIElmIDAgdGhlbiBmdWxsIHdpZHRoLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdyA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0dXJlIGNsaXBwaW5nIGhlaWdodC4gSWYgMCB0aGVuIGZ1bGwgaGVpZ2h0LlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciBwcmVjaXNpb24gKDAuNSA9IGZ1enp5LCAxID0gbm9ybWFsLCAyID0gc2hhcnAgZXZlbiB3aGVuIHNjYWxlZCB0d2ljZSwgZXRjLikuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcmVjaXNpb24gPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgKG1heGltdW0pIGV4cGVjdGVkIHRleHR1cmUgc291cmNlIHdpZHRoLiBVc2VkIGZvciB3aXRoaW4gYm91bmRzIGRldGVybWluYXRpb24gd2hpbGUgdGV4dHVyZSBpcyBub3QgeWV0IGxvYWRlZC5cbiAgICAgICAgICogSWYgbm90IHNldCwgMjA0OCBpcyB1c2VkIGJ5IEVsZW1lbnRDb3JlLnVwZGF0ZS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXcgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgKG1heGltdW0pIGV4cGVjdGVkIHRleHR1cmUgc291cmNlIGhlaWdodC4gVXNlZCBmb3Igd2l0aGluIGJvdW5kcyBkZXRlcm1pbmF0aW9uIHdoaWxlIHRleHR1cmUgaXMgbm90IHlldCBsb2FkZWQuXG4gICAgICAgICAqIElmIG5vdCBzZXQsIDIwNDggaXMgdXNlZCBieSBFbGVtZW50Q29yZS51cGRhdGUuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1oID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIGlmIFRleHR1cmUucHJvdG90eXBlLnRleHR1cmUgdXNlcyBjbGlwcGluZy5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaXBwaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgdGV4dHVyZSBtdXN0IHVwZGF0ZSAod2hlbiBpdCBiZWNvbWVzIHVzZWQgYWdhaW4pLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX211c3RVcGRhdGUgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX211c3RVcGRhdGUgfHwgdGhpcy5zdGFnZS5oYXNVcGRhdGVTb3VyY2VUZXh0dXJlKHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU291cmNlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5yZW1vdmVVcGRhdGVTb3VyY2VUZXh0dXJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gICAgfVxuXG4gICAgYWRkRWxlbWVudCh2KSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50cy5oYXModikpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuYWRkKHYpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50cy5zaXplID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UuYWRkVGV4dHVyZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2LmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jQWN0aXZlQ291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUVsZW1lbnQodikge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50cy5kZWxldGUodikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5yZW1vdmVUZXh0dXJlKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHYuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNBY3RpdmVDb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5jQWN0aXZlQ291bnQoKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRleHR1cmUgc291cmNlJ3MgYWN0aXZlQ291bnQgaGFzIHRyYW5zZmVycmVkIG93bmVyc2hpcC5cbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG5cbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JOZXdlclJldXNhYmxlVGV4dHVyZVNvdXJjZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlQ291bnQrKztcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmJlY29tZXNVc2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWNBY3RpdmVDb3VudCgpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7IC8vIEZvcmNlIHVwZGF0aW5nIHRoZSBzb3VyY2UuXG4gICAgICAgIHRoaXMuX2FjdGl2ZUNvdW50LS07XG4gICAgICAgIGlmICghdGhpcy5fYWN0aXZlQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuYmVjb21lc1VudXNlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYmVjb21lc1VzZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UuaW5jQWN0aXZlVGV4dHVyZUNvdW50KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkxvYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXNpemVNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBseVJlc2l6ZU1vZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQub25UZXh0dXJlU291cmNlTG9hZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9jaGVja0Zvck5ld2VyUmV1c2FibGVUZXh0dXJlU291cmNlKCkge1xuICAgICAgICAvLyBXaGVuIHRoaXMgc291cmNlIGJlY2FtZSB1bnVzZWQgYW5kIGNsZWFuZWQgdXAsIGl0IG1heSBoYXZlIGRpc2FwcGVhcmVkIGZyb20gdGhlIHJldXNhYmxlIHRleHR1cmUgbWFwLlxuICAgICAgICAvLyBJbiB0aGUgbWVhbnRpbWUgYW5vdGhlciB0ZXh0dXJlIG1heSBoYXZlIGJlZW4gZ2VuZXJhdGVkIGxvYWRlZCB3aXRoIHRoZSBzYW1lIGxvb2t1cCBpZC5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgY2FzZSwgdXNlIHRoYXQgb25lIGluc3RlYWQgdG8gbWFrZSBzdXJlIG9ubHkgb25lIGFjdGl2ZSB0ZXh0dXJlIHNvdXJjZSBwZXIgbG9va3VwIGlkIGV4aXN0cy5cbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGlmICghc291cmNlLmlzTG9hZGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldXNhYmxlID0gdGhpcy5fZ2V0UmV1c2FibGVUZXh0dXJlU291cmNlKCk7XG4gICAgICAgICAgICBpZiAocmV1c2FibGUgJiYgcmV1c2FibGUuaXNMb2FkZWQoKSAmJiAocmV1c2FibGUgIT09IHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBsYWNlVGV4dHVyZVNvdXJjZShyZXVzYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVzaXplTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5UmVzaXplTW9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYmVjb21lc1VudXNlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5kZWNBY3RpdmVUZXh0dXJlQ291bnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzVXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUNvdW50ID4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb29rdXAgaWQgZm9yIHRoZSBjdXJyZW50IHRleHR1cmUgc2V0dGluZ3MsIHRvIGJlIGFibGUgdG8gcmV1c2UgaXQuXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIF9nZXRMb29rdXBJZCgpIHtcbiAgICAgICAgLy8gRGVmYXVsdDogZG8gbm90IHJldXNlIHRleHR1cmUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIGxvYWRlciBmdW5jdGlvbiB0aGF0IGlzIGFibGUgdG8gZ2VuZXJhdGUgdGhlIHRleHR1cmUgZm9yIHRoZSBjdXJyZW50IHNldHRpbmdzIG9mIHRoaXMgdGV4dHVyZS5cbiAgICAgKiBJdCBzaG91bGQgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHNpbmdsZSBjYWxsYmFjayBhcmd1bWVudC5cbiAgICAgKiBUaGF0IGNhbGxiYWNrIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czpcbiAgICAgKiAgIC0gZXJyXG4gICAgICogICAtIG9wdGlvbnM6IG9iamVjdFxuICAgICAqICAgICAtIHNvdXJjZTogQXJyYXlCdWZmZXJ8V2ViR2xUZXh0dXJlfEltYWdlRGF0YXxIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SW1hZ2VCaXRtYXBcbiAgICAgKiAgICAgLSB3OiBOdW1iZXJcbiAgICAgKiAgICAgLSBoOiBOdW1iZXJcbiAgICAgKiAgICAgLSBwZXJtYW5lbnQ6IEJvb2xlYW5cbiAgICAgKiAgICAgLSBoYXNBbHBoYTogYm9vbGVhblxuICAgICAqICAgICAtIHBlcm11bHRpcGx5QWxwaGE6IGJvb2xlYW5cbiAgICAgKiAgICAgLSBmbGlwQmx1ZVJlZDogYm9vbGVhblxuICAgICAqICAgICAtIHJlbmRlckluZm86IG9iamVjdFxuICAgICAqIFRoZSBsb2FkZXIgaXRzZWxmIG1heSByZXR1cm4gYSBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIGxvYWRpbmcgb2YgdGhlIHRleHR1cmUgaXMgY2FuY2VsbGVkLiBUaGlzIGNhbiBiZSB1c2VkXG4gICAgICogdG8gc3RvcCBmZXRjaGluZyBhbiBpbWFnZSB3aGVuIGl0IGlzIG5vIGxvbmdlciBpbiBlbGVtZW50LCBmb3IgZXhhbXBsZS5cbiAgICAgKi9cbiAgICBfZ2V0U291cmNlTG9hZGVyKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZXh0dXJlLmdlbmVyYXRlIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cblxuICAgIGdldCBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SXNWYWxpZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRleHR1cmUgaXMgbm90ICd2YWxpZCcsIG5vIHNvdXJjZSBjYW4gYmUgY3JlYXRlZCBmb3IgaXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgX2dldElzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGV4dHVyZSBzb3VyY2UgbXVzdCBiZSByZS1nZW5lcmF0ZWQuXG4gICAgICovXG4gICAgX2NoYW5nZWQoKSB7XG4gICAgICAgIC8vIElmIG5vIGVsZW1lbnQgaXMgYWN0aXZlbHkgdXNpbmcgdGhpcyB0ZXh0dXJlLCBpZ25vcmUgaXQgYWx0b2dldGhlci5cbiAgICAgICAgaWYgKHRoaXMuaXNVc2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNvdXJjZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbXVzdFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdXBkYXRlU291cmNlKCkge1xuICAgICAgICAvLyBXZSBkZWxheSBhbGwgdXBkYXRlU291cmNlIGNhbGxzIHRvIHRoZSBuZXh0IGRyYXdGcmFtZSwgc28gdGhhdCB3ZSBjYW4gYnVuZGxlIHRoZW0uXG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBtYXkgcmVsb2FkIGEgdGV4dHVyZSBtb3JlIG9mdGVuIHRoYW4gbmVjZXNzYXJ5LCB3aGVuLCBmb3IgZXhhbXBsZSwgcGF0Y2hpbmcgbXVsdGlwbGUgdGV4dFxuICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICB0aGlzLnN0YWdlLmFkZFVwZGF0ZVNvdXJjZVRleHR1cmUodGhpcyk7XG4gICAgfVxuXG4gICAgX3BlcmZvcm1VcGRhdGVTb3VyY2UoZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAvLyBJZiwgaW4gdGhlIG1lYW50aW1lLCB0aGUgdGV4dHVyZSB3YXMgbm8gbG9uZ2VyIHVzZWQsIGp1c3QgcmVtZW1iZXIgdGhhdCBpdCBtdXN0IHVwZGF0ZSB1bnRpbCBpdCBiZWNvbWVzIHVzZWRcbiAgICAgICAgLy8gYWdhaW4uXG4gICAgICAgIGlmIChmb3JjZSB8fCB0aGlzLmlzVXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9tdXN0VXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc291cmNlID0gdGhpcy5fZ2V0VGV4dHVyZVNvdXJjZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVwbGFjZVRleHR1cmVTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRUZXh0dXJlU291cmNlKCkge1xuICAgICAgICBsZXQgc291cmNlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX2dldElzVmFsaWQoKSkge1xuICAgICAgICAgICAgY29uc3QgbG9va3VwSWQgPSB0aGlzLl9nZXRMb29rdXBJZCgpO1xuICAgICAgICAgICAgc291cmNlID0gdGhpcy5fZ2V0UmV1c2FibGVUZXh0dXJlU291cmNlKGxvb2t1cElkKTtcbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gdGhpcy5tYW5hZ2VyLmdldFRleHR1cmVTb3VyY2UodGhpcy5fZ2V0U291cmNlTG9hZGVyKCksIGxvb2t1cElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIF9nZXRSZXVzYWJsZVRleHR1cmVTb3VyY2UobG9va3VwSWQgPSB0aGlzLl9nZXRMb29rdXBJZCgpKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZXRJc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIGlmIChsb29rdXBJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0UmV1c2FibGVUZXh0dXJlU291cmNlKGxvb2t1cElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfcmVwbGFjZVRleHR1cmVTb3VyY2UobmV3U291cmNlID0gbnVsbCkge1xuICAgICAgICBsZXQgb2xkU291cmNlID0gdGhpcy5fc291cmNlO1xuXG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IG5ld1NvdXJjZTtcblxuICAgICAgICBpZiAodGhpcy5lbGVtZW50cy5zaXplKSB7XG4gICAgICAgICAgICBpZiAob2xkU291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZFNvdXJjZS5kZWNBY3RpdmVUZXh0dXJlQ291bnQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvbGRTb3VyY2UucmVtb3ZlVGV4dHVyZSh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5ld1NvdXJjZSkge1xuICAgICAgICAgICAgICAgIC8vIE11c3QgaGFwcGVuIGJlZm9yZSBzZXREaXNwbGF5ZWRUZXh0dXJlIHRvIGVuc3VyZSBzcHJpdGUgbWFwIHRleGNvb3JkcyBhcmUgdXNlZC5cbiAgICAgICAgICAgICAgICBuZXdTb3VyY2UuYWRkVGV4dHVyZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U291cmNlLmluY0FjdGl2ZVRleHR1cmVDb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzVXNlZCgpKSB7XG4gICAgICAgICAgICBpZiAobmV3U291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1NvdXJjZS5pc0xvYWRlZCgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcmVzaXplTW9kZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVzaXplTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlSZXNpemVNb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Ll9zZXREaXNwbGF5ZWRUZXh0dXJlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2FkRXJyb3IgPSBuZXdTb3VyY2UubG9hZEVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQub25UZXh0dXJlU291cmNlTG9hZEVycm9yKGxvYWRFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Ll9zZXREaXNwbGF5ZWRUZXh0dXJlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2FkKCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBzb3VyY2UgaXMgdXAgdG8gZGF0ZS5cbiAgICAgICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNMb2FkZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlLmxvYWQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0xvYWRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuaXNMb2FkZWQoKTtcbiAgICB9XG5cbiAgICBnZXQgbG9hZEVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5sb2FkRXJyb3I7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fc291cmNlLmZyZWUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCByZXNpemVNb2RlKHt0eXBlID0gXCJjb3ZlclwiLCB3ID0gMCwgaCA9IDAsIGNsaXBYID0gMC41LCBjbGlwWSA9IDAuNX0pIHtcbiAgICAgICAgdGhpcy5fcmVzaXplTW9kZSA9IHt0eXBlLCB3LCBoLCBjbGlwWCwgY2xpcFl9O1xuICAgICAgICBpZiAodGhpcy5pc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBseVJlc2l6ZU1vZGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCByZXNpemVNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzaXplTW9kZTtcbiAgICB9XG5cbiAgICBfY2xlYXJSZXNpemVNb2RlKCkge1xuICAgICAgICB0aGlzLl9yZXNpemVNb2RlID0gbnVsbDtcbiAgICB9XG5cbiAgICBfYXBwbHlSZXNpemVNb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVzaXplTW9kZS50eXBlID09PSBcImNvdmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5UmVzaXplQ292ZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9yZXNpemVNb2RlLnR5cGUgPT09IFwiY29udGFpblwiKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBseVJlc2l6ZUNvbnRhaW4oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVQcmVjaXNpb24oKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2xpcHBpbmcoKTtcbiAgICB9XG5cbiAgICBfYXBwbHlSZXNpemVDb3ZlcigpIHtcbiAgICAgICAgY29uc3Qgc2NhbGVYID0gdGhpcy5fcmVzaXplTW9kZS53IC8gdGhpcy5fc291cmNlLnc7XG4gICAgICAgIGNvbnN0IHNjYWxlWSA9IHRoaXMuX3Jlc2l6ZU1vZGUuaCAvIHRoaXMuX3NvdXJjZS5oO1xuICAgICAgICBsZXQgc2NhbGUgPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgIGlmICghc2NhbGUpIHJldHVybjtcbiAgICAgICAgdGhpcy5fcHJlY2lzaW9uID0gMS9zY2FsZTtcbiAgICAgICAgaWYgKHNjYWxlWCAmJiBzY2FsZVggPCBzY2FsZSkge1xuICAgICAgICAgICAgY29uc3QgZGVzaXJlZFNpemUgPSB0aGlzLl9wcmVjaXNpb24gKiB0aGlzLl9yZXNpemVNb2RlLnc7XG4gICAgICAgICAgICBjb25zdCBjaG9wcGVkT2ZmUGl4ZWxzID0gdGhpcy5fc291cmNlLncgLSBkZXNpcmVkU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX3ggPSBjaG9wcGVkT2ZmUGl4ZWxzICogdGhpcy5fcmVzaXplTW9kZS5jbGlwWDtcbiAgICAgICAgICAgIHRoaXMuX3cgPSB0aGlzLl9zb3VyY2UudyAtIGNob3BwZWRPZmZQaXhlbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjYWxlWSAmJiBzY2FsZVkgPCBzY2FsZSkge1xuICAgICAgICAgICAgY29uc3QgZGVzaXJlZFNpemUgPSB0aGlzLl9wcmVjaXNpb24gKiB0aGlzLl9yZXNpemVNb2RlLmg7XG4gICAgICAgICAgICBjb25zdCBjaG9wcGVkT2ZmUGl4ZWxzID0gdGhpcy5fc291cmNlLmggLSBkZXNpcmVkU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX3kgPSBjaG9wcGVkT2ZmUGl4ZWxzICogdGhpcy5fcmVzaXplTW9kZS5jbGlwWTtcbiAgICAgICAgICAgIHRoaXMuX2ggPSB0aGlzLl9zb3VyY2UuaCAtIGNob3BwZWRPZmZQaXhlbHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfYXBwbHlSZXNpemVDb250YWluKCkge1xuICAgICAgICBjb25zdCBzY2FsZVggPSB0aGlzLl9yZXNpemVNb2RlLncgLyB0aGlzLl9zb3VyY2UudztcbiAgICAgICAgY29uc3Qgc2NhbGVZID0gdGhpcy5fcmVzaXplTW9kZS5oIC8gdGhpcy5fc291cmNlLmg7XG4gICAgICAgIGxldCBzY2FsZSA9IHNjYWxlWDtcbiAgICAgICAgaWYgKCFzY2FsZSB8fCBzY2FsZVkgPCBzY2FsZSkge1xuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZVk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzY2FsZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9wcmVjaXNpb24gPSAxL3NjYWxlO1xuICAgIH1cblxuICAgIGVuYWJsZUNsaXBwaW5nKHgsIHksIHcsIGgpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJSZXNpemVNb2RlKCk7XG5cbiAgICAgICAgeCAqPSB0aGlzLl9wcmVjaXNpb247XG4gICAgICAgIHkgKj0gdGhpcy5fcHJlY2lzaW9uO1xuICAgICAgICB3ICo9IHRoaXMuX3ByZWNpc2lvbjtcbiAgICAgICAgaCAqPSB0aGlzLl9wcmVjaXNpb247XG4gICAgICAgIGlmICh0aGlzLl94ICE9PSB4IHx8IHRoaXMuX3kgIT09IHkgfHwgdGhpcy5fdyAhPT0gdyB8fCB0aGlzLl9oICE9PSBoKSB7XG4gICAgICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICAgICAgdGhpcy5fdyA9IHc7XG4gICAgICAgICAgICB0aGlzLl9oID0gaDtcblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ2xpcHBpbmcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNhYmxlQ2xpcHBpbmcoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyUmVzaXplTW9kZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLl94IHx8IHRoaXMuX3kgfHwgdGhpcy5fdyB8fCB0aGlzLl9oKSB7XG4gICAgICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgICAgICAgdGhpcy5fdyA9IDA7XG4gICAgICAgICAgICB0aGlzLl9oID0gMDtcblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ2xpcHBpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF91cGRhdGVDbGlwcGluZygpIHtcbiAgICAgICAgdGhpcy5jbGlwcGluZyA9ICEhKHRoaXMuX3ggfHwgdGhpcy5feSB8fCB0aGlzLl93IHx8IHRoaXMuX2gpO1xuXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBpZiBub3QgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgdGV4dHVyZS5cbiAgICAgICAgICAgIGlmIChlbGVtZW50LmRpc3BsYXllZFRleHR1cmUgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9uRGlzcGxheWVkVGV4dHVyZUNsaXBwaW5nQ2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfdXBkYXRlUHJlY2lzaW9uKCkge1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgaWYgbm90IHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHRleHR1cmUuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5kaXNwbGF5ZWRUZXh0dXJlID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5vblByZWNpc2lvbkNoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0Tm9uRGVmYXVsdHMoKSB7XG4gICAgICAgIGxldCBub25EZWZhdWx0cyA9IHt9O1xuICAgICAgICBub25EZWZhdWx0c1sndHlwZSddID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBpZiAodGhpcy54ICE9PSAwKSBub25EZWZhdWx0c1sneCddID0gdGhpcy54O1xuICAgICAgICBpZiAodGhpcy55ICE9PSAwKSBub25EZWZhdWx0c1sneSddID0gdGhpcy55O1xuICAgICAgICBpZiAodGhpcy53ICE9PSAwKSBub25EZWZhdWx0c1sndyddID0gdGhpcy53O1xuICAgICAgICBpZiAodGhpcy5oICE9PSAwKSBub25EZWZhdWx0c1snaCddID0gdGhpcy5oO1xuICAgICAgICBpZiAodGhpcy5wcmVjaXNpb24gIT09IDEpIG5vbkRlZmF1bHRzWydwcmVjaXNpb24nXSA9IHRoaXMucHJlY2lzaW9uO1xuICAgICAgICByZXR1cm4gbm9uRGVmYXVsdHM7XG4gICAgfVxuXG4gICAgZ2V0IHB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9XG5cbiAgICBnZXQgcHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH1cblxuICAgIGdldCBwdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3c7XG4gICAgfVxuXG4gICAgZ2V0IHBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faDtcbiAgICB9XG5cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ggLyB0aGlzLl9wcmVjaXNpb247XG4gICAgfVxuICAgIHNldCB4KHYpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJSZXNpemVNb2RlKCk7XG4gICAgICAgIHYgPSB2ICogdGhpcy5fcHJlY2lzaW9uO1xuICAgICAgICBpZiAodGhpcy5feCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5feCA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDbGlwcGluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95IC8gdGhpcy5fcHJlY2lzaW9uO1xuICAgIH1cbiAgICBzZXQgeSh2KSB7XG4gICAgICAgIHRoaXMuX2NsZWFyUmVzaXplTW9kZSgpO1xuICAgICAgICB2ID0gdiAqIHRoaXMuX3ByZWNpc2lvbjtcbiAgICAgICAgaWYgKHRoaXMuX3kgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3kgPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ2xpcHBpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdyAvIHRoaXMuX3ByZWNpc2lvbjtcbiAgICB9XG5cbiAgICBzZXQgdyh2KSB7XG4gICAgICAgIHRoaXMuX2NsZWFyUmVzaXplTW9kZSgpO1xuICAgICAgICB2ID0gdiAqIHRoaXMuX3ByZWNpc2lvbjtcbiAgICAgICAgaWYgKHRoaXMuX3cgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3cgPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ2xpcHBpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faCAvIHRoaXMuX3ByZWNpc2lvbjtcbiAgICB9XG5cbiAgICBzZXQgaCh2KSB7XG4gICAgICAgIHRoaXMuX2NsZWFyUmVzaXplTW9kZSgpO1xuICAgICAgICB2ID0gdiAqIHRoaXMuX3ByZWNpc2lvbjtcbiAgICAgICAgaWYgKHRoaXMuX2ggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2ggPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ2xpcHBpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBwcmVjaXNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVjaXNpb247XG4gICAgfVxuXG4gICAgc2V0IHByZWNpc2lvbih2KSB7XG4gICAgICAgIHRoaXMuX2NsZWFyUmVzaXplTW9kZSgpO1xuICAgICAgICBpZiAodGhpcy5fcHJlY2lzaW9uICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9wcmVjaXNpb24gPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJlY2lzaW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0F1dG9zaXplVGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZ2V0UmVuZGVyV2lkdGgoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0F1dG9zaXplVGV4dHVyZSgpKSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIG9mIHRoZSByZWN0YW5nbGUgdGV4dHVyZSwgd2UnZCBwcmVmZXIgdG8gbm90IGNhdXNlIGEgMXgxIHcsaCBhcyBpdCB3b3VsZCBpbnRlcmZlcmUgd2l0aCBmbGV4IGxheW91dCBmaXQtdG8tY29udGVudHMuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGRpbWVuc2lvbnMgYXJlIHVua25vd24gKHRleHR1cmUgbm90IHlldCBsb2FkZWQpLCB1c2UgbWF4aW11bSB3aWR0aCBhcyBhIGZhbGxiYWNrIGFzIHJlbmRlciB3aWR0aCB0byBhbGxvdyBwcm9wZXIgYm91bmRzIGNoZWNraW5nLlxuICAgICAgICByZXR1cm4gKHRoaXMuX3cgfHwgKHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS5nZXRSZW5kZXJXaWR0aCgpIC0gdGhpcy5feCA6IDApKSAvIHRoaXMuX3ByZWNpc2lvbjtcbiAgICB9XG5cbiAgICBnZXRSZW5kZXJIZWlnaHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0F1dG9zaXplVGV4dHVyZSgpKSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIG9mIHRoZSByZWN0YW5nbGUgdGV4dHVyZSwgd2UnZCBwcmVmZXIgdG8gbm90IGNhdXNlIGEgMXgxIHcsaCBhcyBpdCB3b3VsZCBpbnRlcmZlcmUgd2l0aCBmbGV4IGxheW91dCBmaXQtdG8tY29udGVudHMuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodGhpcy5faCB8fCAodGhpcy5fc291cmNlID8gdGhpcy5fc291cmNlLmdldFJlbmRlckhlaWdodCgpIC0gdGhpcy5feSA6IDApKSAvIHRoaXMuX3ByZWNpc2lvbjtcbiAgICB9XG5cbiAgICBwYXRjaChzZXR0aW5ncykge1xuICAgICAgICBCYXNlLnBhdGNoT2JqZWN0KHRoaXMsIHNldHRpbmdzKTtcbiAgICB9XG5cbn1cblxuVGV4dHVyZS5wcm90b3R5cGUuaXNUZXh0dXJlID0gdHJ1ZTtcblxuVGV4dHVyZS5pZCA9IDA7XG5cbmltcG9ydCBCYXNlIGZyb20gXCIuL0Jhc2UubWpzXCI7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVGV4dHVyZVNvdXJjZSBmcm9tIFwiLi9UZXh0dXJlU291cmNlLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlTWFuYWdlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgdXNlZCBhbW91bnQgb2YgdGV4dHVyZSBtZW1vcnkuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl91c2VkTWVtb3J5ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHVwbG9hZGVkIHRleHR1cmUgc291cmNlcy5cbiAgICAgICAgICogQHR5cGUge1RleHR1cmVTb3VyY2VbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3VwbG9hZGVkVGV4dHVyZVNvdXJjZXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHR1cmUgc291cmNlIGxvb2t1cCBpZCB0byB0ZXh0dXJlIHNvdXJjZSBoYXNobWFwLlxuICAgICAgICAgKiBAdHlwZSB7TWFwPFN0cmluZywgVGV4dHVyZVNvdXJjZT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHR1cmVTb3VyY2VIYXNobWFwID0gbmV3IE1hcCgpO1xuXG4gICAgfVxuXG4gICAgZ2V0IHVzZWRNZW1vcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91c2VkTWVtb3J5O1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fdXBsb2FkZWRUZXh0dXJlU291cmNlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUZyZWVUZXh0dXJlU291cmNlKHRoaXMuX3VwbG9hZGVkVGV4dHVyZVNvdXJjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLnRleHR1cmVTb3VyY2VIYXNobWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3VzZWRNZW1vcnkgPSAwO1xuICAgIH1cblxuICAgIGdldFJldXNhYmxlVGV4dHVyZVNvdXJjZShpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlU291cmNlSGFzaG1hcC5nZXQoaWQpO1xuICAgIH1cblxuICAgIGdldFRleHR1cmVTb3VyY2UoZnVuYywgaWQpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGV4dHVyZSBzb3VyY2UgaXMgYWxyZWFkeSBrbm93bi5cbiAgICAgICAgbGV0IHRleHR1cmVTb3VyY2UgPSBpZCA/IHRoaXMudGV4dHVyZVNvdXJjZUhhc2htYXAuZ2V0KGlkKSA6IG51bGw7XG4gICAgICAgIGlmICghdGV4dHVyZVNvdXJjZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyB0ZXh0dXJlIHNvdXJjZS5cbiAgICAgICAgICAgIHRleHR1cmVTb3VyY2UgPSBuZXcgVGV4dHVyZVNvdXJjZSh0aGlzLCBmdW5jKTtcblxuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZVNvdXJjZS5sb29rdXBJZCA9IGlkO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZVNvdXJjZUhhc2htYXAuc2V0KGlkLCB0ZXh0dXJlU291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlU291cmNlO1xuICAgIH1cblxuICAgIHVwbG9hZFRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGV4dHVyZVNvdXJjZS5pc0xvYWRlZCgpKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5fYWRkTWVtb3J5VXNhZ2UodGV4dHVyZVNvdXJjZS53ICogdGV4dHVyZVNvdXJjZS5oKTtcblxuICAgICAgICAvLyBMb2FkIHRleHR1cmUuXG4gICAgICAgIGNvbnN0IG5hdGl2ZVRleHR1cmUgPSB0aGlzLl9uYXRpdmVVcGxvYWRUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRleHR1cmVTb3VyY2UuX25hdGl2ZVRleHR1cmUgPSBuYXRpdmVUZXh0dXJlO1xuXG4gICAgICAgIC8vIFdlIGF0dGFjaCB3IGFuZCBoIHRvIG5hdGl2ZSB0ZXh0dXJlICh3ZSBuZWVkIGl0IGluIENvcmVSZW5kZXJTdGF0ZS5faXNSZW5kZXJUZXh0dXJlUmV1c2FibGUpLlxuICAgICAgICBuYXRpdmVUZXh0dXJlLncgPSB0ZXh0dXJlU291cmNlLnc7XG4gICAgICAgIG5hdGl2ZVRleHR1cmUuaCA9IHRleHR1cmVTb3VyY2UuaDtcblxuICAgICAgICBuYXRpdmVUZXh0dXJlLnVwZGF0ZSA9IHRoaXMuc3RhZ2UuZnJhbWVDb3VudGVyO1xuXG4gICAgICAgIHRoaXMuX3VwbG9hZGVkVGV4dHVyZVNvdXJjZXMucHVzaCh0ZXh0dXJlU291cmNlKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuYWRkVG9Mb29rdXBNYXAodGV4dHVyZVNvdXJjZSk7XG4gICAgfVxuXG4gICAgX2FkZE1lbW9yeVVzYWdlKGRlbHRhKSB7XG4gICAgICAgIHRoaXMuX3VzZWRNZW1vcnkgKz0gZGVsdGE7XG4gICAgICAgIHRoaXMuc3RhZ2UuYWRkTWVtb3J5VXNhZ2UoZGVsdGEpO1xuICAgIH1cbiAgICBcbiAgICBhZGRUb0xvb2t1cE1hcCh0ZXh0dXJlU291cmNlKSB7XG4gICAgICAgIGNvbnN0IGxvb2t1cElkID0gdGV4dHVyZVNvdXJjZS5sb29rdXBJZDtcbiAgICAgICAgaWYgKGxvb2t1cElkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudGV4dHVyZVNvdXJjZUhhc2htYXAuaGFzKGxvb2t1cElkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZVNvdXJjZUhhc2htYXAuc2V0KGxvb2t1cElkLCB0ZXh0dXJlU291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdjKCkge1xuICAgICAgICB0aGlzLmZyZWVVbnVzZWRUZXh0dXJlU291cmNlcygpO1xuICAgICAgICB0aGlzLl9jbGVhbnVwTG9va3VwTWFwKCk7XG4gICAgfVxuICAgIFxuICAgIGZyZWVVbnVzZWRUZXh0dXJlU291cmNlcygpIHtcbiAgICAgICAgbGV0IHJlbWFpbmluZ1RleHR1cmVTb3VyY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fdXBsb2FkZWRUZXh0dXJlU291cmNlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0cyA9IHRoaXMuX3VwbG9hZGVkVGV4dHVyZVNvdXJjZXNbaV07XG4gICAgICAgICAgICBpZiAodHMuYWxsb3dDbGVhbnVwKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mcmVlTWFuYWdlZFRleHR1cmVTb3VyY2UodHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1haW5pbmdUZXh0dXJlU291cmNlcy5wdXNoKHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwbG9hZGVkVGV4dHVyZVNvdXJjZXMgPSByZW1haW5pbmdUZXh0dXJlU291cmNlcztcblxuICAgICAgICB0aGlzLl9jbGVhbnVwTG9va3VwTWFwKCk7XG4gICAgfVxuXG4gICAgX2ZyZWVNYW5hZ2VkVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlKSB7XG4gICAgICAgIGlmICh0ZXh0dXJlU291cmNlLmlzTG9hZGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUZyZWVUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UpO1xuICAgICAgICAgICAgdGhpcy5fYWRkTWVtb3J5VXNhZ2UoLXRleHR1cmVTb3VyY2UudyAqIHRleHR1cmVTb3VyY2UuaCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG91bGQgYmUgcmVsb2FkZWQuXG4gICAgICAgIHRleHR1cmVTb3VyY2UubG9hZGluZ1NpbmNlID0gbnVsbDtcbiAgICB9XG5cbiAgICBfY2xlYW51cExvb2t1cE1hcCgpIHtcbiAgICAgICAgLy8gV2Uga2VlcCB0aG9zZSB0aGF0IHN0aWxsIGhhdmUgdmFsdWUgKGFyZSBiZWluZyBsb2FkZWQgb3IgYWxyZWFkeSBsb2FkZWQsIG9yIGFyZSBsaWtlbHkgdG8gYmUgcmV1c2VkKS5cbiAgICAgICAgdGhpcy50ZXh0dXJlU291cmNlSGFzaG1hcC5mb3JFYWNoKCh0ZXh0dXJlU291cmNlLCBsb29rdXBJZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEodGV4dHVyZVNvdXJjZS5pc0xvYWRlZCgpIHx8IHRleHR1cmVTb3VyY2UuaXNMb2FkaW5nKCkpICYmICF0ZXh0dXJlU291cmNlLmlzVXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlU291cmNlSGFzaG1hcC5kZWxldGUobG9va3VwSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRlcm5hbGx5IGZyZWUgdGV4dHVyZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHRleHR1cmVTb3VyY2VcbiAgICAgKi9cbiAgICBmcmVlVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fdXBsb2FkZWRUZXh0dXJlU291cmNlcy5pbmRleE9mKHRleHR1cmVTb3VyY2UpO1xuICAgICAgICBjb25zdCBtYW5hZ2VkID0gKGluZGV4ICE9PSAtMSk7XG5cbiAgICAgICAgaWYgKHRleHR1cmVTb3VyY2UuaXNMb2FkZWQoKSkge1xuICAgICAgICAgICAgaWYgKG1hbmFnZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZW1vcnlVc2FnZSgtdGV4dHVyZVNvdXJjZS53ICogdGV4dHVyZVNvdXJjZS5oKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWRlZFRleHR1cmVTb3VyY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVGcmVlVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3VsZCBiZSByZWxvYWRlZC5cbiAgICAgICAgdGV4dHVyZVNvdXJjZS5sb2FkaW5nU2luY2UgPSBudWxsO1xuICAgIH1cblxuICAgIF9uYXRpdmVVcGxvYWRUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhZ2UucmVuZGVyZXIudXBsb2FkVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfbmF0aXZlRnJlZVRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSkge1xuICAgICAgICB0aGlzLnN0YWdlLnJlbmRlcmVyLmZyZWVUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UpO1xuICAgICAgICB0ZXh0dXJlU291cmNlLmNsZWFyTmF0aXZlVGV4dHVyZSgpO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZVNvdXJjZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBsb2FkZXIgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuaWQgPSBUZXh0dXJlU291cmNlLmlkKys7XG5cbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcblxuICAgICAgICB0aGlzLnN0YWdlID0gbWFuYWdlci5zdGFnZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIGVuYWJsZWQgdGV4dHVyZXMgKHRleHR1cmVzIHRoYXQgYXJlIHVzZWQgYnkgdmlzaWJsZSBlbGVtZW50cykuXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8VGV4dHVyZT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHR1cmVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGFjdGl2ZSB0ZXh0dXJlcyAodGV4dHVyZXMgdGhhdCBoYXZlIGF0IGxlYXN0IG9uZSBhY3RpdmUgZWxlbWVudCkuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hY3RpdmVUZXh0dXJlQ291bnQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmFjdG9yeSBmb3IgdGhlIHNvdXJjZSBvZiB0aGlzIHRleHR1cmUuXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9hZGVyID0gbG9hZGVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVyIGZvciByZXVzZS5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9va3VwSWQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQsIHRoaXMuaXMgY2FsbGVkIHdoZW4gdGhlIHRleHR1cmUgc291cmNlIGlzIG5vIGxvbmdlciBkaXNwbGF5ZWQgKHRoaXMuY29tcG9uZW50cy5zaXplIGJlY29tZXMgMCkuXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NhbmNlbENiID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTG9hZGluZyBzaW5jZSB0aW1lc3RhbXAgaW4gbWlsbGlzLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb2FkaW5nU2luY2UgPSAwO1xuXG4gICAgICAgIHRoaXMudyA9IDA7XG4gICAgICAgIHRoaXMuaCA9IDA7XG5cbiAgICAgICAgdGhpcy5fbmF0aXZlVGV4dHVyZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZW4gdGhpcy50ZXh0dXJlIHNvdXJjZSBpcyBuZXZlciBmcmVlZCBmcm9tIG1lbW9yeSBkdXJpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVybWFuZW50ID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1Yi1vYmplY3Qgd2l0aCB0ZXh0dXJlLXNwZWNpZmljIHJlbmRlcmluZyBpbmZvcm1hdGlvbi5cbiAgICAgICAgICogRm9yIGltYWdlcywgY29udGFpbnMgdGhlIHNyYyBwcm9wZXJ0eSwgZm9yIHRleHRzLCBjb250YWlucyBoYW5keSByZW5kZXJpbmcgaW5mb3JtYXRpb24uXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbmRlckluZm8gPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmF0ZWQgZm9yICdyZW5kZXJUb1RleHR1cmUnLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lzUmVzdWx0VGV4dHVyZSA9ICF0aGlzLmxvYWRlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGFpbnMgdGhlIGxvYWQgZXJyb3IsIGlmIHRoZSB0ZXh0dXJlIHNvdXJjZSBjb3VsZCBwcmV2aW91c2x5IG5vdCBiZSBsb2FkZWQuXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2FkRXJyb3IgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgSG9sZCBhIHJlZmVyZW5jZSB0byB0aGUgamF2YXNjcmlwdCB2YXJpYWJsZSB3aGljaCBjb250YWlucyB0aGUgdGV4dHVyZSwgdGhpcyBpcyBub3QgcmVxdWlyZWQgZm9yIFdlYkdMIGluIFdlYkJyb3dzZXJzIGJ1dCBpcyByZXF1aXJlZCBmb3IgU3BhcmsgcnVudGltZS5cbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ltYWdlUmVmID0gbnVsbDtcblxuICAgIH1cblxuICAgIGdldCBsb2FkRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkRXJyb3I7XG4gICAgfVxuXG4gICAgYWRkVGV4dHVyZSh2KSB7XG4gICAgICAgIGlmICghdGhpcy50ZXh0dXJlcy5oYXModikpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZXMuYWRkKHYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlVGV4dHVyZSh2KSB7XG4gICAgICAgIHRoaXMudGV4dHVyZXMuZGVsZXRlKHYpO1xuICAgIH1cblxuICAgIGluY0FjdGl2ZVRleHR1cmVDb3VudCgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlVGV4dHVyZUNvdW50Kys7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVUZXh0dXJlQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuYmVjb21lc1VzZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlY0FjdGl2ZVRleHR1cmVDb3VudCgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlVGV4dHVyZUNvdW50LS07XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVUZXh0dXJlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYmVjb21lc1VudXNlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGlzUmVzdWx0VGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUmVzdWx0VGV4dHVyZTtcbiAgICB9XG5cbiAgICBzZXQgaXNSZXN1bHRUZXh0dXJlKHYpIHtcbiAgICAgICAgdGhpcy5faXNSZXN1bHRUZXh0dXJlID0gdjtcbiAgICB9XG5cbiAgICBmb3JFYWNoRW5hYmxlZEVsZW1lbnQoY2IpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKHRleHR1cmUgPT4ge1xuICAgICAgICAgICAgdGV4dHVyZS5lbGVtZW50cy5mb3JFYWNoKGNiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGFzRW5hYmxlZEVsZW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlcy5zaXplID4gMDtcbiAgICB9XG5cbiAgICBmb3JFYWNoQWN0aXZlRWxlbWVudChjYikge1xuICAgICAgICB0aGlzLnRleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG4gICAgICAgICAgICB0ZXh0dXJlLmVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRSZW5kZXJXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudztcbiAgICB9XG5cbiAgICBnZXRSZW5kZXJIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmg7XG4gICAgfVxuXG4gICAgYWxsb3dDbGVhbnVwKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucGVybWFuZW50ICYmICF0aGlzLmlzVXNlZCgpO1xuICAgIH1cblxuICAgIGJlY29tZXNVc2VkKCkge1xuICAgICAgICAvLyBFdmVuIHdoaWxlIHRoZSB0ZXh0dXJlIGlzIGJlaW5nIGxvYWRlZCwgbWFrZSBzdXJlIGl0IGlzIG9uIHRoZSBsb29rdXAgbWFwIHNvIHRoYXQgb3RoZXJzIGNhbiByZXVzZSBpdC5cbiAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfVxuXG4gICAgYmVjb21lc1VudXNlZCgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICB9XG5cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9hZGluZygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FuY2VsQ2IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxDYih0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIGNhbGxiYWNrIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxDYiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTaW5jZSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0xvYWRlZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fbmF0aXZlVGV4dHVyZTtcbiAgICB9XG5cbiAgICBpc0xvYWRpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sb2FkaW5nU2luY2UgPiAwKTtcbiAgICB9XG5cbiAgICBpc0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9sb2FkRXJyb3I7XG4gICAgfVxuXG4gICAgcmVsb2FkKCkge1xuICAgICAgICB0aGlzLmZyZWUoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNVc2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZChmb3JjZVN5bmMgPSBmYWxzZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBtb21lbnQgb2YgbG9hZGluZyAod2hlbiBhIHRleHR1cmUgc291cmNlIGJlY29tZXMgdXNlZCBieSBhY3RpdmUgZWxlbWVudHMpXG4gICAgICAgIGlmICh0aGlzLmlzUmVzdWx0VGV4dHVyZSkge1xuICAgICAgICAgICAgLy8gRWxlbWVudCByZXN1bHQgdGV4dHVyZSBzb3VyY2UsIGZvciB3aGljaCB0aGUgbG9hZGluZyBpcyBtYW5hZ2VkIGJ5IHRoZSBjb3JlLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9uYXRpdmVUZXh0dXJlICYmICF0aGlzLmlzTG9hZGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTaW5jZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxDYiA9IHRoaXMubG9hZGVyKChlcnIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgbG9hZHMgdGhhdCBjb21lIGluIGFmdGVyIGEgY2FuY2VsLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTG9hZGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIGNhbGxiYWNrIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsQ2IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc3RhZ2UuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYXN5bmMgbG9hZCB3aGVuIHN0YWdlIGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbWl0IHR4RXJyb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhZ2UuaXNVcGRhdGluZ0ZyYW1lKCkgJiYgIWZvcmNlU3luYyAmJiAob3B0aW9ucy50aHJvdHRsZSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZVRocm90dGxlciA9IHRoaXMuc3RhZ2UudGV4dHVyZVRocm90dGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxDYiA9IHRleHR1cmVUaHJvdHRsZXIuZ2VuZXJpY0NhbmNlbENiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVUaHJvdHRsZXIuYWRkKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NMb2FkZWRTb3VyY2Uob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb2Nlc3NMb2FkZWRTb3VyY2Uob3B0aW9ucykge1xuICAgICAgICB0aGlzLmxvYWRpbmdTaW5jZSA9IDA7XG4gICAgICAgIHRoaXMuc2V0U291cmNlKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHNldFNvdXJjZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG9wdGlvbnMuc291cmNlO1xuXG4gICAgICAgIHRoaXMudyA9IHNvdXJjZS53aWR0aCB8fCAob3B0aW9ucyAmJiBvcHRpb25zLncpIHx8IDA7XG4gICAgICAgIHRoaXMuaCA9IHNvdXJjZS5oZWlnaHQgfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy5oKSB8fCAwO1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVuZGVySW5mbykge1xuICAgICAgICAgICAgLy8gQXNzaWduIHRvIGlkIGluIGNhY2hlIHNvIHRoYXQgaXQgY2FuIGJlIHJldXNlZC5cbiAgICAgICAgICAgIHRoaXMucmVuZGVySW5mbyA9IG9wdGlvbnMucmVuZGVySW5mbztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGVybWFuZW50ID0gISFvcHRpb25zLnBlcm1hbmVudDtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmltYWdlUmVmKVxuICAgICAgICAgICAgdGhpcy5faW1hZ2VSZWYgPSBvcHRpb25zLmltYWdlUmVmO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZsaXBUZXh0dXJlWSkge1xuICAgICAgICAgICAgdGhpcy5fZmxpcFRleHR1cmVZID0gb3B0aW9ucy5mbGlwVGV4dHVyZVk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9mbGlwVGV4dHVyZVkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pc05hdGl2ZVRleHR1cmUoc291cmNlKSkge1xuICAgICAgICAgICAgLy8gVGV4dHVyZSBtYW5hZ2VkIGJ5IGNhbGxlci5cbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZVRleHR1cmUgPSBzb3VyY2U7XG5cbiAgICAgICAgICAgIHRoaXMudyA9IHRoaXMudyB8fCBzb3VyY2UudztcbiAgICAgICAgICAgIHRoaXMuaCA9IHRoaXMuaCB8fCBzb3VyY2UuaDtcblxuICAgICAgICAgICAgLy8gV2ViR0xUZXh0dXJlIG9iamVjdHMgYXJlIGJ5IGRlZmF1bHQ7XG4gICAgICAgICAgICB0aGlzLnBlcm1hbmVudCA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3Blcm1hbmVudCcpID8gb3B0aW9ucy5wZXJtYW5lbnQgOiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLnVwbG9hZFRleHR1cmVTb3VyY2UodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNdXN0IGJlIGNsZWFyZWQgd2hlbiByZWxvYWQgaXMgc3VjY2VzZnVsLlxuICAgICAgICB0aGlzLl9sb2FkRXJyb3IgPSBudWxsO1xuXG4gICAgICAgIHRoaXMub25Mb2FkKCk7XG4gICAgfVxuXG4gICAgaXNVc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlVGV4dHVyZUNvdW50ID4gMDtcbiAgICB9XG5cbiAgICBvbkxvYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5vbkxvYWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yY2VSZW5kZXJVcGRhdGUoKSB7XG4gICAgICAgIC8vIFVzZXJsYW5kIHNob3VsZCBjYWxsIHRoaXMgbWV0aG9kIGFmdGVyIGNoYW5naW5nIHRoZSBuYXRpdmVUZXh0dXJlIG1hbnVhbGx5IG91dHNpZGUgb2YgdGhlIGZyYW1ld29ya1xuICAgICAgICAvLyAgKHVzaW5nIHRleFtTdWJdSW1hZ2UyZCBmb3IgZXhhbXBsZSkuXG5cbiAgICAgICAgaWYgKHRoaXMuX25hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgICAgIC8vIENoYW5nZSAndXBkYXRlJyBmbGFnLiBUaGlzIGlzIGN1cnJlbnRseSBub3QgdXNlZCBieSB0aGUgZnJhbWV3b3JrIGJ1dCBpcyBoYW5keSBpbiB1c2VybGFuZC5cbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZVRleHR1cmUudXBkYXRlID0gdGhpcy5zdGFnZS5mcmFtZUNvdW50ZXI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZvckVhY2hBY3RpdmVFbGVtZW50KGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmZvcmNlUmVuZGVyVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgZm9yY2VVcGRhdGVSZW5kZXJDb29yZHMoKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaEFjdGl2ZUVsZW1lbnQoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuX3VwZGF0ZVRleHR1cmVDb29yZHMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0IG5hdGl2ZVRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVUZXh0dXJlO1xuICAgIH1cblxuICAgIGNsZWFyTmF0aXZlVGV4dHVyZSgpIHtcbiAgICAgICAgdGhpcy5fbmF0aXZlVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIC8vYWxzbyBjbGVhciB0aGUgcmVmZXJlbmNlIHRvIHRoZSB0ZXh0dXJlIHZhcmlhYmxlLlxuICAgICAgICB0aGlzLl9pbWFnZVJlZiA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgcmVzdWx0IHRleHR1cmVzLlxuICAgICAqL1xuICAgIHJlcGxhY2VOYXRpdmVUZXh0dXJlKG5ld05hdGl2ZVRleHR1cmUsIHcsIGgpIHtcbiAgICAgICAgbGV0IHByZXZOYXRpdmVUZXh0dXJlID0gdGhpcy5fbmF0aXZlVGV4dHVyZTtcbiAgICAgICAgLy8gTG9hZGVkIGJ5IGNvcmUuXG4gICAgICAgIHRoaXMuX25hdGl2ZVRleHR1cmUgPSBuZXdOYXRpdmVUZXh0dXJlO1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICB0aGlzLmggPSBoO1xuXG4gICAgICAgIGlmICghcHJldk5hdGl2ZVRleHR1cmUgJiYgdGhpcy5fbmF0aXZlVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoQWN0aXZlRWxlbWVudChlbGVtZW50ID0+IGVsZW1lbnQub25UZXh0dXJlU291cmNlTG9hZGVkKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9uYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hBY3RpdmVFbGVtZW50KGVsZW1lbnQgPT4gZWxlbWVudC5fc2V0RGlzcGxheWVkVGV4dHVyZShudWxsKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaW1lbnNpb25zIG11c3QgYmUgdXBkYXRlZCBhbHNvIG9uIGVuYWJsZWQgZWxlbWVudHMsIGFzIGl0IG1heSBmb3JjZSBpdCB0byBnbyB3aXRoaW4gYm91bmRzLlxuICAgICAgICB0aGlzLmZvckVhY2hFbmFibGVkRWxlbWVudChlbGVtZW50ID0+IGVsZW1lbnQuX3VwZGF0ZURpbWVuc2lvbnMoKSk7XG5cbiAgICAgICAgLy8gTm90aWNlIHRoYXQgdGhlIHNwcml0ZSBtYXAgbXVzdCBuZXZlciBjb250YWluIHJlbmRlciB0ZXh0dXJlcy5cbiAgICB9XG5cbiAgICBvbkVycm9yKGUpIHtcbiAgICAgICAgdGhpcy5fbG9hZEVycm9yID0gZTtcbiAgICAgICAgdGhpcy5sb2FkaW5nU2luY2UgPSAwO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbTGlnaHRuaW5nXSB0ZXh0dXJlIGxvYWQgZXJyb3InLCBlLCB0aGlzLmxvb2t1cElkKTtcbiAgICAgICAgdGhpcy5mb3JFYWNoQWN0aXZlRWxlbWVudChlbGVtZW50ID0+IGVsZW1lbnQub25UZXh0dXJlU291cmNlTG9hZEVycm9yKGUpKTtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZnJlZVRleHR1cmVTb3VyY2UodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfaXNOYXRpdmVUZXh0dXJlKHNvdXJjZSkge1xuICAgICAgICBpZiAoVXRpbHMuaXNOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiV2ViR0xUZXh0dXJlXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ1dlYkdMVGV4dHVyZScgaW4gd2luZG93KSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlIGluc3RhbmNlb2YgV2ViR0xUZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxufVxuXG5UZXh0dXJlU291cmNlLnByb3RvdHlwZS5pc1RleHR1cmVTb3VyY2UgPSB0cnVlO1xuXG5UZXh0dXJlU291cmNlLmlkID0gMTtcblxuaW1wb3J0IFV0aWxzIGZyb20gXCIuL1V0aWxzLm1qc1wiO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBBbGxvd3MgdGhyb3R0bGluZyBvZiBsb2FkaW5nIHRleHR1cmUgc291cmNlcywga2VlcGluZyB0aGUgYXBwIHJlc3BvbnNpdmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmVUaHJvdHRsZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuXG4gICAgICAgIHRoaXMuZ2VuZXJpY0NhbmNlbENiID0gKHRleHR1cmVTb3VyY2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZSh0ZXh0dXJlU291cmNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9zb3VyY2VzID0gW107XG4gICAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzID0gW107XG4gICAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICB9XG5cbiAgICBwcm9jZXNzU29tZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0l0ZW0oKTtcbiAgICAgICAgICAgIH0gd2hpbGUodGhpcy5fc291cmNlcy5sZW5ndGggJiYgKERhdGUubm93KCkgLSBzdGFydCA8IFRleHR1cmVUaHJvdHRsZXIuTUFYX1VQTE9BRF9USU1FX1BFUl9GUkFNRSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3Byb2Nlc3NJdGVtKCkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLnBvcCgpO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YS5wb3AoKTtcbiAgICAgICAgaWYgKHNvdXJjZS5pc0xvYWRpbmcoKSkge1xuICAgICAgICAgICAgc291cmNlLnByb2Nlc3NMb2FkZWRTb3VyY2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGQodGV4dHVyZVNvdXJjZSwgZGF0YSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLnB1c2godGV4dHVyZVNvdXJjZSk7XG4gICAgICAgIHRoaXMuX2RhdGEucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlKHRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YodGV4dHVyZVNvdXJjZSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuVGV4dHVyZVRocm90dGxlci5NQVhfVVBMT0FEX1RJTUVfUEVSX0ZSQU1FID0gMTA7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVdGlscyB7XG5cbiAgICBzdGF0aWMgaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAodmFsdWUgJSAxKSA9PT0gMCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xvbmUodikge1xuICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYpIHx8IEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5nZXREZWVwQ2xvbmUodik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDb3B5IGJ5IHZhbHVlLlxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY2xvbmVPYmpTaGFsbG93KG9iaikge1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGxldCBjbG9uZSA9IHt9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2xvbmVba2V5c1tpXV0gPSBvYmpba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIHN0YXRpYyBtZXJnZShvYmoxLCBvYmoyKSB7XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMob2JqMik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2JqMVtrZXlzW2ldXSA9IG9iajJba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajE7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09PSAnb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzT2JqZWN0TGl0ZXJhbCh2YWx1ZSl7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEFycmF5SW5kZXgoaW5kZXgsIGFycikge1xuICAgICAgICByZXR1cm4gVXRpbHMuZ2V0TW9kdWxvSW5kZXgoaW5kZXgsIGFyci5sZW5ndGgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRNb2R1bG9JbmRleChpbmRleCwgbGVuKSB7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHJldHVybiBpbmRleDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggKz0gTWF0aC5jZWlsKC1pbmRleCAvIGxlbikgKiBsZW47XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBpbmRleCAlIGxlbjtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXREZWVwQ2xvbmUob2JqKSB7XG4gICAgICAgIGxldCBpLCBjO1xuICAgICAgICBpZiAoVXRpbHMuaXNGdW5jdGlvbihvYmopKSB7XG4gICAgICAgICAgICAvLyBDb3B5IGZ1bmN0aW9ucyBieSByZWZlcmVuY2UuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGMgPSBbXTtcbiAgICAgICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY1trZXlzW2ldXSA9IFV0aWxzLmdldERlZXBDbG9uZShvYmpba2V5c1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgICAgICAgICAgYyA9IHt9XG4gICAgICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNba2V5c1tpXV0gPSBVdGlscy5nZXREZWVwQ2xvbmUob2JqW2tleXNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBlcXVhbFZhbHVlcyh2MSwgdjIpIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgdjEpICE9PSAodHlwZW9mIHYyKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYxKSkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2MikgJiYgVXRpbHMuZXF1YWxPYmplY3RMaXRlcmFscyh2MSwgdjIpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodjEpKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2MikgJiYgVXRpbHMuZXF1YWxBcnJheXModjEsIHYyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2MSA9PT0gdjI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZXF1YWxPYmplY3RMaXRlcmFscyhvYmoxLCBvYmoyKSB7XG4gICAgICAgIGxldCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICAgICAgICBsZXQga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcbiAgICAgICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGtleXMxLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgazEgPSBrZXlzMVtpXTtcbiAgICAgICAgICAgIGNvbnN0IGsyID0ga2V5czJbaV07XG4gICAgICAgICAgICBpZiAoazEgIT09IGsyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2MSA9IG9iajFbazFdO1xuICAgICAgICAgICAgY29uc3QgdjIgPSBvYmoyW2syXTtcblxuICAgICAgICAgICAgaWYgKCFVdGlscy5lcXVhbFZhbHVlcyh2MSwgdjIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc3RhdGljIGVxdWFsQXJyYXlzKHYxLCB2Mikge1xuICAgICAgICBpZiAodjEubGVuZ3RoICE9PSB2Mi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHYxLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVxdWFsVmFsdWVzKHYxW2ldLCB2MltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2V0VG9BcnJheShzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXRlcmF0b3JUb0FycmF5KGl0ZXJhdG9yKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGl0ZXJhdG9yUmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIWl0ZXJhdG9yUmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZXJhdG9yUmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIGl0ZXJhdG9yUmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzVWNDaGFyKGNoYXJjb2RlKSB7XG4gICAgICAgIHJldHVybiBjaGFyY29kZSA+PSA2NSAmJiBjaGFyY29kZSA8PSA5MDtcbiAgICB9XG5cbn1cblxuVXRpbHMuaXNXZWIgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikgJiYgKHR5cGVvZiBzcGFya3NjZW5lID09PSBcInVuZGVmaW5lZFwiKTtcblV0aWxzLmlzV1BFID0gVXRpbHMuaXNXZWIgJiYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIldQRVwiKSAhPT0gLTEpO1xuVXRpbHMuaXNTcGFyayA9ICh0eXBlb2Ygc3BhcmtzY2VuZSAhPT0gXCJ1bmRlZmluZWRcIik7XG5VdGlscy5pc05vZGUgPSAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgfHwgVXRpbHMuaXNTcGFyaztcblV0aWxzLmlzUFM0ID0gVXRpbHMuaXNXZWIgJiYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIlBsYXlTdGF0aW9uIDRcIikgIT09IC0xKTtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29yZUNvbnRleHQge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuXG4gICAgICAgIHRoaXMucm9vdCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy51cGRhdGVUcmVlT3JkZXIgPSAwO1xuXG4gICAgICAgIHRoaXMucmVuZGVyU3RhdGUgPSB0aGlzLnN0YWdlLnJlbmRlcmVyLmNyZWF0ZUNvcmVSZW5kZXJTdGF0ZSh0aGlzKTtcblxuICAgICAgICB0aGlzLnJlbmRlckV4ZWMgPSB0aGlzLnN0YWdlLnJlbmRlcmVyLmNyZWF0ZUNvcmVSZW5kZXJFeGVjdXRvcih0aGlzKTtcbiAgICAgICAgdGhpcy5yZW5kZXJFeGVjLmluaXQoKTtcblxuICAgICAgICB0aGlzLl91c2VkTWVtb3J5ID0gMDtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZVBvb2wgPSBbXTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlSWQgPSAxO1xuXG4gICAgICAgIHRoaXMuX3pTb3J0cyA9IFtdO1xuICAgIH1cblxuICAgIGdldCB1c2VkTWVtb3J5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlZE1lbW9yeTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlUG9vbC5mb3JFYWNoKHRleHR1cmUgPT4gdGhpcy5fZnJlZVJlbmRlclRleHR1cmUodGV4dHVyZSkpO1xuICAgICAgICB0aGlzLl91c2VkTWVtb3J5ID0gMDtcbiAgICB9XG5cbiAgICBoYXNSZW5kZXJVcGRhdGVzKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnJvb3QuX3BhcmVudC5faGFzUmVuZGVyVXBkYXRlcztcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vIENsZWFyIGZsYWcgdG8gaWRlbnRpZnkgaWYgYW55dGhpbmcgY2hhbmdlcyBiZWZvcmUgdGhlIG5leHQgZnJhbWUuXG4gICAgICAgIHRoaXMucm9vdC5fcGFyZW50Ll9oYXNSZW5kZXJVcGRhdGVzID0gMDtcblxuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIC8vIER1ZSB0byB0aGUgYm91bmRzVmlzaWJpbGl0eSBmbGFnIGZlYXR1cmUgKGFuZCBvbkFmdGVyVXBkYXRlIGhvb2spLCBpdCBpcyBwb3NzaWJsZSB0aGF0IG90aGVyIGVsZW1lbnRzIHdlcmVcbiAgICAgICAgLy8gY2hhbmdlZCBkdXJpbmcgdGhlIHVwZGF0ZSBsb29wIChmb3IgZXhhbXBsZSBkdWUgdG8gdGhlIHR4TG9hZGVkIGV2ZW50KS4gV2UgcHJvY2VzcyB0aGVzZSBjaGFuZ2VzIGltbWVkaWF0ZWx5XG4gICAgICAgIC8vIChidXQgbm90IHJlY3Vyc2l2ZWx5IHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMpLlxuICAgICAgICBpZiAodGhpcy5yb290Ll9oYXNVcGRhdGVzKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BlcmZvcm1Gb3JjZWRaU29ydHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDZXJ0YWluIEVsZW1lbnRDb3JlIGl0ZW1zIG1heSBiZSBmb3JjZWQgdG8gelNvcnQgdG8gc3RyaXAgb3V0IHJlZmVyZW5jZXMgdG8gcHJldmVudCBtZW1sZWFrcy4uXG4gICAgICovXG4gICAgX3BlcmZvcm1Gb3JjZWRaU29ydHMoKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl96U29ydHMubGVuZ3RoO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgLy8gRm9yY2VkIHotc29ydHMgKEVsZW1lbnRDb3JlIG1heSBmb3JjZSBhIHotc29ydCBpbiBvcmRlciB0byBmcmVlIG1lbW9yeS9wcmV2ZW50IG1lbW9yeSBsZWFrcykuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX3pTb3J0cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5felNvcnRzW2ldLnpTb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3pTb3J0c1tpXS5zb3J0WkluZGV4ZWRDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3pTb3J0cyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3VwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUcmVlT3JkZXIgPSAwO1xuXG4gICAgICAgIHRoaXMucm9vdC51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBfcmVuZGVyKCkge1xuICAgICAgICAvLyBPYnRhaW4gYSBzZXF1ZW5jZSBvZiB0aGUgcXVhZCBvcGVyYXRpb25zLlxuICAgICAgICB0aGlzLl9maWxsUmVuZGVyU3RhdGUoKTtcblxuICAgICAgICBpZiAodGhpcy5zdGFnZS5nZXRPcHRpb24oJ3JlYWRQaXhlbHNCZWZvcmVEcmF3JykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBpeGVscyA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnN0YWdlLmdsO1xuICAgICAgICAgICAgZ2wucmVhZFBpeGVscygwLCAwLCAxLCAxLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IHJ1biB0aGVtIHdpdGggdGhlIHJlbmRlciBleGVjdXRvci5cbiAgICAgICAgdGhpcy5fcGVyZm9ybVJlbmRlcigpO1xuICAgIH1cblxuICAgIF9maWxsUmVuZGVyU3RhdGUoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyU3RhdGUucmVzZXQoKTtcbiAgICAgICAgdGhpcy5yb290LnJlbmRlcigpO1xuICAgICAgICB0aGlzLnJlbmRlclN0YXRlLmZpbmlzaCgpO1xuICAgIH1cblxuICAgIF9wZXJmb3JtUmVuZGVyKCkge1xuICAgICAgICB0aGlzLnJlbmRlckV4ZWMuZXhlY3V0ZSgpO1xuICAgIH1cblxuICAgIF9hZGRNZW1vcnlVc2FnZShkZWx0YSkge1xuICAgICAgICB0aGlzLl91c2VkTWVtb3J5ICs9IGRlbHRhO1xuICAgICAgICB0aGlzLnN0YWdlLmFkZE1lbW9yeVVzYWdlKGRlbHRhKTtcbiAgICB9XG5cbiAgICBhbGxvY2F0ZVJlbmRlclRleHR1cmUodywgaCkge1xuICAgICAgICBsZXQgcHJlYyA9IHRoaXMuc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKCk7XG4gICAgICAgIGxldCBwdyA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQodyAqIHByZWMpKTtcbiAgICAgICAgbGV0IHBoID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChoICogcHJlYykpO1xuXG4gICAgICAgIC8vIFNlYXJjaCBsYXN0IGl0ZW0gZmlyc3QsIHNvIHRoYXQgbGFzdCByZWxlYXNlZCByZW5kZXIgdGV4dHVyZSBpcyBwcmVmZXJyZWQgKG1heSBjYXVzZSBtZW1vcnkgY2FjaGUgYmVuZWZpdHMpLlxuICAgICAgICBjb25zdCBuID0gdGhpcy5fcmVuZGVyVGV4dHVyZVBvb2wubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fcmVuZGVyVGV4dHVyZVBvb2xbaV07XG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJldXNlIHRoZSBzYW1lIHJlbmRlciB0ZXh0dXJlcyB3aXRoaW4gdGhlIHNhbWUgZnJhbWUgYmVjYXVzZSB0aGF0IHdpbGwgY3JlYXRlIGdwdSBzdGFsbHMuXG4gICAgICAgICAgICBpZiAodGV4dHVyZS53ID09PSBwdyAmJiB0ZXh0dXJlLmggPT09IHBoICYmICh0ZXh0dXJlLnVwZGF0ZSAhPT0gdGhpcy5zdGFnZS5mcmFtZUNvdW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5mID0gdGhpcy5zdGFnZS5mcmFtZUNvdW50ZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZVBvb2wuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVJlbmRlclRleHR1cmUodywgaCwgcHcsIHBoKTtcbiAgICAgICAgdGV4dHVyZS5wcmVjaXNpb24gPSBwcmVjO1xuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG5cbiAgICByZWxlYXNlUmVuZGVyVGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVQb29sLnB1c2godGV4dHVyZSk7XG4gICAgfVxuXG4gICAgZnJlZVVudXNlZFJlbmRlclRleHR1cmVzKG1heEFnZSA9IDYwKSB7XG4gICAgICAgIC8vIENsZWFuIHVwIGFsbCB0ZXh0dXJlcyB0aGF0IGFyZSBubyBsb25nZXIgdXNlZC5cbiAgICAgICAgLy8gVGhpcyBjYWNoZSBpcyBzaG9ydC1saXZlZCBiZWNhdXNlIGl0IGlzIHJlYWxseSBqdXN0IG1lYW50IHRvIHN1cHBseSBydW5uaW5nIHNoYWRlcnMgdGhhdCBhcmVcbiAgICAgICAgLy8gdXBkYXRlZCBkdXJpbmcgYSBudW1iZXIgb2YgZnJhbWVzLlxuICAgICAgICBsZXQgbGltaXQgPSB0aGlzLnN0YWdlLmZyYW1lQ291bnRlciAtIG1heEFnZTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlUG9vbCA9IHRoaXMuX3JlbmRlclRleHR1cmVQb29sLmZpbHRlcih0ZXh0dXJlID0+IHtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlLmYgPD0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mcmVlUmVuZGVyVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZVJlbmRlclRleHR1cmUodywgaCwgcHcsIHBoKSB7XG4gICAgICAgIHRoaXMuX2FkZE1lbW9yeVVzYWdlKHB3ICogcGgpO1xuXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnN0YWdlLnJlbmRlcmVyLmNyZWF0ZVJlbmRlclRleHR1cmUodywgaCwgcHcsIHBoKTtcbiAgICAgICAgdGV4dHVyZS5pZCA9IHRoaXMuX3JlbmRlclRleHR1cmVJZCsrO1xuICAgICAgICB0ZXh0dXJlLmYgPSB0aGlzLnN0YWdlLmZyYW1lQ291bnRlcjtcbiAgICAgICAgdGV4dHVyZS5vdyA9IHc7XG4gICAgICAgIHRleHR1cmUub2ggPSBoO1xuICAgICAgICB0ZXh0dXJlLncgPSBwdztcbiAgICAgICAgdGV4dHVyZS5oID0gcGg7XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuXG4gICAgX2ZyZWVSZW5kZXJUZXh0dXJlKG5hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5zdGFnZS5yZW5kZXJlci5mcmVlUmVuZGVyVGV4dHVyZShuYXRpdmVUZXh0dXJlKTtcbiAgICAgICAgdGhpcy5fYWRkTWVtb3J5VXNhZ2UoLW5hdGl2ZVRleHR1cmUudyAqIG5hdGl2ZVRleHR1cmUuaCk7XG4gICAgfVxuXG4gICAgY29weVJlbmRlclRleHR1cmUocmVuZGVyVGV4dHVyZSwgbmF0aXZlVGV4dHVyZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0YWdlLnJlbmRlcmVyLmNvcHlSZW5kZXJUZXh0dXJlKHJlbmRlclRleHR1cmUsIG5hdGl2ZVRleHR1cmUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZvcmNlWlNvcnQoZWxlbWVudENvcmUpIHtcbiAgICAgICAgdGhpcy5felNvcnRzLnB1c2goZWxlbWVudENvcmUpO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29yZVF1YWRMaXN0IHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuXG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuXG4gICAgICAgIHRoaXMucXVhZFRleHR1cmVzID0gW107XG5cbiAgICAgICAgdGhpcy5xdWFkRWxlbWVudHMgPSBbXTtcbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFkVGV4dHVyZXMubGVuZ3RoO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnF1YWRUZXh0dXJlcyA9IFtdO1xuICAgICAgICB0aGlzLnF1YWRFbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGdldEVsZW1lbnQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZEVsZW1lbnRzW2luZGV4XS5fZWxlbWVudDtcbiAgICB9XG5cbiAgICBnZXRFbGVtZW50Q29yZShpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFkRWxlbWVudHNbaW5kZXhdO1xuICAgIH1cblxuICAgIGdldFRleHR1cmUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZFRleHR1cmVzW2luZGV4XTtcbiAgICB9XG5cbiAgICBnZXRUZXh0dXJlV2lkdGgoaW5kZXgpIHtcbiAgICAgICAgbGV0IG5hdGl2ZVRleHR1cmUgPSB0aGlzLnF1YWRUZXh0dXJlc1tpbmRleF07XG4gICAgICAgIGlmIChuYXRpdmVUZXh0dXJlLncpIHtcbiAgICAgICAgICAgIC8vIFJlbmRlciB0ZXh0dXJlO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVRleHR1cmUudztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1YWRFbGVtZW50c1tpbmRleF0uX2Rpc3BsYXllZFRleHR1cmVTb3VyY2UudztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFRleHR1cmVIZWlnaHQoaW5kZXgpIHtcbiAgICAgICAgbGV0IG5hdGl2ZVRleHR1cmUgPSB0aGlzLnF1YWRUZXh0dXJlc1tpbmRleF07XG4gICAgICAgIGlmIChuYXRpdmVUZXh0dXJlLmgpIHtcbiAgICAgICAgICAgIC8vIFJlbmRlciB0ZXh0dXJlO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVRleHR1cmUuaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1YWRFbGVtZW50c1tpbmRleF0uX2Rpc3BsYXllZFRleHR1cmVTb3VyY2UuaDtcbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3JlUXVhZE9wZXJhdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgsIHNoYWRlciwgc2hhZGVyT3duZXIsIHJlbmRlclRleHR1cmVJbmZvLCBzY2lzc29yLCBpbmRleCkge1xuXG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcbiAgICAgICAgdGhpcy5zaGFkZXJPd25lciA9IHNoYWRlck93bmVyO1xuICAgICAgICB0aGlzLnJlbmRlclRleHR1cmVJbmZvID0gcmVuZGVyVGV4dHVyZUluZm87XG4gICAgICAgIHRoaXMuc2Npc3NvciA9IHNjaXNzb3I7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgfVxuXG4gICAgZ2V0IHF1YWRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdHgucmVuZGVyU3RhdGUucXVhZHM7XG4gICAgfVxuXG4gICAgZ2V0VGV4dHVyZShpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFkcy5nZXRUZXh0dXJlKHRoaXMuaW5kZXggKyBpbmRleCk7XG4gICAgfVxuXG4gICAgZ2V0RWxlbWVudENvcmUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZHMuZ2V0RWxlbWVudENvcmUodGhpcy5pbmRleCArIGluZGV4KTtcbiAgICB9XG5cbiAgICBnZXRFbGVtZW50KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRzLmdldEVsZW1lbnQodGhpcy5pbmRleCArIGluZGV4KTtcbiAgICB9XG5cbiAgICBnZXRFbGVtZW50V2lkdGgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudChpbmRleCkucmVuZGVyV2lkdGg7XG4gICAgfVxuXG4gICAgZ2V0RWxlbWVudEhlaWdodChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50KGluZGV4KS5yZW5kZXJIZWlnaHQ7XG4gICAgfVxuXG4gICAgZ2V0VGV4dHVyZVdpZHRoKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRzLmdldFRleHR1cmVXaWR0aCh0aGlzLmluZGV4ICsgaW5kZXgpO1xuICAgIH1cblxuICAgIGdldFRleHR1cmVIZWlnaHQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZHMuZ2V0VGV4dHVyZUhlaWdodCh0aGlzLmluZGV4ICsgaW5kZXgpO1xuICAgIH1cblxuICAgIGdldFJlbmRlcldpZHRoKCkge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJUZXh0dXJlSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVGV4dHVyZUluZm8udztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN0eC5zdGFnZS53O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UmVuZGVySGVpZ2h0KCkge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJUZXh0dXJlSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVGV4dHVyZUluZm8uaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN0eC5zdGFnZS5oO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcmVSZW5kZXJFeGVjdXRvciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZSA9IGN0eC5yZW5kZXJTdGF0ZTtcblxuICAgICAgICB0aGlzLmdsID0gdGhpcy5jdHguc3RhZ2UuZ2w7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICB9XG5cbiAgICBfcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX2JpbmRSZW5kZXJUZXh0dXJlKG51bGwpO1xuICAgICAgICB0aGlzLl9zZXRTY2lzc29yKG51bGwpO1xuICAgICAgICB0aGlzLl9jbGVhclJlbmRlclRleHR1cmUoKTtcbiAgICB9XG5cbiAgICBleGVjdXRlKCkge1xuICAgICAgICB0aGlzLl9yZXNldCgpO1xuXG4gICAgICAgIGxldCBxb3BzID0gdGhpcy5yZW5kZXJTdGF0ZS5xdWFkT3BlcmF0aW9ucztcblxuICAgICAgICBsZXQgaSA9IDAsIGogPSAwLCBuID0gcW9wcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1F1YWRPcGVyYXRpb24ocW9wc1tpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcHJvY2Vzc1F1YWRPcGVyYXRpb24ocXVhZE9wZXJhdGlvbikge1xuICAgICAgICBpZiAocXVhZE9wZXJhdGlvbi5yZW5kZXJUZXh0dXJlSW5mbyAmJiBxdWFkT3BlcmF0aW9uLnJlbmRlclRleHR1cmVJbmZvLmlnbm9yZSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIHF1YWQgb3BlcmF0aW9ucyB3aGVuIHdlIGFyZSAncmUtdXNpbmcnIGFub3RoZXIgdGV4dHVyZSBhcyB0aGUgcmVuZGVyIHRleHR1cmUgcmVzdWx0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0dXBRdWFkT3BlcmF0aW9uKHF1YWRPcGVyYXRpb24pO1xuICAgICAgICB0aGlzLl9leGVjUXVhZE9wZXJhdGlvbihxdWFkT3BlcmF0aW9uKTtcblxuICAgIH1cblxuICAgIF9zZXR1cFF1YWRPcGVyYXRpb24ocXVhZE9wZXJhdGlvbikge1xuICAgIH1cblxuICAgIF9leGVjUXVhZE9wZXJhdGlvbihvcCkge1xuICAgICAgICAvLyBTZXQgcmVuZGVyIHRleHR1cmUuXG4gICAgICAgIGxldCBuYXRpdmVUZXh0dXJlID0gb3AucmVuZGVyVGV4dHVyZUluZm8gPyBvcC5yZW5kZXJUZXh0dXJlSW5mby5uYXRpdmVUZXh0dXJlIDogbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyVGV4dHVyZSAhPT0gbmF0aXZlVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fYmluZFJlbmRlclRleHR1cmUobmF0aXZlVGV4dHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3AucmVuZGVyVGV4dHVyZUluZm8gJiYgIW9wLnJlbmRlclRleHR1cmVJbmZvLmNsZWFyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFNjaXNzb3IobnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclJlbmRlclRleHR1cmUoKTtcbiAgICAgICAgICAgIG9wLnJlbmRlclRleHR1cmVJbmZvLmNsZWFyZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2V0U2Npc3NvcihvcC5zY2lzc29yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFNjaXNzb3Iob3Auc2Npc3Nvcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZW5kZXJRdWFkT3BlcmF0aW9uKG9wKTtcbiAgICB9XG5cbiAgICBfcmVuZGVyUXVhZE9wZXJhdGlvbihvcCkge1xuICAgIH1cblxuICAgIF9iaW5kUmVuZGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmUgPSByZW5kZXJUZXh0dXJlO1xuICAgIH1cblxuICAgIF9jbGVhclJlbmRlclRleHR1cmUocmVuZGVyVGV4dHVyZSkge1xuICAgIH1cblxuICAgIF9zZXRTY2lzc29yKGFyZWEpIHtcbiAgICB9XG5cbn1cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29yZVJlbmRlclN0YXRlIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcblxuICAgICAgICB0aGlzLnN0YWdlID0gY3R4LnN0YWdlO1xuXG4gICAgICAgIHRoaXMuZGVmYXVsdFNoYWRlciA9IHRoaXMuc3RhZ2UucmVuZGVyZXIuZ2V0RGVmYXVsdFNoYWRlcihjdHgpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBjdHguc3RhZ2UucmVuZGVyZXI7XG5cbiAgICAgICAgdGhpcy5xdWFkcyA9IHRoaXMucmVuZGVyZXIuY3JlYXRlQ29yZVF1YWRMaXN0KGN0eCk7XG5cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZUluZm8gPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3NjaXNzb3IgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3NoYWRlciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fc2hhZGVyT3duZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3JlYWxTaGFkZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2NoZWNrID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5xdWFkT3BlcmF0aW9ucyA9IFtdO1xuXG4gICAgICAgIHRoaXMuX3RleHR1cml6ZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3RleHR1cml6ZXJUZW1wb3JhcnkgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9xdWFkT3BlcmF0aW9uID0gbnVsbDtcblxuICAgICAgICB0aGlzLnF1YWRzLnJlc2V0KCk7XG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5VGV4dHVyaXplcnMgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2lzQ2FjaGluZ1RleHR1cml6ZXIgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRzLnF1YWRUZXh0dXJlcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgc2V0U2hhZGVyKHNoYWRlciwgb3duZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NoYWRlck93bmVyICE9PSBvd25lciB8fCB0aGlzLl9yZWFsU2hhZGVyICE9PSBzaGFkZXIpIHtcbiAgICAgICAgICAgIC8vIFNhbWUgc2hhZGVyIG93bmVyOiBhY3RpdmUgc2hhZGVyIGlzIGFsc28gdGhlIHNhbWUuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGFueSBzaGFkZXIgdXNhZ2UgdG8gc2F2ZSBwZXJmb3JtYW5jZS5cblxuICAgICAgICAgICAgdGhpcy5fcmVhbFNoYWRlciA9IHNoYWRlcjtcblxuICAgICAgICAgICAgaWYgKHNoYWRlci51c2VEZWZhdWx0KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRlZmF1bHQgc2hhZGVyIHdoZW4gcG9zc2libGUgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBwcm9ncmFtIGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgc2hhZGVyID0gdGhpcy5kZWZhdWx0U2hhZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3NoYWRlciAhPT0gc2hhZGVyIHx8IHRoaXMuX3NoYWRlck93bmVyICE9PSBvd25lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRlciA9IHNoYWRlcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFkZXJPd25lciA9IG93bmVyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCByZW5kZXJUZXh0dXJlSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclRleHR1cmVJbmZvO1xuICAgIH1cblxuICAgIHNldFNjaXNzb3IoYXJlYSkge1xuICAgICAgICBpZiAodGhpcy5fc2Npc3NvciAhPT0gYXJlYSkge1xuICAgICAgICAgICAgaWYgKGFyZWEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2lzc29yID0gYXJlYTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Npc3NvciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGVjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRTY2lzc29yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Npc3NvcjtcbiAgICB9XG5cbiAgICBzZXRSZW5kZXJUZXh0dXJlSW5mbyhyZW5kZXJUZXh0dXJlSW5mbykge1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyVGV4dHVyZUluZm8gIT09IHJlbmRlclRleHR1cmVJbmZvKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mbyA9IHJlbmRlclRleHR1cmVJbmZvO1xuICAgICAgICAgICAgdGhpcy5fc2Npc3NvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9jaGVjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0ZXh0dXJpemVyIHRvIGJlIGRyYXduIGR1cmluZyBzdWJzZXF1ZW50IGFkZFF1YWRzLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudFRleHR1cml6ZXJ9IHRleHR1cml6ZXJcbiAgICAgKi9cbiAgICBzZXRUZXh0dXJpemVyKHRleHR1cml6ZXIsIGNhY2hlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fdGV4dHVyaXplciA9IHRleHR1cml6ZXI7XG4gICAgICAgIHRoaXMuX2NhY2hlVGV4dHVyaXplciA9IGNhY2hlO1xuICAgIH1cblxuICAgIHNldCBpc0NhY2hpbmdUZXh0dXJpemVyKHYpIHtcbiAgICAgICAgdGhpcy5faXNDYWNoaW5nVGV4dHVyaXplciA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGlzQ2FjaGluZ1RleHR1cml6ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NhY2hpbmdUZXh0dXJpemVyO1xuICAgIH1cblxuICAgIGFkZFF1YWQoZWxlbWVudENvcmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9xdWFkT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVRdWFkT3BlcmF0aW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY2hlY2sgJiYgdGhpcy5faGFzQ2hhbmdlcygpKSB7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hRdWFkT3BlcmF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLl9jaGVjayA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5hdGl2ZVRleHR1cmUgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdGV4dHVyaXplcikge1xuICAgICAgICAgICAgbmF0aXZlVGV4dHVyZSA9IHRoaXMuX3RleHR1cml6ZXIuZ2V0UmVzdWx0VGV4dHVyZSgpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NhY2hlVGV4dHVyaXplcikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiByZWxlYXNlIHRoZSB0ZW1wb3JhcnkgdGV4dHVyZSBpbW1lZGlhdGVseSBhZnRlciBmaW5hbGl6aW5nIHRoaXMgcXVhZCBvcGVyYXRpb24uXG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcG9yYXJ5VGV4dHVyaXplcnMucHVzaCh0aGlzLl90ZXh0dXJpemVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmF0aXZlVGV4dHVyZSkge1xuICAgICAgICAgICAgbmF0aXZlVGV4dHVyZSA9IGVsZW1lbnRDb3JlLl9kaXNwbGF5ZWRUZXh0dXJlU291cmNlLm5hdGl2ZVRleHR1cmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyVGV4dHVyZUluZm8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaGFkZXIgPT09IHRoaXMuZGVmYXVsdFNoYWRlciAmJiB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mby5lbXB0eSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB0ZXh0dXJlIG1pZ2h0IGJlIHJldXNhYmxlIHVuZGVyIHNvbWUgY29uZGl0aW9ucy4gV2Ugd2lsbCBjaGVjayB0aGVtIGluIEVsZW1lbnRDb3JlLnJlbmRlcmVyLlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVJbmZvLm5hdGl2ZVRleHR1cmUgPSBuYXRpdmVUZXh0dXJlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVJbmZvLm9mZnNldCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gcmV1c2UgYW5vdGhlciB0ZXh0dXJlIHdoZW4gdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBxdWFkLlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVJbmZvLm5hdGl2ZVRleHR1cmUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZUluZm8uZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucXVhZHMucXVhZFRleHR1cmVzLnB1c2gobmF0aXZlVGV4dHVyZSk7XG4gICAgICAgIHRoaXMucXVhZHMucXVhZEVsZW1lbnRzLnB1c2goZWxlbWVudENvcmUpO1xuXG4gICAgICAgIHRoaXMuX3F1YWRPcGVyYXRpb24ubGVuZ3RoKys7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRRdWFkKHRoaXMsIHRoaXMucXVhZHMsIHRoaXMubGVuZ3RoIC0gMSlcbiAgICB9XG5cbiAgICBmaW5pc2hlZFJlbmRlclRleHR1cmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJUZXh0dXJlSW5mby5uYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSB3YXMgb25seSBvbmUgdGV4dHVyZSBkcmF3biBpbiB0aGlzIHJlbmRlciB0ZXh0dXJlLlxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgY2FuIHJldXNlIGl0IHNvIHRoYXQgd2UgY2FuIG9wdGltaXplIG91dCBhbiB1bm5lY2Vzc2FyeSByZW5kZXIgdGV4dHVyZSBvcGVyYXRpb24uXG4gICAgICAgICAgICAvLyAoaXQgc2hvdWxkIGV4YWN0bHkgc3BhbiB0aGlzIHJlbmRlciB0ZXh0dXJlKS5cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNSZW5kZXJUZXh0dXJlUmV1c2FibGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVJbmZvLm5hdGl2ZVRleHR1cmUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2lzUmVuZGVyVGV4dHVyZVJldXNhYmxlKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mby5vZmZzZXQ7XG4gICAgICAgIHJldHVybiAodGhpcy5xdWFkcy5xdWFkVGV4dHVyZXNbb2Zmc2V0XS53ID09PSB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mby53KSAmJlxuICAgICAgICAgICAgKHRoaXMucXVhZHMucXVhZFRleHR1cmVzW29mZnNldF0uaCA9PT0gdGhpcy5fcmVuZGVyVGV4dHVyZUluZm8uaCkgJiZcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuaXNSZW5kZXJUZXh0dXJlUmV1c2FibGUodGhpcywgdGhpcy5fcmVuZGVyVGV4dHVyZUluZm8pXG4gICAgfVxuXG4gICAgX2hhc0NoYW5nZXMoKSB7XG4gICAgICAgIGxldCBxID0gdGhpcy5fcXVhZE9wZXJhdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuX3NoYWRlciAhPT0gcS5zaGFkZXIpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fc2hhZGVyT3duZXIgIT09IHEuc2hhZGVyT3duZXIpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyVGV4dHVyZUluZm8gIT09IHEucmVuZGVyVGV4dHVyZUluZm8pIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fc2Npc3NvciAhPT0gcS5zY2lzc29yKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuX3NjaXNzb3JbMF0gIT09IHEuc2Npc3NvclswXSkgfHwgKHRoaXMuX3NjaXNzb3JbMV0gIT09IHEuc2Npc3NvclsxXSkgfHwgKHRoaXMuX3NjaXNzb3JbMl0gIT09IHEuc2Npc3NvclsyXSkgfHwgKHRoaXMuX3NjaXNzb3JbM10gIT09IHEuc2Npc3NvclszXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBfZmluaXNoUXVhZE9wZXJhdGlvbihjcmVhdGUgPSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9xdWFkT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcXVhZE9wZXJhdGlvbi5sZW5ndGggfHwgdGhpcy5fc2hhZGVyLmFkZEVtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3F1YWRPcGVyYXRpb24uc2Npc3NvciB8fCAoKHRoaXMuX3F1YWRPcGVyYXRpb24uc2Npc3NvclsyXSA+IDApICYmICh0aGlzLl9xdWFkT3BlcmF0aW9uLnNjaXNzb3JbM10gPiAwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVtcHR5IGNsaXBwaW5nIHJlZ2lvbnMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVhZE9wZXJhdGlvbnMucHVzaCh0aGlzLl9xdWFkT3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl90ZW1wb3JhcnlUZXh0dXJpemVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX3RlbXBvcmFyeVRleHR1cml6ZXJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gbm93IHJldXNlIHRoZXNlIHJlbmRlci10by10ZXh0dXJlcyBpbiBzdWJzZXF1ZW50IHN0YWdlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gSHVnZSBwZXJmb3JtYW5jZSBiZW5lZml0IHdoZW4gZmlsdGVyaW5nIChmYXN0IGJsdXIpLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wb3JhcnlUZXh0dXJpemVyc1tpXS5yZWxlYXNlUmVuZGVyVGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wb3JhcnlUZXh0dXJpemVycyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9xdWFkT3BlcmF0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVF1YWRPcGVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jcmVhdGVRdWFkT3BlcmF0aW9uKCkge1xuICAgICAgICB0aGlzLl9xdWFkT3BlcmF0aW9uID0gdGhpcy5yZW5kZXJlci5jcmVhdGVDb3JlUXVhZE9wZXJhdGlvbihcbiAgICAgICAgICAgIHRoaXMuY3R4LFxuICAgICAgICAgICAgdGhpcy5fc2hhZGVyLFxuICAgICAgICAgICAgdGhpcy5fc2hhZGVyT3duZXIsXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mbyxcbiAgICAgICAgICAgIHRoaXMuX3NjaXNzb3IsXG4gICAgICAgICAgICB0aGlzLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9jaGVjayA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3F1YWRPcGVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIEFkZCByZW1haW5pbmcuXG4gICAgICAgICAgICB0aGlzLl9maW5pc2hRdWFkT3BlcmF0aW9uKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuZmluaXNoUmVuZGVyU3RhdGUodGhpcyk7XG4gICAgfVxuXG59XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBGbGV4VGFyZ2V0IGZyb20gXCIuLi8uLi9mbGV4L0ZsZXhUYXJnZXQubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnRDb3JlIHtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgICAgdGhpcy5jdHggPSBlbGVtZW50LnN0YWdlLmN0eDtcblxuICAgICAgICAvLyBUaGUgbWVtb3J5IGxheW91dCBvZiB0aGUgaW50ZXJuYWwgdmFyaWFibGVzIGlzIGFmZmVjdGVkIGJ5IHRoZWlyIHBvc2l0aW9uIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgLy8gSXQgYm9vc3RzIHBlcmZvcm1hbmNlIHRvIG9yZGVyIHRoZW0gYnkgdXNhZ2Ugb2YgY3B1LWhlYXZ5IGZ1bmN0aW9ucyAocmVuZGVyU2ltcGxlIGFuZCB1cGRhdGUpLlxuXG4gICAgICAgIHRoaXMuX3JlY2FsYyA9IDA7XG5cbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9vblVwZGF0ZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fcFJlY2FsYyA9IDA7XG5cbiAgICAgICAgdGhpcy5fd29ybGRDb250ZXh0ID0gbmV3IEVsZW1lbnRDb3JlQ29udGV4dCgpO1xuXG4gICAgICAgIHRoaXMuX2hhc1VwZGF0ZXMgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9sb2NhbEFscGhhID0gMTtcblxuICAgICAgICB0aGlzLl9vbkFmdGVyQ2FsY3MgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX29uQWZ0ZXJVcGRhdGUgPSBudWxsO1xuXG4gICAgICAgIC8vIEFsbCBsb2NhbCB0cmFuc2xhdGlvbi90cmFuc2Zvcm0gdXBkYXRlczogZGlyZWN0bHkgcHJvcGFnYXRlZCBmcm9tIHgveS93L2gvc2NhbGUvd2hhdGV2ZXIuXG4gICAgICAgIHRoaXMuX2xvY2FsUHggPSAwO1xuICAgICAgICB0aGlzLl9sb2NhbFB5ID0gMDtcblxuICAgICAgICB0aGlzLl9sb2NhbFRhID0gMTtcbiAgICAgICAgdGhpcy5fbG9jYWxUYiA9IDA7XG4gICAgICAgIHRoaXMuX2xvY2FsVGMgPSAwO1xuICAgICAgICB0aGlzLl9sb2NhbFRkID0gMTtcblxuICAgICAgICB0aGlzLl9pc0NvbXBsZXggPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9kaW1zVW5rbm93biA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2NsaXBwaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gVXNlZCBieSBib3RoIHVwZGF0ZSBhbmQgcmVuZGVyLlxuICAgICAgICB0aGlzLl96U29ydCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX291dE9mQm91bmRzID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHR1cmUgc291cmNlIHRvIGJlIGRpc3BsYXllZC5cbiAgICAgICAgICogQHR5cGUge1RleHR1cmVTb3VyY2V9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaXNwbGF5ZWRUZXh0dXJlU291cmNlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl96Q29udGV4dFVzYWdlID0gMDtcblxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5faGFzUmVuZGVyVXBkYXRlcyA9IDA7XG5cbiAgICAgICAgdGhpcy5fekluZGV4ZWRDaGlsZHJlbiA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyQ29udGV4dCA9IHRoaXMuX3dvcmxkQ29udGV4dDtcblxuICAgICAgICB0aGlzLnJlbmRlclN0YXRlID0gdGhpcy5jdHgucmVuZGVyU3RhdGU7XG5cbiAgICAgICAgdGhpcy5fc2Npc3NvciA9IG51bGw7XG5cbiAgICAgICAgLy8gVGhlIGFuY2VzdG9yIEVsZW1lbnRDb3JlIHRoYXQgb3ducyB0aGUgaW5oZXJpdGVkIHNoYWRlci4gTnVsbCBpZiBub25lIGlzIGFjdGl2ZSAoZGVmYXVsdCBzaGFkZXIpLlxuICAgICAgICB0aGlzLl9zaGFkZXJPd25lciA9IG51bGw7XG5cblxuICAgICAgICB0aGlzLl91cGRhdGVUcmVlT3JkZXIgPSAwO1xuXG4gICAgICAgIHRoaXMuX2NvbG9yVWwgPSB0aGlzLl9jb2xvclVyID0gdGhpcy5fY29sb3JCbCA9IHRoaXMuX2NvbG9yQnIgPSAweEZGRkZGRkZGO1xuXG4gICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgICB0aGlzLl95ID0gMDtcbiAgICAgICAgdGhpcy5fdyA9IDA7XG4gICAgICAgIHRoaXMuX2ggPSAwO1xuXG4gICAgICAgIHRoaXMuX29wdEZsYWdzID0gMDtcbiAgICAgICAgdGhpcy5fZnVuY1ggPSBudWxsO1xuICAgICAgICB0aGlzLl9mdW5jWSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Z1bmNXID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZnVuY0ggPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3NjYWxlWCA9IDE7XG4gICAgICAgIHRoaXMuX3NjYWxlWSA9IDE7XG4gICAgICAgIHRoaXMuX3Bpdm90WCA9IDAuNTtcbiAgICAgICAgdGhpcy5fcGl2b3RZID0gMC41O1xuICAgICAgICB0aGlzLl9tb3VudFggPSAwO1xuICAgICAgICB0aGlzLl9tb3VudFkgPSAwO1xuICAgICAgICB0aGlzLl9yb3RhdGlvbiA9IDA7XG5cbiAgICAgICAgdGhpcy5fYWxwaGEgPSAxO1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl91bHggPSAwO1xuICAgICAgICB0aGlzLl91bHkgPSAwO1xuICAgICAgICB0aGlzLl9icnggPSAxO1xuICAgICAgICB0aGlzLl9icnkgPSAxO1xuXG4gICAgICAgIHRoaXMuX3pJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2ZvcmNlWkluZGV4Q29udGV4dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl96UGFyZW50ID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9pc1Jvb3QgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWZmIHRydWUsIGR1cmluZyB6U29ydCwgdGhpcyBlbGVtZW50IHNob3VsZCBiZSAncmUtc29ydGVkJyBiZWNhdXNlIGVpdGhlcjpcbiAgICAgICAgICogLSB6SW5kZXggZGlkIGNoYW5nXG4gICAgICAgICAqIC0gelBhcmVudCBkaWQgY2hhbmdlXG4gICAgICAgICAqIC0gZWxlbWVudCB3YXMgbW92ZWQgaW4gdGhlIHJlbmRlciB0cmVlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fekluZGV4UmVzb3J0ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fc2hhZGVyID0gbnVsbDtcblxuICAgICAgICAvLyBFbGVtZW50IGlzIHJlbmRlcmVkIG9uIGFub3RoZXIgdGV4dHVyZS5cbiAgICAgICAgdGhpcy5fcmVuZGVyVG9UZXh0dXJlRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3RleHR1cml6ZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3VzZVJlbmRlclRvVGV4dHVyZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2JvdW5kc01hcmdpbiA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fcmVjQm91bmRzTWFyZ2luID0gbnVsbDtcblxuICAgICAgICB0aGlzLl93aXRoaW5Cb3VuZHNNYXJnaW4gPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl92aWV3cG9ydCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fY2xpcGJveCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLl9yZW5kZXJTaW1wbGU7XG5cbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgb2Zmc2V0WCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Z1bmNYKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnVuY1g7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGV4TGF5b3V0KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0Lm9yaWdpbmFsWDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgb2Zmc2V0WCh2KSB7XG4gICAgICAgIGlmIChVdGlscy5pc0Z1bmN0aW9uKHYpKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bmNYID0gdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVGdW5jWCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxleExheW91dCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ICs9ICh2IC0gdGhpcy5fbGF5b3V0Lm9yaWdpbmFsWCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0LnNldE9yaWdpbmFsWFdpdGhvdXRVcGRhdGluZ0xheW91dCh2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9XG5cbiAgICBzZXQgeCh2KSB7XG4gICAgICAgIGlmICh2ICE9PSB0aGlzLl94KSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zbGF0ZURlbHRhKHYgLSB0aGlzLl94LCAwKTtcbiAgICAgICAgICAgIHRoaXMuX3ggPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGZ1bmNYKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX29wdEZsYWdzICYgMSA/IHRoaXMuX2Z1bmNYIDogbnVsbCk7XG4gICAgfVxuXG4gICAgc2V0IGZ1bmNYKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Z1bmNYICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRGbGFncyB8PSAxO1xuICAgICAgICAgICAgdGhpcy5fZnVuY1ggPSB2O1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxleExheW91dCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0LnNldE9yaWdpbmFsWFdpdGhvdXRVcGRhdGluZ0xheW91dCgwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5mb3JjZUxheW91dCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyUmVjYWxjVHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZGlzYWJsZUZ1bmNYKCkge1xuICAgICAgICB0aGlzLl9vcHRGbGFncyA9IHRoaXMuX29wdEZsYWdzICYgKDB4RkZGRiAtIDEpO1xuICAgICAgICB0aGlzLl9mdW5jWCA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IG9mZnNldFkoKSB7XG4gICAgICAgIGlmICh0aGlzLl9mdW5jWSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bmNZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxleExheW91dCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dC5vcmlnaW5hbFk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IG9mZnNldFkodikge1xuICAgICAgICBpZiAoVXRpbHMuaXNGdW5jdGlvbih2KSkge1xuICAgICAgICAgICAgdGhpcy5mdW5jWSA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlRnVuY1koKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZsZXhMYXlvdXQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMueSArPSAodiAtIHRoaXMuX2xheW91dC5vcmlnaW5hbFkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dC5zZXRPcmlnaW5hbFlXaXRob3V0VXBkYXRpbmdMYXlvdXQodik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgfVxuXG4gICAgc2V0IHkodikge1xuICAgICAgICBpZiAodiAhPT0gdGhpcy5feSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2xhdGVEZWx0YSgwLCB2IC0gdGhpcy5feSk7XG4gICAgICAgICAgICB0aGlzLl95ID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBmdW5jWSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9vcHRGbGFncyAmIDIgPyB0aGlzLl9mdW5jWSA6IG51bGwpO1xuICAgIH1cblxuICAgIHNldCBmdW5jWSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9mdW5jWSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fb3B0RmxhZ3MgfD0gMjtcbiAgICAgICAgICAgIHRoaXMuX2Z1bmNZID0gdjtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZsZXhMYXlvdXQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dC5zZXRPcmlnaW5hbFlXaXRob3V0VXBkYXRpbmdMYXlvdXQoMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuZm9yY2VMYXlvdXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlclJlY2FsY1RyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2Rpc2FibGVGdW5jWSgpIHtcbiAgICAgICAgdGhpcy5fb3B0RmxhZ3MgPSB0aGlzLl9vcHRGbGFncyAmICgweEZGRkYgLSAyKTtcbiAgICAgICAgdGhpcy5fZnVuY1kgPSBudWxsO1xuICAgIH1cblxuICAgIGdldCBmdW5jVygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9vcHRGbGFncyAmIDQgPyB0aGlzLl9mdW5jVyA6IG51bGwpO1xuICAgIH1cblxuICAgIHNldCBmdW5jVyh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9mdW5jVyAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fb3B0RmxhZ3MgfD0gNDtcbiAgICAgICAgICAgIHRoaXMuX2Z1bmNXID0gdjtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZsZXhMYXlvdXQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dC5fb3JpZ2luYWxXaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuY2hhbmdlZERpbWVuc2lvbnModHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyUmVjYWxjVHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNhYmxlRnVuY1coKSB7XG4gICAgICAgIHRoaXMuX29wdEZsYWdzID0gdGhpcy5fb3B0RmxhZ3MgJiAoMHhGRkZGIC0gNCk7XG4gICAgICAgIHRoaXMuX2Z1bmNXID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgZnVuY0goKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fb3B0RmxhZ3MgJiA4ID8gdGhpcy5fZnVuY0ggOiBudWxsKTtcbiAgICB9XG5cbiAgICBzZXQgZnVuY0godikge1xuICAgICAgICBpZiAodGhpcy5fZnVuY0ggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX29wdEZsYWdzIHw9IDg7XG4gICAgICAgICAgICB0aGlzLl9mdW5jSCA9IHY7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGV4TGF5b3V0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXQuX29yaWdpbmFsSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5jaGFuZ2VkRGltZW5zaW9ucyhmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJSZWNhbGNUcmFuc2xhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2FibGVGdW5jSCgpIHtcbiAgICAgICAgdGhpcy5fb3B0RmxhZ3MgPSB0aGlzLl9vcHRGbGFncyAmICgweEZGRkYgLSA4KTtcbiAgICAgICAgdGhpcy5fZnVuY0ggPSBudWxsO1xuICAgIH1cblxuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdztcbiAgICB9XG5cbiAgICBnZXRSZW5kZXJXaWR0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRmxleExheW91dCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0Lm9yaWdpbmFsV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faDtcbiAgICB9XG5cbiAgICBnZXRSZW5kZXJIZWlnaHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0ZsZXhMYXlvdXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dC5vcmlnaW5hbEhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHNjYWxlWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlWDtcbiAgICB9XG5cbiAgICBzZXQgc2NhbGVYKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlWCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGVYID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2NhbGVZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVZO1xuICAgIH1cblxuICAgIHNldCBzY2FsZVkodikge1xuICAgICAgICBpZiAodGhpcy5fc2NhbGVZICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9zY2FsZVkgPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVYO1xuICAgIH1cblxuICAgIHNldCBzY2FsZSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9zY2FsZVggIT09IHYgfHwgdGhpcy5fc2NhbGVZICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9zY2FsZVggPSB2O1xuICAgICAgICAgICAgdGhpcy5fc2NhbGVZID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcGl2b3RYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RYO1xuICAgIH1cblxuICAgIHNldCBwaXZvdFgodikge1xuICAgICAgICBpZiAodGhpcy5fcGl2b3RYICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9waXZvdFggPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2xhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBwaXZvdFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXZvdFk7XG4gICAgfVxuXG4gICAgc2V0IHBpdm90WSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9waXZvdFkgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90WSA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zbGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RYO1xuICAgIH1cblxuICAgIHNldCBwaXZvdCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9waXZvdFggIT09IHYgfHwgdGhpcy5fcGl2b3RZICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9waXZvdFggPSB2O1xuICAgICAgICAgICAgdGhpcy5fcGl2b3RZID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNsYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbW91bnRYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW91bnRYO1xuICAgIH1cblxuICAgIHNldCBtb3VudFgodikge1xuICAgICAgICBpZiAodGhpcy5fbW91bnRYICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9tb3VudFggPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2xhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBtb3VudFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb3VudFk7XG4gICAgfVxuXG4gICAgc2V0IG1vdW50WSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb3VudFkgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX21vdW50WSA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zbGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IG1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW91bnRYO1xuICAgIH1cblxuICAgIHNldCBtb3VudCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb3VudFggIT09IHYgfHwgdGhpcy5fbW91bnRZICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9tb3VudFggPSB2O1xuICAgICAgICAgICAgdGhpcy5fbW91bnRZID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNsYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcm90YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcbiAgICB9XG5cbiAgICBzZXQgcm90YXRpb24odikge1xuICAgICAgICBpZiAodGhpcy5fcm90YXRpb24gIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdGF0aW9uID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgYWxwaGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbHBoYTtcbiAgICB9XG5cbiAgICBzZXQgYWxwaGEodikge1xuICAgICAgICAvLyBBY2NvdW50IGZvciByb3VuZGluZyBlcnJvcnMuXG4gICAgICAgIHYgPSAodiA+IDEgPyAxIDogKHYgPCAxZS0xNCA/IDAgOiB2KSk7XG4gICAgICAgIGlmICh0aGlzLl9hbHBoYSAhPT0gdikge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLl9hbHBoYTtcbiAgICAgICAgICAgIHRoaXMuX2FscGhhID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsQWxwaGEoKTtcbiAgICAgICAgICAgIGlmICgocHJldiA9PT0gMCkgIT09ICh2ID09PSAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuX3VwZGF0ZUVuYWJsZWRGbGFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfVxuXG4gICAgc2V0IHZpc2libGUodikge1xuICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbEFscGhhKCk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50Ll91cGRhdGVFbmFibGVkRmxhZygpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGV4TGF5b3V0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5zZXRWaXNpYmxlKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3VwZGF0ZUxvY2FsVHJhbnNmb3JtKCkge1xuICAgICAgICBpZiAodGhpcy5fcm90YXRpb24gIT09IDAgJiYgdGhpcy5fcm90YXRpb24gJSAoMiAqIE1hdGguUEkpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHJvdGF0aW9uIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyByZW5kZXIuIFRoaXMgbWVhbnMgd2Ugb25seSBuZWVkIHRvIHVzZSBzaW4gYW5kIGNvcyB3aGVuIHJvdGF0aW9uIGFjdHVhbGx5IGNoYW5nZXNcbiAgICAgICAgICAgIGxldCBfc3IgPSBNYXRoLnNpbih0aGlzLl9yb3RhdGlvbik7XG4gICAgICAgICAgICBsZXQgX2NyID0gTWF0aC5jb3ModGhpcy5fcm90YXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLl9zZXRMb2NhbFRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICBfY3IgKiB0aGlzLl9zY2FsZVgsXG4gICAgICAgICAgICAgICAgLV9zciAqIHRoaXMuX3NjYWxlWSxcbiAgICAgICAgICAgICAgICBfc3IgKiB0aGlzLl9zY2FsZVgsXG4gICAgICAgICAgICAgICAgX2NyICogdGhpcy5fc2NhbGVZXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0TG9jYWxUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgdGhpcy5fc2NhbGVYLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2FsZVlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2xhdGUoKTtcbiAgICB9O1xuXG4gICAgX3VwZGF0ZUxvY2FsVHJhbnNsYXRlKCkge1xuICAgICAgICB0aGlzLl9yZWNhbGNMb2NhbFRyYW5zbGF0ZSgpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyUmVjYWxjVHJhbnNsYXRlKCk7XG4gICAgfTtcblxuICAgIF9yZWNhbGNMb2NhbFRyYW5zbGF0ZSgpIHtcbiAgICAgICAgbGV0IHBpdm90WE11bCA9IHRoaXMuX3Bpdm90WCAqIHRoaXMuX3c7XG4gICAgICAgIGxldCBwaXZvdFlNdWwgPSB0aGlzLl9waXZvdFkgKiB0aGlzLl9oO1xuICAgICAgICBsZXQgcHggPSB0aGlzLl94IC0gKHBpdm90WE11bCAqIHRoaXMuX2xvY2FsVGEgKyBwaXZvdFlNdWwgKiB0aGlzLl9sb2NhbFRiKSArIHBpdm90WE11bDtcbiAgICAgICAgbGV0IHB5ID0gdGhpcy5feSAtIChwaXZvdFhNdWwgKiB0aGlzLl9sb2NhbFRjICsgcGl2b3RZTXVsICogdGhpcy5fbG9jYWxUZCkgKyBwaXZvdFlNdWw7XG4gICAgICAgIHB4IC09IHRoaXMuX21vdW50WCAqIHRoaXMuX3c7XG4gICAgICAgIHB5IC09IHRoaXMuX21vdW50WSAqIHRoaXMuX2g7XG4gICAgICAgIHRoaXMuX2xvY2FsUHggPSBweDtcbiAgICAgICAgdGhpcy5fbG9jYWxQeSA9IHB5O1xuICAgIH1cblxuICAgIF91cGRhdGVMb2NhbFRyYW5zbGF0ZURlbHRhKGR4LCBkeSkge1xuICAgICAgICB0aGlzLl9hZGRMb2NhbFRyYW5zbGF0ZShkeCwgZHkpO1xuICAgIH07XG5cbiAgICBfdXBkYXRlTG9jYWxBbHBoYSgpIHtcbiAgICAgICAgdGhpcy5fc2V0TG9jYWxBbHBoYSh0aGlzLl92aXNpYmxlID8gdGhpcy5fYWxwaGEgOiAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAgICAgKiAwOiBubyB1cGRhdGVzXG4gICAgICogMTogcmUtaW52b2tlIHNoYWRlclxuICAgICAqIDM6IHJlLWNyZWF0ZSByZW5kZXIgdGV4dHVyZSBhbmQgcmUtaW52b2tlIHNoYWRlclxuICAgICAqL1xuICAgIHNldEhhc1JlbmRlclVwZGF0ZXModHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fd29ybGRDb250ZXh0LmFscGhhKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgaWYgJ3dvcmxkIGludmlzaWJsZScuIFJlbmRlciB1cGRhdGVzIHdpbGwgYmUgcmVzZXQgdG8gMyBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGJlY29tZXMgdmlzaWJsZS5cbiAgICAgICAgICAgIGxldCBwID0gdGhpcztcbiAgICAgICAgICAgIHAuX2hhc1JlbmRlclVwZGF0ZXMgPSBNYXRoLm1heCh0eXBlLCBwLl9oYXNSZW5kZXJVcGRhdGVzKTtcbiAgICAgICAgICAgIHdoaWxlICgocCA9IHAuX3BhcmVudCkgJiYgKHAuX2hhc1JlbmRlclVwZGF0ZXMgIT09IDMpKSB7XG4gICAgICAgICAgICAgICAgcC5faGFzUmVuZGVyVXBkYXRlcyA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdHlwZVxuICAgICAqICAgMTogYWxwaGFcbiAgICAgKiAgIDI6IHRyYW5zbGF0ZVxuICAgICAqICAgNDogdHJhbnNmb3JtXG4gICAgICogMTI4OiBiZWNvbWVzIHZpc2libGVcbiAgICAgKiAyNTY6IGZsZXggbGF5b3V0IHVwZGF0ZWRcbiAgICAgKi9cbiAgICBfc2V0UmVjYWxjKHR5cGUpIHtcbiAgICAgICAgdGhpcy5fcmVjYWxjIHw9IHR5cGU7XG5cbiAgICAgICAgdGhpcy5fc2V0SGFzVXBkYXRlcygpO1xuXG4gICAgICAgIC8vIEFueSBjaGFuZ2VzIGluIGRlc2NlbmRhbnRzIHNob3VsZCB0cmlnZ2VyIHRleHR1cmUgdXBkYXRlcy5cbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50LnNldEhhc1JlbmRlclVwZGF0ZXMoMyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0SGFzVXBkYXRlcygpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICB3aGlsZSAocCAmJiAhcC5faGFzVXBkYXRlcykge1xuICAgICAgICAgICAgcC5faGFzVXBkYXRlcyA9IHRydWU7XG4gICAgICAgICAgICBwID0gcC5fcGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgIH1cblxuICAgIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gdGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgICBsZXQgcHJldklzWkNvbnRleHQgPSB0aGlzLmlzWkNvbnRleHQoKTtcbiAgICAgICAgICAgIGxldCBwcmV2UGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgICAgICAvLyBOb3RpZnkgZmxleCBsYXlvdXQgZW5naW5lLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2xheW91dCB8fCAocGFyZW50ICYmIHBhcmVudC5pc0ZsZXhDb250YWluZXIoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5zZXRQYXJlbnQocHJldlBhcmVudCwgcGFyZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGVsZW1lbnRzIGFyZSBkZWxldGVkLCB0aGUgcmVuZGVyIHRleHR1cmUgbXVzdCBiZSByZS1yZW5kZXJlZC5cbiAgICAgICAgICAgICAgICBwcmV2UGFyZW50LnNldEhhc1JlbmRlclVwZGF0ZXMoMyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFJlY2FsYygxICsgMiArIDQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgcGFyZW50IHRvIHByb3BhZ2F0ZSBoYXNVcGRhdGVzIGZsYWcuXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll9zZXRIYXNVcGRhdGVzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl96SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFpQYXJlbnQocGFyZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRaUGFyZW50KHBhcmVudCA/IHBhcmVudC5maW5kWkNvbnRleHQoKSA6IG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldklzWkNvbnRleHQgIT09IHRoaXMuaXNaQ29udGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzWkNvbnRleHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVaQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlWkNvbnRleHQocHJldlBhcmVudC5maW5kWkNvbnRleHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUcmVlIG9yZGVyIGRpZCBjaGFuZ2U6IGV2ZW4gaWYgelBhcmVudCBzdGF5cyB0aGUgc2FtZSwgd2UgbXVzdCByZXNvcnQuXG4gICAgICAgICAgICB0aGlzLl96SW5kZXhSZXNvcnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3pQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl96UGFyZW50LmVuYWJsZVpTb3J0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1NoYWRlck93bmVyID0gcGFyZW50ICYmICFwYXJlbnQuX3JlbmRlclRvVGV4dHVyZUVuYWJsZWQgPyBwYXJlbnQuX3NoYWRlck93bmVyIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobmV3U2hhZGVyT3duZXIgIT09IHRoaXMuX3NoYWRlck93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SGFzUmVuZGVyVXBkYXRlcygxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2hhZGVyT3duZXJSZWN1cnNpdmUobmV3U2hhZGVyT3duZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBlbmFibGVaU29ydChmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5felNvcnQgJiYgdGhpcy5fekNvbnRleHRVc2FnZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3pTb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIC8vIFpTb3J0IG11c3QgYmUgZG9uZSwgZXZlbiBpZiB0aGlzIGVsZW1lbnQgaXMgaW52aXNpYmxlLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgZG9uZSB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcyB3aGVuIHJlbW92aW5nIGVsZW1lbnQgZnJvbSBpbmFjdGl2ZSByZW5kZXIgYnJhbmNoZXMuXG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZm9yY2VaU29ydCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZENoaWxkQXQoaW5kZXgsIGNoaWxkKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2hpbGRyZW4pIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuICAgICAgICBjaGlsZC5zZXRQYXJlbnQodGhpcyk7XG4gICAgfTtcblxuICAgIHNldENoaWxkQXQoaW5kZXgsIGNoaWxkKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2hpbGRyZW4pIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuW2luZGV4XS5zZXRQYXJlbnQobnVsbCk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuW2luZGV4XSA9IGNoaWxkO1xuICAgICAgICBjaGlsZC5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuXG4gICAgcmVtb3ZlQ2hpbGRBdChpbmRleCkge1xuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpbmRleF07XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGNoaWxkLnNldFBhcmVudChudWxsKTtcbiAgICB9O1xuXG4gICAgcmVtb3ZlQ2hpbGRyZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbltpXS5zZXRQYXJlbnQobnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnNwbGljZSgwKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3pJbmRleGVkQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl96SW5kZXhlZENoaWxkcmVuLnNwbGljZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzeW5jQ2hpbGRyZW4ocmVtb3ZlZCwgYWRkZWQsIG9yZGVyKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gb3JkZXI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gcmVtb3ZlZC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHJlbW92ZWRbaV0uc2V0UGFyZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gYWRkZWQubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBhZGRlZFtpXS5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3ZlQ2hpbGQoZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIGxldCBjID0gdGhpcy5fY2hpbGRyZW5bZnJvbUluZGV4XTtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGZyb21JbmRleCwgMSk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnNwbGljZSh0b0luZGV4LCAwLCBjKTtcblxuICAgICAgICAvLyBUcmVlIG9yZGVyIGNoYW5nZWQ6IG11c3QgcmVzb3J0ITtcbiAgICAgICAgdGhpcy5fekluZGV4UmVzb3J0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3pQYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3pQYXJlbnQuZW5hYmxlWlNvcnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRMb2NhbFRyYW5zZm9ybShhLCBiLCBjLCBkKSB7XG4gICAgICAgIHRoaXMuX3NldFJlY2FsYyg0KTtcbiAgICAgICAgdGhpcy5fbG9jYWxUYSA9IGE7XG4gICAgICAgIHRoaXMuX2xvY2FsVGIgPSBiO1xuICAgICAgICB0aGlzLl9sb2NhbFRjID0gYztcbiAgICAgICAgdGhpcy5fbG9jYWxUZCA9IGQ7XG5cbiAgICAgICAgLy8gV2UgYWxzbyByZWdhcmQgbmVnYXRpdmUgc2NhbGluZyBhcyBhIGNvbXBsZXggY2FzZSwgc28gdGhhdCB3ZSBjYW4gb3B0aW1pemUgdGhlIG5vbi1jb21wbGV4IGNhc2UgYmV0dGVyLlxuICAgICAgICB0aGlzLl9pc0NvbXBsZXggPSAoYiAhPT0gMCkgfHwgKGMgIT09IDApIHx8IChhIDwgMCkgfHwgKGQgPCAwKTtcbiAgICB9O1xuXG4gICAgX2FkZExvY2FsVHJhbnNsYXRlKGR4LCBkeSkge1xuICAgICAgICB0aGlzLl9sb2NhbFB4ICs9IGR4O1xuICAgICAgICB0aGlzLl9sb2NhbFB5ICs9IGR5O1xuICAgICAgICB0aGlzLl90cmlnZ2VyUmVjYWxjVHJhbnNsYXRlKCk7XG4gICAgfVxuXG4gICAgX3NldExvY2FsQWxwaGEoYSkge1xuICAgICAgICBpZiAoIXRoaXMuX3dvcmxkQ29udGV4dC5hbHBoYSAmJiAoKHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX3dvcmxkQ29udGV4dC5hbHBoYSkgJiYgYSkpIHtcbiAgICAgICAgICAgIC8vIEVsZW1lbnQgaXMgYmVjb21pbmcgdmlzaWJsZS4gV2UgbmVlZCB0byBmb3JjZSB1cGRhdGUuXG4gICAgICAgICAgICB0aGlzLl9zZXRSZWNhbGMoMSArIDEyOCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRSZWNhbGMoMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYSA8IDFlLTE0KSB7XG4gICAgICAgICAgICAvLyBUaW55IHJvdW5kaW5nIGVycm9ycyBtYXkgY2F1c2UgZmFpbGluZyB2aXNpYmlsaXR5IHRlc3RzLlxuICAgICAgICAgICAgYSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb2NhbEFscGhhID0gYTtcbiAgICB9O1xuXG4gICAgc2V0RGltZW5zaW9ucyh3LCBoLCBpc0VzdGltYXRlID0gdGhpcy5fZGltc1Vua25vd24pIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBhbiBlc3RpbWF0aW9uLCB0aGUgdXBkYXRlIGxvb3Agc2hvdWxkIHBlcmZvcm0gZGlmZmVyZW50IGJvdW5kIGNoZWNrcy5cbiAgICAgICAgdGhpcy5fZGltc1Vua25vd24gPSBpc0VzdGltYXRlO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZsZXhMYXlvdXQoKSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0Lm9yaWdpbmFsV2lkdGggPSB3O1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0Lm9yaWdpbmFsSGVpZ2h0ID0gaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl93ICE9PSB3IHx8IHRoaXMuX2ggIT09IGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKHcsIGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX3VwZGF0ZURpbWVuc2lvbnModywgaCkge1xuICAgICAgICBpZiAodGhpcy5fdyAhPT0gdyB8fCB0aGlzLl9oICE9PSBoKSB7XG4gICAgICAgICAgICB0aGlzLl93ID0gdztcbiAgICAgICAgICAgIHRoaXMuX2ggPSBoO1xuXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyUmVjYWxjVHJhbnNsYXRlKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0dXJpemVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyaXplci5yZWxlYXNlUmVuZGVyVGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cml6ZXIudXBkYXRlUmVzdWx0VGV4dHVyZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRHVlIHRvIHdpZHRoL2hlaWdodCBjaGFuZ2U6IHVwZGF0ZSB0aGUgdHJhbnNsYXRpb24gdmVjdG9yLlxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2xhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFRleHR1cmVDb29yZHModWx4LCB1bHksIGJyeCwgYnJ5KSB7XG4gICAgICAgIHRoaXMuc2V0SGFzUmVuZGVyVXBkYXRlcygzKTtcblxuICAgICAgICB0aGlzLl91bHggPSB1bHg7XG4gICAgICAgIHRoaXMuX3VseSA9IHVseTtcbiAgICAgICAgdGhpcy5fYnJ4ID0gYnJ4O1xuICAgICAgICB0aGlzLl9icnkgPSBicnk7XG4gICAgfTtcblxuICAgIGdldCBkaXNwbGF5ZWRUZXh0dXJlU291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGxheWVkVGV4dHVyZVNvdXJjZTtcbiAgICB9XG5cbiAgICBzZXREaXNwbGF5ZWRUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zZXRIYXNSZW5kZXJVcGRhdGVzKDMpO1xuICAgICAgICB0aGlzLl9kaXNwbGF5ZWRUZXh0dXJlU291cmNlID0gdGV4dHVyZVNvdXJjZTtcbiAgICB9O1xuXG4gICAgZ2V0IGlzUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUm9vdDtcbiAgICB9XG5cbiAgICBzZXRBc1Jvb3QoKSB7XG4gICAgICAgIC8vIFVzZSBwYXJlbnQgZHVtbXkuXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG5ldyBFbGVtZW50Q29yZSh0aGlzLl9lbGVtZW50KTtcblxuICAgICAgICAvLyBBZnRlciBzZXR0aW5nIHJvb3QsIG1ha2Ugc3VyZSBpdCdzIHVwZGF0ZWQuXG4gICAgICAgIHRoaXMuX3BhcmVudC5faGFzUmVuZGVyVXBkYXRlcyA9IDM7XG4gICAgICAgIHRoaXMuX3BhcmVudC5faGFzVXBkYXRlcyA9IHRydWU7XG5cbiAgICAgICAgLy8gUm9vdCBpcywgYW5kIHdpbGwgYWx3YXlzIGJlLCB0aGUgcHJpbWFyeSB6Q29udGV4dC5cbiAgICAgICAgdGhpcy5faXNSb290ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmN0eC5yb290ID0gdGhpcztcblxuICAgICAgICAvLyBTZXQgc2Npc3NvciBhcmVhIG9mICdmYWtlIHBhcmVudCcgdG8gc3RhZ2UncyB2aWV3cG9ydC5cbiAgICAgICAgdGhpcy5fcGFyZW50Ll92aWV3cG9ydCA9IFswLCAwLCB0aGlzLmN0eC5zdGFnZS5jb29yZHNXaWR0aCwgdGhpcy5jdHguc3RhZ2UuY29vcmRzSGVpZ2h0XTtcbiAgICAgICAgdGhpcy5fcGFyZW50Ll9zY2lzc29yID0gdGhpcy5fcGFyZW50Ll92aWV3cG9ydDtcblxuICAgICAgICAvLyBXaGVuIHJlY0JvdW5kc01hcmdpbiBpcyBudWxsLCB0aGUgZGVmYXVsdHMgYXJlIHVzZWQgKDEwMCBmb3IgYWxsIHNpZGVzKS5cbiAgICAgICAgdGhpcy5fcGFyZW50Ll9yZWNCb3VuZHNNYXJnaW4gPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3NldFJlY2FsYygxICsgMiArIDQpO1xuICAgIH07XG5cbiAgICBpc0FuY2VzdG9yT2YoYykge1xuICAgICAgICBsZXQgcCA9IGM7XG4gICAgICAgIHdoaWxlIChwID0gcC5fcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcyA9PT0gcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgaXNaQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9mb3JjZVpJbmRleENvbnRleHQgfHwgdGhpcy5fcmVuZGVyVG9UZXh0dXJlRW5hYmxlZCB8fCB0aGlzLl96SW5kZXggIT09IDAgfHwgdGhpcy5faXNSb290IHx8ICF0aGlzLl9wYXJlbnQpO1xuICAgIH07XG5cbiAgICBmaW5kWkNvbnRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWkNvbnRleHQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50LmZpbmRaQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNldFpQYXJlbnQobmV3WlBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5felBhcmVudCAhPT0gbmV3WlBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3pQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fekluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3pQYXJlbnQuZGVjWkNvbnRleHRVc2FnZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlIG11c3QgZmlsdGVyIG91dCB0aGlzIGl0ZW0gdXBvbiB0aGUgbmV4dCByZXNvcnQuXG4gICAgICAgICAgICAgICAgdGhpcy5felBhcmVudC5lbmFibGVaU29ydCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV3WlBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBoYWRaQ29udGV4dFVzYWdlID0gKG5ld1pQYXJlbnQuX3pDb250ZXh0VXNhZ2UgPiAwKTtcblxuICAgICAgICAgICAgICAgIC8vIEBwcmU6IG5ldyBwYXJlbnQncyBjaGlsZHJlbiBhcnJheSBoYXMgYWxyZWFkeSBiZWVuIG1vZGlmaWVkLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl96SW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3WlBhcmVudC5pbmNaQ29udGV4dFVzYWdlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5ld1pQYXJlbnQuX3pDb250ZXh0VXNhZ2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFkWkNvbnRleHRVc2FnZSAmJiAodGhpcy5fcGFyZW50ID09PSBuZXdaUGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjaGlsZCB3YXMgYWxyZWFkeSBpbiB0aGUgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhZGQgZG91YmxlLlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG5ldyBjaGlsZCB0byBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1pQYXJlbnQuX3pJbmRleGVkQ2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9yZGVyIHNob3VsZCBiZSBjaGVja2VkLlxuICAgICAgICAgICAgICAgICAgICBuZXdaUGFyZW50LmVuYWJsZVpTb3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl96UGFyZW50ID0gbmV3WlBhcmVudDtcblxuICAgICAgICAgICAgLy8gTmV3bHkgYWRkZWQgZWxlbWVudCBtdXN0IGJlIG1hcmtlZCBmb3IgcmVzb3J0LlxuICAgICAgICAgICAgdGhpcy5fekluZGV4UmVzb3J0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpbmNaQ29udGV4dFVzYWdlKCkge1xuICAgICAgICB0aGlzLl96Q29udGV4dFVzYWdlKys7XG4gICAgICAgIGlmICh0aGlzLl96Q29udGV4dFVzYWdlID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3pJbmRleGVkQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl96SW5kZXhlZENoaWxkcmVuID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBDb3B5LlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3pJbmRleGVkQ2hpbGRyZW4ucHVzaCh0aGlzLl9jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxseSwgY2hpbGRyZW4gYXJlIGFscmVhZHkgc29ydGVkIHByb3Blcmx5ICh0cmVlIG9yZGVyKS5cbiAgICAgICAgICAgICAgICB0aGlzLl96U29ydCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRlY1pDb250ZXh0VXNhZ2UoKSB7XG4gICAgICAgIHRoaXMuX3pDb250ZXh0VXNhZ2UtLTtcbiAgICAgICAgaWYgKHRoaXMuX3pDb250ZXh0VXNhZ2UgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3pTb3J0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl96SW5kZXhlZENoaWxkcmVuLnNwbGljZSgwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnZXQgekluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fekluZGV4O1xuICAgIH1cblxuICAgIHNldCB6SW5kZXgoekluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLl96SW5kZXggIT09IHpJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIYXNSZW5kZXJVcGRhdGVzKDEpO1xuXG4gICAgICAgICAgICBsZXQgbmV3WlBhcmVudCA9IHRoaXMuX3pQYXJlbnQ7XG5cbiAgICAgICAgICAgIGxldCBwcmV2SXNaQ29udGV4dCA9IHRoaXMuaXNaQ29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKHpJbmRleCA9PT0gMCAmJiB0aGlzLl96SW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ID09PSB0aGlzLl96UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl96UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl96UGFyZW50LmRlY1pDb250ZXh0VXNhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1pQYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh6SW5kZXggIT09IDAgJiYgdGhpcy5fekluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbmV3WlBhcmVudCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5maW5kWkNvbnRleHQoKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1pQYXJlbnQgPT09IHRoaXMuX3pQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3pQYXJlbnQuaW5jWkNvbnRleHRVc2FnZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5felBhcmVudC5lbmFibGVaU29ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh6SW5kZXggIT09IHRoaXMuX3pJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl96UGFyZW50ICYmIHRoaXMuX3pQYXJlbnQuX3pDb250ZXh0VXNhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5felBhcmVudC5lbmFibGVaU29ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5ld1pQYXJlbnQgIT09IHRoaXMuX3pQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFpQYXJlbnQobnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3pJbmRleCA9IHpJbmRleDtcblxuICAgICAgICAgICAgaWYgKG5ld1pQYXJlbnQgIT09IHRoaXMuX3pQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFpQYXJlbnQobmV3WlBhcmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2SXNaQ29udGV4dCAhPT0gdGhpcy5pc1pDb250ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNaQ29udGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZVpDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGVaQ29udGV4dCh0aGlzLl9wYXJlbnQuZmluZFpDb250ZXh0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgcmVzb3J0IGlzIGRvbmUuXG4gICAgICAgICAgICB0aGlzLl96SW5kZXhSZXNvcnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3pQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl96UGFyZW50LmVuYWJsZVpTb3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ2V0IGZvcmNlWkluZGV4Q29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcmNlWkluZGV4Q29udGV4dDtcbiAgICB9XG5cbiAgICBzZXQgZm9yY2VaSW5kZXhDb250ZXh0KHYpIHtcbiAgICAgICAgdGhpcy5zZXRIYXNSZW5kZXJVcGRhdGVzKDEpO1xuXG4gICAgICAgIGxldCBwcmV2SXNaQ29udGV4dCA9IHRoaXMuaXNaQ29udGV4dCgpO1xuICAgICAgICB0aGlzLl9mb3JjZVpJbmRleENvbnRleHQgPSB2O1xuXG4gICAgICAgIGlmIChwcmV2SXNaQ29udGV4dCAhPT0gdGhpcy5pc1pDb250ZXh0KCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1pDb250ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVaQ29udGV4dCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZVpDb250ZXh0KHRoaXMuX3BhcmVudC5maW5kWkNvbnRleHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZW5hYmxlWkNvbnRleHQocHJldlpDb250ZXh0KSB7XG4gICAgICAgIGlmIChwcmV2WkNvbnRleHQgJiYgcHJldlpDb250ZXh0Ll96Q29udGV4dFVzYWdlID4gMCkge1xuICAgICAgICAgICAgLy8gVHJhbnNmZXIgZnJvbSB1cHBlciB6IGNvbnRleHQgdG8gdGhpcyB6IGNvbnRleHQuXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5fZ2V0WkluZGV4ZWREZXNjcygpO1xuICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBbmNlc3Rvck9mKGMpICYmIGMuX3pJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjLnNldFpQYXJlbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0WkluZGV4ZWREZXNjcygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0uX2dldFpJbmRleGVkRGVzY3NSZWMocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgX2dldFpJbmRleGVkRGVzY3NSZWMocmVzdWx0cykge1xuICAgICAgICBpZiAodGhpcy5fekluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY2hpbGRyZW4gJiYgIXRoaXMuaXNaQ29udGV4dCgpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLl9nZXRaSW5kZXhlZERlc2NzUmVjKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzYWJsZVpDb250ZXh0KCkge1xuICAgICAgICAvLyBUcmFuc2ZlciBmcm9tIHRoaXMgeiBjb250ZXh0IHRvIHVwcGVyIHogY29udGV4dC5cbiAgICAgICAgaWYgKHRoaXMuX3pDb250ZXh0VXNhZ2UgPiAwKSB7XG4gICAgICAgICAgICBsZXQgbmV3WlBhcmVudCA9IHRoaXMuX3BhcmVudC5maW5kWkNvbnRleHQoKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgei1pbmRleGVkIGNoaWxkcmVuIGFyZSB1cCB0byBkYXRlIChvbGQgb25lcyByZW1vdmVkKS5cbiAgICAgICAgICAgIGlmICh0aGlzLl96U29ydCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ydFpJbmRleGVkQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fekluZGV4ZWRDaGlsZHJlbi5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5fekluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuc2V0WlBhcmVudChuZXdaUGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnZXQgY29sb3JVbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yVWw7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yVWwoY29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yVWwgIT09IGNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhhc1JlbmRlclVwZGF0ZXModGhpcy5fZGlzcGxheWVkVGV4dHVyZVNvdXJjZSA/IDMgOiAxKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yVWwgPSBjb2xvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjb2xvclVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JVcjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JVcihjb2xvcikge1xuICAgICAgICBpZiAodGhpcy5fY29sb3JVciAhPT0gY29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGFzUmVuZGVyVXBkYXRlcyh0aGlzLl9kaXNwbGF5ZWRUZXh0dXJlU291cmNlID8gMyA6IDEpO1xuICAgICAgICAgICAgdGhpcy5fY29sb3JVciA9IGNvbG9yO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGdldCBjb2xvckJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JCbDtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JCbChjb2xvcikge1xuICAgICAgICBpZiAodGhpcy5fY29sb3JCbCAhPT0gY29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGFzUmVuZGVyVXBkYXRlcyh0aGlzLl9kaXNwbGF5ZWRUZXh0dXJlU291cmNlID8gMyA6IDEpO1xuICAgICAgICAgICAgdGhpcy5fY29sb3JCbCA9IGNvbG9yO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGdldCBjb2xvckJyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JCcjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JCcihjb2xvcikge1xuICAgICAgICBpZiAodGhpcy5fY29sb3JCciAhPT0gY29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGFzUmVuZGVyVXBkYXRlcyh0aGlzLl9kaXNwbGF5ZWRUZXh0dXJlU291cmNlID8gMyA6IDEpO1xuICAgICAgICAgICAgdGhpcy5fY29sb3JCciA9IGNvbG9yO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgc2V0IG9uVXBkYXRlKGYpIHtcbiAgICAgICAgdGhpcy5fb25VcGRhdGUgPSBmO1xuICAgICAgICB0aGlzLl9zZXRSZWNhbGMoNyk7XG4gICAgfVxuXG4gICAgc2V0IG9uQWZ0ZXJVcGRhdGUoZikge1xuICAgICAgICB0aGlzLl9vbkFmdGVyVXBkYXRlID0gZjtcbiAgICAgICAgdGhpcy5fc2V0UmVjYWxjKDcpO1xuICAgIH1cblxuICAgIHNldCBvbkFmdGVyQ2FsY3MoZikge1xuICAgICAgICB0aGlzLl9vbkFmdGVyQ2FsY3MgPSBmO1xuICAgICAgICB0aGlzLl9zZXRSZWNhbGMoNyk7XG4gICAgfVxuXG4gICAgZ2V0IHNoYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYWRlcjtcbiAgICB9XG5cbiAgICBzZXQgc2hhZGVyKHYpIHtcbiAgICAgICAgdGhpcy5zZXRIYXNSZW5kZXJVcGRhdGVzKDEpO1xuXG4gICAgICAgIGxldCBwcmV2U2hhZGVyID0gdGhpcy5fc2hhZGVyO1xuICAgICAgICB0aGlzLl9zaGFkZXIgPSB2O1xuICAgICAgICBpZiAoIXYgJiYgcHJldlNoYWRlcikge1xuICAgICAgICAgICAgLy8gRGlzYWJsZWQgc2hhZGVyLlxuICAgICAgICAgICAgbGV0IG5ld1NoYWRlck93bmVyID0gKHRoaXMuX3BhcmVudCAmJiAhdGhpcy5fcGFyZW50Ll9yZW5kZXJUb1RleHR1cmVFbmFibGVkID8gdGhpcy5fcGFyZW50Ll9zaGFkZXJPd25lciA6IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fc2V0U2hhZGVyT3duZXJSZWN1cnNpdmUobmV3U2hhZGVyT3duZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHYpIHtcbiAgICAgICAgICAgIC8vIEVuYWJsZWQgc2hhZGVyLlxuICAgICAgICAgICAgdGhpcy5fc2V0U2hhZGVyT3duZXJSZWN1cnNpdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgYWN0aXZlU2hhZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hhZGVyT3duZXIgPyB0aGlzLl9zaGFkZXJPd25lci5zaGFkZXIgOiB0aGlzLnJlbmRlclN0YXRlLmRlZmF1bHRTaGFkZXI7XG4gICAgfVxuXG4gICAgZ2V0IGFjdGl2ZVNoYWRlck93bmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hhZGVyT3duZXI7XG4gICAgfVxuXG4gICAgZ2V0IGNsaXBwaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpcHBpbmc7XG4gICAgfVxuXG4gICAgc2V0IGNsaXBwaW5nKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NsaXBwaW5nICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlwcGluZyA9IHY7XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIHVwZGF0ZSBvZiBzY2lzc29yIGJ5IHVwZGF0aW5nIHRyYW5zbGF0ZS5cbiAgICAgICAgICAgIC8vIEFscGhhIG11c3QgYWxzbyBiZSB1cGRhdGVkIGJlY2F1c2UgdGhlIHNjaXNzb3IgYXJlYSBtYXkgaGF2ZSBiZWVuIGVtcHR5LlxuICAgICAgICAgICAgdGhpcy5fc2V0UmVjYWxjKDEgKyAyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjbGlwYm94KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpcGJveDtcbiAgICB9XG5cbiAgICBzZXQgY2xpcGJveCh2KSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2Ygb3V0LW9mLWJvdW5kcyBlbGVtZW50LCBhbGwgY2hpbGRyZW4gd2lsbCBhbHNvIGJlIGlnbm9yZWQuXG4gICAgICAgIC8vIEl0IHdpbGwgc2F2ZSB1cyBmcm9tIGV4ZWN1dGluZyB0aGUgdXBkYXRlL3JlbmRlciBsb29wcyBmb3IgdGhvc2UuXG4gICAgICAgIC8vIFRoZSBvcHRpbWl6YXRpb24gd2lsbCBiZSB1c2VkIGltbWVkaWF0ZWx5IGR1cmluZyB0aGUgbmV4dCBmcmFtZS5cbiAgICAgICAgdGhpcy5fY2xpcGJveCA9IHY7XG4gICAgfVxuXG4gICAgX3NldFNoYWRlck93bmVyUmVjdXJzaXZlKGVsZW1lbnRDb3JlKSB7XG4gICAgICAgIHRoaXMuX3NoYWRlck93bmVyID0gZWxlbWVudENvcmU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuICYmICF0aGlzLl9yZW5kZXJUb1RleHR1cmVFbmFibGVkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKCFjLl9zaGFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5fc2V0U2hhZGVyT3duZXJSZWN1cnNpdmUoZWxlbWVudENvcmUpO1xuICAgICAgICAgICAgICAgICAgICBjLl9oYXNSZW5kZXJVcGRhdGVzID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX3NldFNoYWRlck93bmVyQ2hpbGRyZW5SZWN1cnNpdmUoZWxlbWVudENvcmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKCFjLl9zaGFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5fc2V0U2hhZGVyT3duZXJSZWN1cnNpdmUoZWxlbWVudENvcmUpO1xuICAgICAgICAgICAgICAgICAgICBjLl9oYXNSZW5kZXJVcGRhdGVzID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX2hhc1JlbmRlckNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJDb250ZXh0ICE9PSB0aGlzLl93b3JsZENvbnRleHQ7XG4gICAgfVxuXG4gICAgZ2V0IHJlbmRlckNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJDb250ZXh0O1xuICAgIH1cblxuICAgIHVwZGF0ZVJlbmRlclRvVGV4dHVyZUVuYWJsZWQoKSB7XG4gICAgICAgIC8vIEVuZm9yY2UgdGV4dHVyaXplciBpbml0aWFsaXNhdGlvbi5cbiAgICAgICAgbGV0IHYgPSB0aGlzLnRleHR1cml6ZXIuX2VuYWJsZWQ7XG5cbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZVJlbmRlclRvVGV4dHVyZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZVJlbmRlclRvVGV4dHVyZSgpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyaXplci5yZWxlYXNlUmVuZGVyVGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2VuYWJsZVJlbmRlclRvVGV4dHVyZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJUb1RleHR1cmVFbmFibGVkKSB7XG4gICAgICAgICAgICBsZXQgcHJldklzWkNvbnRleHQgPSB0aGlzLmlzWkNvbnRleHQoKTtcblxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVG9UZXh0dXJlRW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNvbnRleHQgPSBuZXcgRWxlbWVudENvcmVDb250ZXh0KCk7XG5cbiAgICAgICAgICAgIC8vIElmIHJlbmRlciB0byB0ZXh0dXJlIGlzIGFjdGl2ZSwgYSBuZXcgc2hhZGVyIGNvbnRleHQgaXMgc3RhcnRlZC5cbiAgICAgICAgICAgIHRoaXMuX3NldFNoYWRlck93bmVyQ2hpbGRyZW5SZWN1cnNpdmUobnVsbCk7XG5cbiAgICAgICAgICAgIGlmICghcHJldklzWkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgY29udGV4dCBmb3JjZXMgeiBjb250ZXh0LlxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlWkNvbnRleHQodGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZpbmRaQ29udGV4dCgpIDogbnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0SGFzUmVuZGVyVXBkYXRlcygzKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHJlbmRlciBjb29yZGluYXRlcyBnZXQgdXBkYXRlZC5cbiAgICAgICAgICAgIHRoaXMuX3NldFJlY2FsYyg3KTtcblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLl9yZW5kZXJBZHZhbmNlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9kaXNhYmxlUmVuZGVyVG9UZXh0dXJlKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyVG9UZXh0dXJlRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVG9UZXh0dXJlRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLl9zZXRTaGFkZXJPd25lckNoaWxkcmVuUmVjdXJzaXZlKHRoaXMuX3NoYWRlck93bmVyKTtcblxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ29udGV4dCA9IHRoaXMuX3dvcmxkQ29udGV4dDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzWkNvbnRleHQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZVpDb250ZXh0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSByZW5kZXIgY29vcmRpbmF0ZXMgZ2V0IHVwZGF0ZWQuXG4gICAgICAgICAgICB0aGlzLl9zZXRSZWNhbGMoNyk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0SGFzUmVuZGVyVXBkYXRlcygzKTtcblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLl9yZW5kZXJTaW1wbGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc1doaXRlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2NvbG9yVWwgPT09IDB4RkZGRkZGRkYpICYmICh0aGlzLl9jb2xvclVyID09PSAweEZGRkZGRkZGKSAmJiAodGhpcy5fY29sb3JCbCA9PT0gMHhGRkZGRkZGRikgJiYgKHRoaXMuX2NvbG9yQnIgPT09IDB4RkZGRkZGRkYpO1xuICAgIH1cblxuICAgIGhhc1NpbXBsZVRleENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl91bHggPT09IDApICYmICh0aGlzLl91bHkgPT09IDApICYmICh0aGlzLl9icnggPT09IDEpICYmICh0aGlzLl9icnkgPT09IDEpO1xuICAgIH1cblxuICAgIF9zdGFzaFRleENvb3JkcygpIHtcbiAgICAgICAgdGhpcy5fc3Rhc2hlZFRleENvb3JkcyA9IFt0aGlzLl91bHgsIHRoaXMuX3VseSwgdGhpcy5fYnJ4LCB0aGlzLl9icnldO1xuICAgICAgICB0aGlzLl91bHggPSAwO1xuICAgICAgICB0aGlzLl91bHkgPSAwO1xuICAgICAgICB0aGlzLl9icnggPSAxO1xuICAgICAgICB0aGlzLl9icnkgPSAxO1xuICAgIH1cblxuICAgIF91bnN0YXNoVGV4Q29vcmRzKCkge1xuICAgICAgICB0aGlzLl91bHggPSB0aGlzLl9zdGFzaGVkVGV4Q29vcmRzWzBdO1xuICAgICAgICB0aGlzLl91bHkgPSB0aGlzLl9zdGFzaGVkVGV4Q29vcmRzWzFdO1xuICAgICAgICB0aGlzLl9icnggPSB0aGlzLl9zdGFzaGVkVGV4Q29vcmRzWzJdO1xuICAgICAgICB0aGlzLl9icnkgPSB0aGlzLl9zdGFzaGVkVGV4Q29vcmRzWzNdO1xuICAgICAgICB0aGlzLl9zdGFzaGVkVGV4Q29vcmRzID0gbnVsbDtcbiAgICB9XG5cbiAgICBfc3Rhc2hDb2xvcnMoKSB7XG4gICAgICAgIHRoaXMuX3N0YXNoZWRDb2xvcnMgPSBbdGhpcy5fY29sb3JVbCwgdGhpcy5fY29sb3JVciwgdGhpcy5fY29sb3JCciwgdGhpcy5fY29sb3JCbF07XG4gICAgICAgIHRoaXMuX2NvbG9yVWwgPSAweEZGRkZGRkZGO1xuICAgICAgICB0aGlzLl9jb2xvclVyID0gMHhGRkZGRkZGRjtcbiAgICAgICAgdGhpcy5fY29sb3JCciA9IDB4RkZGRkZGRkY7XG4gICAgICAgIHRoaXMuX2NvbG9yQmwgPSAweEZGRkZGRkZGO1xuICAgIH1cblxuICAgIF91bnN0YXNoQ29sb3JzKCkge1xuICAgICAgICB0aGlzLl9jb2xvclVsID0gdGhpcy5fc3Rhc2hlZENvbG9yc1swXTtcbiAgICAgICAgdGhpcy5fY29sb3JVciA9IHRoaXMuX3N0YXNoZWRDb2xvcnNbMV07XG4gICAgICAgIHRoaXMuX2NvbG9yQnIgPSB0aGlzLl9zdGFzaGVkQ29sb3JzWzJdO1xuICAgICAgICB0aGlzLl9jb2xvckJsID0gdGhpcy5fc3Rhc2hlZENvbG9yc1szXTtcbiAgICAgICAgdGhpcy5fc3Rhc2hlZENvbG9ycyA9IG51bGw7XG4gICAgfVxuXG4gICAgaXNWaXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2xvY2FsQWxwaGEgPiAxZS0xNCk7XG4gICAgfTtcblxuICAgIGdldCBvdXRPZkJvdW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX291dE9mQm91bmRzO1xuICAgIH1cblxuICAgIHNldCBib3VuZHNNYXJnaW4odikge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgbnVsbDogaW5oZXJpdCBmcm9tIHBhcmVudC5cbiAgICAgICAgICogIG51bWJlcls0XTogc3BlY2lmaWMgbWFyZ2luczogbGVmdCwgdG9wLCByaWdodCwgYm90dG9tLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYm91bmRzTWFyZ2luID0gdiA/IHYuc2xpY2UoKSA6IG51bGw7XG5cbiAgICAgICAgLy8gV2UgZm9yY2UgcmVjYWxjIGluIG9yZGVyIHRvIHNldCBhbGwgYm91bmRzTWFyZ2luIHJlY3Vyc2l2ZWx5IGR1cmluZyB0aGUgbmV4dCB1cGRhdGUuXG4gICAgICAgIHRoaXMuX3RyaWdnZXJSZWNhbGNUcmFuc2xhdGUoKTtcbiAgICB9XG5cbiAgICBnZXQgYm91bmRzTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzTWFyZ2luO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcmVjYWxjIHw9IHRoaXMuX3BhcmVudC5fcFJlY2FsYztcblxuICAgICAgICBpZiAodGhpcy5fbGF5b3V0ICYmIHRoaXMuX2xheW91dC5pc0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlY2FsYyAmIDI1Nikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dC5sYXlvdXRGbGV4VHJlZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCh0aGlzLl9yZWNhbGMgJiAyKSAmJiB0aGlzLl9vcHRGbGFncykge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlSZWxhdGl2ZURpbUZ1bmNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb25VcGRhdGUpIHtcbiAgICAgICAgICAgIC8vIEJsb2NrIGFsbCAndXB3YXJkcycgdXBkYXRlcyB3aGVuIGNoYW5naW5nIHRoaW5ncyBpbiB0aGlzIGJyYW5jaC5cbiAgICAgICAgICAgIHRoaXMuX2hhc1VwZGF0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fb25VcGRhdGUodGhpcy5lbGVtZW50LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHB3ID0gdGhpcy5fcGFyZW50Ll93b3JsZENvbnRleHQ7XG4gICAgICAgIGxldCB3ID0gdGhpcy5fd29ybGRDb250ZXh0O1xuICAgICAgICBjb25zdCB2aXNpYmxlID0gKHB3LmFscGhhICYmIHRoaXMuX2xvY2FsQWxwaGEpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBtdXN0IHVwZGF0ZSBpZjpcbiAgICAgICAgICogLSBicmFuY2ggY29udGFpbnMgdXBkYXRlcyAoZXZlbiB3aGVuIGludmlzaWJsZSBiZWNhdXNlIGl0IG1heSBjb250YWluIHotaW5kZXhlZCBkZXNjZW5kYW50cylcbiAgICAgICAgICogLSB0aGVyZSBhcmUgKGluaGVyaXRlZCkgdXBkYXRlcyBhbmQgdGhpcyBicmFuY2ggaXMgdmlzaWJsZVxuICAgICAgICAgKiAtIHRoaXMgYnJhbmNoIGJlY29tZXMgaW52aXNpYmxlIChkZXNjcyBtYXkgYmUgei1pbmRleGVkIHNvIHdlIG11c3QgdXBkYXRlIGFsbCBhbHBoYSB2YWx1ZXMpXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5faGFzVXBkYXRlcyB8fCAodGhpcy5fcmVjYWxjICYmIHZpc2libGUpIHx8ICh3LmFscGhhICYmICF2aXNpYmxlKSkge1xuICAgICAgICAgICAgbGV0IHJlY2FsYyA9IHRoaXMuX3JlY2FsYztcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHdvcmxkIGNvb3Jkcy9hbHBoYS5cbiAgICAgICAgICAgIGlmIChyZWNhbGMgJiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3LmFscGhhICYmIHZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVjb21lcyB2aXNpYmxlLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNSZW5kZXJVcGRhdGVzID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdy5hbHBoYSA9IHB3LmFscGhhICogdGhpcy5fbG9jYWxBbHBoYTtcblxuICAgICAgICAgICAgICAgIGlmICh3LmFscGhhIDwgMWUtMTQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGlueSByb3VuZGluZyBlcnJvcnMgbWF5IGNhdXNlIGZhaWxpbmcgdmlzaWJpbGl0eSB0ZXN0cy5cbiAgICAgICAgICAgICAgICAgICAgdy5hbHBoYSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVjYWxjICYgNikge1xuICAgICAgICAgICAgICAgIHcucHggPSBwdy5weCArIHRoaXMuX2xvY2FsUHggKiBwdy50YTtcbiAgICAgICAgICAgICAgICB3LnB5ID0gcHcucHkgKyB0aGlzLl9sb2NhbFB5ICogcHcudGQ7XG4gICAgICAgICAgICAgICAgaWYgKHB3LnRiICE9PSAwKSB3LnB4ICs9IHRoaXMuX2xvY2FsUHkgKiBwdy50YjtcbiAgICAgICAgICAgICAgICBpZiAocHcudGMgIT09IDApIHcucHkgKz0gdGhpcy5fbG9jYWxQeCAqIHB3LnRjO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVjYWxjICYgNCkge1xuICAgICAgICAgICAgICAgIHcudGEgPSB0aGlzLl9sb2NhbFRhICogcHcudGE7XG4gICAgICAgICAgICAgICAgdy50YiA9IHRoaXMuX2xvY2FsVGQgKiBwdy50YjtcbiAgICAgICAgICAgICAgICB3LnRjID0gdGhpcy5fbG9jYWxUYSAqIHB3LnRjO1xuICAgICAgICAgICAgICAgIHcudGQgPSB0aGlzLl9sb2NhbFRkICogcHcudGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNDb21wbGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHcudGEgKz0gdGhpcy5fbG9jYWxUYyAqIHB3LnRiO1xuICAgICAgICAgICAgICAgICAgICB3LnRiICs9IHRoaXMuX2xvY2FsVGIgKiBwdy50YTtcbiAgICAgICAgICAgICAgICAgICAgdy50YyArPSB0aGlzLl9sb2NhbFRjICogcHcudGQ7XG4gICAgICAgICAgICAgICAgICAgIHcudGQgKz0gdGhpcy5fbG9jYWxUYiAqIHB3LnRjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIHJlbmRlciBjb29yZHMvYWxwaGEuXG4gICAgICAgICAgICBjb25zdCBwciA9IHRoaXMuX3BhcmVudC5fcmVuZGVyQ29udGV4dDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQuX2hhc1JlbmRlckNvbnRleHQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXQgPSB0aGlzLl9yZW5kZXJDb250ZXh0ID09PSB0aGlzLl93b3JsZENvbnRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgcmVuZGVyIGNvbnRleHQgYnVpbGQ6IG1ha2Ugc3VyZSB0aGF0IGl0IGlzIGZ1bGx5IGluaXRpYWxpemVkIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSBnZXQgaW50byBib3VuZHMgbGF0ZXIsIHRoZSByZW5kZXIgY29udGV4dCB3b3VsZCBub3QgYmUgaW5pdGlhbGl6ZWQgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJDb250ZXh0ID0gbmV3IEVsZW1lbnRDb3JlQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9yZW5kZXJDb250ZXh0O1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHdvcmxkIGNvb3Jkcy9hbHBoYS5cbiAgICAgICAgICAgICAgICBpZiAoaW5pdCB8fCAocmVjYWxjICYgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgci5hbHBoYSA9IHByLmFscGhhICogdGhpcy5fbG9jYWxBbHBoYTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoci5hbHBoYSA8IDFlLTE0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByLmFscGhhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbml0IHx8IChyZWNhbGMgJiA2KSkge1xuICAgICAgICAgICAgICAgICAgICByLnB4ID0gcHIucHggKyB0aGlzLl9sb2NhbFB4ICogcHIudGE7XG4gICAgICAgICAgICAgICAgICAgIHIucHkgPSBwci5weSArIHRoaXMuX2xvY2FsUHkgKiBwci50ZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByLnRiICE9PSAwKSByLnB4ICs9IHRoaXMuX2xvY2FsUHkgKiBwci50YjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByLnRjICE9PSAwKSByLnB5ICs9IHRoaXMuX2xvY2FsUHggKiBwci50YztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzZXQgdGhlIHJlY2FsYyB0b2dnbGUsIGJlY2F1c2Ugd2UgbXVzdCBtYWtlIHN1cmUgdGhhdCB0aGUgc2Npc3NvciBpcyB1cGRhdGVkLlxuICAgICAgICAgICAgICAgICAgICByZWNhbGMgfD0gMjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5pdCB8fCAocmVjYWxjICYgNCkpIHtcbiAgICAgICAgICAgICAgICAgICAgci50YSA9IHRoaXMuX2xvY2FsVGEgKiBwci50YTtcbiAgICAgICAgICAgICAgICAgICAgci50YiA9IHRoaXMuX2xvY2FsVGQgKiBwci50YjtcbiAgICAgICAgICAgICAgICAgICAgci50YyA9IHRoaXMuX2xvY2FsVGEgKiBwci50YztcbiAgICAgICAgICAgICAgICAgICAgci50ZCA9IHRoaXMuX2xvY2FsVGQgKiBwci50ZDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNDb21wbGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByLnRhICs9IHRoaXMuX2xvY2FsVGMgKiBwci50YjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIudGIgKz0gdGhpcy5fbG9jYWxUYiAqIHByLnRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgci50YyArPSB0aGlzLl9sb2NhbFRjICogcHIudGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByLnRkICs9IHRoaXMuX2xvY2FsVGIgKiBwci50YztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ29udGV4dCA9IHRoaXMuX3dvcmxkQ29udGV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY3R4LnVwZGF0ZVRyZWVPcmRlciA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC51cGRhdGVUcmVlT3JkZXIgPSB0aGlzLl91cGRhdGVUcmVlT3JkZXIgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVUcmVlT3JkZXIgPSB0aGlzLmN0eC51cGRhdGVUcmVlT3JkZXIrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgd2UgbXVzdCB1c2UgYSAncmVuZGVyVGV4dHVyZScuXG4gICAgICAgICAgICBjb25zdCB1c2VSZW5kZXJUb1RleHR1cmUgPSB0aGlzLl9yZW5kZXJUb1RleHR1cmVFbmFibGVkICYmIHRoaXMuX3RleHR1cml6ZXIubXVzdFJlbmRlclRvVGV4dHVyZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VzZVJlbmRlclRvVGV4dHVyZSAhPT0gdXNlUmVuZGVyVG9UZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29vcmRzIG11c3QgYmUgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNhbGMgfD0gMiArIDQ7XG5cbiAgICAgICAgICAgICAgICAvLyBTY2lzc29yIG1heSBjaGFuZ2U6IGZvcmNlIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICByZWNhbGMgfD0gMjtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdXNlUmVuZGVyVG9UZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG11c3QgcmVsZWFzZSB0aGUgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyaXplci5yZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXNlUmVuZGVyVG9UZXh0dXJlID0gdXNlUmVuZGVyVG9UZXh0dXJlO1xuXG4gICAgICAgICAgICBjb25zdCByID0gdGhpcy5fcmVuZGVyQ29udGV4dDtcblxuICAgICAgICAgICAgY29uc3QgYmJveFcgPSB0aGlzLl9kaW1zVW5rbm93biA/IDIwNDggOiB0aGlzLl93O1xuICAgICAgICAgICAgY29uc3QgYmJveEggPSB0aGlzLl9kaW1zVW5rbm93biA/IDIwNDggOiB0aGlzLl9oO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgYSBiYm94IGZvciB0aGlzIGVsZW1lbnQuXG4gICAgICAgICAgICBsZXQgc3gsIHN5LCBleCwgZXk7XG4gICAgICAgICAgICBjb25zdCByQ29tcGxleCA9IChyLnRiICE9PSAwKSB8fCAoci50YyAhPT0gMCkgfHwgKHIudGEgPCAwKSB8fCAoci50ZCA8IDApO1xuICAgICAgICAgICAgaWYgKHJDb21wbGV4KSB7XG4gICAgICAgICAgICAgICAgc3ggPSBNYXRoLm1pbigwLCBiYm94VyAqIHIudGEsIGJib3hXICogci50YSArIGJib3hIICogci50YiwgYmJveEggKiByLnRiKSArIHIucHg7XG4gICAgICAgICAgICAgICAgZXggPSBNYXRoLm1heCgwLCBiYm94VyAqIHIudGEsIGJib3hXICogci50YSArIGJib3hIICogci50YiwgYmJveEggKiByLnRiKSArIHIucHg7XG4gICAgICAgICAgICAgICAgc3kgPSBNYXRoLm1pbigwLCBiYm94VyAqIHIudGMsIGJib3hXICogci50YyArIGJib3hIICogci50ZCwgYmJveEggKiByLnRkKSArIHIucHk7XG4gICAgICAgICAgICAgICAgZXkgPSBNYXRoLm1heCgwLCBiYm94VyAqIHIudGMsIGJib3hXICogci50YyArIGJib3hIICogci50ZCwgYmJveEggKiByLnRkKSArIHIucHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN4ID0gci5weDtcbiAgICAgICAgICAgICAgICBleCA9IHIucHggKyByLnRhICogYmJveFc7XG4gICAgICAgICAgICAgICAgc3kgPSByLnB5O1xuICAgICAgICAgICAgICAgIGV5ID0gci5weSArIHIudGQgKiBiYm94SDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2RpbXNVbmtub3duICYmIChyQ29tcGxleCB8fCB0aGlzLl9sb2NhbFRhIDwgMSB8fCB0aGlzLl9sb2NhbFRiIDwgMSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgbm9uLWlkZW50aXR5IG1hdHJpeCwgd2UgbXVzdCBleHRlbmQgdGhlIGJib3ggc28gdGhhdCB3aXRoaW5Cb3VuZHMgYW5kXG4gICAgICAgICAgICAgICAgLy8gIHNjaXNzb3JzIHdpbGwgaW5jbHVkZSB0aGUgY29tcGxldGUgcmFuZ2Ugb2YgKHBvc2l0aXZlKSBkaW1lbnNpb25zIHVwIHRvICxsaC5cbiAgICAgICAgICAgICAgICBjb25zdCBueCA9IHRoaXMuX3ggKiBwci50YSArIHRoaXMuX3kgKiBwci50YiArIHByLnB4O1xuICAgICAgICAgICAgICAgIGNvbnN0IG55ID0gdGhpcy5feCAqIHByLnRjICsgdGhpcy5feSAqIHByLnRkICsgcHIucHk7XG4gICAgICAgICAgICAgICAgaWYgKG54IDwgc3gpIHN4ID0gbng7XG4gICAgICAgICAgICAgICAgaWYgKG55IDwgc3kpIHN5ID0gbnk7XG4gICAgICAgICAgICAgICAgaWYgKG54ID4gZXgpIGV4ID0gbng7XG4gICAgICAgICAgICAgICAgaWYgKG55ID4gZXkpIGV5ID0gbnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZWNhbGMgJiA2IHx8ICF0aGlzLl9zY2lzc29yIC8qIGluaXRpYWwgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB3ZSBtdXN0ICdjbGlwJy5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2xpcHBpbmcgJiYgci5pc1NxdWFyZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwYXJlbnQgcmVuZGVycyB0byBhIHRleHR1cmUsIGl0J3Mgc2Npc3NvciBzaG91bGQgYmUgaWdub3JlZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJlYSA9IHRoaXMuX3BhcmVudC5fdXNlUmVuZGVyVG9UZXh0dXJlID8gdGhpcy5fcGFyZW50Ll92aWV3cG9ydCA6IHRoaXMuX3BhcmVudC5fc2Npc3NvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1lcmdlIHNjaXNzb3IgYXJlYXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBseCA9IE1hdGgubWF4KGFyZWFbMF0sIHN4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGx5ID0gTWF0aC5tYXgoYXJlYVsxXSwgc3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2Npc3NvciA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBseCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBseSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihhcmVhWzJdICsgYXJlYVswXSwgZXgpIC0gbHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oYXJlYVszXSArIGFyZWFbMV0sIGV5KSAtIGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2Npc3NvciA9IFtzeCwgc3ksIGV4IC0gc3gsIGV5IC0gc3ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gY2xpcHBpbmc6IHJldXNlIHBhcmVudCBzY2lzc29yLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY2lzc29yID0gdGhpcy5fcGFyZW50Ll91c2VSZW5kZXJUb1RleHR1cmUgPyB0aGlzLl9wYXJlbnQuX3ZpZXdwb3J0IDogdGhpcy5fcGFyZW50Ll9zY2lzc29yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBvdXRPZkJvdW5kcyBtYXJnaW4uXG4gICAgICAgICAgICBpZiAodGhpcy5fYm91bmRzTWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjQm91bmRzTWFyZ2luID0gdGhpcy5fYm91bmRzTWFyZ2luO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNCb3VuZHNNYXJnaW4gPSB0aGlzLl9wYXJlbnQuX3JlY0JvdW5kc01hcmdpbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX29uQWZ0ZXJDYWxjcykge1xuICAgICAgICAgICAgICAgIC8vIEFmdGVyIGNhbGNzIG1heSBjaGFuZ2UgcmVuZGVyIGNvb3Jkcywgc2Npc3NvciBhbmQvb3IgcmVjQm91bmRzTWFyZ2luLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbkFmdGVyQ2FsY3ModGhpcy5lbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSBiYm94LlxuICAgICAgICAgICAgICAgICAgICBpZiAockNvbXBsZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4ID0gTWF0aC5taW4oMCwgYmJveFcgKiByLnRhLCBiYm94VyAqIHIudGEgKyBiYm94SCAqIHIudGIsIGJib3hIICogci50YikgKyByLnB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZXggPSBNYXRoLm1heCgwLCBiYm94VyAqIHIudGEsIGJib3hXICogci50YSArIGJib3hIICogci50YiwgYmJveEggKiByLnRiKSArIHIucHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeSA9IE1hdGgubWluKDAsIGJib3hXICogci50YywgYmJveFcgKiByLnRjICsgYmJveEggKiByLnRkLCBiYm94SCAqIHIudGQpICsgci5weTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV5ID0gTWF0aC5tYXgoMCwgYmJveFcgKiByLnRjLCBiYm94VyAqIHIudGMgKyBiYm94SCAqIHIudGQsIGJib3hIICogci50ZCkgKyByLnB5O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ggPSByLnB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZXggPSByLnB4ICsgci50YSAqIGJib3hXO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3kgPSByLnB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgZXkgPSByLnB5ICsgci50ZCAqIGJib3hIO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RpbXNVbmtub3duICYmIChyQ29tcGxleCB8fCB0aGlzLl9sb2NhbFRhIDwgMSB8fCB0aGlzLl9sb2NhbFRiIDwgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG54ID0gdGhpcy5feCAqIHByLnRhICsgdGhpcy5feSAqIHByLnRiICsgcHIucHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBueSA9IHRoaXMuX3ggKiBwci50YyArIHRoaXMuX3kgKiBwci50ZCArIHByLnB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG54IDwgc3gpIHN4ID0gbng7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnkgPCBzeSkgc3kgPSBueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChueCA+IGV4KSBleCA9IG54O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG55ID4gZXkpIGV5ID0gbnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQuX291dE9mQm91bmRzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5oZXJpdCBwYXJlbnQgb3V0IG9mIGJvdW5kc25lc3MuXG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dpdGhpbkJvdW5kc01hcmdpbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93aXRoaW5Cb3VuZHNNYXJnaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Ll9kaXNhYmxlV2l0aGluQm91bmRzTWFyZ2luKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjYWxjICYgNikge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWNoZWNrIGlmIGVsZW1lbnQgaXMgb3V0LW9mLWJvdW5kcyAoYWxsIHNldHRpbmdzIHRoYXQgYWZmZWN0IHRoaXMgc2hvdWxkIGVuYWJsZSByZWNhbGMgYml0IDIgb3IgNCkuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX291dE9mQm91bmRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdpdGhpbk1hcmdpbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT2Zmc2NyZWVucyBhcmUgYWx3YXlzIHJlbmRlcmVkIGFzIGxvbmcgYXMgdGhlIHBhcmVudCBpcyB3aXRoaW4gYm91bmRzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JlbmRlclRvVGV4dHVyZUVuYWJsZWQgfHwgIXRoaXMuX3RleHR1cml6ZXIgfHwgIXRoaXMuX3RleHR1cml6ZXIucmVuZGVyT2Zmc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2Npc3NvciAmJiAodGhpcy5fc2Npc3NvclsyXSA8PSAwIHx8IHRoaXMuX3NjaXNzb3JbM10gPD0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbXB0eSBzY2lzc29yIGFyZWEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYmJveCB0byBjaGVjayBvdXQtb2YtYm91bmRuZXNzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5fc2Npc3NvclswXSA+IGV4KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5fc2Npc3NvclsxXSA+IGV5KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3ggPiAodGhpcy5fc2Npc3NvclswXSArIHRoaXMuX3NjaXNzb3JbMl0pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3kgPiAodGhpcy5fc2Npc3NvclsxXSArIHRoaXMuX3NjaXNzb3JbM10pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX291dE9mQm91bmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jbGlwcGluZyB8fCB0aGlzLl91c2VSZW5kZXJUb1RleHR1cmUgfHwgKHRoaXMuX2NsaXBib3ggJiYgKGJib3hXICYmIGJib3hIKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX291dE9mQm91bmRzID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgd2l0aGluTWFyZ2luID0gKHRoaXMuX291dE9mQm91bmRzID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2l0aGluTWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmUtdGVzdCwgbm93IHdpdGggbWFyZ2lucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVjQm91bmRzTWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhpbk1hcmdpbiA9ICEoKGV4IDwgdGhpcy5fc2Npc3NvclswXSAtIHRoaXMuX3JlY0JvdW5kc01hcmdpblsyXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleSA8IHRoaXMuX3NjaXNzb3JbMV0gLSB0aGlzLl9yZWNCb3VuZHNNYXJnaW5bM10pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3ggPiB0aGlzLl9zY2lzc29yWzBdICsgdGhpcy5fc2Npc3NvclsyXSArIHRoaXMuX3JlY0JvdW5kc01hcmdpblswXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzeSA+IHRoaXMuX3NjaXNzb3JbMV0gKyB0aGlzLl9zY2lzc29yWzNdICsgdGhpcy5fcmVjQm91bmRzTWFyZ2luWzFdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aGluTWFyZ2luID0gISgoZXggPCB0aGlzLl9zY2lzc29yWzBdIC0gMTAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV5IDwgdGhpcy5fc2Npc3NvclsxXSAtIDEwMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzeCA+IHRoaXMuX3NjaXNzb3JbMF0gKyB0aGlzLl9zY2lzc29yWzJdICsgMTAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN5ID4gdGhpcy5fc2Npc3NvclsxXSArIHRoaXMuX3NjaXNzb3JbM10gKyAxMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpdGhpbk1hcmdpbiAmJiB0aGlzLl9vdXRPZkJvdW5kcyA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGlsZHJlbiBtdXN0IGJlIHZpc2l0ZWQgYmVjYXVzZSB0aGV5IG1heSBjb250YWluIGVsZW1lbnRzIHRoYXQgYXJlIHdpdGhpbiBtYXJnaW4sIHNvIG11c3QgYmUgdmlzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl93aXRoaW5Cb3VuZHNNYXJnaW4gIT09IHdpdGhpbk1hcmdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2l0aGluQm91bmRzTWFyZ2luID0gd2l0aGluTWFyZ2luO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fd2l0aGluQm91bmRzTWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtYXkgdXBkYXRlIHRoaW5ncyAodHhMb2FkZWQgZXZlbnRzKSBpbiB0aGUgZWxlbWVudCBpdHNlbGYsIGJ1dCBhbHNvIGluIGRlc2NlbmRhbnRzIGFuZCBhbmNlc3RvcnMuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2VzIGluIGFuY2VzdG9ycyBzaG91bGQgYmUgZXhlY3V0ZWQgZHVyaW5nIHRoZSBuZXh0IGNhbGwgb2YgdGhlIHN0YWdlIHVwZGF0ZS4gQnV0IHdlIG11c3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWtlIGNhcmUgdGhhdCB0aGUgX3JlY2FsYyBhbmQgX2hhc1VwZGF0ZXMgZmxhZ3MgYXJlIHByb3Blcmx5IHJlZ2lzdGVyZWQuIFRoYXQncyB3aHkgd2UgY2xlYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib3RoIGJlZm9yZSBlbnRlcmluZyB0aGUgY2hpbGRyZW4sIGFuZCB1c2UgX3BSZWNhbGMgdG8gdHJhbnNmZXIgaW5oZXJpdGVkIHVwZGF0ZXMgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIF9yZWNhbGMgZGlyZWN0bHkuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2VzIGluIGRlc2NlbmRhbnRzIGFyZSBhdXRvbWF0aWNhbGx5IGV4ZWN1dGVkIHdpdGhpbiB0aGUgY3VycmVudCB1cGRhdGUgbG9vcCwgdGhvdWdoIHdlIG11c3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWtlIGNhcmUgdG8gbm90IHVwZGF0ZSB0aGUgaGFzVXBkYXRlcyBmbGFnIHVubmVjZXNzYXJpbHkgaW4gYW5jZXN0b3JzLiBXZSBhY2hpZXZlIHRoaXMgYnkgbWFraW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VyZSB0aGF0IHRoZSBoYXNVcGRhdGVzIGZsYWcgb2YgdGhpcyBlbGVtZW50IGlzIHR1cm5lZCBvbiwgd2hpY2ggYmxvY2tzIGl0IGZvciBhbmNlc3RvcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzVXBkYXRlcyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNhbGMgPSB0aGlzLl9yZWNhbGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVjYWxjID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuX2VuYWJsZVdpdGhpbkJvdW5kc01hcmdpbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlY2FsYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGVsZW1lbnQgbmVlZHMgdG8gYmUgcmUtdXBkYXRlZCBub3csIGJlY2F1c2Ugd2Ugd2FudCB0aGUgZGltZW5zaW9ucyAoYW5kIG90aGVyIGNoYW5nZXMpIHRvIGJlIHVwZGF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY2FsYyA9IHJlY2FsYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Ll9kaXNhYmxlV2l0aGluQm91bmRzTWFyZ2luKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl91c2VSZW5kZXJUb1RleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdmlld3BvcnQgbmVjZXNzYXJ5IGZvciBjaGlsZHJlbiBzY2lzc29yIGNhbGN1bGF0aW9uLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl92aWV3cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92aWV3cG9ydFsyXSA9IGJib3hXO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92aWV3cG9ydFszXSA9IGJib3hIO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gWzAsIDAsIGJib3hXLCBiYm94SF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGJpdHMgdGhhdCBzaG91bGQgbm90IGJlIGNvcGllZCB0byB0aGUgY2hpbGRyZW4gKGN1cnJlbnRseSBhbGwgYXJlKS5cbiAgICAgICAgICAgIHRoaXMuX3BSZWNhbGMgPSAodGhpcy5fcmVjYWxjICYgMTM1KTtcblxuICAgICAgICAgICAgLy8gQ2xlYXIgZmxhZ3Mgc28gdGhhdCBmdXR1cmUgdXBkYXRlcyBhcmUgcHJvcGVybHkgZGV0ZWN0ZWQuXG4gICAgICAgICAgICB0aGlzLl9yZWNhbGMgPSAwO1xuICAgICAgICAgICAgdGhpcy5faGFzVXBkYXRlcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fb3V0T2ZCb3VuZHMgPCAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VzZVJlbmRlclRvVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fd29ybGRDb250ZXh0LmlzSWRlbnRpdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHdvcmxkIGNvbnRleHQgaXMgYWxyZWFkeSBpZGVudGl0eTogdXNlIHRoZSB3b3JsZCBjb250ZXh0IGFzIHJlbmRlciBjb250ZXh0IHRvIHByZXZlbnRzIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5jZXN0b3JzIGZyb20gaGF2aW5nIHRvIHVwZGF0ZSB0aGUgcmVuZGVyIGNvbnRleHQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJDb250ZXh0ID0gdGhpcy5fd29ybGRDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVtcG9yYXJpbHkgcmVwbGFjZSB0aGUgcmVuZGVyIGNvb3JkIGF0dHJpYnMgYnkgdGhlIGlkZW50aXR5IG1hdHJpeC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHRoZSBjaGlsZHJlbiB0byBjYWxjdWxhdGUgdGhlIHJlbmRlciBjb250ZXh0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ29udGV4dCA9IEVsZW1lbnRDb3JlQ29udGV4dC5JREVOVElUWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0udXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXNlUmVuZGVyVG9UZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckNvbnRleHQgPSByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW5baV0uX2hhc1VwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbltpXS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IGxvc2UgdGhlICdpbmhlcml0ZWQnIHVwZGF0ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0uX3JlY2FsYyB8PSB0aGlzLl9wUmVjYWxjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLnVwZGF0ZU91dE9mQm91bmRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vbkFmdGVyVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25BZnRlclVwZGF0ZSh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3R4LnVwZGF0ZVRyZWVPcmRlciA9PT0gLTEgfHwgdGhpcy5fdXBkYXRlVHJlZU9yZGVyID49IHRoaXMuY3R4LnVwZGF0ZVRyZWVPcmRlcikge1xuICAgICAgICAgICAgICAgIC8vIElmIG5ldyB0cmVlIG9yZGVyIGRvZXMgbm90IGludGVyZmVyZSB3aXRoIHRoZSBjdXJyZW50IChnYXBzIGFsbG93ZWQpIHRoZXJlJ3Mgbm8gbmVlZCB0byB0cmF2ZXJzZSB0aGUgYnJhbmNoLlxuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnVwZGF0ZVRyZWVPcmRlciA9IC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyZWVPcmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2FwcGx5UmVsYXRpdmVEaW1GdW5jcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wdEZsYWdzICYgMSkge1xuICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuX2Z1bmNYKHRoaXMuX3BhcmVudC53KTtcbiAgICAgICAgICAgIGlmICh4ICE9PSB0aGlzLl94KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxQeCArPSAoeCAtIHRoaXMuX3gpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vcHRGbGFncyAmIDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLl9mdW5jWSh0aGlzLl9wYXJlbnQuaCk7XG4gICAgICAgICAgICBpZiAoeSAhPT0gdGhpcy5feSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsUHkgKz0gKHkgLSB0aGlzLl95KTtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjaGFuZ2VkRGltcyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fb3B0RmxhZ3MgJiA0KSB7XG4gICAgICAgICAgICBjb25zdCB3ID0gdGhpcy5fZnVuY1codGhpcy5fcGFyZW50LncpO1xuICAgICAgICAgICAgaWYgKHcgIT09IHRoaXMuX3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ID0gdztcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRGltcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdEZsYWdzICYgOCkge1xuICAgICAgICAgICAgY29uc3QgaCA9IHRoaXMuX2Z1bmNIKHRoaXMuX3BhcmVudC5oKTtcbiAgICAgICAgICAgIGlmIChoICE9PSB0aGlzLl9oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faCA9IGg7XG4gICAgICAgICAgICAgICAgY2hhbmdlZERpbXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZWREaW1zKSB7XG4gICAgICAgICAgICAvLyBSZWNhbGMgbW91bnQsIHNjYWxlIHBvc2l0aW9uLlxuICAgICAgICAgICAgdGhpcy5fcmVjYWxjTG9jYWxUcmFuc2xhdGUoKTtcblxuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm9uRGltZW5zaW9uc0NoYW5nZWQodGhpcy5fdywgdGhpcy5faCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVPdXRPZkJvdW5kcygpIHtcbiAgICAgICAgLy8gUHJvcGFnYXRlIG91dE9mQm91bmRzIGZsYWcgdG8gZGVzY2VuZGFudHMgKG5lY2Vzc2FyeSBiZWNhdXNlIG9mIHotaW5kZXhpbmcpLlxuICAgICAgICAvLyBJbnZpc2libGUgZWxlbWVudHMgYXJlIG5vdCBkcmF3biBhbnl3YXkuIFdoZW4gYWxwaGEgaXMgdXBkYXRlZCwgc28gd2lsbCBfb3V0T2ZCb3VuZHMuXG4gICAgICAgIGlmICh0aGlzLl9vdXRPZkJvdW5kcyAhPT0gMiAmJiB0aGlzLl9yZW5kZXJDb250ZXh0LmFscGhhID4gMCkge1xuXG4gICAgICAgICAgICAvLyBJbmhlcml0IHBhcmVudCBvdXQgb2YgYm91bmRzbmVzcy5cbiAgICAgICAgICAgIHRoaXMuX291dE9mQm91bmRzID0gMjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3dpdGhpbkJvdW5kc01hcmdpbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpdGhpbkJvdW5kc01hcmdpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5fZGlzYWJsZVdpdGhpbkJvdW5kc01hcmdpbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbltpXS51cGRhdGVPdXRPZkJvdW5kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVRyZWVPcmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsQWxwaGEgJiYgKHRoaXMuX291dE9mQm91bmRzICE9PSAyKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVHJlZU9yZGVyID0gdGhpcy5jdHgudXBkYXRlVHJlZU9yZGVyKys7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLnVwZGF0ZVRyZWVPcmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZW5kZXJTaW1wbGUoKSB7XG4gICAgICAgIHRoaXMuX2hhc1JlbmRlclVwZGF0ZXMgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLl96U29ydCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0WkluZGV4ZWRDaGlsZHJlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX291dE9mQm91bmRzIDwgMiAmJiB0aGlzLl9yZW5kZXJDb250ZXh0LmFscGhhKSB7XG4gICAgICAgICAgICBsZXQgcmVuZGVyU3RhdGUgPSB0aGlzLnJlbmRlclN0YXRlO1xuXG4gICAgICAgICAgICBpZiAoKHRoaXMuX291dE9mQm91bmRzID09PSAwKSAmJiB0aGlzLl9kaXNwbGF5ZWRUZXh0dXJlU291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2V0U2hhZGVyKHRoaXMuYWN0aXZlU2hhZGVyLCB0aGlzLl9zaGFkZXJPd25lcik7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2V0U2Npc3Nvcih0aGlzLl9zY2lzc29yKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclN0YXRlLmFkZFF1YWQodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFsc28gYWRkIGNoaWxkcmVuIHRvIHRoZSBWQk8uXG4gICAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fekNvbnRleHRVc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX3pJbmRleGVkQ2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl96SW5kZXhlZENoaWxkcmVuW2ldLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbltpXS5fekluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgekluZGV4IGlzIHNldCwgdGhpcyBpdGVtIGFscmVhZHkgYmVsb25ncyB0byBhIHpJbmRleGVkQ2hpbGRyZW4gYXJyYXkgaW4gb25lIG9mIHRoZSBhbmNlc3RvcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0ucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZW5kZXJBZHZhbmNlZCgpIHtcbiAgICAgICAgY29uc3QgaGFzUmVuZGVyVXBkYXRlcyA9IHRoaXMuX2hhc1JlbmRlclVwZGF0ZXM7XG5cbiAgICAgICAgLy8gV2UgbXVzdCBjbGVhciB0aGUgaGFzUmVuZGVyVXBkYXRlcyBmbGFnIGJlZm9yZSByZW5kZXJpbmcsIGJlY2F1c2UgdXBkYXRpbmcgcmVzdWx0IHRleHR1cmVzIGluIGNvbWJpbmF0aW9uXG4gICAgICAgIC8vIHdpdGggei1pbmRleGluZyBtYXkgdHJpZ2dlciByZW5kZXIgdXBkYXRlcyBvbiBhIHJlbmRlciBicmFuY2ggdGhhdCBpcyAnaGFsZiBkb25lJy5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgZnVsbCByZW5kZXIgYnJhbmNoIGlzIG1hcmtlZCBmb3IgcmVuZGVyIHVwZGF0ZXMsIG5vdCBvbmx5IGhhbGYgKGxlYWRpbmcgdG8gZnJlZXplKS5cbiAgICAgICAgdGhpcy5faGFzUmVuZGVyVXBkYXRlcyA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuX3pTb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRaSW5kZXhlZENoaWxkcmVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb3V0T2ZCb3VuZHMgPCAyICYmIHRoaXMuX3JlbmRlckNvbnRleHQuYWxwaGEpIHtcbiAgICAgICAgICAgIGxldCByZW5kZXJTdGF0ZSA9IHRoaXMucmVuZGVyU3RhdGU7XG5cbiAgICAgICAgICAgIGxldCBtdXN0UmVuZGVyQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHJlbmRlclRleHR1cmVJbmZvO1xuICAgICAgICAgICAgbGV0IHByZXZSZW5kZXJUZXh0dXJlSW5mbztcbiAgICAgICAgICAgIGlmICh0aGlzLl91c2VSZW5kZXJUb1RleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdyA9PT0gMCB8fCB0aGlzLl9oID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGlzIGJyYW5jaCBhbmQgZG9uJ3QgZHJhdyBhbnl0aGluZy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3RleHR1cml6ZXIuaGFzUmVuZGVyVGV4dHVyZSgpIHx8IChoYXNSZW5kZXJVcGRhdGVzID49IDMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN3aXRjaCB0byBkZWZhdWx0IHNoYWRlciBmb3IgYnVpbGRpbmcgdXAgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zZXRTaGFkZXIocmVuZGVyU3RhdGUuZGVmYXVsdFNoYWRlciwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJldlJlbmRlclRleHR1cmVJbmZvID0gcmVuZGVyU3RhdGUucmVuZGVyVGV4dHVyZUluZm87XG5cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVUZXh0dXJlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwLCAgLy8gU2V0IGJ5IENvcmVSZW5kZXJTdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHc6IHRoaXMuX3csXG4gICAgICAgICAgICAgICAgICAgICAgICBoOiB0aGlzLl9oLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyaXplci5oYXNSZXN1bHRUZXh0dXJlKCkgfHwgKCFyZW5kZXJTdGF0ZS5pc0NhY2hpbmdUZXh0dXJpemVyICYmIChoYXNSZW5kZXJVcGRhdGVzIDwgMykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFdlIGRvbid0IGFsd2F5cyBjYWNoZSByZW5kZXIgdGV4dHVyZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIHJ1bGUgaXMsIHRoYXQgY2FjaGluZyBmb3IgYSBzcGVjaWZpYyByZW5kZXIgdGV4dHVyZSBpcyBvbmx5IGVuYWJsZWQgaWY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAtIFRoZXJlIGlzIGEgcmVzdWx0IHRleHR1cmUgdG8gYmUgdXBkYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIC0gVGhlcmUgd2VyZSBubyByZW5kZXIgdXBkYXRlcyAtd2l0aGluIHRoZSBjb250ZW50cy0gc2luY2UgbGFzdCBmcmFtZSAoRWxlbWVudENvcmUuaGFzUmVuZGVyVXBkYXRlcyA8IDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAtIEFORCB0aGVyZSBhcmUgbm8gYW5jZXN0b3JzIHRoYXQgYXJlIGJlaW5nIGNhY2hlZCBkdXJpbmcgdGhpcyBmcmFtZSAoQ29yZVJlbmRlclN0YXRlLmlzQ2FjaGluZ1RleHR1cml6ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgIElmIGFuIGFuY2VzdG9yIGlzIGNhY2hlZCBhbnl3YXksIGl0J3MgcHJvYmFibHkgbm90IG5lY2Vzc2FyeSB0byBrZWVwIGRlZXBlciBjYWNoZXMuIElmIHRoZSB0b3AgbGV2ZWwgaXMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAqICAgY2hhbmdlIHdoaWxlIGEgbG93ZXIgb25lIGlzIG5vdCwgdGhhdCBsb3dlciBsZXZlbCB3aWxsIGJlIGNhY2hlZCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEluIGNhc2Ugb2YgdGhlIGZhc3QgYmx1ciBlbGVtZW50LCB0aGlzIHByZXZlbnRzIGhhdmluZyB0byBjYWNoZSBhbGwgYmx1ciBsZXZlbHMgYW5kIHN0YWdlcywgc2F2aW5nIGEgaHVnZSBhbW91bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIG9mIEdQVSBtZW1vcnkhXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRXNwZWNpYWxseSB3aGVuIHVzaW5nIG11bHRpcGxlIHN0YWNrZWQgbGF5ZXJzIG9mIHRoZSBzYW1lIGRpbWVuc2lvbnMgdGhhdCBhcmUgUlRUIHRoaXMgd2lsbCBoYXZlIGEgdmVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICogbm90aWNhYmxlIGVmZmVjdCBvbiBwZXJmb3JtYW5jZSBhcyBsZXNzIHJlbmRlciB0ZXh0dXJlcyBuZWVkIHRvIGJlIGFsbG9jYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZUluZm8uY2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuaXNDYWNoaW5nVGV4dHVyaXplciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3RleHR1cml6ZXIuaGFzUmVzdWx0VGV4dHVyZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gYWxyZWFkeSByZWxlYXNlIHRoZSBjdXJyZW50IHRleHR1cmUgdG8gdGhlIHBvb2wsIGFzIGl0IHdpbGwgYmUgcmVidWlsZCBhbnl3YXkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIG11bHRpcGxlIGxheWVycyBvZiAnZmlsdGVyaW5nJywgdGhpcyBtYXkgc2F2ZSB1cyBmcm9tIGhhdmluZyB0byBjcmVhdGUgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgcmVuZGVyLXRvLXRleHR1cmUgbGF5ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RpY2UgdGhhdCB3ZSBkb24ndCBkbyB0aGlzIHdoZW4gdGhlcmUgaXMgYSByZXN1bHQgdGV4dHVyZSwgYXMgYW55IG90aGVyIGVsZW1lbnQgbWF5IHJlbHkgb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICB0aGF0IHJlc3VsdCB0ZXh0dXJlIGJlaW5nIGZpbGxlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cml6ZXIucmVsZWFzZVJlbmRlclRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNldFJlbmRlclRleHR1cmVJbmZvKHJlbmRlclRleHR1cmVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2V0U2Npc3NvcihudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGlzcGxheWVkVGV4dHVyZVNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHIgPSB0aGlzLl9yZW5kZXJDb250ZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYW4gaWRlbnRpdHkgY29udGV4dCBmb3IgZHJhd2luZyB0aGUgZGlzcGxheWVkIHRleHR1cmUgdG8gdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ29udGV4dCA9IEVsZW1lbnRDb3JlQ29udGV4dC5JREVOVElUWTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGRpc3BsYXllZCB0ZXh0dXJlIHNvdXJjZSBpbiBsb2NhbCBjb29yZGluYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU3RhdGUuYWRkUXVhZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ29udGV4dCA9IHI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtdXN0UmVuZGVyQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy5fb3V0T2ZCb3VuZHMgPT09IDApICYmIHRoaXMuX2Rpc3BsYXllZFRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2V0U2hhZGVyKHRoaXMuYWN0aXZlU2hhZGVyLCB0aGlzLl9zaGFkZXJPd25lcik7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNldFNjaXNzb3IodGhpcy5fc2Npc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU3RhdGUuYWRkUXVhZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFsc28gYWRkIGNoaWxkcmVuIHRvIHRoZSBWQk8uXG4gICAgICAgICAgICBpZiAobXVzdFJlbmRlckNoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pDb250ZXh0VXNhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl96SW5kZXhlZENoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fekluZGV4ZWRDaGlsZHJlbltpXS5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW5baV0uX3pJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHpJbmRleCBpcyBzZXQsIHRoaXMgaXRlbSBhbHJlYWR5IGJlbG9uZ3MgdG8gYSB6SW5kZXhlZENoaWxkcmVuIGFycmF5IGluIG9uZSBvZiB0aGUgYW5jZXN0b3JzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fdXNlUmVuZGVyVG9UZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHVwZGF0ZVJlc3VsdFRleHR1cmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAobXVzdFJlbmRlckNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmlzaGVkIHJlZnJlc2hpbmcgcmVuZGVyVGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuZmluaXNoZWRSZW5kZXJUZXh0dXJlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90aGluZyB3YXMgcmVuZGVyZWQsIHdlIHN0b3JlIGEgZmxhZyBpbiB0aGUgdGV4dHVyaXplciBhbmQgcHJldmVudCB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAvLyAgcmVuZGVyLXRvLXRleHR1cmUgYW5kIGZpbHRlcmluZy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyaXplci5lbXB0eSA9IHJlbmRlclRleHR1cmVJbmZvLmVtcHR5O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW5kZXJUZXh0dXJlSW5mby5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaWdub3JlIGVtcHR5IHJlbmRlciB0ZXh0dXJlcyBhbmQgZG8gbm90IGRyYXcgdGhlIGZpbmFsIHF1YWQuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY2xlYW5zIHVwIG1lbW9yeSBhbmQgZW5mb3JjZXMgdGhhdCB0aGUgcmVzdWx0IHRleHR1cmUgaXMgYWxzbyBjbGVhcmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyaXplci5yZWxlYXNlUmVuZGVyVGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlbmRlclRleHR1cmVJbmZvLm5hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5hdGl2ZVRleHR1cmUgaXMgc2V0LCB3ZSBjYW4gcmV1c2UgdGhhdCBkaXJlY3RseSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IHJlbmRlciB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyaXplci5yZXVzZVRleHR1cmVBc1JlbmRlclRleHR1cmUocmVuZGVyVGV4dHVyZUluZm8ubmF0aXZlVGV4dHVyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclRleHR1cmVJbmZvLmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyaXplci5yZW5kZXJUZXh0dXJlUmV1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVhZCBvcGVyYXRpb25zIG11c3QgYmUgd3JpdHRlbiB0byBhIHJlbmRlciB0ZXh0dXJlIGFjdHVhbGx5IG93bmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cml6ZXIucmVsZWFzZVJlbmRlclRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgY3JlYXRlIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclRleHR1cmVJbmZvLm5hdGl2ZVRleHR1cmUgPSB0aGlzLl90ZXh0dXJpemVyLmdldFJlbmRlclRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHBhcmVudCdzIHJlbmRlciB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zZXRSZW5kZXJUZXh0dXJlSW5mbyhwcmV2UmVuZGVyVGV4dHVyZUluZm8pO1xuXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdFRleHR1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdGV4dHVyaXplci5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0VGV4dHVyZSA9IHRoaXMuX3RleHR1cml6ZXIuZ2V0UmVzdWx0VGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlUmVzdWx0VGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2dnaW5nIHRoZSB1cGRhdGUgZnJhbWUgY2FuIGJlIGhhbmR5IGZvciB1c2VybGFuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRUZXh0dXJlLnVwZGF0ZSA9IHJlbmRlclN0YXRlLnN0YWdlLmZyYW1lQ291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cml6ZXIudXBkYXRlUmVzdWx0VGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJpemVyLnJlbmRlck9mZnNjcmVlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVuZGVyIHJlc3VsdCB0ZXh0dXJlIHRvIHRoZSBhY3R1YWwgcmVuZGVyIHRhcmdldC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNldFNoYWRlcih0aGlzLmFjdGl2ZVNoYWRlciwgdGhpcy5fc2hhZGVyT3duZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2V0U2Npc3Nvcih0aGlzLl9zY2lzc29yKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gcmVuZGVyIHRleHR1cmUgaW5mbyBpcyBzZXQsIHRoZSBjYWNoZSBjYW4gYmUgcmV1c2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGUgPSAhcmVuZGVyVGV4dHVyZUluZm8gfHwgcmVuZGVyVGV4dHVyZUluZm8uY2FjaGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNldFRleHR1cml6ZXIodGhpcy5fdGV4dHVyaXplciwgY2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3Rhc2hUZXhDb29yZHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdGV4dHVyaXplci5jb2xvcml6ZSkgdGhpcy5fc3Rhc2hDb2xvcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU3RhdGUuYWRkUXVhZCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdGV4dHVyaXplci5jb2xvcml6ZSkgdGhpcy5fdW5zdGFzaENvbG9ycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5zdGFzaFRleENvb3JkcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2V0VGV4dHVyaXplcihudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlclRleHR1cmVJbmZvICYmIHJlbmRlclRleHR1cmVJbmZvLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgc2libGluZ3MgdG8gY2FjaGUuXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuaXNDYWNoaW5nVGV4dHVyaXplciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHpTb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5felNvcnQ7XG4gICAgfVxuXG4gICAgc29ydFpJbmRleGVkQ2hpbGRyZW4oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSB3YW50IHRvIGF2b2lkIHJlc29ydGluZyBldmVyeXRoaW5nLiBJbnN0ZWFkLCB3ZSBkbyBhIHNpbmdsZSBwYXNzIG9mIHRoZSBmdWxsIGFycmF5OlxuICAgICAgICAgKiAtIGZpbHRlcmluZyBvdXQgZWxlbWVudHMgd2l0aCBhIGRpZmZlcmVudCB6UGFyZW50IHRoYW4gdGhpcyAod2VyZSByZW1vdmVkKVxuICAgICAgICAgKiAtIGZpbHRlcmluZyBvdXQsIGJ1dCBhbHNvIGdhdGhlcmluZyAoaW4gYSB0ZW1wb3JhcnkgYXJyYXkpIHRoZSBlbGVtZW50cyB0aGF0IGhhdmUgekluZGV4UmVzb3J0IGZsYWdcbiAgICAgICAgICogLSB0aGVuLCBmaW5hbGx5LCB3ZSBtZXJnZS1zb3J0IGJvdGggdGhlIG5ldyBhcnJheSBhbmQgdGhlICdvbGQnIG9uZVxuICAgICAgICAgKiAtIGVsZW1lbnQgbWF5IGhhdmUgYmVlbiBhZGRlZCAnZG91YmxlJywgc28gd2hlbiBtZXJnZS1zb3J0aW5nIGFsc28gY2hlY2sgZm9yIGRvdWJsZXMuXG4gICAgICAgICAqIC0gaWYgdGhlIG9sZCBvbmUgaXMgbGFyZ2VyIChpbiBzaXplKSB0aGFuIGl0IHNob3VsZCBiZSwgc3BsaWNlIG9mZiB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgICAgICovXG5cbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX3pJbmRleGVkQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBsZXQgcHRyID0gMDtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuX3pJbmRleGVkQ2hpbGRyZW47XG5cbiAgICAgICAgLy8gTm90aWNlIHRoYXQgaXRlbXMgbWF5IG9jY3VyIG11bHRpcGxlIHRpbWVzIGR1ZSB0byB6LWluZGV4IGNoYW5naW5nLlxuICAgICAgICBjb25zdCBiID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYVtpXS5felBhcmVudCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIGlmIChhW2ldLl96SW5kZXhSZXNvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYi5wdXNoKGFbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwdHIgIT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFbcHRyXSA9IGFbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHRyKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbSA9IGIubGVuZ3RoO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgICAgICBiW2pdLl96SW5kZXhSZXNvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYi5zb3J0KEVsZW1lbnRDb3JlLnNvcnRaSW5kZXhlZENoaWxkcmVuKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBwdHI7XG4gICAgICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICAgICAgICBwdHIgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGFbcHRyKytdID0gYltqKytdO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGogPCBtKTtcblxuICAgICAgICAgICAgICAgIGlmIChhLmxlbmd0aCA+IHB0cikge1xuICAgICAgICAgICAgICAgICAgICAvLyBTbGljZSBvbGQgKHVubmVjZXNzYXJ5KSBwYXJ0IG9mZiBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgYS5zcGxpY2UocHRyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1lcmdlLXNvcnQgYXJyYXlzO1xuICAgICAgICAgICAgICAgIHB0ciA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXJnZVJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IChhW2ldLl96SW5kZXggPT09IGJbal0uX3pJbmRleCA/IGFbaV0uX3VwZGF0ZVRyZWVPcmRlciAtIGJbal0uX3VwZGF0ZVRyZWVPcmRlciA6IGFbaV0uX3pJbmRleCAtIGJbal0uX3pJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkID0gdiA+IDAgPyBiW2orK10gOiBhW2krK107XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHB0ciA9PT0gMCB8fCAobWVyZ2VSZXN1bHRbcHRyIC0gMV0gIT09IGFkZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlUmVzdWx0W3B0cisrXSA9IGFkZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID49IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGQgPSBiW2orK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHB0ciA9PT0gMCB8fCAobWVyZ2VSZXN1bHRbcHRyIC0gMV0gIT09IGFkZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VSZXN1bHRbcHRyKytdID0gYWRkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGogPCBtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGogPj0gbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZCA9IGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHRyID09PSAwIHx8IChtZXJnZVJlc3VsdFtwdHIgLSAxXSAhPT0gYWRkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZVJlc3VsdFtwdHIrK10gPSBhZGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoaSA8IG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3pJbmRleGVkQ2hpbGRyZW4gPSBtZXJnZVJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhLmxlbmd0aCA+IHB0cikge1xuICAgICAgICAgICAgICAgIC8vIFNsaWNlIG9sZCAodW5uZWNlc3NhcnkpIHBhcnQgb2ZmIGFycmF5LlxuICAgICAgICAgICAgICAgIGEuc3BsaWNlKHB0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl96U29ydCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBnZXQgbG9jYWxUYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsVGE7XG4gICAgfTtcblxuICAgIGdldCBsb2NhbFRiKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxUYjtcbiAgICB9O1xuXG4gICAgZ2V0IGxvY2FsVGMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFRjO1xuICAgIH07XG5cbiAgICBnZXQgbG9jYWxUZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsVGQ7XG4gICAgfTtcblxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICB9XG5cbiAgICBnZXQgcmVuZGVyVXBkYXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1JlbmRlclVwZGF0ZXM7XG4gICAgfVxuXG4gICAgZ2V0IHRleHR1cml6ZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGV4dHVyaXplcikge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyaXplciA9IG5ldyBFbGVtZW50VGV4dHVyaXplcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyaXplcjtcbiAgICB9XG5cbiAgICBnZXRDb3JuZXJQb2ludHMoKSB7XG4gICAgICAgIGxldCB3ID0gdGhpcy5fd29ybGRDb250ZXh0O1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB3LnB4LFxuICAgICAgICAgICAgdy5weSxcbiAgICAgICAgICAgIHcucHggKyB0aGlzLl93ICogdy50YSxcbiAgICAgICAgICAgIHcucHkgKyB0aGlzLl93ICogdy50YyxcbiAgICAgICAgICAgIHcucHggKyB0aGlzLl93ICogdy50YSArIHRoaXMuX2ggKiB3LnRiLFxuICAgICAgICAgICAgdy5weSArIHRoaXMuX3cgKiB3LnRjICsgdGhpcy5faCAqIHcudGQsXG4gICAgICAgICAgICB3LnB4ICsgdGhpcy5faCAqIHcudGIsXG4gICAgICAgICAgICB3LnB5ICsgdGhpcy5faCAqIHcudGRcbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgZ2V0UmVuZGVyVGV4dHVyZUNvb3JkcyhyZWxYLCByZWxZKSB7XG4gICAgICAgIGxldCByID0gdGhpcy5fcmVuZGVyQ29udGV4dDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHIucHggKyByLnRhICogcmVsWCArIHIudGIgKiByZWxZLFxuICAgICAgICAgICAgci5weSArIHIudGMgKiByZWxYICsgci50ZCAqIHJlbFlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBnZXRBYnNvbHV0ZUNvb3JkcyhyZWxYLCByZWxZKSB7XG4gICAgICAgIGxldCB3ID0gdGhpcy5fcmVuZGVyQ29udGV4dDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHcucHggKyB3LnRhICogcmVsWCArIHcudGIgKiByZWxZLFxuICAgICAgICAgICAgdy5weSArIHcudGMgKiByZWxYICsgdy50ZCAqIHJlbFlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBjb2xsZWN0QXRDb29yZCh4LCB5LCBjaGlsZHJlbikge1xuICAgICAgICAvLyByZXR1cm4gd2hlbiBicmFuY2ggaXMgaGlkZGVuXG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJDb250ZXh0LmFscGhhID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pbkJvdW5kKHgsIHkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2Npc3Nvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluU2Npc3NvcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBqID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbltpXS5jb2xsZWN0QXRDb29yZCh4LCB5LCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGRyZW4uc29ydChFbGVtZW50Q29yZS5zb3J0WkluZGV4ZWRDaGlsZHJlbik7XG4gICAgfVxuXG4gICAgaW5Cb3VuZCh0eCwgdHkpIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0Q29ybmVyUG9pbnRzKCk7XG4gICAgICAgIHJldHVybiB0eCA+IGNbMF0gJiYgdHggPCBjWzJdICYmIHR5ID4gY1sxXSAmJiB0eSA8IGNbN107XG4gICAgfVxuXG4gICAgaW5TY2lzc29yKCkge1xuICAgICAgICBjb25zdCBzYyA9IHRoaXMuX3NjaXNzb3I7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldENvcm5lclBvaW50cygpO1xuXG4gICAgICAgIHJldHVybiBjWzJdID49IHNjWzBdICYmIGNbMF0gPD0gc2NbMF0gKyBzY1syXSAmJiBjWzddID49IHNjWzFdICYmIGNbMV0gPD0gc2NbMV0gKyBzY1szXTtcbiAgICB9XG5cbiAgICBnZXQgbGF5b3V0KCkge1xuICAgICAgICB0aGlzLl9lbnN1cmVMYXlvdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dDtcbiAgICB9XG5cbiAgICBnZXQgZmxleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dCA/IHRoaXMuX2xheW91dC5mbGV4IDogbnVsbDtcbiAgICB9XG5cbiAgICBzZXQgZmxleCh2KSB7XG4gICAgICAgIHRoaXMubGF5b3V0LmZsZXggPSB2O1xuICAgIH1cblxuICAgIGdldCBmbGV4SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dCA/IHRoaXMuX2xheW91dC5mbGV4SXRlbSA6IG51bGw7XG4gICAgfVxuXG4gICAgc2V0IGZsZXhJdGVtKHYpIHtcbiAgICAgICAgdGhpcy5sYXlvdXQuZmxleEl0ZW0gPSB2O1xuICAgIH1cblxuICAgIGlzRmxleEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2xheW91dCAmJiB0aGlzLl9sYXlvdXQuaXNGbGV4SXRlbUVuYWJsZWQoKTtcbiAgICB9XG5cbiAgICBpc0ZsZXhDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2xheW91dCAmJiB0aGlzLl9sYXlvdXQuaXNGbGV4RW5hYmxlZCgpO1xuICAgIH1cblxuICAgIGVuYWJsZUZsZXhMYXlvdXQoKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUxheW91dCgpO1xuICAgIH1cblxuICAgIF9lbnN1cmVMYXlvdXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQgPSBuZXcgRmxleFRhcmdldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2FibGVGbGV4TGF5b3V0KCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyUmVjYWxjVHJhbnNsYXRlKCk7XG4gICAgfVxuXG4gICAgaGFzRmxleExheW91dCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9sYXlvdXQgJiYgdGhpcy5fbGF5b3V0LmlzRW5hYmxlZCgpKTtcbiAgICB9XG5cbiAgICBzZXRMYXlvdXQoeCwgeSwgdywgaCkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKHcsIGgpO1xuICAgIH1cblxuICAgIHRyaWdnZXJMYXlvdXQoKSB7XG4gICAgICAgIHRoaXMuX3NldFJlY2FsYygyNTYpO1xuICAgIH1cblxuICAgIF90cmlnZ2VyUmVjYWxjVHJhbnNsYXRlKCkge1xuICAgICAgICB0aGlzLl9zZXRSZWNhbGMoMik7XG4gICAgfVxuXG59XG5cbmNsYXNzIEVsZW1lbnRDb3JlQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XG5cbiAgICAgICAgdGhpcy5weCA9IDA7XG4gICAgICAgIHRoaXMucHkgPSAwO1xuXG4gICAgICAgIHRoaXMudGEgPSAxO1xuICAgICAgICB0aGlzLnRiID0gMDtcbiAgICAgICAgdGhpcy50YyA9IDA7XG4gICAgICAgIHRoaXMudGQgPSAxO1xuICAgIH1cblxuICAgIGlzSWRlbnRpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFscGhhID09PSAxICYmXG4gICAgICAgICAgICB0aGlzLnB4ID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLnB5ID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLnRhID09PSAxICYmXG4gICAgICAgICAgICB0aGlzLnRiID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLnRjID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLnRkID09PSAxO1xuICAgIH1cblxuICAgIGlzU3F1YXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YiA9PT0gMCAmJiB0aGlzLnRjID09PSAwO1xuICAgIH1cblxufVxuXG5FbGVtZW50Q29yZUNvbnRleHQuSURFTlRJVFkgPSBuZXcgRWxlbWVudENvcmVDb250ZXh0KCk7XG5FbGVtZW50Q29yZS5zb3J0WkluZGV4ZWRDaGlsZHJlbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIChhLl96SW5kZXggPT09IGIuX3pJbmRleCA/IGEuX3VwZGF0ZVRyZWVPcmRlciAtIGIuX3VwZGF0ZVRyZWVPcmRlciA6IGEuX3pJbmRleCAtIGIuX3pJbmRleCk7XG59O1xuXG5pbXBvcnQgRWxlbWVudFRleHR1cml6ZXIgZnJvbSBcIi4vRWxlbWVudFRleHR1cml6ZXIubWpzXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL1V0aWxzLm1qc1wiO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFRleHR1cmVTb3VyY2UgZnJvbSAnLi4vVGV4dHVyZVNvdXJjZS5tanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50VGV4dHVyaXplciB7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50Q29yZSkge1xuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50Q29yZS5lbGVtZW50O1xuICAgICAgICB0aGlzLl9jb3JlID0gZWxlbWVudENvcmU7XG5cbiAgICAgICAgdGhpcy5jdHggPSB0aGlzLl9jb3JlLmN0eDtcblxuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGF6eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb2xvcml6ZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVSZXVzZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9yZXN1bHRUZXh0dXJlU291cmNlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9yZW5kZXJPZmZzY3JlZW4gPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmVtcHR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH1cblxuICAgIHNldCBlbmFibGVkKHYpIHtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHY7XG4gICAgICAgIHRoaXMuX2NvcmUudXBkYXRlUmVuZGVyVG9UZXh0dXJlRW5hYmxlZCgpO1xuICAgIH1cblxuICAgIGdldCByZW5kZXJPZmZzY3JlZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJPZmZzY3JlZW47XG4gICAgfVxuXG4gICAgc2V0IHJlbmRlck9mZnNjcmVlbih2KSB7XG4gICAgICAgIHRoaXMuX3JlbmRlck9mZnNjcmVlbiA9IHY7XG4gICAgICAgIHRoaXMuX2NvcmUuc2V0SGFzUmVuZGVyVXBkYXRlcygxKTtcblxuICAgICAgICAvLyBUaGlzIGVuZm9yY2VzIHJlY2hlY2tpbmcgdGhlICd3aXRoaW4gYm91bmRzJy5cbiAgICAgICAgdGhpcy5fY29yZS5fc2V0UmVjYWxjKDYpO1xuICAgIH1cblxuICAgIGdldCBjb2xvcml6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yaXplO1xuICAgIH1cblxuICAgIHNldCBjb2xvcml6ZSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9jb2xvcml6ZSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fY29sb3JpemUgPSB2O1xuXG4gICAgICAgICAgICAvLyBPbmx5IGFmZmVjdHMgdGhlIGZpbmFsbHkgZHJhd24gcXVhZC5cbiAgICAgICAgICAgIHRoaXMuX2NvcmUuc2V0SGFzUmVuZGVyVXBkYXRlcygxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRUZXh0dXJlU291cmNlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc3VsdFRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3VsdFRleHR1cmVTb3VyY2UgPSBuZXcgVGV4dHVyZVNvdXJjZSh0aGlzLl9lbGVtZW50LnN0YWdlLnRleHR1cmVNYW5hZ2VyKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzdWx0VGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXN1bHRUZXh0dXJlU291cmNlO1xuICAgIH1cblxuICAgIGhhc1Jlc3VsdFRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3Jlc3VsdFRleHR1cmVTb3VyY2U7XG4gICAgfVxuXG4gICAgcmVzdWx0VGV4dHVyZUluVXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0VGV4dHVyZVNvdXJjZSAmJiB0aGlzLl9yZXN1bHRUZXh0dXJlU291cmNlLmhhc0VuYWJsZWRFbGVtZW50cygpO1xuICAgIH1cblxuICAgIHVwZGF0ZVJlc3VsdFRleHR1cmUoKSB7XG4gICAgICAgIGxldCByZXN1bHRUZXh0dXJlID0gdGhpcy5nZXRSZXN1bHRUZXh0dXJlKCk7XG4gICAgICAgIGlmICh0aGlzLl9yZXN1bHRUZXh0dXJlU291cmNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVzdWx0VGV4dHVyZVNvdXJjZS5uYXRpdmVUZXh0dXJlICE9PSByZXN1bHRUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHcgPSByZXN1bHRUZXh0dXJlID8gcmVzdWx0VGV4dHVyZS53IDogMDtcbiAgICAgICAgICAgICAgICBsZXQgaCA9IHJlc3VsdFRleHR1cmUgPyByZXN1bHRUZXh0dXJlLmggOiAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VsdFRleHR1cmVTb3VyY2UucmVwbGFjZU5hdGl2ZVRleHR1cmUocmVzdWx0VGV4dHVyZSwgdywgaCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRleHR1cmUgd2lsbCBiZSB1cGRhdGVkOiBhbGwgZWxlbWVudHMgdXNpbmcgdGhlIHNvdXJjZSBuZWVkIHRvIGJlIHVwZGF0ZWQgYXMgd2VsbC5cbiAgICAgICAgICAgIHRoaXMuX3Jlc3VsdFRleHR1cmVTb3VyY2UuZm9yRWFjaEVuYWJsZWRFbGVtZW50KGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuX3VwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNvcmUuc2V0SGFzUmVuZGVyVXBkYXRlcygzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbXVzdFJlbmRlclRvVGV4dHVyZSgpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbXVzdCByZWFsbHkgcmVuZGVyIGFzIHRleHR1cmUuXG4gICAgICAgIGlmICh0aGlzLl9lbmFibGVkICYmICF0aGlzLmxhenkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2VuYWJsZWQgJiYgdGhpcy5sYXp5ICYmIHRoaXMuX2NvcmUuX2hhc1JlbmRlclVwZGF0ZXMgPCAzKSB7XG4gICAgICAgICAgICAvLyBTdGF0aWMtb25seTogaWYgcmVuZGVyVG9UZXh0dXJlIGRpZCBub3QgbmVlZCB0byB1cGRhdGUgZHVyaW5nIGxhc3QgZHJhd24gZnJhbWUsIGdlbmVyYXRlIGl0IGFzIGEgY2FjaGUuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgdGhpcy5yZWxlYXNlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHJlbmRlclRleHR1cmVSZXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJUZXh0dXJlUmV1c2VkO1xuICAgIH1cblxuICAgIHJlbGVhc2UoKSB7XG4gICAgICAgIHRoaXMucmVsZWFzZVJlbmRlclRleHR1cmUoKTtcbiAgICB9XG5cbiAgICByZWxlYXNlUmVuZGVyVGV4dHVyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVuZGVyVGV4dHVyZVJldXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnJlbGVhc2VSZW5kZXJUZXh0dXJlKHRoaXMuX3JlbmRlclRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlUmV1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc3VsdFRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldXNlcyB0aGUgc3BlY2lmaWVkIHRleHR1cmUgYXMgdGhlIHJlbmRlciB0ZXh0dXJlIChpbiBhbmNlc3RvcikuXG4gICAgcmV1c2VUZXh0dXJlQXNSZW5kZXJUZXh0dXJlKG5hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmUgIT09IG5hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZVJlbmRlclRleHR1cmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmUgPSBuYXRpdmVUZXh0dXJlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZVJldXNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNSZW5kZXJUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9yZW5kZXJUZXh0dXJlO1xuICAgIH1cblxuICAgIGdldFJlbmRlclRleHR1cmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZSA9IHRoaXMuY3R4LmFsbG9jYXRlUmVuZGVyVGV4dHVyZSh0aGlzLl9jb3JlLl93LCB0aGlzLl9jb3JlLl9oKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVSZXVzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyVGV4dHVyZTtcbiAgICB9XG5cbiAgICBnZXRSZXN1bHRUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyVGV4dHVyZTtcbiAgICB9XG5cbn1cblxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8qXG4qIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qXG4qIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4qL1xuXG5pbXBvcnQgeyBMYXVuY2ggfSBmcm9tICdAbGlnaHRuaW5nanMvc2RrJztcblxuaW1wb3J0IHsgQXBwIH0gZnJvbSAnLi4vc3JjL0FwcCc7XG5pbXBvcnQgeyBhcHBEYXRhLCBhcHBTZXR0aW5ncywgcGxhdGZvcm1TZXR0aW5ncyB9IGZyb20gJy4uL3NyYy9zZXR0aW5ncyc7XG5cbi8vIGxhdW5jaCB0aGUgYXBwbGljYXRpb24gd2l0aCBjdXN0b20gc2V0dGluZ3NcbmNvbnN0IGFwcCA9IExhdW5jaChBcHAsIGFwcFNldHRpbmdzLCBwbGF0Zm9ybVNldHRpbmdzLCBhcHBEYXRhKTtcblxuLy8gYXBwZW5kIHRoZSBjYW52YXMgdG8gdGhlIGRvbVxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhcHAuc3RhZ2UuZ2V0Q2FudmFzKCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9